/* version: 13.84.0_13.20241220.112403_eebbbae7 */
defineEvoVideo("videojs", [], ( () => ( () => {
    var e = {
        615: (e, t) => {
            var V, l, d = d || function(e) {
                var t = {}
                  , V = t.lib = {}
                  , l = function() {}
                  , d = V.Base = {
                    extend: function(e) {
                        l.prototype = this;
                        var t = new l;
                        return e && t.mixIn(e),
                        t.hasOwnProperty("init") || (t.init = function() {
                            t.$super.init.apply(this, arguments)
                        }
                        ),
                        t.init.prototype = t,
                        t.$super = this,
                        t
                    },
                    create: function() {
                        var e = this.extend();
                        return e.init.apply(e, arguments),
                        e
                    },
                    init: function() {},
                    mixIn: function(e) {
                        for (var t in e)
                            e.hasOwnProperty(t) && (this[t] = e[t]);
                        e.hasOwnProperty("toString") && (this.toString = e.toString)
                    },
                    clone: function() {
                        return this.init.prototype.extend(this)
                    }
                }
                  , a = V.WordArray = d.extend({
                    init: function(e, t) {
                        e = this.words = e || [],
                        this.sigBytes = null != t ? t : 4 * e.length
                    },
                    toString: function(e) {
                        return (e || n).stringify(this)
                    },
                    concat: function(e) {
                        var t = this.words
                          , V = e.words
                          , l = this.sigBytes;
                        if (e = e.sigBytes,
                        this.clamp(),
                        l % 4)
                            for (var d = 0; d < e; d++)
                                t[l + d >>> 2] |= (V[d >>> 2] >>> 24 - d % 4 * 8 & 255) << 24 - (l + d) % 4 * 8;
                        else if (65535 < V.length)
                            for (d = 0; d < e; d += 4)
                                t[l + d >>> 2] = V[d >>> 2];
                        else
                            t.push.apply(t, V);
                        return this.sigBytes += e,
                        this
                    },
                    clamp: function() {
                        var t = this.words
                          , V = this.sigBytes;
                        t[V >>> 2] &= 4294967295 << 32 - V % 4 * 8,
                        t.length = e.ceil(V / 4)
                    },
                    clone: function() {
                        var e = d.clone.call(this);
                        return e.words = this.words.slice(0),
                        e
                    },
                    random: function(t) {
                        for (var V = [], l = 0; l < t; l += 4)
                            V.push(4294967296 * e.random() | 0);
                        return new a.init(V,t)
                    }
                })
                  , U = t.enc = {}
                  , n = U.Hex = {
                    stringify: function(e) {
                        var t = e.words;
                        e = e.sigBytes;
                        for (var V = [], l = 0; l < e; l++) {
                            var d = t[l >>> 2] >>> 24 - l % 4 * 8 & 255;
                            V.push((d >>> 4).toString(16)),
                            V.push((15 & d).toString(16))
                        }
                        return V.join("")
                    },
                    parse: function(e) {
                        for (var t = e.length, V = [], l = 0; l < t; l += 2)
                            V[l >>> 3] |= parseInt(e.substr(l, 2), 16) << 24 - l % 8 * 4;
                        return new a.init(V,t / 2)
                    }
                }
                  , R = U.Latin1 = {
                    stringify: function(e) {
                        var t = e.words;
                        e = e.sigBytes;
                        for (var V = [], l = 0; l < e; l++)
                            V.push(String.fromCharCode(t[l >>> 2] >>> 24 - l % 4 * 8 & 255));
                        return V.join("")
                    },
                    parse: function(e) {
                        for (var t = e.length, V = [], l = 0; l < t; l++)
                            V[l >>> 2] |= (255 & e.charCodeAt(l)) << 24 - l % 4 * 8;
                        return new a.init(V,t)
                    }
                }
                  , Z = U.Utf8 = {
                    stringify: function(e) {
                        try {
                            return decodeURIComponent(escape(R.stringify(e)))
                        } catch (t) {
                            throw Error("Malformed UTF-8 data")
                        }
                    },
                    parse: function(e) {
                        return R.parse(unescape(encodeURIComponent(e)))
                    }
                }
                  , N = V.BufferedBlockAlgorithm = d.extend({
                    reset: function() {
                        this._data = new a.init,
                        this._nDataBytes = 0
                    },
                    _append: function(e) {
                        "string" == typeof e && (e = Z.parse(e)),
                        this._data.concat(e),
                        this._nDataBytes += e.sigBytes
                    },
                    _process: function(t) {
                        var V = this._data
                          , l = V.words
                          , d = V.sigBytes
                          , U = this.blockSize
                          , n = d / (4 * U);
                        if (t = (n = t ? e.ceil(n) : e.max((0 | n) - this._minBufferSize, 0)) * U,
                        d = e.min(4 * t, d),
                        t) {
                            for (var R = 0; R < t; R += U)
                                this._doProcessBlock(l, R);
                            R = l.splice(0, t),
                            V.sigBytes -= d
                        }
                        return new a.init(R,d)
                    },
                    clone: function() {
                        var e = d.clone.call(this);
                        return e._data = this._data.clone(),
                        e
                    },
                    _minBufferSize: 0
                });
                V.Hasher = N.extend({
                    cfg: d.extend(),
                    init: function(e) {
                        this.cfg = this.cfg.extend(e),
                        this.reset()
                    },
                    reset: function() {
                        N.reset.call(this),
                        this._doReset()
                    },
                    update: function(e) {
                        return this._append(e),
                        this._process(),
                        this
                    },
                    finalize: function(e) {
                        return e && this._append(e),
                        this._doFinalize()
                    },
                    blockSize: 16,
                    _createHelper: function(e) {
                        return function(t, V) {
                            return new e.init(V).finalize(t)
                        }
                    },
                    _createHmacHelper: function(e) {
                        return function(t, V) {
                            return new c.HMAC.init(e,V).finalize(t)
                        }
                    }
                });
                var c = t.algo = {};
                return t
            }(Math);
            !function(e) {
                for (var t = d, V = (a = t.lib).WordArray, l = a.Hasher, a = t.algo, U = [], n = [], R = function(e) {
                    return 4294967296 * (e - (0 | e)) | 0
                }, Z = 2, N = 0; 64 > N; ) {
                    var c;
                    e: {
                        c = Z;
                        for (var T = e.sqrt(c), W = 2; W <= T; W++)
                            if (!(c % W)) {
                                c = !1;
                                break e
                            }
                        c = !0
                    }
                    c && (8 > N && (U[N] = R(e.pow(Z, .5))),
                    n[N] = R(e.pow(Z, 1 / 3)),
                    N++),
                    Z++
                }
                var i = [];
                a = a.SHA256 = l.extend({
                    _doReset: function() {
                        this._hash = new V.init(U.slice(0))
                    },
                    _doProcessBlock: function(e, t) {
                        for (var V = this._hash.words, l = V[0], d = V[1], a = V[2], U = V[3], R = V[4], Z = V[5], N = V[6], c = V[7], T = 0; 64 > T; T++) {
                            if (16 > T)
                                i[T] = 0 | e[t + T];
                            else {
                                var W = i[T - 15]
                                  , F = i[T - 2];
                                i[T] = ((W << 25 | W >>> 7) ^ (W << 14 | W >>> 18) ^ W >>> 3) + i[T - 7] + ((F << 15 | F >>> 17) ^ (F << 13 | F >>> 19) ^ F >>> 10) + i[T - 16]
                            }
                            W = c + ((R << 26 | R >>> 6) ^ (R << 21 | R >>> 11) ^ (R << 7 | R >>> 25)) + (R & Z ^ ~R & N) + n[T] + i[T],
                            F = ((l << 30 | l >>> 2) ^ (l << 19 | l >>> 13) ^ (l << 10 | l >>> 22)) + (l & d ^ l & a ^ d & a),
                            c = N,
                            N = Z,
                            Z = R,
                            R = U + W | 0,
                            U = a,
                            a = d,
                            d = l,
                            l = W + F | 0
                        }
                        V[0] = V[0] + l | 0,
                        V[1] = V[1] + d | 0,
                        V[2] = V[2] + a | 0,
                        V[3] = V[3] + U | 0,
                        V[4] = V[4] + R | 0,
                        V[5] = V[5] + Z | 0,
                        V[6] = V[6] + N | 0,
                        V[7] = V[7] + c | 0
                    },
                    _doFinalize: function() {
                        var t = this._data
                          , V = t.words
                          , l = 8 * this._nDataBytes
                          , d = 8 * t.sigBytes;
                        return V[d >>> 5] |= 128 << 24 - d % 32,
                        V[14 + (d + 64 >>> 9 << 4)] = e.floor(l / 4294967296),
                        V[15 + (d + 64 >>> 9 << 4)] = l,
                        t.sigBytes = 4 * V.length,
                        this._process(),
                        this._hash
                    },
                    clone: function() {
                        var e = l.clone.call(this);
                        return e._hash = this._hash.clone(),
                        e
                    }
                }),
                t.SHA256 = l._createHelper(a),
                t.HmacSHA256 = l._createHmacHelper(a)
            }(Math),
            l = (V = d).enc.Utf8,
            V.algo.HMAC = V.lib.Base.extend({
                init: function(e, t) {
                    e = this._hasher = new e.init,
                    "string" == typeof t && (t = l.parse(t));
                    var V = e.blockSize
                      , d = 4 * V;
                    t.sigBytes > d && (t = e.finalize(t)),
                    t.clamp();
                    for (var a = this._oKey = t.clone(), U = this._iKey = t.clone(), n = a.words, R = U.words, Z = 0; Z < V; Z++)
                        n[Z] ^= 1549556828,
                        R[Z] ^= 909522486;
                    a.sigBytes = U.sigBytes = d,
                    this.reset()
                },
                reset: function() {
                    var e = this._hasher;
                    e.reset(),
                    e.update(this._iKey)
                },
                update: function(e) {
                    return this._hasher.update(e),
                    this
                },
                finalize: function(e) {
                    var t = this._hasher;
                    return e = t.finalize(e),
                    t.reset(),
                    t.finalize(this._oKey.clone().concat(e))
                }
            }),
            function() {
                var e = d
                  , t = e.lib.WordArray;
                e.enc.Base64 = {
                    stringify: function(e) {
                        var t = e.words
                          , V = e.sigBytes
                          , l = this._map;
                        e.clamp(),
                        e = [];
                        for (var d = 0; d < V; d += 3)
                            for (var a = (t[d >>> 2] >>> 24 - d % 4 * 8 & 255) << 16 | (t[d + 1 >>> 2] >>> 24 - (d + 1) % 4 * 8 & 255) << 8 | t[d + 2 >>> 2] >>> 24 - (d + 2) % 4 * 8 & 255, U = 0; 4 > U && d + .75 * U < V; U++)
                                e.push(l.charAt(a >>> 6 * (3 - U) & 63));
                        if (t = l.charAt(64))
                            for (; e.length % 4; )
                                e.push(t);
                        return e.join("")
                    },
                    parse: function(e) {
                        var V = e.length
                          , l = this._map;
                        (d = l.charAt(64)) && -1 != (d = e.indexOf(d)) && (V = d);
                        for (var d = [], a = 0, U = 0; U < V; U++)
                            if (U % 4) {
                                var n = l.indexOf(e.charAt(U - 1)) << U % 4 * 2
                                  , R = l.indexOf(e.charAt(U)) >>> 6 - U % 4 * 2;
                                d[a >>> 2] |= (n | R) << 24 - a % 4 * 8,
                                a++
                            }
                        return t.create(d, a)
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                }
            }(),
            function(e) {
                for (var t = d, V = (a = t.lib).WordArray, l = a.Hasher, a = t.algo, U = [], n = [], R = function(e) {
                    return 4294967296 * (e - (0 | e)) | 0
                }, Z = 2, N = 0; 64 > N; ) {
                    var c;
                    e: {
                        c = Z;
                        for (var T = e.sqrt(c), W = 2; W <= T; W++)
                            if (!(c % W)) {
                                c = !1;
                                break e
                            }
                        c = !0
                    }
                    c && (8 > N && (U[N] = R(e.pow(Z, .5))),
                    n[N] = R(e.pow(Z, 1 / 3)),
                    N++),
                    Z++
                }
                var i = [];
                a = a.SHA256 = l.extend({
                    _doReset: function() {
                        this._hash = new V.init(U.slice(0))
                    },
                    _doProcessBlock: function(e, t) {
                        for (var V = this._hash.words, l = V[0], d = V[1], a = V[2], U = V[3], R = V[4], Z = V[5], N = V[6], c = V[7], T = 0; 64 > T; T++) {
                            if (16 > T)
                                i[T] = 0 | e[t + T];
                            else {
                                var W = i[T - 15]
                                  , F = i[T - 2];
                                i[T] = ((W << 25 | W >>> 7) ^ (W << 14 | W >>> 18) ^ W >>> 3) + i[T - 7] + ((F << 15 | F >>> 17) ^ (F << 13 | F >>> 19) ^ F >>> 10) + i[T - 16]
                            }
                            W = c + ((R << 26 | R >>> 6) ^ (R << 21 | R >>> 11) ^ (R << 7 | R >>> 25)) + (R & Z ^ ~R & N) + n[T] + i[T],
                            F = ((l << 30 | l >>> 2) ^ (l << 19 | l >>> 13) ^ (l << 10 | l >>> 22)) + (l & d ^ l & a ^ d & a),
                            c = N,
                            N = Z,
                            Z = R,
                            R = U + W | 0,
                            U = a,
                            a = d,
                            d = l,
                            l = W + F | 0
                        }
                        V[0] = V[0] + l | 0,
                        V[1] = V[1] + d | 0,
                        V[2] = V[2] + a | 0,
                        V[3] = V[3] + U | 0,
                        V[4] = V[4] + R | 0,
                        V[5] = V[5] + Z | 0,
                        V[6] = V[6] + N | 0,
                        V[7] = V[7] + c | 0
                    },
                    _doFinalize: function() {
                        var t = this._data
                          , V = t.words
                          , l = 8 * this._nDataBytes
                          , d = 8 * t.sigBytes;
                        return V[d >>> 5] |= 128 << 24 - d % 32,
                        V[14 + (d + 64 >>> 9 << 4)] = e.floor(l / 4294967296),
                        V[15 + (d + 64 >>> 9 << 4)] = l,
                        t.sigBytes = 4 * V.length,
                        this._process(),
                        this._hash
                    },
                    clone: function() {
                        var e = l.clone.call(this);
                        return e._hash = this._hash.clone(),
                        e
                    }
                }),
                t.SHA256 = l._createHelper(a),
                t.HmacSHA256 = l._createHmacHelper(a)
            }(Math),
            t.enc = {
                Base64: d.enc.Base64,
                Utf8: d.enc.Utf8,
                Latin1: d.enc.Latin1
            },
            t.SHA256 = d.SHA256,
            t.HmacSHA256 = d.HmacSHA256
        }
        ,
        605: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.parseAudioMeta = function(e) {
                const [t] = (0,
                a.findAtom)(e.data, ["mdia", "hdlr"]);
                if (!t)
                    return;
                if ("soun" !== (0,
                a.getTrackType)(t))
                    return;
                const [V] = (0,
                a.findAtom)(e.data, ["tkhd"]);
                if (!V)
                    return;
                const [U] = (0,
                a.findAtom)(e.data, ["mdia", "mdhd"]);
                if (!U)
                    return;
                const [n] = (0,
                a.findAtom)(e.data, ["mdia", "minf", "stbl", "stsd"]);
                if (!n)
                    return;
                const R = n.data.subarray(8)
                  , Z = (0,
                a.toString)(R.subarray(4, 8))
                  , N = "mp4a" === Z ? "mp4a.40.2" : "opus"
                  , c = "mp4a" === Z ? (0,
                l.mp4a)(n.data.subarray(8)) : "Opus" === Z ? (0,
                d.Opus)(n.data.subarray(8)) : void 0;
                if (!c)
                    return;
                const T = 0 === (0,
                a.toInt)(V.data.subarray(0, 1)) ? (0,
                a.toInt)(V.data.subarray(12, 16)) : (0,
                a.toInt)(V.data.subarray(20, 24))
                  , W = (0,
                a.getTimescale)(U);
                return Object.assign({
                    id: T,
                    timeScale: W,
                    codec: N
                }, c)
            }
            ;
            const l = V(606)
              , d = V(751)
              , a = V(979)
        }
        ,
        751: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.Opus = function(e) {
                return "Opus" !== (0,
                l.toString)(e.subarray(4, 8)) ? void 0 : {
                    numberOfChannels: (0,
                    l.toInt)(e.subarray(25, 26)),
                    sampleRate: (0,
                    l.toInt)(e.subarray(32, 34))
                }
            }
            ;
            const l = V(979)
        }
        ,
        920: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.parseVideoMeta = function(e) {
                const [t] = (0,
                l.findAtom)(e.data, ["mdia", "hdlr"]);
                if (!t)
                    return;
                if ("vide" !== (0,
                l.getTrackType)(t))
                    return;
                const [V] = (0,
                l.findAtom)(e.data, ["tkhd"]);
                if (!V)
                    return;
                const [d] = (0,
                l.findAtom)(e.data, ["mdia", "mdhd"]);
                if (!d)
                    return;
                const [a] = (0,
                l.findAtom)(e.data, ["mdia", "minf", "stbl", "stsd"]);
                if (!a)
                    return;
                const U = (0,
                l.extractAtoms)(a.data.subarray(8))[0];
                if (!U)
                    return;
                const n = (0,
                l.toInt)(U.data.subarray(24, 26))
                  , R = (0,
                l.toInt)(U.data.subarray(26, 28))
                  , Z = U.data.subarray(86);
                let N;
                if ("avc1" === U.name)
                    N = "avc1.64001f";
                else {
                    if ("av01" !== U.name)
                        return;
                    N = "av01.0.04M.08"
                }
                return {
                    id: 0 === (0,
                    l.toInt)(V.data.subarray(0, 1)) ? (0,
                    l.toInt)(V.data.subarray(12, 16)) : (0,
                    l.toInt)(V.data.subarray(20, 24)),
                    codedWidth: n,
                    codedHeight: R,
                    timeScale: (0,
                    l.getTimescale)(d),
                    description: Z,
                    codec: N
                }
            }
            ;
            const l = V(979)
        }
        ,
        282: function(e, t, V) {
            "use strict";
            var l = this && this.__createBinding || (Object.create ? function(e, t, V, l) {
                void 0 === l && (l = V);
                var d = Object.getOwnPropertyDescriptor(t, V);
                d && !("get"in d ? !t.__esModule : d.writable || d.configurable) || (d = {
                    enumerable: !0,
                    get: function() {
                        return t[V]
                    }
                }),
                Object.defineProperty(e, l, d)
            }
            : function(e, t, V, l) {
                void 0 === l && (l = V),
                e[l] = t[V]
            }
            )
              , d = this && this.__exportStar || function(e, t) {
                for (var V in e)
                    "default" === V || Object.prototype.hasOwnProperty.call(t, V) || l(t, e, V)
            }
            ;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.makeBufferWithEgwc = t.parseVideoMeta = t.parseAudioMeta = void 0,
            d(V(979), t);
            var a = V(605);
            Object.defineProperty(t, "parseAudioMeta", {
                enumerable: !0,
                get: function() {
                    return a.parseAudioMeta
                }
            });
            var U = V(920);
            Object.defineProperty(t, "parseVideoMeta", {
                enumerable: !0,
                get: function() {
                    return U.parseVideoMeta
                }
            });
            var n = V(654);
            Object.defineProperty(t, "makeBufferWithEgwc", {
                enumerable: !0,
                get: function() {
                    return n.makeBufferWithEgwc
                }
            })
        },
        654: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.makeBufferWithEgwc = function(e=V) {
                const {data: t, pts: d, wallclock: a, edgeWallclock: U} = Object.assign(Object.assign({}, V), e)
                  , n = Array.isArray(d) ? d : l(d)
                  , R = Array.isArray(a) ? a : l(a)
                  , Z = Array.isArray(U) ? U : l(U);
                return new Uint8Array([...l(t.length + 8, 4), 109, 100, 97, 116, ...t, 0, 0, 0, 32, 101, 103, 119, 99, ...n, ...R, ...Z]).buffer
            }
            ;
            const V = {
                data: [],
                pts: Date.now(),
                wallclock: Date.now(),
                edgeWallclock: Date.now()
            };
            function l(e, t=8) {
                const V = new Array(t).fill(0);
                let l = e
                  , d = 1;
                for (; l > 0; )
                    V[V.length - d] = l % 256,
                    l = Math.floor(l / 256),
                    d++;
                return V
            }
        }
        ,
        606: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.mp4a = function(e) {
                return "mp4a" !== (0,
                l.toString)(e.subarray(4, 8)) ? void 0 : {
                    numberOfChannels: (0,
                    l.toInt)(e.subarray(24, 26)),
                    sampleRate: (0,
                    l.toInt)(e.subarray(32, 34))
                }
            }
            ;
            const l = V(979)
        }
        ,
        979: (e, t) => {
            "use strict";
            function V(e) {
                return e.reduce(( (e, t) => 256 * e + t))
            }
            function l(e) {
                const t = new Uint8Array(4);
                for (let V = 0; V < 4; V++)
                    t[3 - V] = 255 & e,
                    e >>>= 8;
                return t
            }
            function d(e) {
                return String.fromCharCode(...e)
            }
            function a(e) {
                const t = new Uint8Array(4);
                for (let V = 0; V < 4; V++)
                    t[V] = V < e.length ? e.charCodeAt(V) : 0;
                return t
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.toInt = V,
            t.toUint8 = l,
            t.toString = d,
            t.strToUint8 = a,
            t.extractAtoms = function(e) {
                const t = [];
                for (let l = 0; l < e.length; ) {
                    const a = V(e.subarray(l, l + 4))
                      , U = d(e.subarray(l + 4, l + 8))
                      , n = e.slice(l + 8, l + a);
                    t.push({
                        size: a,
                        name: U,
                        data: n
                    }),
                    l += a
                }
                return t
            }
            ,
            t.findAtom = function(e, t) {
                const V = []
                  , l = new DataView(e.buffer,e.byteOffset,e.byteLength);
                let d = 0
                  , a = 0;
                for (; d < e.byteLength; ) {
                    const n = t[a]
                      , R = l.getUint32(d)
                      , Z = U.decode(e.subarray(d + 4, d + 8));
                    n === Z ? n === Z && a < t.length - 1 ? (d += 8,
                    a += 1) : (V.push({
                        size: R,
                        name: Z,
                        data: e.subarray(d + 8, d + R)
                    }),
                    d += R) : d += R
                }
                return V
            }
            ,
            t.getEgwc = function(e) {
                const {data: t} = e;
                return {
                    pts: V(t.subarray(0, 8)),
                    wallclock: Math.floor(V(t.subarray(8, 16)) / 1e3),
                    edgeWallclock: V(t.subarray(16, 24))
                }
            }
            ,
            t.getTimescale = function(e) {
                const {data: t} = e;
                return V(t.subarray(12, 16))
            }
            ,
            t.getSampleRate = function(e) {
                const {data: t} = e;
                return V(t.subarray(40, 42))
            }
            ,
            t.getTrackType = function(e) {
                return d(e.data.subarray(8, 12))
            }
            ,
            t.atomsToBuffer = function(e) {
                const t = e.map((e => e.size)).reduce(( (e, t) => e + t))
                  , V = new ArrayBuffer(t)
                  , d = new Uint8Array(V);
                let U = 0;
                for (const n of e)
                    d.set(l(n.size), U + 0),
                    d.set(a(n.name), U + 4),
                    d.set(n.data, U + 8),
                    U += n.size;
                return V
            }
            ;
            const U = new TextDecoder
        }
        ,
        595: e => {
            ( () => {
                var t = {
                    985: (e, t, V) => {
                        e.exports = V(878)('(()=>{"use strict";var t;!function(t){t.OnSufficientBuffer="OnSufficientBuffer",t.OnPts="OnPts",t.OnSilent="OnSilent",t.PushFrame="PushFrame",t.DropOldFrames="DropOldFrames",t.SetPlaybackRate="SetPlaybackRate",t.Destroy="Destroy"}(t||(t={}));class e{constructor(){this.frames=[],this.availableSamples=0}push(t){this.frames.push(t),this.availableSamples+=t.numSamples}trim(t){this.frames=this.frames.slice(t),this.availableSamples=this.frames.reduce(((t,e)=>t+e.numSamples),0)}dropOldFrames(t){for(var e;this.frames.length&&this.frames[0].pts<t;){const t=this.frames.shift();this.availableSamples-=null!==(e=null==t?void 0:t.numSamples)&&void 0!==e?e:0}}get length(){return this.availableSamples}}class s{constructor(t,e=0){this.buffer=t,this.index=e,this.frameIndex=0,this.move(e)}available(){let t=this.index;for(let e=0;e<this.frameIndex;e++)t+=this.buffer.frames[e].numSamples;return this.buffer.length-t}trim(){this.buffer.trim(this.frameIndex),this.frameIndex=0}pts(t,e=0){const s=this.buffer.frames[this.frameIndex];if(s)return s.pts+(this.index+e)/t*1e3}get(t){const e=this.currentFrame();return e?e.buffers[t][this.index]:void 0}getNext(t){const e=this.currentFrame();if(e){if(this.index+1>=e.numSamples){const e=this.buffer.frames[this.frameIndex+1];return e?e.buffers[t][0]:void 0}return e.buffers[t][this.index+1]}}currentFrame(){return this.buffer.frames[this.frameIndex]}hasFrame(){return this.frameIndex<this.buffer.frames.length}hasSample(){const t=this.currentFrame();return!!(t&&this.index<t.numSamples)}hasNext(){return this.hasNextFrame()||this.hasFrameNextSample()}next(){this.index++,this.hasSample()||(this.frameIndex++,this.index=0)}move(t){this.index+=t;let e=this.currentFrame();for(;e&&!this.hasSample();)this.index-=e.numSamples,this.frameIndex++,e=this.currentFrame()}copyTo(t,e){let s=e;for(;s>0;){const i=this.currentFrame();if(!i)break;const a=Math.min(s,i.numSamples-this.index),r=e-s;t.forEach(((t,e)=>{for(let s=this.index,n=r;s<a+this.index;s++,n++)t[n]=i.buffers[e][s]})),s-=a,this.index+=a,this.index>=i.numSamples&&(this.index=0,this.frameIndex++)}}hasFrameNextSample(){const t=this.currentFrame();return!!t&&this.index+1<t.numSamples}hasNextFrame(){return this.frameIndex+1<this.buffer.frames.length}}class i extends AudioWorkletProcessor{constructor(i){var a,r,n,l,h,o,u,m,f,p,c,d;super(i),this.samples=new e,this.sampleIterator=new s(this.samples),this.isSufficientBuffer=!1,this.lastPtsReport=0,this.silentDuration=0,this.isDestroy=!1,this.sampleRateRatio=1,this.sampleFraction=0,this.playbackRate=1,this.channelCount=null!==(r=null===(a=null==i?void 0:i.outputChannelCount)||void 0===a?void 0:a[0])&&void 0!==r?r:2,this.playbackRate=null!==(l=null===(n=null==i?void 0:i.parameterData)||void 0===n?void 0:n.playbackRate)&&void 0!==l?l:this.playbackRate,this.sampleRateRatio=null!==(o=null===(h=null==i?void 0:i.parameterData)||void 0===h?void 0:h.sampleRateRatio)&&void 0!==o?o:this.sampleRateRatio,this.initBufferLength=null!==(m=null===(u=null==i?void 0:i.parameterData)||void 0===u?void 0:u.initBufferLength)&&void 0!==m?m:500,this.inputSampleRate=null!==(p=null===(f=null==i?void 0:i.parameterData)||void 0===f?void 0:f.inputSampleRate)&&void 0!==p?p:44100,this.outputSampleRate=null!==(d=null===(c=null==i?void 0:i.parameterData)||void 0===c?void 0:c.outputSampleRate)&&void 0!==d?d:44100,this.port.onmessage=e=>{switch(e.data.type){case t.PushFrame:this.samples.push(e.data.frame),this.bufferCheck();break;case t.DropOldFrames:this.dropOldFrames(e.data.pts);break;case t.SetPlaybackRate:this.setPlaybackRate(e.data.playbackRate);break;case t.Destroy:this.isDestroy=!0}}}process(t,e){if(this.isDestroy)return!1;const s=e[0],i=s[0].length,a=this.sampleRateRatio*this.playbackRate,r=Math.floor(this.sampleIterator.available()/a)-1,n=Math.min(r,i);return this.reportPts(),!this.isSufficientBuffer||r<i?(this.silentDuration+=i/this.inputSampleRate*1e3,this.reportSilent(),function(t,e=0){t.forEach((t=>{t.fill(0,e)}))}(s,i),!0):(1===a?this.copyToOutput(s,n):this.interpolateToOutput(s,n,a),this.sampleIterator.trim(),!0)}reportSilent(){this.silentDuration<100||(this.port.postMessage({type:t.OnSilent,duration:this.silentDuration}),this.silentDuration=0)}copyToOutput(t,e){this.sampleFraction=0,this.sampleIterator.copyTo(t,e)}interpolateToOutput(t,e,s){var i,a,r,n,l;for(let h=0;h<e;h++){for(let e=0;e<this.channelCount;e++){const s=null!==(i=this.sampleIterator.get(e))&&void 0!==i?i:0,o=null!==(a=this.sampleIterator.getNext(e))&&void 0!==a?a:s;t[e][h]=(r=s,n=o,l=this.sampleFraction,r+(n-r)*(l=.5*(1-Math.cos(l*Math.PI))))}for(this.sampleFraction+=s;this.sampleFraction>=1;)this.sampleIterator.next(),this.sampleFraction-=1}}bufferCheck(){this.isSufficientBuffer||Math.round(this.samples.length/this.inputSampleRate*1e3)>=this.initBufferLength&&(this.isSufficientBuffer=!0,this.port.postMessage({type:t.OnSufficientBuffer}))}dropOldFrames(t){this.samples.dropOldFrames(t)}setPlaybackRate(t){this.playbackRate=t}reportPts(){var e;if(!this.isSufficientBuffer)return;const s=1e3*currentTime;if(s-this.lastPtsReport<200)return;const i=Math.round(null!==(e=this.sampleIterator.pts(this.outputSampleRate))&&void 0!==e?e:0);this.lastPtsReport=s,this.port.postMessage({type:t.OnPts,pts:i})}}registerProcessor("bufferProcessor",i)})();')
                    }
                    ,
                    878: e => {
                        "use strict";
                        var t = window.URL || window.webkitURL;
                        e.exports = function(e) {
                            try {
                                var V;
                                try {
                                    (V = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder)).append(e),
                                    V = V.getBlob("application/javascript; charset=utf-8")
                                } catch (t) {
                                    V = new Blob([e],{
                                        type: "application/javascript; charset=utf-8"
                                    })
                                }
                                return t.createObjectURL(V)
                            } catch (t) {
                                return "data:application/javascript," + encodeURIComponent(e)
                            }
                        }
                    }
                }
                  , V = {};
                function l(e) {
                    var d = V[e];
                    if (void 0 !== d)
                        return d.exports;
                    var a = V[e] = {
                        exports: {}
                    };
                    return t[e](a, a.exports, l),
                    a.exports
                }
                l.n = e => {
                    var t = e && e.__esModule ? () => e.default : () => e;
                    return l.d(t, {
                        a: t
                    }),
                    t
                }
                ,
                l.d = (e, t) => {
                    for (var V in t)
                        l.o(t, V) && !l.o(e, V) && Object.defineProperty(e, V, {
                            enumerable: !0,
                            get: t[V]
                        })
                }
                ,
                l.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
                l.r = e => {
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                        value: "Module"
                    }),
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    })
                }
                ;
                var d = {};
                ( () => {
                    "use strict";
                    l.r(d),
                    l.d(d, {
                        AudioSampleBuffer: () => e,
                        AudioSampleIterator: () => t,
                        ScriptProcessorBuffer: () => V,
                        WorkletBuffer: () => Z,
                        createAudioPlayer: () => N
                    });
                    class e {
                        constructor() {
                            this.frames = [],
                            this.availableSamples = 0
                        }
                        push(e) {
                            this.frames.push(e),
                            this.availableSamples += e.numSamples
                        }
                        trim(e) {
                            this.frames = this.frames.slice(e),
                            this.availableSamples = this.frames.reduce(( (e, t) => e + t.numSamples), 0)
                        }
                        dropOldFrames(e) {
                            for (var t; this.frames.length && this.frames[0].pts < e; ) {
                                const e = this.frames.shift();
                                this.availableSamples -= null !== (t = null == e ? void 0 : e.numSamples) && void 0 !== t ? t : 0
                            }
                        }
                        get length() {
                            return this.availableSamples
                        }
                    }
                    class t {
                        constructor(e, t=0) {
                            this.buffer = e,
                            this.index = t,
                            this.frameIndex = 0,
                            this.move(t)
                        }
                        available() {
                            let e = this.index;
                            for (let t = 0; t < this.frameIndex; t++)
                                e += this.buffer.frames[t].numSamples;
                            return this.buffer.length - e
                        }
                        trim() {
                            this.buffer.trim(this.frameIndex),
                            this.frameIndex = 0
                        }
                        pts(e, t=0) {
                            const V = this.buffer.frames[this.frameIndex];
                            if (V)
                                return V.pts + (this.index + t) / e * 1e3
                        }
                        get(e) {
                            const t = this.currentFrame();
                            return t ? t.buffers[e][this.index] : void 0
                        }
                        getNext(e) {
                            const t = this.currentFrame();
                            if (t) {
                                if (this.index + 1 >= t.numSamples) {
                                    const t = this.buffer.frames[this.frameIndex + 1];
                                    return t ? t.buffers[e][0] : void 0
                                }
                                return t.buffers[e][this.index + 1]
                            }
                        }
                        currentFrame() {
                            return this.buffer.frames[this.frameIndex]
                        }
                        hasFrame() {
                            return this.frameIndex < this.buffer.frames.length
                        }
                        hasSample() {
                            const e = this.currentFrame();
                            return !!(e && this.index < e.numSamples)
                        }
                        hasNext() {
                            return this.hasNextFrame() || this.hasFrameNextSample()
                        }
                        next() {
                            this.index++,
                            this.hasSample() || (this.frameIndex++,
                            this.index = 0)
                        }
                        move(e) {
                            this.index += e;
                            let t = this.currentFrame();
                            for (; t && !this.hasSample(); )
                                this.index -= t.numSamples,
                                this.frameIndex++,
                                t = this.currentFrame()
                        }
                        copyTo(e, t) {
                            let V = t;
                            for (; V > 0; ) {
                                const l = this.currentFrame();
                                if (!l)
                                    break;
                                const d = Math.min(V, l.numSamples - this.index)
                                  , a = t - V;
                                e.forEach(( (e, t) => {
                                    for (let V = this.index, U = a; V < d + this.index; V++,
                                    U++)
                                        e[U] = l.buffers[t][V]
                                }
                                )),
                                V -= d,
                                this.index += d,
                                this.index >= l.numSamples && (this.index = 0,
                                this.frameIndex++)
                            }
                        }
                        hasFrameNextSample() {
                            const e = this.currentFrame();
                            return !!e && this.index + 1 < e.numSamples
                        }
                        hasNextFrame() {
                            return this.frameIndex + 1 < this.buffer.frames.length
                        }
                    }
                    class V {
                        constructor(V, l, d, a, U, n, R, Z, N, c) {
                            this.audioContext = V,
                            this.initBufferLength = l,
                            this.inputSampleRate = d,
                            this.channelCount = a,
                            this.playbackRate = U,
                            this.sampleRateRatio = n,
                            this.onSufficientBuffer = R,
                            this.reportPts = Z,
                            this.onSilent = N,
                            this.getReferencePoint = c,
                            this.samples = new e,
                            this.sampleIterator = new t(this.samples),
                            this.isSufficient = !1,
                            this.sampleFraction = 0,
                            this.bufferSize = 1024,
                            this.sampleRateRatio = d / V.sampleRate,
                            this.sourceNode = this.audioContext.createOscillator(),
                            this.gainNode = this.audioContext.createGain(),
                            this.scriptNode = V.createScriptProcessor(this.bufferSize, 0, this.channelCount),
                            this.scriptNode.onaudioprocess = this.onAudioProcess.bind(this),
                            this.sourceNode.connect(this.scriptNode),
                            this.scriptNode.connect(this.gainNode),
                            this.gainNode.connect(this.audioContext.destination),
                            this.sourceNode.start(0)
                        }
                        onAudioFrame(e) {
                            this.samples.push(e),
                            this.bufferCheck()
                        }
                        isSufficientBuffer() {
                            return this.isSufficient
                        }
                        getReferencePts() {
                            var e;
                            return (null === (e = this.samples.frames[0]) || void 0 === e ? void 0 : e.pts) || 0
                        }
                        dropOldFrames(e) {
                            this.samples.dropOldFrames(e)
                        }
                        setPlaybackRate(e) {
                            this.playbackRate = e
                        }
                        setVolume(e) {
                            this.gainNode.gain.value = e
                        }
                        destroy() {
                            try {
                                this.sourceNode.stop(0),
                                this.sourceNode.disconnect(),
                                this.gainNode.disconnect(),
                                this.scriptNode.disconnect()
                            } catch (e) {}
                        }
                        onAudioProcess(e) {
                            const {referencePts: t, referenceTime: V} = this.getReferencePoint()
                              , l = function(e, t) {
                                return Array.from({
                                    length: t
                                }, ( (t, V) => e.outputBuffer.getChannelData(V)))
                            }(e, this.channelCount)
                              , d = l[0].length;
                            let U = this.sampleRateRatio * this.playbackRate;
                            const n = Math.floor(this.sampleIterator.available() / U) - 1
                              , R = Math.min(n, e.outputBuffer.length);
                            if (!this.isSufficient || n < d) {
                                const e = d / this.inputSampleRate * 1e3;
                                return this.onSilent(e),
                                void a(l, d)
                            }
                            const Z = t + (performance.now() - V)
                              , N = this.sampleIterator.pts(this.inputSampleRate, R);
                            if (N) {
                                const e = Z - N;
                                e > 50 && (U *= 1.05),
                                e < -50 && (U *= .95)
                            }
                            N && this.reportPts(N),
                            1 === U ? this.copyToOutput(l, R) : this.interpolateToOutput(l, R, U),
                            this.sampleIterator.trim(),
                            R < e.outputBuffer.length && a(l, R)
                        }
                        copyToOutput(e, t) {
                            this.sampleFraction = 0,
                            this.sampleIterator.copyTo(e, t)
                        }
                        interpolateToOutput(e, t, V) {
                            var l, d, a, U, n;
                            for (let R = 0; R < t; R++) {
                                for (let t = 0; t < this.channelCount; t++) {
                                    const V = null !== (l = this.sampleIterator.get(t)) && void 0 !== l ? l : 0
                                      , Z = null !== (d = this.sampleIterator.getNext(t)) && void 0 !== d ? d : V;
                                    e[t][R] = (a = V,
                                    U = Z,
                                    n = this.sampleFraction,
                                    a + (U - a) * (n = .5 * (1 - Math.cos(n * Math.PI))))
                                }
                                for (this.sampleFraction += V; this.sampleFraction >= 1; )
                                    this.sampleIterator.next(),
                                    this.sampleFraction -= 1
                            }
                        }
                        bufferCheck() {
                            this.isSufficient || this.samples.length / this.inputSampleRate * 1e3 >= this.initBufferLength && (this.isSufficient || this.onSufficientBuffer(),
                            this.isSufficient = !0)
                        }
                    }
                    function a(e, t=0) {
                        e.forEach((e => {
                            e.fill(0, t)
                        }
                        ))
                    }
                    var U;
                    !function(e) {
                        e.OnSufficientBuffer = "OnSufficientBuffer",
                        e.OnPts = "OnPts",
                        e.OnSilent = "OnSilent",
                        e.PushFrame = "PushFrame",
                        e.DropOldFrames = "DropOldFrames",
                        e.SetPlaybackRate = "SetPlaybackRate",
                        e.Destroy = "Destroy"
                    }(U || (U = {}));
                    var n = l(985)
                      , R = l.n(n);
                    class Z {
                        constructor(e, t, V, l, d, a, n, Z, N) {
                            this.audioContext = e,
                            this.onSufficientBuffer = n,
                            this.reportPts = Z,
                            this.onSilent = N,
                            this.isSufficient = !1,
                            this.referencePts = 0,
                            this.onWorkletMessage = e => {
                                switch (e.data.type) {
                                case U.OnSufficientBuffer:
                                    this.isSufficient || this.onSufficientBuffer(),
                                    this.isSufficient = !0;
                                    break;
                                case U.OnPts:
                                    this.reportPts(e.data.pts);
                                    break;
                                case U.OnSilent:
                                    this.onSilent(e.data.duration)
                                }
                            }
                            ,
                            this.sourceNode = this.audioContext.createOscillator(),
                            this.gainNode = this.audioContext.createGain(),
                            e.audioWorklet.addModule(R()).then(( () => {
                                this.worklet = new AudioWorkletNode(e,"bufferProcessor",{
                                    outputChannelCount: [l],
                                    parameterData: {
                                        initBufferLength: t,
                                        playbackRate: d,
                                        inputSampleRate: V,
                                        outputSampleRate: e.sampleRate,
                                        sampleRateRatio: a
                                    }
                                }),
                                this.worklet.port.onmessage = this.onWorkletMessage,
                                this.sourceNode.connect(this.worklet),
                                this.worklet.connect(this.gainNode),
                                this.gainNode.connect(this.audioContext.destination),
                                this.sourceNode.start(0)
                            }
                            ))
                        }
                        onAudioFrame(e) {
                            var t;
                            null === (t = this.worklet) || void 0 === t || t.port.postMessage({
                                type: U.PushFrame,
                                frame: e
                            }, e.buffers.map((e => e.buffer))),
                            this.referencePts || (this.referencePts = e.pts)
                        }
                        isSufficientBuffer() {
                            return this.isSufficient
                        }
                        setVolume(e) {
                            this.gainNode.gain.value = e
                        }
                        getReferencePts() {
                            return this.referencePts
                        }
                        dropOldFrames(e) {
                            var t;
                            null === (t = this.worklet) || void 0 === t || t.port.postMessage({
                                type: U.DropOldFrames,
                                pts: e
                            })
                        }
                        setPlaybackRate(e) {
                            var t;
                            null === (t = this.worklet) || void 0 === t || t.port.postMessage({
                                type: U.SetPlaybackRate,
                                playbackRate: e
                            })
                        }
                        destroy() {
                            var e, t;
                            try {
                                null === (e = this.worklet) || void 0 === e || e.port.postMessage({
                                    type: U.Destroy
                                }),
                                this.sourceNode.stop(0),
                                null === (t = this.worklet) || void 0 === t || t.disconnect(),
                                this.sourceNode.disconnect(),
                                this.gainNode.disconnect()
                            } catch (e) {}
                        }
                    }
                    function N(e, t, l, d, a, U, n) {
                        let R = !1
                          , N = 0
                          , c = 0
                          , T = [];
                        const W = new (AudioWorklet ? Z : V)(e,t,l,d,n,l / e.sampleRate,(function() {
                            R || (N = W.getReferencePts(),
                            c = performance.now(),
                            R = !0),
                            U ? T.forEach((e => e(N))) : e.resume()
                        }
                        ),(function(e) {
                            N = e,
                            c = performance.now(),
                            T.forEach((t => t(e)))
                        }
                        ),(function(e) {
                            N -= e
                        }
                        ),(function() {
                            return {
                                referencePts: N,
                                referenceTime: c
                            }
                        }
                        ));
                        return W.setVolume(a),
                        U && "closed" !== e.state && e.suspend(),
                        {
                            pushFrame: e => {
                                W.onAudioFrame(e),
                                function(e=performance.now()) {
                                    if (R && U) {
                                        const t = N + e - c;
                                        W.dropOldFrames(t)
                                    }
                                }()
                            }
                            ,
                            pts: {
                                subscribe: e => {
                                    T.push(e)
                                }
                                ,
                                unsubscribe: e => {
                                    T = T.filter((t => t !== e))
                                }
                            },
                            volume: {
                                get: () => a,
                                set: e => {
                                    a = e,
                                    W.setVolume(a)
                                }
                            },
                            mute: {
                                get: () => U,
                                set: t => {
                                    (U = t) ? e.suspend() : e.resume()
                                }
                            },
                            playbackRate: {
                                get: () => n,
                                set: e => {
                                    n = e,
                                    W.setPlaybackRate(n)
                                }
                            },
                            destroy: () => {
                                W.destroy(),
                                T.length = 0
                            }
                        }
                    }
                }
                )(),
                e.exports = d
            }
            )()
        }
        ,
        632: function(e, t, V) {
            "use strict";
            var l = this && this.__createBinding || (Object.create ? function(e, t, V, l) {
                void 0 === l && (l = V);
                var d = Object.getOwnPropertyDescriptor(t, V);
                d && !("get"in d ? !t.__esModule : d.writable || d.configurable) || (d = {
                    enumerable: !0,
                    get: function() {
                        return t[V]
                    }
                }),
                Object.defineProperty(e, l, d)
            }
            : function(e, t, V, l) {
                void 0 === l && (l = V),
                e[l] = t[V]
            }
            )
              , d = this && this.__exportStar || function(e, t) {
                for (var V in e)
                    "default" === V || Object.prototype.hasOwnProperty.call(t, V) || l(t, e, V)
            }
            ;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            d(V(704), t)
        },
        947: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.createAudioPlayer = function(e, t=1, V=!1) {
                return e.volume = t,
                e.muted = V,
                {
                    setVolume: function(t) {
                        e.volume = t
                    },
                    mute: function(t) {
                        e.muted = t
                    },
                    setPlaybackRate: function(t) {
                        e.playbackRate = t
                    }
                }
            }
        }
        ,
        933: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.createBufferManager = function() {
                const e = []
                  , t = (0,
                d.notifier)();
                let V;
                return {
                    bufferLength: t,
                    push: function(d) {
                        var a;
                        const [U] = null !== (a = (0,
                        l.findAtom)(new Uint8Array(d), ["egwc"])) && void 0 !== a ? a : []
                          , n = U ? d.slice(0, d.byteLength - 32) : d;
                        if (e.push(n),
                        !U)
                            return;
                        const R = (0,
                        l.getEgwc)(U);
                        if (!V)
                            return V = R.wallclock,
                            void t.notify(0);
                        if (R.wallclock <= V)
                            return;
                        const Z = R.wallclock - V;
                        t.notify(Z)
                    },
                    shift: function() {
                        return e.shift()
                    },
                    dispose: function() {
                        e.splice(0),
                        t.dispose()
                    }
                }
            }
            ;
            const l = V(282)
              , d = V(373)
        }
        ,
        545: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.FMP4Error = void 0;
            class V extends Error {
                constructor(e, t, l) {
                    super(t),
                    this.type = e,
                    this.code = l,
                    this.name = "Fmp4Error",
                    Object.setPrototypeOf(this, V.prototype)
                }
            }
            t.FMP4Error = V
        }
        ,
        14: function(e, t, V) {
            "use strict";
            var l = this && this.__awaiter || function(e, t, V, l) {
                return new (V || (V = Promise))((function(d, a) {
                    function U(e) {
                        try {
                            R(l.next(e))
                        } catch (t) {
                            a(t)
                        }
                    }
                    function n(e) {
                        try {
                            R(l.throw(e))
                        } catch (t) {
                            a(t)
                        }
                    }
                    function R(e) {
                        var t;
                        e.done ? d(e.value) : (t = e.value,
                        t instanceof V ? t : new V((function(e) {
                            e(t)
                        }
                        ))).then(U, n)
                    }
                    R((l = l.apply(e, t || [])).next())
                }
                ))
            }
            ;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.FMP4Player = void 0;
            const d = V(947)
              , a = V(933)
              , U = V(837)
              , n = V(60)
              , R = V(402)
              , Z = V(578)
              , N = V(580)
              , c = V(633)
              , T = V(269)
              , W = V(600)
              , i = V(435)
              , F = V(248)
              , r = V(373)
              , s = V(971)
              , h = V(926)
              , o = V(976)
              , m = V(18)
              , M = V(591);
            t.FMP4Player = class {
                constructor(e) {
                    var t, V, l;
                    this.stack = (0,
                    m.createDisposableStack)(),
                    this.state = (0,
                    r.mutableState)({
                        state: "IDLE",
                        context: {
                            stream: Object.assign(Object.assign({}, e.stream), {
                                codec: e.codec
                            }),
                            configuration: {
                                video: e.video,
                                transport: e.transport,
                                initBufferLength: null !== (t = e.initBufferLength) && void 0 !== t ? t : 1e3,
                                volume: null !== (V = e.volume) && void 0 !== V ? V : 1,
                                muted: null === (l = e.muted) || void 0 === l || l
                            }
                        }
                    }),
                    this.stats = {
                        streamName: (0,
                        r.mutableState)(e.stream.name, {
                            replay: !0
                        }),
                        pts: (0,
                        i.measurePts)(e.video),
                        wallclock: (0,
                        F.measureWallclock)(),
                        latency: (0,
                        W.measureLatency)(),
                        bufferLength: (0,
                        Z.measureBufferLength)(),
                        bitrate: (0,
                        r.notifier)(),
                        droppedFrames: (0,
                        c.measureDroppedFrames)(e.video),
                        fps: (0,
                        T.measureFps)(e.video),
                        bandwidth: (0,
                        r.notifier)(),
                        isBuffering: (0,
                        N.measureBuffering)(e.video)
                    };
                    const d = window.setInterval(this.onTick.bind(this), 1e3);
                    this.stack.defer(( () => window.clearInterval(d)))
                }
                onTick() {
                    this.stats.fps.tick(),
                    this.stats.droppedFrames.tick(),
                    this.stats.latency.tick()
                }
                play() {
                    return l(this, void 0, void 0, (function*() {
                        const e = this.state.get();
                        if ("IDLE" !== e.state)
                            return;
                        const {stream: t, configuration: V} = e.context
                          , l = yield V.transport(t.url, this.dispose.bind(this));
                        this.stack.defer(l.dispose),
                        l.stats.bandwidth.subscribe((e => this.stats.bandwidth.notify(e))),
                        l.stats.bitrate.subscribe((e => this.stats.bitrate.notify(e)));
                        const Z = (0,
                        a.createBufferManager)();
                        this.stack.defer(Z.dispose),
                        l.binaries.subscribe((e => Z.push(e.buffer)));
                        const N = (0,
                        R.mseRenderer)(V.video, t.codec, Z, this.dispose.bind(this));
                        this.stack.defer(N.dispose);
                        const c = (0,
                        d.createAudioPlayer)(V.video, V.volume, V.muted)
                          , T = (0,
                        U.createSwitcher)(t, l);
                        this.stack.defer(T.dispose);
                        const W = (0,
                        n.egwc)();
                        this.stack.defer(W.dispose),
                        l.binaries.subscribe((e => W.push(e.buffer))),
                        this.stats.pts.subscribe((e => this.stats.wallclock.push(e))),
                        W.subscribe((e => this.stats.wallclock.setReference(e))),
                        this.stats.wallclock.subscribe((e => this.stats.latency.setWallclock(e))),
                        l.stats.serverTime.subscribe((e => this.stats.latency.setTimeSync(e))),
                        this.stats.pts.subscribe((e => this.stats.bufferLength.setCurrentTime(e))),
                        W.subscribe((e => this.stats.bufferLength.setPts(e.pts)));
                        const i = (0,
                        s.cond)(this.stats.bufferLength, (e => e > V.initBufferLength ? (0,
                        M.some)(void 0) : (0,
                        M.none)()))
                          , F = (0,
                        o.deferred)();
                        this.stack.defer(( () => {
                            const e = this.state.get()
                              , t = "DESTROYED" === e.state && e.error ? e.error : new Error("Play is cancelled");
                            F.reject(t)
                        }
                        )),
                        Promise.all([l.play(t), i]).then(( () => N.render())).then(( () => F.resolve())).catch(F.reject),
                        yield F.promise,
                        this.state.set({
                            state: "PLAYING",
                            context: {
                                transport: l,
                                renderer: N,
                                audio: c,
                                switcher: T
                            }
                        })
                    }
                    ))
                }
                setVolume(e) {
                    const t = this.state.get();
                    "PLAYING" === t.state && t.context.audio.setVolume(e)
                }
                mute(e) {
                    const t = this.state.get();
                    "PLAYING" === t.state && t.context.audio.mute(e)
                }
                setPlaybackRate(e) {
                    const t = this.state.get();
                    "PLAYING" === t.state && t.context.audio.setPlaybackRate(e)
                }
                switchStream(e) {
                    const t = this.state.get();
                    if ("PLAYING" !== t.state)
                        return;
                    const {switcher: V} = t.context;
                    V.change(e).then(( () => l(this, void 0, void 0, (function*() {
                        const t = yield Promise.all([(0,
                        h.once)(this.stats.bufferLength), (0,
                        h.once)(this.stats.pts)]).then(( ([e,t]) => e + t)).catch(console.error);
                        if (t) {
                            for (; (yield(0,
                            h.once)(this.stats.pts)) < t; )
                                ;
                            this.stats.streamName.set(e.name)
                        }
                    }
                    ))))
                }
                dispose(e) {
                    this.state.set({
                        state: "DESTROYED",
                        error: e
                    });
                    for (const t of [...Object.values(this.stats), this.stack, this.state])
                        t.dispose()
                }
            }
        },
        837: function(e, t, V) {
            "use strict";
            var l = this && this.__awaiter || function(e, t, V, l) {
                return new (V || (V = Promise))((function(d, a) {
                    function U(e) {
                        try {
                            R(l.next(e))
                        } catch (t) {
                            a(t)
                        }
                    }
                    function n(e) {
                        try {
                            R(l.throw(e))
                        } catch (t) {
                            a(t)
                        }
                    }
                    function R(e) {
                        var t;
                        e.done ? d(e.value) : (t = e.value,
                        t instanceof V ? t : new V((function(e) {
                            e(t)
                        }
                        ))).then(U, n)
                    }
                    R((l = l.apply(e, t || [])).next())
                }
                ))
            }
              , d = this && this.__await || function(e) {
                return this instanceof d ? (this.v = e,
                this) : new d(e)
            }
              , a = this && this.__asyncGenerator || function(e, t, V) {
                if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined.");
                var l, a = V.apply(e, t || []), U = [];
                return l = Object.create(("function" == typeof AsyncIterator ? AsyncIterator : Object).prototype),
                n("next"),
                n("throw"),
                n("return", (function(e) {
                    return function(t) {
                        return Promise.resolve(t).then(e, N)
                    }
                }
                )),
                l[Symbol.asyncIterator] = function() {
                    return this
                }
                ,
                l;
                function n(e, t) {
                    a[e] && (l[e] = function(t) {
                        return new Promise((function(V, l) {
                            U.push([e, t, V, l]) > 1 || R(e, t)
                        }
                        ))
                    }
                    ,
                    t && (l[e] = t(l[e])))
                }
                function R(e, t) {
                    try {
                        (V = a[e](t)).value instanceof d ? Promise.resolve(V.value.v).then(Z, N) : c(U[0][2], V)
                    } catch (l) {
                        c(U[0][3], l)
                    }
                    var V
                }
                function Z(e) {
                    R("next", e)
                }
                function N(e) {
                    R("throw", e)
                }
                function c(e, t) {
                    e(t),
                    U.shift(),
                    U.length && R(U[0][0], U[0][1])
                }
            }
            ;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.createSwitcher = function(e, t) {
                let V = e;
                const n = function() {
                    return a(this, arguments, (function*() {
                        for (; ; ) {
                            const [l,a] = yield yield d(void 0);
                            if (V.name !== l.name)
                                try {
                                    yield d(t.switchStream(l)),
                                    a.resolve(),
                                    V = l
                                } catch (e) {
                                    a.reject(e)
                                }
                            else
                                a.resolve()
                        }
                    }
                    ))
                }();
                return n.next().catch(console.error),
                {
                    change: function(e) {
                        return l(this, void 0, void 0, (function*() {
                            const t = (0,
                            U.deferred)();
                            return n.next([e, t]).catch(console.error),
                            t.promise
                        }
                        ))
                    },
                    dispose: function() {
                        n.return().catch(console.error)
                    }
                }
            }
            ;
            const U = V(976)
        },
        60: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.egwc = function() {
                const e = (0,
                d.notifier)();
                let t, V;
                return {
                    subscribe: e.subscribe,
                    unsubscribe: e.unsubscribe,
                    push: function(d) {
                        var a, U;
                        for (const e of null !== (a = (0,
                        l.findAtom)(new Uint8Array(d), ["moov", "trak"])) && void 0 !== a ? a : []) {
                            const t = (0,
                            l.parseVideoMeta)(e);
                            t && (V = t.timeScale)
                        }
                        if (!V)
                            return;
                        const [n] = null !== (U = (0,
                        l.findAtom)(new Uint8Array(d), ["egwc"])) && void 0 !== U ? U : [];
                        if (!n)
                            return;
                        const R = (0,
                        l.getEgwc)(n);
                        void 0 === t && (t = R.pts);
                        const Z = 1e3 * (R.pts - t) / V;
                        e.notify(Object.assign(Object.assign({}, R), {
                            pts: Z
                        }))
                    },
                    dispose: e.dispose
                }
            }
            ;
            const l = V(282)
              , d = V(373)
        }
        ,
        704: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.FMP4Error = t.FMP4Player = void 0;
            var l = V(14);
            Object.defineProperty(t, "FMP4Player", {
                enumerable: !0,
                get: function() {
                    return l.FMP4Player
                }
            });
            var d = V(545);
            Object.defineProperty(t, "FMP4Error", {
                enumerable: !0,
                get: function() {
                    return d.FMP4Error
                }
            })
        }
        ,
        398: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.getCurrentTime = function(e) {
                const t = e.buffered.length - 1;
                if (t < 0)
                    return 0;
                const V = e.buffered.end(t);
                if (e.currentTime > V)
                    return V;
                if (1 === e.buffered.length) {
                    const t = e.buffered.start(0);
                    if (t > e.currentTime)
                        return t
                }
                return e.currentTime
            }
        }
        ,
        402: function(e, t, V) {
            "use strict";
            var l = this && this.__awaiter || function(e, t, V, l) {
                return new (V || (V = Promise))((function(d, a) {
                    function U(e) {
                        try {
                            R(l.next(e))
                        } catch (t) {
                            a(t)
                        }
                    }
                    function n(e) {
                        try {
                            R(l.throw(e))
                        } catch (t) {
                            a(t)
                        }
                    }
                    function R(e) {
                        var t;
                        e.done ? d(e.value) : (t = e.value,
                        t instanceof V ? t : new V((function(e) {
                            e(t)
                        }
                        ))).then(U, n)
                    }
                    R((l = l.apply(e, t || [])).next())
                }
                ))
            }
            ;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.mseRenderer = function(e, t, V, c, T=[R.unpause, n.timelineGap]) {
                const W = (0,
                U.createDisposableStack)();
                let i, F, r = !1, s = "append";
                function h() {
                    if (i) {
                        i.removeEventListener("sourceopen", h);
                        try {
                            F = function(e, V) {
                                return F = V.addSourceBuffer(t),
                                F.mode = "sequence",
                                F.addEventListener("error", M),
                                F.addEventListener("updateend", m),
                                e.defer(( () => {
                                    F && (F.removeEventListener("updateend", m),
                                    F.removeEventListener("error", M),
                                    "open" === V.readyState && F.abort(),
                                    F = void 0)
                                }
                                )),
                                F
                            }(W, i)
                        } catch (e) {
                            c(new d.FMP4Error("MEDIA_ERROR",e.message)),
                            E()
                        }
                    }
                }
                function o() {
                    if (i && "open" !== i.readyState)
                        return;
                    if (!F)
                        return;
                    if (r)
                        return;
                    const e = V.shift();
                    if (e) {
                        r = !0;
                        try {
                            F.appendBuffer(e)
                        } catch (t) {
                            r = !1,
                            c(new d.FMP4Error("MEDIA_ERROR",`SourceBuffer failed - error: ${t.message}`)),
                            E()
                        }
                    }
                }
                function m() {
                    r = !1,
                    s = "append" === s ? "remove" : "append",
                    "remove" === s && function() {
                        if (i && "open" !== i.readyState)
                            return;
                        if (!F)
                            return;
                        if (r)
                            return;
                        if (r = !0,
                        F.buffered.length < 1)
                            return void (r = !1);
                        const t = F.buffered.start(F.buffered.length - 1)
                          , V = (0,
                        a.getCurrentTime)(e) - Z;
                        if (V > t)
                            try {
                                F.remove(0, V)
                            } catch (l) {
                                r = !1,
                                c(new d.FMP4Error("MEDIA_ERROR",`SourceBuffer failed - error: ${l.message}`)),
                                E()
                            }
                        else
                            r = !1
                    }(),
                    "append" === s && o()
                }
                function M() {
                    c(new d.FMP4Error("MEDIA_ERROR","SourceBuffer failed")),
                    E()
                }
                function S() {
                    null != e.error && (c(function(e) {
                        var t;
                        const V = e.code
                          , l = `${null !== (t = N.get(V)) && void 0 !== t ? t : "MEDIA_ERR_UNKNOWN"}${e.message ? ` - ${e.message}` : ""}`;
                        return new d.FMP4Error("MEDIA_ERROR",l,V)
                    }(e.error)),
                    E())
                }
                function E() {
                    V.bufferLength.unsubscribe(o),
                    W.dispose()
                }
                return function(e, t) {
                    if (i = "ManagedMediaSource"in window ? new window.ManagedMediaSource : new window.MediaSource,
                    !i)
                        return;
                    e.defer(( () => {
                        i && "open" === i.readyState && i.endOfStream()
                    }
                    )),
                    i.addEventListener("sourceopen", h),
                    t.src = "",
                    t.load(),
                    t.preservesPitch = !0,
                    t.disableRemotePlayback = !0,
                    t.addEventListener("error", S);
                    const V = URL.createObjectURL(i);
                    e.defer(( () => URL.revokeObjectURL(V))),
                    t.src = V,
                    e.defer(( () => {
                        t.removeEventListener("error", S),
                        t.src = "",
                        t.load()
                    }
                    ))
                }(W, e),
                V.bufferLength.subscribe(o),
                {
                    render: function() {
                        return l(this, void 0, void 0, (function*() {
                            yield e.play();
                            for (const t of T) {
                                const l = t({
                                    video: e,
                                    buffer: V,
                                    onError: c
                                });
                                W.defer(l)
                            }
                        }
                        ))
                    },
                    dispose: E
                }
            }
            ;
            const d = V(704)
              , a = V(398)
              , U = V(18)
              , n = V(32)
              , R = V(794)
              , Z = 2
              , N = new Map([[1, "MEDIA_ERR_ABORTED"], [2, "MEDIA_ERR_NETWORK"], [3, "MEDIA_ERR_DECODE"], [4, "MEDIA_ERR_SRC_NOT_SUPPORTED"]])
        },
        32: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.timelineGap = function(e, t=3) {
                const {video: V, buffer: d} = e;
                let a, U = 0;
                function n() {
                    if (0 === V.buffered.length)
                        return;
                    const e = (0,
                    l.getCurrentTime)(V);
                    if (void 0 === a)
                        return a = e,
                        void (U = 0);
                    if (a !== e)
                        return a = e,
                        void (U = 0);
                    if (a === e && U++,
                    U >= t) {
                        const e = V.buffered.start(V.buffered.length - 1);
                        if (e < V.currentTime)
                            return;
                        V.currentTime = e,
                        a = V.currentTime,
                        U = 0
                    }
                }
                return d.bufferLength.subscribe(n),
                function() {
                    d.bufferLength.unsubscribe(n)
                }
            }
            ;
            const l = V(398)
        }
        ,
        794: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.unpause = function(e) {
                const {video: t, onError: V} = e;
                function d() {
                    const e = t.buffered.length;
                    if (0 === e)
                        return;
                    const d = t.buffered.end(e - 1);
                    t.currentTime > d && (t.currentTime = d),
                    new Promise((e => setTimeout(e, 0))).then(( () => t.play())).catch((e => {
                        var t, d;
                        const a = new l.FMP4Error("MEDIA_ERROR",`Failed to unpause - ${null !== (t = e.code) && void 0 !== t ? t : ""}: ${null !== (d = e.message) && void 0 !== d ? d : ""}`);
                        V(a)
                    }
                    ))
                }
                return t.addEventListener("pause", d),
                function() {
                    t.removeEventListener("pause", d)
                }
            }
            ;
            const l = V(545)
        }
        ,
        578: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.measureBufferLength = function() {
                const e = (0,
                l.notifier)();
                let t, V;
                function d() {
                    if (void 0 === t)
                        return;
                    if (void 0 === V)
                        return;
                    const l = Math.max(0, V - t);
                    e.notify(l)
                }
                return {
                    subscribe: e.subscribe,
                    unsubscribe: e.unsubscribe,
                    dispose: e.dispose,
                    setCurrentTime: function(e) {
                        t = e,
                        d()
                    },
                    setPts: function(e) {
                        V && e < V || (V = e,
                        void 0 === t && (t = V),
                        d())
                    }
                }
            }
            ;
            const l = V(373)
        }
        ,
        580: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.measureBuffering = function(e) {
                const t = (0,
                l.notifier)();
                function V() {
                    t.notify(!1)
                }
                function d() {
                    t.notify(!0)
                }
                return e.addEventListener("playing", V),
                e.addEventListener("waiting", d),
                {
                    subscribe: t.subscribe,
                    unsubscribe: t.unsubscribe,
                    dispose: function() {
                        t.dispose(),
                        e.removeEventListener("playing", V),
                        e.removeEventListener("waiting", d)
                    }
                }
            }
            ;
            const l = V(373)
        }
        ,
        633: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.measureDroppedFrames = function(e) {
                const t = (0,
                l.notifier)();
                return {
                    subscribe: t.subscribe,
                    unsubscribe: t.unsubscribe,
                    dispose: t.dispose,
                    tick: function() {
                        const V = e.getVideoPlaybackQuality().droppedVideoFrames;
                        t.notify(V)
                    }
                }
            }
            ;
            const l = V(373)
        }
        ,
        269: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.measureFps = function(e) {
                const t = (0,
                l.notifier)();
                let V;
                return {
                    subscribe: t.subscribe,
                    unsubscribe: t.unsubscribe,
                    dispose: t.dispose,
                    tick: function() {
                        const l = e.getVideoPlaybackQuality();
                        if (void 0 === V)
                            return void (V = l);
                        const d = l.totalVideoFrames - l.droppedVideoFrames - (V.totalVideoFrames - V.droppedVideoFrames)
                          , a = l.creationTime - V.creationTime;
                        t.notify(d / a * 1e3),
                        V = l
                    }
                }
            }
            ;
            const l = V(373)
        }
        ,
        600: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.measureLatency = function() {
                const e = (0,
                l.notifier)();
                let t, V;
                function d() {
                    if (!t)
                        return;
                    if (!V)
                        return;
                    const l = Math.round(performance.now());
                    e.notify(V.serverTime + (l - V.clientTime) - t)
                }
                return Object.assign(Object.assign({}, e), {
                    setWallclock: function(e) {
                        t = e,
                        d()
                    },
                    setTimeSync: function(e) {
                        V = e,
                        d()
                    },
                    tick: d
                })
            }
            ;
            const l = V(373)
        }
        ,
        435: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.measurePts = function(e, t=l.getCurrentTime) {
                const V = (0,
                d.notifier)();
                let a;
                function U() {
                    const l = 1e3 * t(e);
                    l <= 0 || (void 0 === a && (a = l),
                    V.notify(l - a))
                }
                return e.addEventListener("timeupdate", U),
                {
                    subscribe: V.subscribe,
                    unsubscribe: V.unsubscribe,
                    dispose: function() {
                        e.removeEventListener("timeupdate", U),
                        V.dispose()
                    }
                }
            }
            ;
            const l = V(398)
              , d = V(373)
        }
        ,
        248: (e, t, V) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.measureWallclock = function() {
                const e = (0,
                l.notifier)();
                let t;
                return Object.assign(Object.assign({}, e), {
                    setReference: function(e) {
                        t = e
                    },
                    push: function(V) {
                        void 0 !== t && e.notify(Math.trunc(V + (t.wallclock - t.pts)))
                    }
                })
            }
            ;
            const l = V(373)
        }
        ,
        373: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.notifier = function() {
                const e = [];
                return {
                    notify: function(t) {
                        for (const V of e.slice())
                            V(t)
                    },
                    subscribe: function(t) {
                        e.push(t)
                    },
                    unsubscribe: function(t) {
                        const V = e.indexOf(t);
                        V > -1 && e.splice(V, 1)
                    },
                    dispose: function() {
                        e.splice(0)
                    }
                }
            }
            ,
            t.mutableState = function(e, t={
                replay: !1
            }) {
                let V = e;
                const l = [];
                return {
                    set: function(e) {
                        V = e;
                        for (const t of l.slice())
                            t(V)
                    },
                    get: function() {
                        return V
                    },
                    subscribe: function(e) {
                        l.push(e),
                        t.replay && e(V)
                    },
                    unsubscribe: function(e) {
                        const t = l.indexOf(e);
                        t > -1 && l.splice(t, 1)
                    },
                    dispose: function() {
                        l.splice(0)
                    }
                }
            }
        }
        ,
        971: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.cond = function(e, t) {
                const V = "subscribe"in e ? e.subscribe : e.addListener.bind(e)
                  , l = "unsubscribe"in e ? e.unsubscribe : e.removeListener.bind(e);
                return new Promise((e => {
                    V((function V(d) {
                        const a = t(d);
                        "none" !== a.kind && (e(a.value),
                        l(V))
                    }
                    ))
                }
                ))
            }
        }
        ,
        926: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.once = function(e) {
                return new Promise((t => {
                    e.subscribe((function V(l) {
                        t(l),
                        e.unsubscribe(V)
                    }
                    ))
                }
                ))
            }
        }
        ,
        976: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.deferred = function() {
                let e, t, V = !1;
                return {
                    promise: new Promise(( (l, d) => {
                        e = e => {
                            V || (V = !0,
                            l(e))
                        }
                        ,
                        t = e => {
                            V || (V = !0,
                            d(e))
                        }
                    }
                    )),
                    resolve: e,
                    reject: t
                }
            }
        }
        ,
        18: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.createDisposableStack = function() {
                const e = [];
                return {
                    defer: function(t) {
                        e.push(t)
                    },
                    dispose: function() {
                        for (var t; e.length > 0; )
                            try {
                                null === (t = e.pop()) || void 0 === t || t()
                            } catch (V) {
                                console.error(V)
                            }
                    }
                }
            }
        }
        ,
        591: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.some = function(e) {
                return {
                    kind: "some",
                    value: e
                }
            }
            ,
            t.none = function() {
                return {
                    kind: "none"
                }
            }
        }
        ,
        833: (e, t, V) => {
            "use strict";
            V.d(t, {
                version: () => l
            });
            const l = "13.84.0_13.20241220.112403_eebbbae7"
        }
    }
      , t = {};
    function V(l) {
        var d = t[l];
        if (void 0 !== d)
            return d.exports;
        var a = t[l] = {
            exports: {}
        };
        return e[l].call(a.exports, a, a.exports, V),
        a.exports
    }
    V.d = (e, t) => {
        for (var l in t)
            V.o(t, l) && !V.o(e, l) && Object.defineProperty(e, l, {
                enumerable: !0,
                get: t[l]
            })
    }
    ,
    V.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
    V.r = e => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ;
    var l = {};
    return ( () => {
        "use strict";
        V.r(l),
        V.d(l, {
            AudioCodec: () => e.AudioCodec,
            BatteryManager: () => Z.BatteryManager,
            BrowserFeatures: () => t.BrowserFeatures,
            BrowserFeaturesStats: () => d.BrowserFeaturesStats,
            EvoError: () => Qe,
            EvoPlayerReactiveProps: () => N.EvoPlayerReactiveProps,
            EvoPlayerSubscribers: () => N.EvoPlayerSubscribers,
            EvoVideoComponentError: () => e.EvoVideoComponentError,
            EvoVideoPlayerAPI: () => N.EvoVideoPlayerAPI,
            FullTableSettings: () => n.FullTableSettings,
            GlobalConfig: () => N.GlobalConfig,
            LoadingMetrics: () => Z.LoadingMetrics,
            ManifestFetchStats: () => Z.ManifestFetchStats,
            ManifestLogic: () => b,
            MediaErrorName: () => e.MediaErrorName,
            MediaPlayerEventData: () => R.MediaPlayerEventData,
            NetworkInformation: () => a.NetworkInformation,
            ObjectFit: () => e.ObjectFit,
            PlaybackAttemptEvent: () => Z.PlaybackAttemptEvent,
            PlaybackData: () => R.PlaybackData,
            PlaybackError: () => H,
            PlayerName: () => k,
            PlayerStats: () => Z.PlayerStats,
            Publisher: () => U.Publisher,
            Quality: () => m,
            QualityIndex: () => M,
            QualityMode: () => E,
            QualityResolution: () => S,
            RawConfig: () => N.RawConfig,
            SecurityError: () => B,
            Statistics: () => Z.Statistics,
            Stats: () => Z.Stats,
            StatsCallbacks: () => Z.StatsCallbacks,
            StatsClientData: () => Z.StatsClientData,
            StatsComponentData: () => Z.StatsComponentData,
            StatsDeviceData: () => Z.StatsDeviceData,
            StatsError: () => Z.StatsError,
            StatsHeartbeat: () => Z.StatsHeartbeat,
            StatsInfo: () => Z.StatsInfo,
            StatsInfoData: () => Z.StatsInfoData,
            StatsInitialized: () => Z.StatsInitialized,
            StatsInitializedMetrics: () => Z.StatsInitializedMetrics,
            StatsInitializedSessionData: () => Z.StatsInitializedSessionData,
            StatsLogicData: () => Z.StatsLogicData,
            StatsMessageMap: () => Z.StatsMessageMap,
            StatsMetricsData: () => Z.StatsMetricsData,
            StatsPlaybackAttempt: () => Z.StatsPlaybackAttempt,
            StatsPlaybackAttemptLogicData: () => Z.StatsPlaybackAttemptLogicData,
            StatsPlaybackStarted: () => Z.StatsPlaybackStarted,
            StatsPlaybackStartedLogicData: () => Z.StatsPlaybackStartedLogicData,
            StatsSessionData: () => Z.StatsSessionData,
            StatsVideoData: () => Z.StatsVideoData,
            StreamProviderErrorTypes: () => j,
            Subscriber: () => U.Subscriber,
            SubscriberFn: () => N.SubscriberFn,
            SupportError: () => D,
            TableSettings: () => n.TableSettings,
            TableSettingsKeyPrefix: () => n.TableSettingsKeyPrefix,
            UnknownError: () => O,
            VideoCodec: () => e.VideoCodec,
            VideoPlaylist: () => z,
            VideoQualityString: () => p,
            WithGetter: () => N.WithGetter,
            WithSetGet: () => N.WithSetGet,
            WithSetter: () => N.WithSetter,
            WithSubUnsub: () => N.WithSubUnsub,
            createEvoPlayer: () => Ha,
            defaultReactiveProps: () => w,
            defaultTableSettings: () => mV,
            detectBrowserFeatures: () => le,
            featuresToStats: () => $t,
            isMultiManifestStream: () => et,
            version: () => Yt.version
        });
        var e = {};
        V.r(e),
        V.d(e, {
            DX: () => I,
            kI: () => Y,
            A_: () => b,
            zq: () => u,
            ib: () => H,
            A: () => G,
            hZ: () => k,
            jB: () => y,
            en: () => m,
            yb: () => M,
            V0: () => E,
            UT: () => S,
            Vx: () => B,
            af: () => j,
            Gx: () => D,
            Kj: () => X,
            Bk: () => O,
            Wo: () => v,
            UC: () => z,
            eY: () => p,
            LF: () => A,
            rF: () => w,
            hv: () => Q,
            tY: () => J,
            kK: () => x
        });
        var t = {};
        V.r(t),
        V.d(t, {
            j: () => le
        });
        var d = {};
        V.r(d),
        V.d(d, {
            IU: () => $t,
            k6: () => qt
        });
        var a = {};
        V.r(a),
        V.d(a, {
            z: () => VV
        });
        var U = {};
        V.r(U),
        V.d(U, {
            j: () => nV
        });
        var n = {};
        V.r(n),
        V.d(n, {
            b: () => mV,
            P: () => MV
        });
        var R = {};
        V.r(R);
        var Z = {};
        V.r(Z);
        var N = {};
        function c(e, t, V) {
            let l = !1
              , d = t => {
                if (!l)
                    try {
                        null == e || e(t)
                    } catch (V) {
                        if (V instanceof Error)
                            return void (null == a || a(V));
                        throw new Error(`Invalid error thrown - ${V}`)
                    }
            }
              , a = e => {
                l || (null == t || t(e),
                null == U || U())
            }
              , U = () => {
                l || (l = !0,
                null == V || V())
            }
            ;
            return {
                onNext(e) {
                    null == d || d(e)
                },
                onError(e) {
                    null == a || a(e)
                },
                onComplete() {
                    null == U || U(),
                    d = void 0,
                    a = void 0,
                    U = void 0
                }
            }
        }
        function T(e= () => {}
        ) {
            let t = !1;
            return {
                isClosed: () => t,
                close() {
                    t || (t = !0,
                    e())
                },
                closeBy(e) {
                    e.add(this)
                }
            }
        }
        V.r(N);
        class W {
            constructor(e) {
                this.observe = e
            }
            pipe(...e) {
                return e.reduce(( (e, t) => t(e)), this)
            }
            subscribe(e, t, V) {
                return this.observe(c(e, t, V))
            }
        }
        class i extends W {
            constructor() {
                super(( () => T())),
                this.observers = []
            }
            next(e) {
                this.subscription && this.onNext(e)
            }
            error(e) {
                this.subscription && this.onError(e)
            }
            complete() {
                this.subscription && (this.onComplete(),
                this.disconnect())
            }
            onComplete() {
                for (const e of this.observers.slice())
                    e.onComplete()
            }
            onError(e) {
                for (const t of this.observers.slice())
                    t.onError(e)
            }
            onNext(e) {
                for (const t of this.observers.slice())
                    t.onNext(e)
            }
            subscribe(e, t, V) {
                return this.connectAndSubscribe(c(e, t, V))
            }
            connect() {
                this.subscription = this.observe(c(this.next, this.error, this.complete))
            }
            disconnect() {
                var e;
                this.observers = [],
                null === (e = this.subscription) || void 0 === e || e.close(),
                this.subscription = void 0
            }
            connectAndSubscribe(e) {
                return this.subscription || this.connect(),
                this.observers.push(e),
                T(( () => {
                    const t = this.observers.indexOf(e);
                    -1 !== t && (this.observers.splice(t, 1),
                    this.observers.length > 0 || this.disconnect())
                }
                ))
            }
        }
        class F extends i {
            constructor(e) {
                super(),
                this.value = e
            }
            next(e) {
                this.value = e,
                super.next(e)
            }
            subscribe(e, t, V) {
                const l = c(e, t, V)
                  , d = super.connectAndSubscribe(l);
                return l.onNext(this.value),
                d
            }
        }
        const r = (e= (e, t) => e === t) => t => new W((V => {
            let l, d = !1;
            return t.subscribe((t => {
                if (!d)
                    return d = !0,
                    l = t,
                    void V.onNext(t);
                d && !e(t, l) && V.onNext(t),
                l = t
            }
            ), V.onError, V.onComplete)
        }
        ));
        class s {
            constructor() {
                this.disposables = []
            }
            add(e) {
                this.disposables.push(e)
            }
            close() {
                this.disposables.splice(0, this.disposables.length).reverse().filter((e => !e.isClosed())).forEach((e => e.close()))
            }
        }
        function h(e, t=new s) {
            return new W((V => {
                function l() {
                    V.onComplete(),
                    t.close()
                }
                const d = {
                    onNext: V.onNext,
                    onError: function(e) {
                        V.onError(e),
                        l()
                    },
                    onComplete: l
                };
                return e(t, d),
                T(( () => t.close()))
            }
            ))
        }
        function o(e, t) {
            return h(( (V, l) => {
                const d = new i
                  , a = [];
                d.subscribe(( ([V,d]) => {
                    a[V] = d;
                    const U = a.filter(( () => !0));
                    if (U.length < e.length)
                        return;
                    const n = t(U);
                    l.onNext(n)
                }
                )).closeBy(V),
                e.forEach(( (e, t) => {
                    e.subscribe((e => d.next([t, e])), l.onError, l.onComplete).closeBy(V)
                }
                ))
            }
            ))
        }
        const m = {
            "4K": "4K",
            "2K": "2K",
            "HD+": "HD+",
            HD: "HD",
            HIGH: "HIGH",
            MEDIUM: "MEDIUM",
            LOW: "LOW",
            LOWEST: "LOWEST"
        }
          , M = {
            LOWEST: 0,
            LOW: 1,
            MEDIUM: 2,
            HIGH: 3,
            HD: 4,
            "HD+": 5,
            "2K": 6,
            "4K": 7
        }
          , S = {
            [m.LOWEST]: "234p",
            [m.LOW]: "360p",
            [m.MEDIUM]: "486p",
            [m.HIGH]: "720p",
            [m.HD]: "1080p",
            [m["HD+"]]: "1080p",
            [m["2K"]]: "1440p",
            [m["4K"]]: "2160p"
        };
        var E, p, b, k;
        !function(e) {
            e.AUTO = "AUTO",
            e.MANUAL = "MANUAL",
            e.INTERNAL = "INTERNAL"
        }(E || (E = {})),
        function(e) {
            e["4K"] = "4k",
            e["2K"] = "2k",
            e["HD+"] = "hd2",
            e.HD = "hd",
            e.HIGH = "hi",
            e.MEDIUM = "med",
            e.LOW = "low",
            e.LOWEST = "slow",
            e.AUTO = "auto"
        }(p || (p = {})),
        function(e) {
            e[e.BROWSER = 0] = "BROWSER",
            e[e.MANUAL = 1] = "MANUAL",
            e[e.WEBSOCKET = 2] = "WEBSOCKET"
        }(b || (b = {})),
        function(e) {
            e.Fmp4 = "fmp4",
            e.WebCodec = "webcodec",
            e.Wasm = "wasm",
            e.Hls = "hls",
            e.Inhousehls = "inhousehls",
            e.Flipbook = "flipbook",
            e.None = "NONE"
        }(k || (k = {}));
        const Y = "Failed to fetch"
          , Q = {
            LOADING: "loading",
            PLAYING: "playing",
            ERROR: "error"
        }
          , J = {
            UPGRADE: "UPGRADE",
            DOWNGRADE: "DOWNGRADE",
            MANUAL_CHANGE: "MANUAL_CHANGE",
            PLAYER_ATTEMPT: "PLAYER_ATTEMPT",
            PLAYER_STARTED: "PLAYER_STARTED",
            PLAYER_FAILED: "PLAYER_FAILED",
            RECONNECT: "RECONNECT",
            MANIFEST_STATS: "MANIFEST_STATS",
            QUALITY_MODE_CHANGED: "QUALITY_MODE_CHANGED",
            PLAYING: "PLAYING",
            WAITING: "WAITING",
            STREAM_ID_CHANGED: "STREAM_ID_CHANGED",
            WARNING: "WARNING"
        };
        var G, z;
        !function(e) {
            e.ManualChange = "MANUAL_CHANGE",
            e.InsufficientBandwidth = "INSUFFICIENT_BANDWIDTH",
            e.SufficientBandwidth = "SUFFICIENT_BANDWIDTH",
            e.MultiplePlayerFailureCalls = "MULTIPLE_PLAYER_FAILURE_CALLS",
            e.MediaTimeout = "MEDIA_TIMEOUT",
            e.InternalOverride = "INTERNAL_OVERRIDE",
            e.SwitchToAuto = "SWITCH_TO_AUTO",
            e.StreamIdChangeRequested = "STREAM_ID_CHANGE_REQUESTED",
            e.UnknownReason = "UNKNOWN_REASON"
        }(G || (G = {})),
        function(e) {
            e.Default = "view1",
            e.Classic = "view2",
            e.Classic3 = "view3",
            e.Classic4 = "view4",
            e.Immersive = "hd1",
            e.Single = "hd2",
            e.SlingshotRoulette = "slingshot",
            e.Static1 = "view1-static",
            e.Static2 = "view2-static"
        }(z || (z = {}));
        const x = {
            IDLE: "IDLE",
            LOADING: "LOADING",
            PLAYING: "PLAYING",
            STOPPING: "STOPPING",
            DESTROYED: "DESTROYED"
        };
        var u;
        !function(e) {
            e[e.MEDIA_NOT_ALLOWED = 0] = "MEDIA_NOT_ALLOWED",
            e[e.MEDIA_ERR_ABORTED = 1] = "MEDIA_ERR_ABORTED",
            e[e.MEDIA_ERR_NETWORK = 2] = "MEDIA_ERR_NETWORK",
            e[e.MEDIA_ERR_DECODE = 3] = "MEDIA_ERR_DECODE",
            e[e.MEDIA_ERR_SRC_NOT_SUPPORTED = 9] = "MEDIA_ERR_SRC_NOT_SUPPORTED"
        }(u || (u = {}));
        const X = {
            STREAM_HOST: "video.stream.host",
            VIDEO_MASTER_HOST: "video-master-host",
            FLIPBOOK_VIDEO_HOST: "video.flipbook.video.host",
            FLIPBOOK_STREAM_HOST: "flipbook_stream_host",
            FLIPBOOK_STREAM_URL: "flipbook_stream_url",
            TABLE_ID: "table_id",
            GAME_TYPE: "game_type",
            VIEW1_DESKTOP: "view1-desktop",
            VIEW2_DESKTOP: "view2-desktop",
            VIEW3_DESKTOP: "view3-desktop",
            VIEW4_DESKTOP: "view4-desktop",
            VIEW1_MOBILE: "view1-mobile",
            VIEW2_MOBILE: "view2-mobile",
            VIEW3_MOBILE: "view3-mobile",
            VIEW4_MOBILE: "view4-mobile",
            AB_TEST_TICKET: "video_ab_test",
            ENABLE_MUTED_AUTO_PLAY_SUPPORT: "enable_muted_auto_play_support",
            ENABLE_AUTO_PLAY_SUPPORT: "enable_auto_play_support",
            ENABLE_CDN_SKIP: "enable_cdn_skip",
            ENABLE_PLATFORM_EXCEPTIONS: "enable_platform_exceptions",
            ENABLE_HLS_IN_WEBVIEW: "enable_hls_in_webview",
            ENABLE_CUSTOM_REDIRECT: "enable_custom_redirect",
            ENABLE_ERROR_DEBUG: "enable_error_debug",
            LIMITATION: "limitation",
            STREAM_BASE_NAME: "streamBaseName",
            FMP4_ENABLE: "video.fmp4.enable",
            FLIPBOOK_ENABLE: "video.flipbook.enable",
            HLS_ENABLE: "video.hls.enable",
            WASM_ENABLE: "video.wasm.enable"
        };
        var y, B, H, j, D;
        !function(e) {
            e.AcceptableAverageMsBetweenFrames = "ACCEPTABLE_AVERAGE_MS_BETWEEN_FRAMES"
        }(y || (y = {})),
        function(e) {
            e.SecurityReauthFailed = "SECURITY_REAUTH_FAILED",
            e.StreamSecurityError = "STREAM_SECURITY_ERROR",
            e.InvalidConfig = "INVALID_CONFIGURATION"
        }(B || (B = {})),
        function(e) {
            e.WrongMediaElement = "WRONG_MEDIA_ELEMENT",
            e.SourceBufferFull = "SOURCE_BUFFER_FULL",
            e.MediaEnded = "MEDIA_ENDED",
            e.StreamShutdown = "STREAM_SHUTDOWN",
            e.MediaError = "MEDIA_ERROR",
            e.PermissionError = "PERMISSION_ERROR",
            e.MaxLatencyReached = "MAX_LATENCY_REACHED",
            e.NetworkError = "NETWORK_ERROR",
            e.ChunklistStalling = "CHUNKLIST_STALLING",
            e.MaxStallingErrors = "MAX_STALLING_ERRORS",
            e.ValidationTimeout = "VALIDATION_TIMEOUT",
            e.MediaStalledCritical = "MEDIA_STALLED_CRITICAL",
            e.MediaStalled = "MEDIA_STALLED",
            e.ManifestNotFound = "MANIFEST_NOT_FOUND",
            e.ManifestDataError = "MANIFEST_DATA_ERROR",
            e.MediaErrorAborted = "MEDIA_ERROR_ABORTED",
            e.MediaErrorUnsupported = "MEDIA_ERROR_UNSUPPORTED",
            e.InvalidConfig = "INVALID_CONFIGURATION",
            e.NoAvailablePlayers = "NO_AVAILABLE_PLAYERS",
            e.PerformanceError = "PERFORMANCE_ERROR",
            e.DecodeError = "DECODE_ERROR"
        }(H || (H = {})),
        function(e) {
            e.QualityChangeFailed = "QUALITY_CHANGE_FAILED",
            e.SettingNotFound = "SETTING_NOT_FOUND",
            e.WrongPlaylistFormat = "WRONG_PLAYLIST_FORMAT",
            e.CannotResolveUrl = "CANNOT_RESOLVE_URL",
            e.FailedLoadingManifest = "FAILED_LOADING_MANIFEST",
            e.StreamUnavailable = "STREAM_UNAVAILABLE",
            e.UnknownStream = "UNKNOWN_STREAM",
            e.ManifestManagerError = "MANIFEST_MANAGER_ERROR",
            e.PlaylistNotDefined = "PLAYLIST_NOT_DEFINED",
            e.SocketError = "SOCKET_ERROR",
            e.NoQualitiesAvailable = "NO_QUALITIES_AVAILABLE"
        }(j || (j = {})),
        function(e) {
            e.NotSupported = "NOT_SUPPORTED"
        }(D || (D = {}));
        const O = "UNKNOWN_ERROR";
        var A;
        !function(e) {
            e[e.EnableV2 = 6] = "EnableV2",
            e[e.Off = 11] = "Off"
        }(A || (A = {}));
        const w = {
            quality: m.MEDIUM,
            qualityMode: E.AUTO,
            volume: 1,
            muted: !0,
            showInfo: !1,
            streamId: 0,
            enableVideo: !0,
            objectFit: "contain"
        }
          , v = {
            h264: "avc1.640028",
            av1: "av01.0.00M.10"
        }
          , I = {
            aac: "mp4a.40.2",
            opus: "opus"
        };
        function L() {
            const e = window.document.createElement("audio");
            for (const t of Object.values(I))
                if ("probably" !== e.canPlayType(`audio/mp4; codecs="${t}"`))
                    return !1;
            return !0
        }
        function K() {
            const e = document.createElement("canvas");
            return !!window.WebGLRenderingContext && e && !(!e.getContext("webgl") && !e.getContext("experimental-webgl"))
        }
        function g() {
            const e = document.createElement("canvas");
            return !!window.HTMLCanvasElement && !!(e && e.getContext && e.getContext("2d"))
        }
        function f() {
            const e = window.OffscreenCanvas;
            return !!e && !!new e(10,10).getContext("webgl")
        }
        function C() {
            const e = document.createElement("video");
            return !(!e.canPlayType || !e.canPlayType("application/vnd.apple.mpegURL"))
        }
        function P() {
            const e = window.ManagedMediaSource || window.MediaSource;
            return !!e && (!(!window.ManagedSourceBuffer && !window.SourceBuffer) && {
                video: Object.entries(v).map(( ([t,V]) => ({
                    [t]: e.isTypeSupported(`video/mp4; codecs="${V}"`)
                }))).reduce(( (e, t) => Object.assign(e, t)), {}),
                audio: Object.entries(I).map(( ([t,V]) => ({
                    [t]: e.isTypeSupported(`audio/mp4; codecs="${V}"`)
                }))).reduce(( (e, t) => Object.assign(e, t)), {})
            })
        }
        function q() {
            try {
                if ("object" == typeof WebAssembly && "function" == typeof WebAssembly.instantiate) {
                    const e = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
                    if (e instanceof WebAssembly.Module)
                        return new WebAssembly.Instance(e)instanceof WebAssembly.Instance
                }
            } catch (e) {}
            return !1
        }
        function _() {
            try {
                if (q() && window.SharedArrayBuffer)
                    return !!new window.SharedArrayBuffer(1)
            } catch (e) {}
            return !1
        }
        var $, ee = function(e, t, V, l) {
            return new (V || (V = Promise))((function(d, a) {
                function U(e) {
                    try {
                        R(l.next(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function n(e) {
                    try {
                        R(l.throw(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function R(e) {
                    var t;
                    e.done ? d(e.value) : (t = e.value,
                    t instanceof V ? t : new V((function(e) {
                        e(t)
                    }
                    ))).then(U, n)
                }
                R((l = l.apply(e, t || [])).next())
            }
            ))
        };
        function te() {
            return ee(this, void 0, void 0, (function*() {
                if ("VideoDecoder"in window) {
                    const e = Object.entries(v).map(( ([e,t]) => window.VideoDecoder.isConfigSupported({
                        codec: t
                    }).then(( ({supported: t}) => ({
                        [e]: t
                    }))).catch(( () => ({
                        [e]: !1
                    })))));
                    return yield Promise.all(e).then((e => e.reduce(( (e, t) => Object.assign(e, t)), {})))
                }
                return Promise.resolve(!1)
            }
            ))
        }
        function Ve() {
            return ee(this, void 0, void 0, (function*() {
                if ("AudioDecoder"in window) {
                    const e = Object.entries(I).map(( ([e,t]) => window.AudioDecoder.isConfigSupported({
                        codec: t,
                        numberOfChannels: 2,
                        sampleRate: 48e3
                    }).then(( ({supported: t}) => ({
                        [e]: t
                    }))).catch(( () => ({
                        [e]: !1
                    })))));
                    return yield Promise.all(e).then((e => e.reduce(( (e, t) => Object.assign(e, t)), {})))
                }
                return Promise.resolve(!1)
            }
            ))
        }
        function le() {
            const e = Promise.resolve({
                hls: C()
            })
              , t = Promise.resolve({
                mse: P()
            })
              , V = Promise.all([q(), _()]).then(( ([e,t]) => e ? {
                webAssembly: {
                    threads: t
                }
            } : {
                webAssembly: !1
            }))
              , l = [e, t, Promise.all([te(), Ve()]).then(( ([e,t]) => ({
                webCodec: {
                    video: e,
                    audio: t
                }
            }))), Promise.resolve({
                webAudio: L()
            }), V, new Promise((e => {
                const t = new Image;
                t.onload = () => e(!0),
                t.onerror = () => e(!1),
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"
            }
            )).then((e => ({
                webP: e
            }))), Promise.resolve({
                audioWorklet: "AudioWorklet"in window
            }), Promise.resolve({
                audioContext: ["AudioContext", "webkitAudioContext"].some((e => e in window))
            }), Promise.resolve({
                canvas: {
                    context2d: g(),
                    contextWebGl: K(),
                    offscreen: f()
                }
            })];
            return Promise.all(l).then((e => e.reduce(( (e, t) => Object.assign(Object.assign({}, e), t)), {}))).then((e => e))
        }
        function de(e, t) {
            return t >= e.length || "" === e[t] ? 0 : parseInt(e[t], 10)
        }
        function ae(e="", t) {
            const V = e.split(/[._]/i)
              , l = t.split(/[._]/i);
            for (let d = 0; d < Math.max(V.length, l.length); d += 1) {
                const e = de(V, d)
                  , t = de(l, d);
                if (e > t)
                    return 1;
                if (e < t)
                    return -1
            }
            return 0
        }
        !function(e) {
            e[e.Phone = 0] = "Phone",
            e[e.Tablet = 1] = "Tablet",
            e[e.Desktop = 2] = "Desktop"
        }($ || ($ = {}));
        const Ue = {
            [$.Phone]: "mobile",
            [$.Tablet]: "mobile",
            [$.Desktop]: "desktop"
        };
        var ne, Re, Ze, Ne, ce;
        !function(e) {
            e[e.Android = 0] = "Android",
            e[e.Ios = 1] = "Ios",
            e[e.Windows = 2] = "Windows",
            e[e.Macosx = 3] = "Macosx",
            e[e.Linux = 4] = "Linux",
            e[e.Other = 5] = "Other",
            e[e.IpadOs = 6] = "IpadOs"
        }(ne || (ne = {})),
        function(e) {
            e[e.Other = 0] = "Other",
            e[e.Chrome = 1] = "Chrome",
            e[e.Safari = 2] = "Safari",
            e[e.Edge = 3] = "Edge",
            e[e.IE = 4] = "IE",
            e[e.Firefox = 5] = "Firefox",
            e[e.UCBrowser = 6] = "UCBrowser",
            e[e.UCBrowserChina = 7] = "UCBrowserChina",
            e[e.MiBrowser = 8] = "MiBrowser",
            e[e.HuaweiBrowser = 9] = "HuaweiBrowser",
            e[e.OppoBrowser = 10] = "OppoBrowser",
            e[e.MeizuBrowser = 11] = "MeizuBrowser",
            e[e.QQBrowser = 12] = "QQBrowser",
            e[e.Opera = 13] = "Opera",
            e[e.YandexBrowser = 14] = "YandexBrowser",
            e[e.AtomBrowser = 15] = "AtomBrowser",
            e[e.SamsungBrowser = 16] = "SamsungBrowser",
            e[e.Sogou = 17] = "Sogou",
            e[e.Maxthon = 18] = "Maxthon",
            e[e.Threesixty = 19] = "Threesixty",
            e[e.VivoBrowser = 20] = "VivoBrowser",
            e[e.WhaleBrowser = 21] = "WhaleBrowser",
            e[e.CocCocBrowser = 22] = "CocCocBrowser",
            e[e.LiebaoBrowser = 23] = "LiebaoBrowser",
            e[e.BaiduBrowser = 24] = "BaiduBrowser"
        }(Re || (Re = {})),
        function(e) {
            e.IpadNonRetina = "ipad-non-retina",
            e.IpadRetina = "ipad-retina",
            e.IpadPro = "ipad-pro",
            e.IpadPro11inch = "ipad-pro-11inch",
            e.Ipad7 = "ipad7-9",
            e.Ipad4 = "ipad4-5-10",
            e.Ipad2 = "ipad2-3",
            e.Ipad6Mini = "ipad-6-mini"
        }(Ze || (Ze = {})),
        function(e) {
            e.Iphone4 = "iphone4",
            e.Iphone5 = "iphone5",
            e.Iphone6 = "iphone6-8",
            e.IphonePlusZoomed = "iphone-plus-zoomed",
            e.Iphone6Plus = "iphone6Plus",
            e.Iphone10 = "iphone10-11",
            e.Iphone10Zoomed = "iphone10Zoomed",
            e.Iphone10ProMax = "iphone10ProMax",
            e.Iphone10R = "iphone10R",
            e.Iphone10RZoomed = "iphone10RZoomed",
            e.Iphone12 = "iphone12-13",
            e.Iphone12ProMax = "iphone12ProMax",
            e.Iphone14 = "iphone14-15"
        }(Ne || (Ne = {})),
        function(e) {
            e.UNKNOWN = "UNKNOWN",
            e.iPAD = "iPAD",
            e.iPHONE = "iPHONE"
        }(ce || (ce = {}));
        const Te = [{
            min: 320,
            max: 480,
            ratio: 2,
            type: Ne.Iphone4
        }, {
            min: 320,
            max: 568,
            ratio: 2,
            type: Ne.Iphone5
        }, {
            min: 375,
            max: 667,
            ratio: 2,
            type: Ne.Iphone6
        }, {
            min: 375,
            max: 667,
            ratio: 3,
            type: Ne.Iphone6
        }, {
            min: 414,
            max: 736,
            ratio: 3,
            type: Ne.Iphone6
        }, {
            min: 375,
            max: 812,
            ratio: 3,
            type: Ne.Iphone10
        }, {
            min: 320,
            max: 693,
            ratio: 3,
            type: Ne.Iphone10
        }, {
            min: 414,
            max: 896,
            ratio: 3,
            type: Ne.Iphone10
        }, {
            min: 414,
            max: 896,
            ratio: 2,
            type: Ne.Iphone10
        }, {
            min: 375,
            max: 812,
            ratio: 2,
            type: Ne.Iphone10
        }, {
            min: 390,
            max: 844,
            ratio: 3,
            type: Ne.Iphone12
        }, {
            min: 428,
            max: 926,
            ratio: 3,
            type: Ne.Iphone12
        }, {
            min: 393,
            max: 852,
            ratio: 3,
            type: Ne.Iphone14
        }, {
            min: 430,
            max: 932,
            ratio: 3,
            type: Ne.Iphone14
        }, {
            min: 768,
            max: 1024,
            ratio: 1,
            type: Ze.IpadNonRetina
        }, {
            min: 768,
            max: 1024,
            ratio: 2,
            type: Ze.IpadRetina
        }, {
            min: 834,
            max: 1194,
            ratio: 2,
            type: Ze.IpadPro11inch
        }, {
            min: 1024,
            max: 1366,
            ratio: 2,
            type: Ze.IpadPro
        }, {
            min: 810,
            max: 1080,
            ratio: 2,
            type: Ze.Ipad7
        }, {
            min: 820,
            max: 1180,
            ratio: 2,
            type: Ze.Ipad4
        }, {
            min: 834,
            max: 1112,
            ratio: 2,
            type: Ze.Ipad2
        }, {
            min: 744,
            max: 1133,
            ratio: 2,
            type: Ze.Ipad6Mini
        }]
          , We = [Re.Chrome, Re.Safari, Re.Firefox, Re.Opera, Re.QQBrowser, Re.YandexBrowser, Re.UCBrowser, Re.Sogou, Re.Maxthon, Re.Threesixty, Re.BaiduBrowser];
        var ie = function(e, t) {
            var V = {};
            for (var l in e)
                Object.prototype.hasOwnProperty.call(e, l) && t.indexOf(l) < 0 && (V[l] = e[l]);
            if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                var d = 0;
                for (l = Object.getOwnPropertySymbols(e); d < l.length; d++)
                    t.indexOf(l[d]) < 0 && Object.prototype.propertyIsEnumerable.call(e, l[d]) && (V[l[d]] = e[l[d]])
            }
            return V
        };
        const Fe = {
            name: "unknown",
            codeName: ce.UNKNOWN
        }
          , re = [{
            name: "iPad",
            codeName: ce.iPAD,
            userAgentMask: /iPad|Intel Mac OS X/i
        }, {
            name: "iPhone",
            codeName: ce.iPHONE,
            userAgentMask: /iPhone|iPod/i
        }]
          , se = {
            width: 1920,
            height: 1080
        }
          , he = m["HD+"]
          , oe = m.HIGH
          , me = [{
            quality: m["4K"],
            width: 3840,
            height: 2160
        }, {
            quality: m["2K"],
            width: 2560,
            height: 1440
        }, {
            quality: m["HD+"],
            width: 1920,
            height: 1080
        }, {
            quality: m.HD,
            width: 1920,
            height: 1080
        }, {
            quality: m.HIGH,
            width: 1280,
            height: 720
        }, {
            quality: m.MEDIUM,
            width: 864,
            height: 486
        }, {
            quality: m.LOW,
            width: 640,
            height: 360
        }, {
            quality: m.LOWEST,
            width: 416,
            height: 234
        }]
          , Me = /\b(WOW64|Win64|x64|x86_64|Windows NT|Intel Mac OS X|CrOS aarch64|X11.*Linux)\b/i;
        function Se() {
            return window ? window.navigator.userAgent : ""
        }
        function Ee() {
            var e, t, V, l;
            return window ? {
                width: null !== (t = null === (e = window.screen) || void 0 === e ? void 0 : e.width) && void 0 !== t ? t : window.innerWidth,
                height: null !== (l = null === (V = window.screen) || void 0 === V ? void 0 : V.height) && void 0 !== l ? l : window.innerHeight
            } : {
                width: 0,
                height: 0
            }
        }
        function pe() {
            return window && window.devicePixelRatio || 1
        }
        function be(e, t) {
            for (const [V,l] of Object.entries(t))
                Object.defineProperty(e, V, {
                    value: l,
                    enumerable: !0
                });
            return e
        }
        function ke(e, t) {
            const V = function(e) {
                return function() {
                    const e = void 0 !== window.orientation
                      , t = navigator.maxTouchPoints > 1;
                    return !!window.navigator.userAgent.match(/(Intel Mac OS X)/i) && e && t
                }() ? $.Tablet : window ? Me.test(e) || !window.matchMedia ? $.Desktop : window.matchMedia("(min-width: 1024px) and (min-height: 600px) and (orientation: landscape), (min-width: 768px) and (orientation: portrait)").matches ? $.Tablet : $.Phone : $.Desktop
            }(t)
              , l = function(e, t) {
                if (e === $.Desktop)
                    return Fe;
                for (const V of re)
                    if (V.userAgentMask.test(t)) {
                        const {userAgentMask: e} = V;
                        return ie(V, ["userAgentMask"])
                    }
                return Fe
            }(V, t)
              , d = function(e, t) {
                const V = [[ne.Ios, /(?:iPhone|iPad).*(?:CPU[^;)]+?OS) ([0-9._]+)/], [ne.Macosx, /(?:Mac OS X) ([0-9._]+)/], [ne.Windows, /(?:Windows NT|Windows Phone) ([0-9._]+)/], [ne.Android, /(?:Android) ([0-9._]*)/], [ne.Linux, /(?:Linux)/]];
                for (const l of V) {
                    const V = e.match(l[1]);
                    if (V) {
                        let e = l[0];
                        const d = (V[1] || "").replace(/_/g, ".");
                        return e === ne.Macosx && t === $.Tablet && (e = ne.IpadOs),
                        {
                            os: e,
                            osVersion: d
                        }
                    }
                }
                return {
                    os: ne.Other,
                    osVersion: ""
                }
            }(t, V)
              , a = function(e, t) {
                const V = [[Re.Edge, /Edge?\/([0-9._]*)/i], [Re.Edge, /EdgA\/([0-9._]*)/i], [Re.Opera, /OPR\/([0-9._]*)/i], [Re.UCBrowser, /UCBrowser\/([0-9._]+) \(UCMini\)/i], [Re.UCBrowser, / UC?Browser\/([0-9._]*)/i], [Re.QQBrowser, / M?QQBrowser\/([0-9._]*)|MttCustomUA/i], [Re.SamsungBrowser, /SamsungBrowser\/([0-9._]*)/i], [Re.VivoBrowser, /VivoBrowser\/([0-9._]*)/i], [Re.HuaweiBrowser, /HuaweiBrowser\/([0-9._]*)/i], [Re.MiBrowser, /MiuiBrowser\/([0-9._]*)/i], [Re.OppoBrowser, /OppoBrowser\/([0-9._]*)/i], [Re.MeizuBrowser, /MZBrowser\/([0-9._]*)/i], [Re.WhaleBrowser, /Whale\/([0-9._]*)/i], [Re.YandexBrowser, /YaBrowser\/([0-9._]*)/i], [Re.AtomBrowser, /Atom\/([0-9._]*)/i], [Re.CocCocBrowser, /coc_coc_browser\/([0-9._]*)/i], [Re.CocCocBrowser, /CoRom\/([0-9._]*)/i], [Re.LiebaoBrowser, /LieBaoFast\/([0-9._]*)/i], [Re.LiebaoBrowser, /LieBao\/([0-9._]*)/i], [Re.BaiduBrowser, /baidubrowser\/([0-9._]*)/i], [Re.BaiduBrowser, /bdbrowser\/([0-9._]*)/i], [Re.BaiduBrowser, /BIDUBrowser\/([0-9._]*)/i], [Re.BaiduBrowser, /baiduboxapp\/([0-9._]*)/i]]
                  , l = [[Re.Sogou, /MetaSr ([0-9\\.]+)/], [Re.Sogou, /SogouMobileBrowser\/([0-9._]*)/], [Re.Sogou, /SogouMSE\/([0-9._]*)/], [Re.Maxthon, /(MXiOS|Maxthon)\/([0-9._]*)/], [Re.Chrome, /Chrome\/([0-9._]*)/i, V], [Re.Chrome, /CriOS\/([0-9._]*)/i], [Re.QQBrowser, / M?QQBrowser\/([0-9._]*)|MttCustomUA/i], [Re.UCBrowserChina, /AliApp/i], [Re.UCBrowser, / UC?Browser\/([0-9._]*)/i], [Re.Firefox, /Firefox\/([0-9\\.]+)/i], [Re.Firefox, /FxiOS\/([0-9\\.]+)/i], [Re.Opera, /OPT\/([0-9._]*)/i], [Re.Edge, /EdgiOS\/([0-9._]*)/i], [Re.Safari, /Version\/([0-9._]+).*?Safari\/[0-9._]*/i], [Re.IE, /Trident\/[0-9._]*.*rv:([0-9._]*)/i], [Re.IE, /IEMobile\/([0-9._]*)/i], [Re.Threesixty, /QihooBrowserHD\/([0-9._]*)|QihooBrowser\/([0-9._]*)/i], [Re.BaiduBrowser, /baiduboxapp\/([0-9._]*)/i]];
                let d, a, U = Re.Other, n = "";
                for (const Z of l) {
                    const t = e.match(Z[1]);
                    if (t) {
                        U = Z[0],
                        n = t[1],
                        d = Z[2];
                        break
                    }
                }
                let R = "";
                if (d)
                    for (const Z of d) {
                        const t = e.match(Z[1]);
                        if (t) {
                            a = Z[0],
                            R = t[1];
                            break
                        }
                    }
                return function(e, t, V) {
                    let l = window;
                    try {
                        for (; l !== l.parent && l.location.origin === l.parent.location.origin; )
                            l = l.parent
                    } catch (d) {}
                    return e === Re.Chrome && t === ne.Android && (!!V.match(/(wv\))/) || !!V.match(/(Chrome\/\d+\.0\.0\.0)/)) && "A3RunInPage"in l
                }(U, t, e) && (U = Re.Threesixty),
                {
                    browser: U,
                    browserVersion: n,
                    browserFork: a,
                    browserForkVersion: R
                }
            }(t, d.os)
              , U = navigator.hardwareConcurrency || null
              , n = function(e, t, V) {
                var l;
                if (e === $.Desktop)
                    return;
                const d = V ? {
                    width: V.width * t,
                    height: V.height * t
                } : se
                  , a = d.width > d.height ? d.width : d.height
                  , U = d.width > d.height ? d.height : d.width
                  , n = me.find((e => a >= e.width && U >= e.height))
                  , R = null !== (l = null == n ? void 0 : n.quality) && void 0 !== l ? l : he;
                return M[R] > M[oe] ? void 0 : oe
            }(V, pe(), e)
              , R = Object.assign(Object.assign(Object.assign(Object.assign({}, l), a), d), {
                platform: V,
                threads: U,
                maxSupportedQuality: n
            });
            return R.os !== ne.Ios && R.os !== ne.IpadOs || (R.appleScreenType = function() {
                var e, t, V, l;
                const d = null !== (t = null === (e = window.screen) || void 0 === e ? void 0 : e.width) && void 0 !== t ? t : window.innerWidth
                  , a = null !== (l = null === (V = window.screen) || void 0 === V ? void 0 : V.height) && void 0 !== l ? l : window.innerHeight
                  , U = window.devicePixelRatio || 1
                  , n = Math.min(d, a)
                  , R = Math.max(d, a);
                for (const Z of Te)
                    if (Z.min === n && Z.max === R && Z.ratio === U)
                        return Z.type;
                return `iphone_${n}x${R}_${U}`
            }()),
            R
        }
        const Ye = function() {
            let e;
            return (t=Se(), V=Ee()) => (e || (e = function(e=Se(), t=Ee()) {
                const V = ke(t, e)
                  , l = be({}, {
                    OS: ne,
                    Device: ce,
                    Browser: Re,
                    userAgent: e,
                    getDevicePixelRatio: pe,
                    DeviceProperties: V,
                    IS_PHONE: V.platform === $.Phone,
                    IS_TABLET: V.platform === $.Tablet,
                    IS_DESKTOP: V.platform === $.Desktop,
                    IS_IN_IFRAME: ( () => {
                        try {
                            return window.top !== window
                        } catch (e) {
                            return !0
                        }
                    }
                    )(),
                    IS_MACOSX: V.os === ne.Macosx,
                    IS_ANDROID: V.os === ne.Android,
                    IS_CHROME: V.browser === Re.Chrome,
                    IS_SAFARI: V.browser === Re.Safari,
                    IS_IE: V.browser === Re.IE,
                    IS_EDGE: V.browser === Re.Edge || V.browserFork === Re.Edge,
                    IS_FIREFOX: V.browser === Re.Firefox,
                    IS_SOGOU: V.browser === Re.Sogou,
                    IS_MAXTHON: V.browser === Re.Maxthon,
                    IS_UCBROWSER: V.browser === Re.UCBrowser || V.browserFork === Re.UCBrowser,
                    IS_UCBROWSER_CHINA: V.browser === Re.UCBrowserChina,
                    IS_QQBROWSER: V.browser === Re.QQBrowser || V.browserFork === Re.QQBrowser || void 0 !== window.x5mtt,
                    IS_COCCOCBROWSER: V.browserFork === Re.CocCocBrowser,
                    IS_LIEBAOBROWSER: V.browserFork === Re.LiebaoBrowser,
                    IS_MIBROWSER: V.browserFork === Re.MiBrowser,
                    IS_OPPOBROWSER: V.browserFork === Re.OppoBrowser,
                    IS_YANDEXBROWSER: V.browserFork === Re.YandexBrowser,
                    IS_ATOMBROWSER: V.browserFork === Re.AtomBrowser,
                    IS_SAMSUNGBROWSER: V.browserFork === Re.SamsungBrowser,
                    IS_HUAWEIBROWSER: V.browserFork === Re.HuaweiBrowser,
                    IS_VIVOBROWSER: V.browserFork === Re.VivoBrowser,
                    IS_WHALEBROWSER: V.browserFork === Re.WhaleBrowser,
                    IS_MEIZUBROWSER: V.browserFork === Re.MeizuBrowser,
                    IS_OPERA: V.browser === Re.Opera || V.browserFork === Re.Opera,
                    IS_BAIDUBROWSER: V.browser === Re.BaiduBrowser || V.browserFork === Re.BaiduBrowser,
                    IS_IPAD: V.codeName === ce.iPAD,
                    IS_IPHONE: V.codeName === ce.iPHONE
                })
                  , d = be(l, {
                    IS_IOS: l.IS_IPAD || l.IS_IPHONE,
                    IS_IPAD_PRO: l.IS_IPAD && V.appleScreenType === Ze.IpadPro
                })
                  , a = be(d, {
                    IS_IN_IOS_WEB_VIEW: d.IS_IOS && !We.includes(V.browser),
                    IS_IN_ANDROID_WEB_VIEW: l.IS_ANDROID && (!!l.userAgent.match(/(wv\))/) || !!l.userAgent.match(/(Chrome\/\d+\.0\.0\.0)/)),
                    IS_IOS15_OR_GREATER: d.IS_IOS && ae(V.osVersion, "15") >= 0,
                    IS_NATIVE_ANDROID_BROWSER: ( () => {
                        if (!l.IS_ANDROID)
                            return !1;
                        if (l.IS_FIREFOX || l.IS_UCBROWSER || l.IS_QQBROWSER || l.IS_OPERA)
                            return !1;
                        if (!l.IS_CHROME || l.IS_SAMSUNGBROWSER || l.IS_MIBROWSER || l.IS_MEIZUBROWSER || l.IS_OPPOBROWSER)
                            return !0;
                        const {browserVersion: e} = V;
                        return ae(e, "35.0.0") < 0
                    }
                    )()
                })
                  , U = be(a, {
                    IS_SAMSUNG_NATIVE_BROWSER: l.userAgent.indexOf("SamsungBrowser") >= 0,
                    IS_THREESIXTY: V.browser === Re.Threesixty,
                    DEVICE_NAME: ( () => {
                        const {name: e, os: t, osVersion: d} = V;
                        return `${l.IS_DESKTOP ? "desktop" : e} ${void 0 !== t ? ne[t] : ne[ne.Other]} ${d}`
                    }
                    )()
                });
                return be(U, {
                    BROWSER_NAME: ( () => {
                        const {browser: e, browserVersion: t, browserFork: l, browserForkVersion: d} = V;
                        return a.IS_NATIVE_ANDROID_BROWSER && U.IS_SAMSUNG_NATIVE_BROWSER ? "Android native" : void 0 !== l ? `${Re[l]} ${d}` : `${void 0 !== e ? Re[e] : Re[Re.Other]} ${t}`
                    }
                    )()
                })
            }(t, V)),
            e)
        }();
        class Qe extends Error {
            constructor(e, t, V=!1) {
                var l;
                super(t),
                this.type = e,
                this.isCritical = V,
                Object.setPrototypeOf(this, Qe.prototype),
                null === (l = Error.captureStackTrace) || void 0 === l || l.call(Error, this, Qe),
                this.name = "EvoError",
                Qe.enableErrorDebug && console.error(this.toString())
            }
            toString() {
                return Ge(this.name, this.type, this.message, this.code, this.stack)
            }
        }
        function Je(e, t) {
            const V = !(e instanceof DOMException) && e && e.code;
            let l;
            switch (l = "string" == typeof e ? new Error(e) : e instanceof Error ? e : new Error("Unknown error with type: " + typeof e),
            Object.setPrototypeOf(l, Qe.prototype),
            l.type = t,
            V) {
            case u.MEDIA_NOT_ALLOWED:
                l.type = H.PermissionError;
                break;
            case u.MEDIA_ERR_DECODE:
                l.type = H.DecodeError
            }
            return l.name = "EvoError",
            l.toString = () => Ge(l.name, l.type, l.message, l.code, l.stack),
            Qe.enableErrorDebug && console.error(l.toString()),
            l
        }
        function Ge(e, t, V, l, d) {
            return `[${e}] ${t}: ${Number.isInteger(l) ? `(code: ${l}) ` : ""}${V}${d ? ` ${d.replace(/.*/, "")}` : ""}`
        }
        function ze(e, t) {
            const {IS_IOS: V, IS_IN_IOS_WEB_VIEW: l} = e;
            return !(!V || l && !t.video.hls.enableInWebView)
        }
        function xe(e) {
            const {IS_ANDROID: t, IS_IOS: V, IS_QQBROWSER: l} = e;
            return !((t || V) && l)
        }
        function ue(e) {
            return !e.IS_BAIDUBROWSER
        }
        function Xe(e) {
            const {IS_UCBROWSER: t, IS_UCBROWSER_CHINA: V} = e;
            return !(t || V)
        }
        function ye(e) {
            return !e.IS_OPPOBROWSER
        }
        function Be(e) {
            return !e.IS_MEIZUBROWSER
        }
        function He(e) {
            return [Be, Xe, ye, xe, ue].every((t => t(e)))
        }
        function je(e) {
            return [Xe, xe, ue].every((t => t(e)))
        }
        Qe.enableErrorDebug = !1;
        const De = {
            name: k.None,
            factory: (e, t) => {
                throw new Error("Unable to create None player")
            }
            ,
            initialSoundCheck: () => Promise.resolve(!0)
        };
        function Oe(e, t) {
            if (e.name === k.None)
                return t[0];
            const V = t.findIndex((t => t.name === e.name));
            return t[(V + 1) % t.length]
        }
        function Ae(e, t, V, l) {
            let d = function(e, t) {
                return e.filter(( ({name: e}) => {
                    switch (e) {
                    case k.Fmp4:
                        return t.video.fmp4.enable;
                    case k.WebCodec:
                        return t.video.webcodec.enable;
                    case k.Wasm:
                        return t.video.wasm.enable;
                    case k.Hls:
                        return t.video.hls.enable;
                    case k.Inhousehls:
                        return t.video.inhousehls.enable;
                    case k.Flipbook:
                        return t.video.flipbook.enable;
                    default:
                        return !1
                    }
                }
                ))
            }(e, t);
            return t.video.debug.enableAllPlayers || (d = function(e, t, V) {
                return e.filter(( ({name: e}) => {
                    switch (e) {
                    case k.Hls:
                        return function(e, t) {
                            return [ze, je].every((V => V(e, t)))
                        }(t, V);
                    case k.Fmp4:
                        return function(e) {
                            return !!e.IS_DESKTOP || [He].every((t => t(e)))
                        }(t) && function(e, t) {
                            return !(e.IS_IN_IOS_WEB_VIEW && !t.video.fmp4.enableInWebView)
                        }(t, V);
                    default:
                        return !0
                    }
                }
                ))
            }(d, V, t),
            d = function(e, t, V) {
                return e.filter((e => {
                    switch (e.name) {
                    case k.WebCodec:
                        return !1 !== t.webAssembly && !1 !== t.webCodec.video && t.webCodec.video[V.video.webcodec.videoCodec] && !1 !== t.webCodec.audio && t.webCodec.audio[V.video.webcodec.audioCodec];
                    case k.Fmp4:
                        return !1 !== t.mse && !1 !== t.webAssembly && t.mse.video[V.video.fmp4.videoCodec] && t.mse.audio[V.video.fmp4.audioCodec];
                    case k.Hls:
                        return t.hls;
                    default:
                        return !0
                    }
                }
                ))
            }(d, l, t)),
            d
        }
        function we(e) {
            return new W((t => (t.onNext(e),
            t.onComplete(),
            T())))
        }
        const ve = (e, ...t) => [e, ...t]
          , Ie = (...e) => t => {
            const V = e[e.length - 1]
              , l = "function" == typeof V
              , d = l ? V : ve
              , a = e.slice(0, e.length - (l ? 1 : 0));
            return h(( (e, V) => {
                const l = [];
                a.forEach(( (t, d) => {
                    t.subscribe((e => {
                        l[d] = e
                    }
                    ), V.onError, ( () => {
                        l.splice(0, l.length),
                        V.onComplete()
                    }
                    )).closeBy(e)
                }
                )),
                t.subscribe((e => {
                    const t = l.filter(( () => !0));
                    if (t.length < a.length)
                        return;
                    const [U,...n] = t
                      , R = d(e, U, ...n);
                    V.onNext(R)
                }
                ), V.onError, ( () => {
                    l.splice(0, l.length),
                    V.onComplete()
                }
                )).closeBy(e)
            }
            ))
        }
          , Le = e => t => new W((V => {
            let l = 0
              , d = !1;
            const a = [];
            return t.subscribe((t => {
                a.push(t),
                d || function() {
                    for (d = !0; a.length > 0; ) {
                        l++;
                        const t = a.splice(0, 1)[0];
                        if (V.onNext(t),
                        l === e) {
                            V.onComplete(),
                            d = !1,
                            a.splice(0, a.length);
                            break
                        }
                    }
                    d = !1
                }()
            }
            ), V.onError, V.onComplete)
        }
        ))
          , Ke = (e, t=e, V=!1) => l => new W((d => {
            let a = [];
            return l.subscribe((l => {
                a.push(l),
                a.length > e && (a = a.slice(t)),
                (a.length === e || V) && d.onNext(a.slice())
            }
            ), d.onError, d.onComplete)
        }
        ))
          , ge = e => t => new W((V => t.subscribe((t => {
            e(t) && V.onNext(t)
        }
        ), V.onError, V.onComplete)));
        function fe(e) {
            return e.length > 0 ? {
                isValid: !0,
                item: e.shift()
            } : {
                isValid: !1
            }
        }
        const Ce = e => t => new W((V => {
            const l = [];
            let d, a = !1, U = !1;
            function n() {
                l.splice(0, l.length)
            }
            function R() {
                null == d || d.close(),
                d = void 0
            }
            function Z(t) {
                a = !0,
                d = e(t).subscribe((e => V.onNext(e)), (e => {
                    n(),
                    V.onError(e)
                }
                ), ( () => {
                    a = !1,
                    R();
                    const e = fe(l);
                    e.isValid ? Z(e.item) : U && V.onComplete()
                }
                ))
            }
            const N = t.subscribe((e => {
                if (l.push(e),
                !a) {
                    const e = fe(l);
                    if (!e.isValid)
                        return;
                    Z(e.item)
                }
            }
            ), (e => {
                n(),
                V.onError(e)
            }
            ), ( () => {
                U = !0,
                a || (n(),
                R(),
                V.onComplete())
            }
            ));
            return T(( () => {
                n(),
                R(),
                N.close()
            }
            ))
        }
        ));
        function Pe(e) {
            return new W((t => {
                let V = !1;
                return e.then((e => {
                    V || (V = !0,
                    t.onNext(e),
                    t.onComplete())
                }
                )).catch((e => {
                    V || (V = !0,
                    t.onError(e),
                    t.onComplete())
                }
                )),
                T(( () => {
                    V = !0
                }
                ))
            }
            ))
        }
        const qe = e => t => new W((V => t.subscribe((t => {
            e(t),
            V.onNext(t)
        }
        ), V.onError, V.onComplete)))
          , _e = e => t => new W((V => t.subscribe((t => V.onNext(e(t))), V.onError, V.onComplete)))
          , $e = /\(.*\)/;
        function et(e) {
            var t;
            return $e.test(null !== (t = e[0]) && void 0 !== t ? t : "")
        }
        function tt(e) {
            e.removeAttribute("src");
            for (const t of Array.from(e.childNodes))
                e.removeChild(t);
            e.playsInline = !0,
            e.style.display = "block"
        }
        function Vt(e) {
            e.muted = !0,
            e.style.display = "none"
        }
        function lt(e, t) {
            return e.filter((e => M[e] <= M[t]))
        }
        const dt = {
            NONE: null,
            flipbook: j.UnknownStream,
            fmp4: H.StreamShutdown,
            webcodec: H.StreamShutdown,
            wasm: H.StreamShutdown,
            hls: null,
            inhousehls: null
        }
          , at = [Y, j.FailedLoadingManifest, j.UnknownStream, H.ManifestNotFound, H.NetworkError, B.StreamSecurityError];
        function Ut(...e) {}
        const nt = window.navigator;
        class Rt {
            constructor(e) {
                this.isDesktop = e,
                this.isCriticalErrorDetected = !1,
                this.updateState = (e, t) => {
                    this.activePlayer = t,
                    [H.MediaError, H.PermissionError, H.NetworkError].map((e => e.toString())).includes(e.eventType) && (this.isCriticalErrorDetected = !0)
                }
                ,
                this.skipFlipbookAfterPrimaryPlayer = () => {
                    if (!this.activePlayer)
                        return !1;
                    let e = !1;
                    return this.isDesktop && !this.isCriticalErrorDetected && this.activePlayer.name !== k.Flipbook && (e = !0),
                    this.isCriticalErrorDetected = !1,
                    e
                }
                ,
                this.rules = [this.skipFlipbookAfterPrimaryPlayer]
            }
        }
        class Zt {
            constructor() {
                this.isNetworkErrorDetected = !1,
                this.isFMP4inAvailablePlayers = !1,
                this.updateState = e => {
                    e.eventType === H.NetworkError && (this.isNetworkErrorDetected = !0),
                    e.playerName === k.Fmp4 && (this.isFMP4inAvailablePlayers = !0)
                }
                ,
                this.removeAfterNetworkError = () => this.isNetworkErrorDetected,
                this.removeAfterFMP4Started = () => this.isFMP4inAvailablePlayers,
                this.rules = [this.removeAfterNetworkError, this.removeAfterFMP4Started]
            }
        }
        class Nt {
            constructor(e) {
                this.filter = e => e.filter((e => {
                    var t;
                    const V = !(null === (t = this.filters[e.name]) || void 0 === t ? void 0 : t.rules.some((e => e())));
                    return null == V || V
                }
                )),
                this.updateState = (e, t) => {
                    Object.entries(this.filters).forEach(( ([,V]) => V.updateState(e, t)))
                }
                ,
                this.filters = {
                    [k.Hls]: new Zt,
                    [k.Flipbook]: new Rt(e)
                }
            }
        }
        function ct(e, t=960, V=540) {
            e.width = t,
            e.height = V,
            Object.assign(e.style, {
                width: "100%",
                height: "100%",
                "pointer-events": "none",
                display: "block"
            })
        }
        function Tt(e) {
            e.width = 0,
            e.height = 0,
            Object.assign(e.style, {
                display: "none"
            })
        }
        const Wt = [H.StreamShutdown, H.PermissionError, H.WrongMediaElement, H.MediaStalledCritical, H.ValidationTimeout, H.PerformanceError, j.FailedLoadingManifest, B.StreamSecurityError, D.NotSupported]
          , it = ["FIRST_FRAME_TIMEOUT", Y];
        class Ft {
            constructor(e, t, V, l) {
                this.lifeCycleScope = e,
                this.config = t,
                this.videoStats = {},
                this.successfulPlayers = [],
                this.lastFlipbookUpgrade = 0,
                this.player = {
                    instance: void 0,
                    name: k.None,
                    playbackAttempts: 0,
                    errorCount: 0,
                    errorCountResetScheduler: void 0
                },
                this.isQualityModeManual = !1,
                this.audioContext = new AudioContext,
                this.canvas = function() {
                    const e = document.createElement("canvas");
                    return Tt(e),
                    e
                }(),
                this.videoTag = function() {
                    const e = document.createElement("video");
                    return Object.entries({
                        muted: !0,
                        preload: "none",
                        controls: !1,
                        "data-current-player": !0,
                        disablePictureInPicture: !0,
                        playsinline: !0,
                        "webkit-playsinline": !0
                    }).forEach(( ([t,V]) => {
                        !1 === V ? e.removeAttribute(t) : e.setAttribute(t, V.toString())
                    }
                    )),
                    Object.assign(e.style, {
                        height: "100%",
                        width: "100%",
                        "pointer-events": "none"
                    }),
                    Vt(e),
                    e
                }(),
                this.restartPlayer = () => {
                    we(void 0).pipe(Ie(this.activePlayer)).subscribe(( ([,e]) => this.initNewActivePlayer(e))).closeBy(this.lifeCycleScope)
                }
                ,
                this.onMediaPlayerSuccess = () => {
                    this.player.playbackAttempts = 0,
                    this.scheduleErrorCountReset(),
                    this.firstRetryThrottlingErrorTime = void 0,
                    this.successfulPlayers.includes(this.activePlayer.value.name) || this.successfulPlayers.push(this.activePlayer.value.name),
                    this.config.publishers.onPlay.emit(!0),
                    this.config.stats.onPlaybackStarted(this.activePlayer.value.name)
                }
                ,
                this.onMediaPlayerStop = () => {
                    this.config.publishers.onPlay.emit(!1),
                    this.config.stats.onStop(!1)
                }
                ,
                this.onMediaPlayerStats = e => {
                    if (e.playerName = this.activePlayer.value.name,
                    this.config.stats.onStats(e),
                    e.currentQuality) {
                        const t = this.videoStats.currentQuality
                          , V = e.currentQuality;
                        t !== V && this.onQualityChanged(V)
                    }
                    e.availableQualities && we(e.availableQualities).pipe(Ie(this.observables.maxAutoQuality), Le(1)).subscribe(( ([e,t]) => {
                        const {returnAllAvailableQualities: V} = this.config.settings.video.stream
                          , l = V || !t ? e : lt(e, t);
                        this.config.publishers.onAvailableQualities.emit(l)
                    }
                    )),
                    e.currentQuality && (this.videoStats.currentQuality = e.currentQuality),
                    void 0 !== e.bufferLength && (this.videoStats.bufferLength = e.bufferLength),
                    void 0 !== e.latency && (this.videoStats.latency = e.latency),
                    void 0 !== e.wallclock && (this.videoStats.wallclock = e.wallclock),
                    void 0 !== e.latency && void 0 !== this.videoStats.latency && void 0 !== this.videoStats.bufferLength && void 0 !== this.videoStats.wallclock && this.config.publishers.onVideoWallclock.emit({
                        wallclock: this.videoStats.wallclock,
                        bufferLength: this.videoStats.bufferLength,
                        latency: this.videoStats.latency
                    }),
                    void 0 !== e.streamId && this.config.publishers.onStreamId.emit(e.streamId)
                }
                ,
                this.onMediaPlayerFailure = e => {
                    this.player.errorCount++;
                    const {maxAttempts: t, maxErrors: V} = this.player.name !== k.None ? this.getPlayerConfig(this.player.name).settings.playback : {
                        maxAttempts: 1,
                        maxErrors: 1
                    };
                    e.isCritical = this.isFailureCritical(e) || this.player.playbackAttempts >= t || this.player.errorCount >= V,
                    e.isCritical && this.onMediaPlayerEvent({
                        eventType: e.type,
                        eventReason: `${e.type}: ${e.message}`
                    });
                    const l = e.isCritical ? J.PLAYER_FAILED : J.RECONNECT;
                    if (this.onPlaybackEvent({
                        eventType: l,
                        eventReason: `${e.type}: ${e.message}`
                    }),
                    this.config.stats.onError(e),
                    e.type === B.StreamSecurityError)
                        return this.config.availablePlayers = [],
                        void this.onAllPlayersFailed(e);
                    if (e.type === H.PermissionError && console.warn(e.type, e.message),
                    e.isCritical)
                        if (this.successfulPlayers.includes(this.activePlayer.value.name) && function(e, t) {
                            const V = dt[t];
                            return null !== V && e.type === V
                        }(e, this.activePlayer.value.name)) {
                            const e = 1e4 + 1e4 * Math.random();
                            this.schedulePlayerRestart(e, !1)
                        } else if (this.activePlayer.value.name !== k.None) {
                            const t = this.runtimeFilter.filter(this.config.availablePlayers)
                              , V = Oe(this.activePlayer.value, t)
                              , l = t.findIndex((e => e.name === V.name))
                              , d = 0 === l ? De : V;
                            this.activePlayer.next(d),
                            this.config.stats.onStats({
                                playerName: d.name
                            }),
                            d.name === k.None && this.onAllPlayersFailed(e)
                        } else
                            this.onPlaybackEvent({
                                eventType: J.PLAYER_FAILED,
                                eventReason: G.MultiplePlayerFailureCalls
                            });
                    else
                        this.restartPlayer()
                }
                ,
                this.onPlaybackAttempt = e => {
                    this.player.playbackAttempts++,
                    this.config.scheduler.deschedule(this.player.errorCountResetScheduler),
                    e.playerName = this.activePlayer.value.name,
                    this.config.stats.onPlaybackAttempt(e),
                    this.videoStats.latency = void 0,
                    this.videoStats.bufferLength = void 0,
                    this.videoStats.wallclock = void 0
                }
                ,
                this.onMediaPlayerEvent = e => {
                    e.playerName = this.activePlayer.value.name,
                    this.runtimeFilter.updateState(e, this.activePlayer.value),
                    this.config.publishers.onMediaPlayerEvent.emit(e)
                }
                ,
                this.onPlaybackEvent = ({eventType: e, eventReason: t, data: V={}}) => {
                    this.config.stats.onPlaybackEvent({
                        eventType: e,
                        eventReason: t,
                        data: V,
                        playerName: this.activePlayer.value.name
                    }, this.config.settings.video.session.videoSessionId),
                    V.qualityModeChanged && this.config.stats.onStats({
                        qualityMode: V.qualityModeChanged.next
                    }),
                    V.qualityChanged && (t === G.ManualChange ? this.config.stats.onStats({
                        manualQuality: V.qualityChanged.next
                    }) : this.onQualityChanged(V.qualityChanged.next))
                }
                ,
                this.onPlayerCanUpgrade = e => {
                    this.runtimeFilter.filter(this.config.availablePlayers).length <= 1 || e.emitter !== k.Flipbook || this.config.settings.video.flipbook.networkMeter.enable && this.flipbookCanUpgrade(e)
                }
                ,
                l.appendChild(this.videoTag),
                l.appendChild(this.canvas),
                this.videoTag.addEventListener("enterpictureinpicture", this.exitPIP);
                const d = t.availablePlayers.length ? Oe(De, t.availablePlayers) : De;
                this.activePlayer = new F(d),
                this.runtimeFilter = new Nt(t.deviceSupport.IS_DESKTOP),
                t.stats.onStats({
                    playerName: d.name,
                    videoSessionId: t.settings.video.session.videoSessionId
                }),
                "mediaSession"in nt && nt.mediaSession && nt.mediaSession.setActionHandler("play", Ut),
                this.observables = this.createPlayerObservables(V),
                this.subscribeToStateObservables(V),
                this.subscribeToParentObservables(V),
                V.maxAutoQuality.pipe(Ke(2, 1), Ie(this.activePlayer)).subscribe(( ([,e]) => this.initNewActivePlayer(e))).closeBy(this.lifeCycleScope)
            }
            createPlayerObservables(e) {
                return {
                    quality: e.quality,
                    qualityMode: e.qualityMode,
                    volume: e.volume,
                    streamId: e.streamId,
                    maxAutoQuality: e.maxAutoQuality,
                    muted: e.muted,
                    isBackgroundMode: e.isBackgroundMode
                }
            }
            subscribeToStateObservables(e) {
                o([this.activePlayer, e.play], (e => e)).pipe(ge(( ([,e]) => e)), Ce(( ([e]) => Pe(e.initialSoundCheck(this.videoTag, this.audioContext)).pipe(qe((e => {
                    this.config.stats.onStats({
                        userInteractionRequired: !e
                    }),
                    this.config.publishers.onUserInteractionRequired.emit(!e)
                }
                )), _e(( () => e)))))).subscribe((e => this.initNewActivePlayer(e))).closeBy(this.lifeCycleScope)
            }
            subscribeToParentObservables(e) {
                e.play.pipe(Ke(2, 1), ge(( ([e,t]) => e && !t))).subscribe(( () => {
                    var e;
                    null === (e = this.player.instance) || void 0 === e || e.destroy(),
                    this.config.stats.onStop(!0)
                }
                )).closeBy(this.lifeCycleScope),
                et(this.config.settings.video.fmp4.urls) || e.streamId.pipe(Ke(2, 1)).subscribe(( () => {
                    var e;
                    const t = null !== (e = this.config.availablePlayers.find((e => e.name === this.player.name))) && void 0 !== e ? e : this.config.availablePlayers[0];
                    this.initNewActivePlayer(t)
                }
                )).closeBy(this.lifeCycleScope),
                o([e.volume, e.muted], ( ([e,t]) => ({
                    volume: e,
                    muted: t
                }))).pipe(_e(( ({volume: e, muted: t}) => t ? 0 : e)), r()).subscribe((e => this.config.stats.onStats({
                    volume: e
                }))).closeBy(this.lifeCycleScope),
                e.qualityMode.subscribe((e => this.isQualityModeManual = e === E.MANUAL)).closeBy(this.lifeCycleScope),
                e.objectFit.subscribe((e => {
                    this.videoTag.style.objectFit = e,
                    this.canvas.style.objectFit = e
                }
                )).closeBy(this.lifeCycleScope)
            }
            initNewActivePlayer(e) {
                var t;
                if (null === (t = this.player.instance) || void 0 === t || t.destroy(),
                this.player.instance = void 0,
                this.player.name = k.None,
                this.config.scheduler.deschedule(this.player.errorCountResetScheduler),
                0 !== this.config.availablePlayers.length) {
                    if (e.name !== k.None) {
                        this.player.name = e.name;
                        const t = this.getPlayerConfig(e.name);
                        this.player.instance = e.factory(t, this.observables)
                    }
                } else
                    this.config.stats.onStop(!1)
            }
            exitPIP() {
                var e, t;
                null === (t = (e = document).exitPictureInPicture) || void 0 === t || t.call(e)
            }
            destroy() {
                var e;
                this.videoTag.removeEventListener("enterpictureinpicture", this.exitPIP),
                this.config.scheduler.deschedule(this.player.errorCountResetScheduler),
                null === (e = this.player.instance) || void 0 === e || e.destroy(),
                this.player.instance = void 0,
                this.audioContext.close(),
                this.lifeCycleScope.close()
            }
            scheduleErrorCountReset() {
                if (this.player.name === k.None)
                    return;
                const {errorResetTime: e} = this.getPlayerConfig(this.player.name).settings.playback;
                this.player.errorCountResetScheduler = this.config.scheduler.schedule(( () => {
                    this.player.errorCount = 0
                }
                ), e)
            }
            isFailureCritical(e) {
                return Wt.includes(e.type) || it.some((t => e.message.includes(t)))
            }
            getPlayerConfig(e) {
                const t = this.config.settings.video
                  , V = t[e];
                return {
                    restartPlayer: this.restartPlayer,
                    scheduler: this.config.scheduler,
                    onPlaybackAttempt: this.onPlaybackAttempt,
                    onSuccess: this.onMediaPlayerSuccess,
                    onStop: this.onMediaPlayerStop,
                    onFailure: this.onMediaPlayerFailure,
                    onEvent: this.onMediaPlayerEvent,
                    onStats: this.onMediaPlayerStats,
                    onPlaybackEvent: this.onPlaybackEvent,
                    onPlayerCanUpgrade: this.onPlayerCanUpgrade,
                    browserFeatures: this.config.browserFeatures,
                    settings: Object.assign(Object.assign({}, V), {
                        abtest: t.abtest,
                        debug: t.debug,
                        stream: t.stream,
                        session: t.session
                    }),
                    audioContext: this.audioContext,
                    videoTag: this.videoTag,
                    canvas: this.canvas
                }
            }
            onAllPlayersFailed(e) {
                e.type !== B.StreamSecurityError && this.schedulePlayerRestart(this.getRestartTime(e))
            }
            getRestartTime(e) {
                if (function(e) {
                    return at.some((t => e.type.includes(t) || e.message.includes(t)))
                }(e)) {
                    const e = window.performance.now();
                    return this.firstRetryThrottlingErrorTime || (this.firstRetryThrottlingErrorTime = e),
                    (e - this.firstRetryThrottlingErrorTime > 6e4 ? 59e3 : 5e3) + 5e3 * Math.random()
                }
                return 3e3
            }
            flipbookCanUpgrade(e) {
                const t = this.lastFlipbookUpgrade + 12e4 < window.performance.now() || 0 === this.lastFlipbookUpgrade;
                !this.isQualityModeManual && t && e.reason === y.AcceptableAverageMsBetweenFrames && (this.schedulePlayerRestart(),
                this.lastFlipbookUpgrade = window.performance.now())
            }
            onQualityChanged(e) {
                this.config.publishers.onQuality.emit(e),
                this.config.stats.onStats({
                    currentQuality: e
                })
            }
            schedulePlayerRestart(e=3e3, t=!0) {
                this.retryPlayersTimeout || (this.retryPlayersTimeout = this.config.scheduler.schedule(( () => {
                    this.retryPlayersTimeout = void 0;
                    const e = this.runtimeFilter.filter(this.config.availablePlayers)
                      , V = t ? Oe(De, e) : this.activePlayer.value;
                    this.activePlayer.next(V),
                    this.config.stats.onStats({
                        playerName: V.name
                    })
                }
                ), e))
            }
        }
        class rt {
            static getDocumentHiddenAttr() {
                const e = document;
                let t, V;
                if (void 0 !== e.hidden)
                    t = "hidden",
                    V = "visibilitychange";
                else if (void 0 !== e.msHidden)
                    t = "msHidden",
                    V = "msvisibilitychange";
                else {
                    if (void 0 === e.webkitHidden)
                        return null;
                    t = "webkitHidden",
                    V = "webkitvisibilitychange"
                }
                return {
                    hiddenAttribute: t,
                    visibilityChangeEvent: V
                }
            }
            constructor(e, t) {
                this.isWindowHidden = () => !!document[this.hiddenAttribute];
                const {hiddenAttribute: V, visibilityChangeEvent: l} = t;
                this.hiddenAttribute = V,
                this.visibilityChangeEvent = l,
                this.visibilityChangeCallback = () => e(this.isWindowHidden()),
                document.addEventListener(this.visibilityChangeEvent, this.visibilityChangeCallback)
            }
            destroy() {
                document.removeEventListener(this.visibilityChangeEvent, this.visibilityChangeCallback)
            }
        }
        class st {
            constructor(e, t=500) {
                this.isHidden = !1,
                this.timeoutId = 0,
                this.animationFrameId = 0,
                this.isWindowHidden = () => this.isHidden,
                this.runTimers = () => {
                    const e = performance.now();
                    this.timeoutId = window.setTimeout(this.onTimeout, this.visibilityCheckTimeout),
                    this.animationFrameId = window.requestAnimationFrame(this.requestAnimationFrameCallback(e))
                }
                ,
                this.onTimeout = () => {
                    this.isHidden || (this.isHidden = !0,
                    this.visibilityChangeCallback && this.visibilityChangeCallback(this.isHidden)),
                    this.stopTimers(),
                    this.runTimers()
                }
                ,
                this.requestAnimationFrameCallback = e => t => {
                    this.isHidden && t - e > 0 && (this.isHidden = !1,
                    this.visibilityChangeCallback && this.visibilityChangeCallback(this.isHidden)),
                    this.stopTimers(),
                    this.runTimers()
                }
                ,
                this.onDocumentFocus = () => {
                    this.stopCheck(),
                    this.isHidden = !1,
                    this.visibilityChangeCallback && this.visibilityChangeCallback(this.isHidden)
                }
                ,
                this.onDocumentBlur = () => {
                    this.runTimers()
                }
                ,
                this.visibilityChangeCallback = () => e(this.isWindowHidden()),
                this.startCheck(),
                this.visibilityCheckTimeout = t
            }
            startCheck() {
                window.addEventListener("blur", this.onDocumentBlur),
                window.addEventListener("focus", this.onDocumentFocus)
            }
            stopCheck() {
                this.stopTimers(),
                this.isHidden = !1
            }
            destroy() {
                window.removeEventListener("blur", this.onDocumentBlur),
                window.removeEventListener("focus", this.onDocumentFocus),
                this.stopCheck()
            }
            stopTimers() {
                window.clearTimeout(this.timeoutId),
                window.cancelAnimationFrame(this.animationFrameId)
            }
        }
        const ht = (e, t, V) => {
            let l;
            const d = new F(!1)
              , a = new F(!1)
              , U = function(e) {
                const t = rt.getDocumentHiddenAttr();
                return t ? new rt(e,t) : new st(e)
            }((e => a.next(e)));
            return e.add(T(( () => {
                U.destroy()
            }
            ))),
            a.pipe(Ie(t.enableVideo)).subscribe(( ([e,t]) => {
                if (e) {
                    if (!t)
                        return;
                    d.next(!0),
                    V.scheduler.deschedule(l)
                } else
                    l = V.scheduler.schedule(( () => d.next(!1)), 500)
            }
            )).closeBy(e),
            Object.assign(Object.assign({}, t), {
                isBackgroundMode: d.pipe(r())
            })
        }
          , ot = (e= () => new i) => t => {
            const V = e();
            let l, d = 0;
            return {
                pipe: V.pipe,
                subscribe(e, a, U) {
                    const n = V.subscribe(e, a, U);
                    return d++,
                    l || (l = t.subscribe((e => V.next(e)), (e => V.error(e)), ( () => V.complete()))),
                    T(( () => {
                        n.close(),
                        d--,
                        0 === d && (null == l || l.close(),
                        l = void 0)
                    }
                    ))
                }
            }
        }
        ;
        class mt extends i {
            constructor(e) {
                super(),
                this.size = e,
                this.cache = []
            }
            next(e) {
                this.cache.push(e),
                this.cache.length > this.size && this.cache.shift(),
                super.next(e)
            }
            subscribe(e, t, V) {
                const l = c(e, t, V)
                  , d = super.connectAndSubscribe(l);
                return this.cache.forEach((e => l.onNext(e))),
                d
            }
        }
        const Mt = (e, t, V) => {
            let l;
            const d = new F(!1);
            t.isBackgroundMode.subscribe((e => (e => {
                if (V.deviceSupport.IS_DESKTOP)
                    if (e) {
                        const e = () => {
                            l = void 0,
                            d.next(!0)
                        }
                        ;
                        l = V.scheduler.schedule(e, 1e4)
                    } else
                        d.next(!1),
                        l && (V.scheduler.deschedule(l),
                        l = void 0)
            }
            )(e))).closeBy(e);
            const a = o([t.qualityMode, d], (e => e)).pipe(_e(( ([e,t]) => t ? E.INTERNAL : e)), r(), ot(( () => new mt(1))));
            return Object.assign(Object.assign({}, t), {
                qualityMode: a.pipe(r())
            })
        }
          , St = (e, t, V) => {
            const l = o([t.enableVideo, t.isBackgroundMode], (e => e)).pipe(_e(( ([e,t]) => {
                const l = t && !V.deviceSupport.IS_DESKTOP;
                return e && !l
            }
            )), r(), ot(( () => new mt(1))));
            return Object.assign(Object.assign({}, t), {
                play: l
            })
        }
        ;
        class Et {
            constructor(e) {
                this.onStatsPublisher = e,
                this.onVolumeUpdate = (...e) => {
                    this.onStatsPublisher.emit(["onVolumeUpdate", e])
                }
                ,
                this.onPlaybackAttempt = (...e) => {
                    this.onStatsPublisher.emit(["onPlaybackAttempt", e])
                }
                ,
                this.onPlaybackStarted = (...e) => {
                    this.onStatsPublisher.emit(["onPlaybackStarted", e])
                }
                ,
                this.onPlaybackEvent = (...e) => {
                    this.onStatsPublisher.emit(["onPlaybackEvent", e])
                }
                ,
                this.onStats = (...e) => {
                    this.onStatsPublisher.emit(["onStats", e])
                }
                ,
                this.onStop = (...e) => {
                    this.onStatsPublisher.emit(["onStop", e])
                }
                ,
                this.onError = (...e) => {
                    this.onStatsPublisher.emit(["onError", e])
                }
            }
            destroy() {
                this.onStatsPublisher.emit(["destroy", []])
            }
        }
        function pt(e) {
            const t = Object.assign({}, e);
            let V;
            for (V in t)
                void 0 === t[V] && delete t[V];
            return t
        }
        function bt(e) {
            var t, V;
            if (-1 !== e.indexOf("version"))
                return "dev";
            const l = e.split("_");
            return 1 === l.length ? e : null !== (V = null === (t = l.shift()) || void 0 === t ? void 0 : t.replace("v", "")) && void 0 !== V ? V : ""
        }
        function kt(e) {
            var t;
            return -1 !== e.indexOf("version") ? "dev" : 1 === e.split("_").length ? "bundled app" : null !== (t = e.split("_").pop()) && void 0 !== t ? t : ""
        }
        var Yt = V(833);
        const Qt = {
            limit: 10,
            backgroundColor: "#000",
            fontSize: 12,
            gridYCount: 5,
            gridXCount: 15
        }
          , Jt = Object.assign(Object.assign({}, Qt), {
            type: "line",
            values: [],
            label: "Line Chart",
            color: "#0f0"
        })
          , Gt = Object.assign(Object.assign({}, Qt), {
            type: "multiline",
            values: [],
            labels: ["Line Chart1", "Line Chart2", "Line Chart3"],
            colors: ["#f00", "#0f0", "#00f"]
        })
          , zt = 50;
        class xt {
            constructor(e) {
                this.selectedMultiLineIndex = 0,
                this.update = e => {
                    "multiline" === this.chartState.type ? this.chartState.values = this.chartState.values.map(( (t, V) => (t.push(e[V]),
                    t.length > this.chartState.limit && t.shift(),
                    t))) : (this.chartState.values.push(...e),
                    this.chartState.values.length > this.chartState.limit && this.chartState.values.shift()),
                    this.draw()
                }
                ,
                this.clear = () => {
                    const {width: e, height: t} = this.canvas
                      , {backgroundColor: V} = this.chartState;
                    return this.ctx.beginPath(),
                    this.ctx.rect(0, 0, e, t),
                    this.ctx.fillStyle = V,
                    this.ctx.fill(),
                    this
                }
                ,
                this.drawLabel = () => {
                    const {width: e} = this.canvas
                      , {fontSize: t} = this.chartState
                      , V = e / 2;
                    if ("multiline" === this.chartState.type) {
                        const {labels: e, colors: l} = this.chartState;
                        return this.ctx.font = `${t}px Arial`,
                        e.forEach(( (e, d) => {
                            if (!this.ctx)
                                return this;
                            this.ctx.fillStyle = d === this.selectedMultiLineIndex ? "#ddd" : "#555",
                            this.ctx.fillText(e, V - 60 + 60 * d, t),
                            this.ctx.beginPath(),
                            this.ctx.strokeStyle = (null == l ? void 0 : l[d]) || "#555",
                            this.ctx.arc(V - 65 + 60 * d, t - 4, 2, 0, 2 * Math.PI),
                            this.ctx.stroke()
                        }
                        )),
                        this
                    }
                    {
                        const {label: e, color: l} = this.chartState;
                        return this.ctx.font = `${t}px Arial`,
                        this.ctx.fillStyle = "#ddd",
                        this.ctx.fillText(e, V - 30, t),
                        this.ctx.beginPath(),
                        this.ctx.strokeStyle = l || "#555",
                        this.ctx.arc(V - 35, t - 4, 2, 0, 2 * Math.PI),
                        this.ctx.stroke(),
                        this
                    }
                }
                ,
                this.drawGrid = e => {
                    const t = "x" === e
                      , {width: V, height: l} = this.canvas
                      , {gridYCount: d, gridXCount: a, fontSize: U} = this.chartState
                      , n = t ? V / a : (l - 15) / d
                      , R = t ? a : d;
                    this.ctx.strokeStyle = "#111",
                    this.ctx.beginPath(),
                    this.ctx.lineWidth = 1;
                    for (let Z = 0; Z < R; Z++)
                        if (this.ctx.font = `${U}px Arial`,
                        this.ctx.fillStyle = "#ddd",
                        t)
                            this.ctx.moveTo(V - Z * n, 0),
                            this.ctx.lineTo(V - Z * n, l);
                        else {
                            const e = "line" === this.chartState.type && this.chartState.valueToString ? this.chartState.valueToString.get(Math.round(Z * n / this.pixelPerValue.y)) || "" : (Z * n / this.pixelPerValue.y).toFixed(0);
                            this.ctx.moveTo(0, l - Z * n),
                            this.ctx.lineTo(V, l - Z * n),
                            this.ctx.stroke();
                            const t = 3;
                            this.ctx.fillText(e, t, l - Z * n - t)
                        }
                    return this
                }
                ,
                this.drawLines = () => {
                    const {height: e} = this.canvas;
                    if ("multiline" === this.chartState.type) {
                        const {colors: t} = this.chartState;
                        this.chartState.values.forEach(( (V, l) => {
                            if (!this.ctx)
                                return this;
                            this.ctx.strokeStyle = (null == t ? void 0 : t[l]) || "#f00",
                            this.ctx.beginPath(),
                            this.ctx.moveTo(zt, V.length > 0 ? e - V[0] * this.pixelPerValue.y : e),
                            V.forEach(( (t, V) => {
                                var l;
                                null === (l = this.ctx) || void 0 === l || l.lineTo(50 + V * this.pixelPerValue.x, e - t * this.pixelPerValue.y)
                            }
                            )),
                            this.ctx.stroke()
                        }
                        ))
                    } else {
                        const {color: t} = this.chartState;
                        this.ctx.strokeStyle = t || "#f00",
                        this.ctx.beginPath(),
                        this.ctx.moveTo(zt, this.chartState.values.length > 0 ? e - this.chartState.values[0] * this.pixelPerValue.y : e),
                        this.chartState.values.forEach(( (t, V) => {
                            var l;
                            null === (l = this.ctx) || void 0 === l || l.lineTo(zt + V * this.pixelPerValue.x, e - t * this.pixelPerValue.y)
                        }
                        )),
                        this.ctx.stroke()
                    }
                    return this
                }
                ,
                this.drawTooltip = e => {
                    this.draw();
                    const {fontSize: t} = this.chartState
                      , {height: V, width: l} = this.canvas
                      , d = this.canvas.getBoundingClientRect()
                      , a = e.clientX - d.left
                      , U = e.clientY - d.top
                      , n = Math.round((a - zt) / this.pixelPerValue.x);
                    let R, Z = "", N = 0;
                    if ("multiline" === this.chartState.type) {
                        const {labels: e, colors: t} = this.chartState;
                        if (this.ctx.fillStyle = this.ctx.strokeStyle = (null == t ? void 0 : t[this.selectedMultiLineIndex]) || "#f00",
                        R = this.chartState.values[this.selectedMultiLineIndex][n],
                        void 0 === R)
                            return;
                        Z = `${e[this.selectedMultiLineIndex]}: ${this.chartState.values[this.selectedMultiLineIndex][n]}`,
                        N = V - this.chartState.values[this.selectedMultiLineIndex][n] * this.pixelPerValue.y
                    } else {
                        const {label: e, valueToString: t} = this.chartState;
                        if (R = this.chartState.values[n],
                        void 0 === R)
                            return;
                        Z = t ? `${e}: ${t.get(R) || ""}` : `${e}: ${R}`,
                        N = V - this.chartState.values[n] * this.pixelPerValue.y
                    }
                    this.ctx.beginPath(),
                    this.ctx.font = `${t}px Arial`,
                    this.ctx.fillStyle = "#aaa";
                    const c = a > l / 2 ? -100 : 10;
                    this.ctx.fillText(Z, a + c, U),
                    this.ctx.stroke(),
                    this.ctx.beginPath(),
                    this.ctx.moveTo(a, 0),
                    this.ctx.lineTo(a, this.canvas.height),
                    this.ctx.stroke(),
                    this.ctx.beginPath(),
                    this.ctx.arc(zt + n * this.pixelPerValue.x, N, 3, 0, 2 * Math.PI),
                    this.ctx.stroke()
                }
                ,
                this.selectChart = e => {
                    this.selectedMultiLineIndex++,
                    this.selectedMultiLineIndex >= this.chartState.values.length && (this.selectedMultiLineIndex = 0),
                    this.draw()
                }
                ,
                this.getMaxValue = (e, t, V) => {
                    if (V)
                        if (V.includes("max+")) {
                            const l = parseInt(V.replace("max+", ""));
                            e = Math.max(...t) + l + 1
                        } else
                            e = parseInt(V);
                    return e
                }
                ,
                this.draw = () => {
                    const e = this.ctx;
                    this.canvas && e && this.clear().drawLabel().drawGrid("y").drawGrid("x").drawLines()
                }
                ,
                "multiline" === e.type ? this.chartState = Object.assign(Object.assign({}, Gt), e) : this.chartState = Object.assign(Object.assign({}, Jt), e),
                this.canvas = document.createElement("canvas"),
                this.canvas.style.display = "block",
                this.canvas.style.position = "relative",
                this.canvas.style.margin = "0",
                this.canvas.style.borderLeft = "5px solid #000",
                this.canvas.style.borderTop = "1px solid #000",
                this.canvas.style.borderBottom = "5px solid #000",
                this.canvas.style.opacity = "0.7",
                this.canvas.style.filter = "saturate(2)",
                this.canvas.width = 240,
                this.canvas.height = 100,
                this.canvas.addEventListener("mousemove", this.drawTooltip),
                this.canvas.addEventListener("click", this.selectChart);
                const t = this.canvas.getContext("2d");
                if (!this.canvas || !t)
                    throw new Qe(O,"Chart Error. Canvas is not supported");
                this.ctx = t
            }
            destroy() {
                this.canvas.removeEventListener("mousemove", this.drawTooltip),
                this.canvas.removeEventListener("click", this.selectChart)
            }
            getCanvas() {
                return this.canvas
            }
            get pixelPerValue() {
                var e;
                const {width: t, height: V} = this.canvas
                  , {limit: l} = this.chartState;
                let d = 0;
                switch (this.chartState.type) {
                case "line":
                    if (d = this.getMaxValue(Math.max(...this.chartState.values) + 1, this.chartState.values, this.chartState.maxY),
                    this.chartState.valueToString && (d = this.chartState.valueToString.size),
                    this.chartState.valueToString)
                        return {
                            x: (t - zt) / (l - 1),
                            y: (V - 15) / d
                        };
                    break;
                case "multiline":
                    d = this.getMaxValue(Math.max(...this.chartState.values.map((e => Math.max(...e)))) + 1, this.chartState.values[this.selectedMultiLineIndex], null === (e = this.chartState.maxY) || void 0 === e ? void 0 : e[this.selectedMultiLineIndex])
                }
                const a = Math.log10(d)
                  , U = Math.ceil(isFinite(a) ? a : 0);
                return d = (Math.floor(d / Math.pow(10, U - 1)) + 1) * Math.pow(10, Math.ceil(U - 1)),
                {
                    x: (t - zt) / (l - 1),
                    y: (V - 15) / d
                }
            }
        }
        class ut {
            constructor() {
                this.valueToQuality = new Map,
                this.isAvailableQualityRceived = !1,
                this.lastDroppedFrames = 0,
                this.container = document.createElement("div")
            }
            getContainer() {
                return this.container
            }
            update(e) {
                var t, V, l, d, a, U, n;
                if (!this.isAvailableQualityRceived && e.availableQualities.length > 0) {
                    this.isAvailableQualityRceived = !0,
                    this.qualityToValue = new Map(null === (t = e.availableQualities) || void 0 === t ? void 0 : t.map(( (e, t) => [e, t]))),
                    this.qualityToValue.forEach(( (e, t) => {
                        this.valueToQuality.set(e, t)
                    }
                    ));
                    try {
                        this.chartQuality = new xt({
                            label: "Quality",
                            type: "line",
                            gridYCount: null === (V = e.availableQualities) || void 0 === V ? void 0 : V.length,
                            limit: 60,
                            values: [],
                            valueToString: this.valueToQuality
                        }),
                        this.chartLatencyBitrate = new xt({
                            labels: ["Latency", "Buf.Len"],
                            type: "multiline",
                            colors: ["#09f", "#f09"],
                            limit: 60,
                            values: [[], []]
                        }),
                        this.chartDroppedFrames = new xt({
                            label: "Dropped frames",
                            type: "line",
                            color: "#f9f",
                            limit: 60,
                            values: []
                        }),
                        this.chartBandwidth = new xt({
                            labels: ["Bitrate", "Bandwidth"],
                            type: "multiline",
                            colors: ["#ff0", "#f90"],
                            limit: 60,
                            values: [[], []],
                            maxY: ["max+1000"]
                        }),
                        this.container.appendChild(this.chartQuality.getCanvas()),
                        this.container.appendChild(this.chartLatencyBitrate.getCanvas()),
                        this.container.appendChild(this.chartDroppedFrames.getCanvas()),
                        this.container.appendChild(this.chartBandwidth.getCanvas())
                    } catch (i) {}
                }
                const {currentQuality: R, latency: Z, playbackBitrate: N, droppedFrames: c, bandwidth: T, bufferLength: W} = e;
                R && (null === (l = this.chartQuality) || void 0 === l || l.update([null !== (d = this.qualityToValue.get(R)) && void 0 !== d ? d : -1])),
                null === (a = this.chartLatencyBitrate) || void 0 === a || a.update([null != Z ? Z : 0, null != W ? W : 0]),
                null === (U = this.chartDroppedFrames) || void 0 === U || U.update([(null != c ? c : 0) - this.lastDroppedFrames]),
                null === (n = this.chartBandwidth) || void 0 === n || n.update([null != N ? N : 0, null != T ? T : 0]),
                this.lastDroppedFrames = null != c ? c : 0
            }
            destroy() {
                var e, t, V, l;
                this.container.innerHTML = "",
                null === (e = this.chartLatencyBitrate) || void 0 === e || e.destroy(),
                null === (t = this.chartDroppedFrames) || void 0 === t || t.destroy(),
                null === (V = this.chartBandwidth) || void 0 === V || V.destroy(),
                null === (l = this.chartQuality) || void 0 === l || l.destroy()
            }
        }
        function Xt(e) {
            return ("0" + e).slice(-2)
        }
        function yt(e) {
            if (!e)
                return "";
            const t = new Date(e);
            return `${Xt(t.getHours())}:${Xt(t.getMinutes())}:${Xt(t.getSeconds())}`
        }
        const Bt = {
            background: "rgba(0, 0, 0, 0.4)",
            color: "#fff",
            position: "fixed",
            top: 0,
            left: 0,
            "z-index": 1100,
            margin: 0,
            "text-align": "left",
            "font-size": "12px",
            "line-height": "130%",
            display: "flex",
            overflow: "auto",
            width: "100%",
            "max-width": "fit-content",
            "pointer-events": "none"
        }
          , Ht = {
            padding: "20px",
            "min-width": "300px",
            "list-style-type": "none"
        }
          , jt = {
            "font-size": "1.2em",
            "text-shadow": "0 0 5px black"
        };
        class Dt {
            constructor(e) {
                this.initialProps = e,
                this.onClick = e => {
                    e.stopPropagation(),
                    this.initialProps.onClick()
                }
                ,
                this.container = document.createElement("div"),
                this.container.id = "video-statistics",
                Object.assign(this.container.style, Bt),
                this.tableContainer = document.createElement("ul"),
                Object.assign(this.tableContainer.style, Ht),
                this.tableContainer.addEventListener("click", this.onClick),
                this.charts = new ut,
                this.container.appendChild(this.tableContainer),
                this.container.appendChild(this.charts.getContainer()),
                this.update(this.initialProps)
            }
            update(e) {
                var t, V, l, d, a, U, n, R, Z, N, c;
                const T = [{
                    label: "Player",
                    class: "player",
                    value: e.playerName || ""
                }, {
                    label: "Version",
                    class: "version",
                    value: bt(Yt.version)
                }, {
                    label: "Version hash",
                    class: "version-hash",
                    value: kt(Yt.version)
                }, {
                    label: "Host",
                    class: "host",
                    value: e.streamHost || ""
                }, {
                    label: "Stream ID",
                    class: "stream-id",
                    value: null !== (t = e.streamId) && void 0 !== t ? t : ""
                }, {
                    label: "Stream",
                    class: "stream",
                    value: e.streamName || ""
                }, {
                    label: "Video loading time (ms)",
                    class: "loading-time",
                    value: (null === (V = e.videoInitTime) || void 0 === V ? void 0 : V.toFixed()) || ""
                }, {
                    label: "Droped frames",
                    class: "drop-frm",
                    style: {
                        color: "#f9f"
                    },
                    value: (null === (l = e.droppedFrames) || void 0 === l ? void 0 : l.toFixed()) || ""
                }, {
                    label: "FPS",
                    class: "fps",
                    value: (null === (d = e.fps) || void 0 === d ? void 0 : d.toFixed(2)) || ""
                }, {
                    label: "Bitrate (kbps)",
                    class: "bitrate",
                    style: {
                        color: "#ff0"
                    },
                    value: (null === (a = e.playbackBitrate) || void 0 === a ? void 0 : a.toFixed(2)) || ""
                }, {
                    label: "Qualities",
                    class: "qualities",
                    value: (null === (U = e.availableQualities) || void 0 === U ? void 0 : U.join(" | ")) || ""
                }, {
                    label: "Current quality",
                    class: "cur-quality",
                    style: {
                        color: "lime"
                    },
                    value: null !== (n = e.currentQuality) && void 0 !== n ? n : ""
                }, {
                    label: "Quality mode",
                    class: "quality-mode",
                    value: null !== (R = e.qualityMode) && void 0 !== R ? R : ""
                }, {
                    label: "Latency (ms)",
                    class: "latency",
                    style: {
                        color: "#09f"
                    },
                    value: (null === (Z = e.latency) || void 0 === Z ? void 0 : Z.toFixed(2)) || ""
                }, {
                    label: "Wallclock (time)",
                    class: "wallclock-time",
                    value: yt(e.wallclock)
                }, {
                    label: "Wallclock (ms)",
                    class: "wallclock-ms",
                    value: e.wallclock || ""
                }, {
                    label: "BufferLength (ms)",
                    class: "buffer",
                    style: {
                        color: "#f09"
                    },
                    value: (null === (N = e.bufferLength) || void 0 === N ? void 0 : N.toFixed(2)) || ""
                }, {
                    label: "Bandwidth (kbps)",
                    class: "bandwidth",
                    style: {
                        color: "#f90"
                    },
                    value: (null === (c = e.bandwidth) || void 0 === c ? void 0 : c.toFixed(2)) || ""
                }];
                this.tableContainer.innerHTML = "";
                const W = document.createElement("li");
                W.innerHTML = "<h3 style='font-weight: 600; font-size: 130%; margin-bottom: 0.4em'>Player Info</h3>",
                this.tableContainer.appendChild(W),
                T.forEach((e => {
                    const t = document.createElement("li");
                    t.className = e.class,
                    t.innerHTML = `<strong style='font-weight: 600;'>${e.label}</strong>: ${e.value}`,
                    Object.assign(t.style, Object.assign(Object.assign({}, jt), e.style)),
                    this.tableContainer.appendChild(t)
                }
                )),
                this.charts.update(e)
            }
            getContainer() {
                return this.container
            }
            destroy() {
                this.tableContainer.removeEventListener("click", this.onClick),
                this.charts.destroy()
            }
        }
        class Ot {
            constructor() {
                this.runnables = [],
                this.runnablesCheckTimeout = 0,
                this.nextCheckTimestamp = 0,
                this.runInProgress = !1,
                this.run = () => {
                    this.runInProgress = !0;
                    const e = this.now();
                    this.runnables.forEach((t => this.processRunnable(t, e))),
                    this.addedRunnables && this.addedRunnables.length && this.addedRunnables.sort(( (e, t) => e.timestamp - t.timestamp)).forEach((t => this.processRunnable(t, e))),
                    this.updateRunnables(),
                    this.scheduleNextCheck(),
                    this.runInProgress = !1
                }
            }
            schedule(e, t, V={}) {
                const l = V.name ? V.name : this.generateUUID()
                  , d = !!V.repeat
                  , a = this.now() + t
                  , U = {
                    name: l,
                    callback: e,
                    repeat: d,
                    timeout: t,
                    timestamp: a
                };
                return this.runInProgress ? (this.addedRunnables || (this.addedRunnables = []),
                this.addedRunnables.push(U)) : this.runnables.push(U),
                (!this.nextCheckTimestamp || this.nextCheckTimestamp > a) && this.scheduleNextCheck(),
                l
            }
            deschedule(e) {
                e && ((this.addedRunnables && this.addedRunnables.length ? this.runnables.concat(this.addedRunnables) : this.runnables).forEach((t => {
                    const V = t.name;
                    (e === V || "string" != typeof e && -1 !== e.indexOf(V)) && (this.removedRunnables || (this.removedRunnables = []),
                    this.removedRunnables.push(t))
                }
                )),
                this.runInProgress || this.updateRunnables())
            }
            reschedule(e, t, V, l={}) {
                e && this.deschedule(e),
                this.schedule(t, V, Object.assign(Object.assign({}, l), {
                    name: e
                }))
            }
            destroy() {
                window.clearTimeout(this.runnablesCheckTimeout),
                this.nextCheckTimestamp = 0,
                this.addedRunnables = void 0,
                this.removedRunnables = void 0,
                this.runnables = []
            }
            now() {
                return window.performance.now()
            }
            scheduleNextCheck() {
                const e = this.addedRunnables && this.addedRunnables.length ? this.runnables.concat(this.addedRunnables) : this.runnables;
                if (window.clearTimeout(this.runnablesCheckTimeout),
                !e.length)
                    return void (this.nextCheckTimestamp = 0);
                const t = this.now()
                  , V = e.sort(( (e, t) => e.timestamp - t.timestamp));
                this.nextCheckTimestamp = V[0].timestamp,
                this.runnablesCheckTimeout = window.setTimeout(this.run, Math.ceil(this.nextCheckTimestamp - t))
            }
            processRunnable(e, t) {
                if ((!this.removedRunnables || -1 === this.removedRunnables.indexOf(e)) && t >= e.timestamp) {
                    try {
                        e.callback()
                    } catch (V) {}
                    e.repeat ? e.timestamp += e.timeout : (this.removedRunnables || (this.removedRunnables = []),
                    this.removedRunnables.push(e))
                }
            }
            updateRunnables() {
                const e = this.addedRunnables
                  , t = this.removedRunnables;
                t && (this.runnables = this.runnables.filter((e => -1 === t.indexOf(e)))),
                e && (this.runnables = this.runnables.concat(e.filter((e => !t || -1 === t.indexOf(e))))),
                this.runnables = this.runnables.sort(( (e, t) => e.timestamp - t.timestamp)),
                this.runnables.length || (this.nextCheckTimestamp = 0),
                this.removedRunnables = void 0,
                this.addedRunnables = void 0
            }
            generateUUID() {
                return `${window.performance.now()}-${Math.random().toString(36).substr(2, 10)}`
            }
        }
        class At {
            constructor(e) {
                this.onShowPlayerInfoChange = e,
                this.playerStats = {
                    playerName: k.None,
                    bandwidth: 0,
                    isPlaying: !1,
                    fps: 0,
                    droppedFrames: 0,
                    availableQualities: [],
                    soundVolume: 0,
                    videoSessionId: ""
                },
                this.startLoadingTime = 0,
                this.scheduler = new Ot,
                this.updateToken = (...e) => {}
                ,
                this.getInfoTableStats = () => {
                    const {latency: e, playbackBitrate: t, wallclock: V, bufferLength: l, streamHost: d, streamName: a, streamId: U, availableQualities: n, currentQuality: R, qualityMode: Z, fps: N, droppedFrames: c, videoInitTime: T, playerName: W, bandwidth: i} = this.playerStats;
                    return {
                        onClick: this.onClick,
                        latency: e,
                        playbackBitrate: t,
                        wallclock: V,
                        bufferLength: l,
                        streamHost: d,
                        streamName: a,
                        streamId: U,
                        availableQualities: n,
                        currentQuality: R,
                        qualityMode: Z,
                        fps: N,
                        droppedFrames: c,
                        videoInitTime: T,
                        playerName: W,
                        bandwidth: i
                    }
                }
                ,
                this.resetPlayerStats = () => {
                    this.playerStats = {
                        playerName: k.None,
                        isPlaying: !1,
                        bandwidth: 0,
                        fps: 0,
                        droppedFrames: 0,
                        availableQualities: [],
                        soundVolume: 0,
                        videoSessionId: ""
                    },
                    this.startLoadingTime = 0
                }
                ,
                this.onClick = () => {
                    this.onShowPlayerInfoChange(!1)
                }
                ,
                this.playerInfoTable = new Dt(this.getInfoTableStats())
            }
            showInfo(e) {
                e && !this.renderTimeout && (this.renderTimeout = this.scheduler.schedule(( () => {
                    this.playerInfoTable.update(this.getInfoTableStats())
                }
                ), 1e3, {
                    repeat: !0
                })),
                !e && this.renderTimeout && (this.scheduler.deschedule(this.renderTimeout),
                this.renderTimeout = void 0)
            }
            onVolumeUpdate(e, t) {}
            onPlaybackAttempt(e) {
                this.playerStats.playerName = e.playerName,
                this.playerStats.videoSessionId = e.videoSessionId,
                this.playerStats.videoInitTime = void 0,
                this.startLoadingTime = window.performance.now()
            }
            onPlaybackStarted(e) {
                this.playerStats.videoInitTime || (this.playerStats = Object.assign(Object.assign({}, this.playerStats), {
                    playerName: e,
                    fps: 0,
                    droppedFrames: 0,
                    isPlaying: !0,
                    videoInitTime: Math.round(window.performance.now() - this.startLoadingTime)
                }))
            }
            onPlaybackEvent() {}
            onStats(e) {
                const t = pt(e);
                Object.assign(this.playerStats, t)
            }
            onStop(e) {
                this.playerStats.isPlaying = !1
            }
            onError(e) {
                this.resetPlayerStats()
            }
            destroy() {
                this.scheduler.deschedule(this.renderTimeout),
                this.playerInfoTable.destroy()
            }
            getContainer() {
                return this.playerInfoTable.getContainer()
            }
        }
        function wt(e) {
            let t = null;
            return {
                push: function(V) {
                    const l = e(V);
                    l && (null == t || t > l) && (t = l)
                },
                clean: function() {
                    t = null
                },
                aggregate: function() {
                    return t
                }
            }
        }
        function vt(e) {
            let t = null;
            return {
                push: function(V) {
                    const l = e(V);
                    l && (null == t || t < l) && (t = l)
                },
                clean: function() {
                    t = null
                },
                aggregate: function() {
                    return t
                }
            }
        }
        function It(e) {
            let t = [];
            return {
                push: function(V) {
                    const l = e(V);
                    l && t.push(l)
                },
                clean: function() {
                    t.splice(0, t.length)
                },
                aggregate: function() {
                    return 0 === t.length ? null : t.reduce(( (e, t) => e + t), 0) / t.length
                }
            }
        }
        function Lt(e, t) {
            let V, l, d = !0;
            return {
                push: function(a) {
                    const U = null == t ? void 0 : t(a);
                    void 0 !== U && (d = U);
                    const n = e(a);
                    n && (void 0 !== V ? l = n : V = n)
                },
                clean: function() {
                    V = l
                },
                aggregate: function() {
                    return d ? void 0 === V ? 0 : void 0 === l ? V : l - V : 0
                }
            }
        }
        var Kt;
        !function(e) {
            e.AppSwitchStarted = "evoAppSwitchStarted",
            e.ComponentMounted = "evoVideoComponentMounted"
        }(Kt || (Kt = {}));
        const gt = {
            wrapperInitToLibLoadingStartedTime: null,
            libLoadingTime: null,
            libLoadedToMountedTime: null
        }
          , ft = /video_(?!version)[^./]+\.js/;
        function Ct(e) {
            var t;
            const V = t => function(e, t) {
                const V = t.find((t => t.name === e));
                return V ? V.startTime : null
            }(t, e)
              , l = V(Kt.ComponentMounted);
            if (!l || 0 === e.length)
                return gt;
            const d = null !== (t = V(Kt.AppSwitchStarted)) && void 0 !== t ? t : e[0].startTime
              , a = e.find((e => ft.test(e.name)))
              , U = a ? a.startTime : d
              , n = a ? a.startTime + a.duration : d;
            return {
                wrapperInitToLibLoadingStartedTime: Math.round(U - d),
                libLoadingTime: Math.round(n - U),
                libLoadedToMountedTime: Math.round(l - n)
            }
        }
        const Pt = bt(Yt.version);
        function qt(e, t) {
            var V, l, d;
            const {deviceSupport: a, publishers: {stats: U}, videoSessionId: n, abtest: R, gameType: Z} = e
              , {DeviceProperties: N, Browser: c, OS: T, userAgent: W} = a
              , {browser: i, browserVersion: F, browserForkVersion: r, browserFork: s} = N;
            let h;
            h = c ? s ? c[s] : void 0 !== i ? c[i] : c[c.Other] : "";
            const o = N.reportedScreenSize
              , m = {
                userAgent: W,
                screenSize: o && o.width && o.height ? `${o.width}x${o.height}` : null,
                type: Ue[N.platform],
                name: _t(N),
                browser: {
                    family: h,
                    version: F,
                    forkVersion: r,
                    features: $t(t)
                },
                os: {
                    family: T[N.os],
                    version: N.osVersion
                },
                threads: N.threads || null,
                maxSupportedQuality: null !== (V = N.maxSupportedQuality) && void 0 !== V ? V : null
            }
              , M = {
                pointInTime: 0,
                timestamp: Date.now()
            }
              , S = {
                videoSessionId: n,
                gameType: Z,
                scenario: R,
                referer: window.location.hostname
            }
              , E = {
                device: m,
                client: M,
                component: {
                    version: Yt.version,
                    scenario: R
                },
                video: {
                    masterHost: e.masterHost
                },
                session: S,
                metrics: Object.assign({}, Ct(null !== (d = null === (l = performance.getEntries) || void 0 === l ? void 0 : l.call(performance)) && void 0 !== d ? d : [])),
                v: Pt
            };
            U.emit(["CLIENT_VIDEO_V2_INITIALIZED", E])
        }
        function _t(e) {
            return e.appleScreenType ? e.appleScreenType : "unknown" === e.name ? null : e.name
        }
        function $t(e) {
            return Object.assign(Object.assign({}, e), {
                mse: e.mse || {
                    audio: {
                        aac: !1,
                        opus: !1
                    },
                    video: {
                        h264: !1,
                        av1: !1
                    }
                },
                webAssembly: e.webAssembly || {
                    threads: !1
                },
                webCodec: {
                    audio: e.webCodec.audio || {
                        aac: !1,
                        opus: !1
                    },
                    video: e.webCodec.video || {
                        h264: !1,
                        av1: !1
                    }
                },
                mseSupport: !!e.mse,
                webAssemblySupport: !!e.webAssembly,
                audioDecoderSupport: !!e.webCodec.audio,
                videoDecoderSupport: !!e.webCodec.video
            })
        }
        const eV = bt(Yt.version);
        function tV(e, t, V, l, d={
            valid: 1
        }) {
            const {videoSessionId: a, publishers: {stats: U}, gameType: n, abtest: R} = e
              , Z = {
                info: l,
                logic: {
                    currentPlayer: t
                },
                client: {
                    pointInTime: V,
                    timestamp: Date.now()
                },
                session: {
                    videoSessionId: a,
                    gameType: n,
                    scenario: R
                },
                metrics: d,
                v: eV
            };
            U.emit(["CLIENT_VIDEO_V2_INFO", Z])
        }
        function VV() {
            if ("connection"in navigator) {
                const e = navigator.connection;
                return {
                    downlink: e.downlink,
                    effectiveType: e.effectiveType,
                    rtt: e.rtt,
                    saveData: e.saveData
                }
            }
            return null
        }
        const lV = 15e3;
        class dV {
            constructor(e, t, V) {
                this.settings = t,
                this.playerStats = {
                    playerName: k.None,
                    isPlaying: !1,
                    fps: 0,
                    droppedFrames: 0,
                    availableQualities: [],
                    soundVolume: 0,
                    videoSessionId: ""
                },
                this.localStats = {
                    fpsMin: 0,
                    bufferLengthMin: 0,
                    bufferLengthMax: 0
                },
                this.scheduler = new Ot,
                this.startLoadingTime = 0,
                this.wasVideoLoadingTimeSent = !1,
                this.lastHeartbeatTimestamp = 0,
                this.initTime = window.performance.now(),
                this.attemptCount = 0,
                this.wasFirstStarted = !1,
                this.fallbackCount = 0,
                this.bufferingDuration = 0,
                this.aggregator = void 0,
                this.batteryManager = void 0,
                this.onVolumeUpdate = (e, t) => {
                    this.playerStats.soundVolume = e ? 0 : t
                }
                ,
                this.onPlaybackAttempt = e => {
                    e.playerName !== this.playerStats.playerName && this.playerStats.playerName !== k.None && this.fallbackCount++,
                    this.playerStats.playerName = e.playerName,
                    this.attemptCount++,
                    this.startLoadingTime = window.performance.now(),
                    void 0 === this.playbackAttemptTime && (this.playbackAttemptTime = window.performance.now());
                    const {publishers: {stats: t}, videoSessionId: V, gameType: l, abtest: d} = this.staticStats
                      , a = {
                        behaviour: {
                            autoPlayAllowed: !this.playerStats.userInteractionRequired
                        },
                        logic: {
                            currentPlayer: this.playerStats.playerName,
                            tableBaseName: e.tableBaseName
                        },
                        client: {
                            pointInTime: Math.round(window.performance.now() - this.initTime),
                            timestamp: Date.now()
                        },
                        session: {
                            videoSessionId: V,
                            gameType: l,
                            scenario: d
                        },
                        v: eV
                    };
                    t.emit(["CLIENT_VIDEO_V2_PLAYBACK_ATTEMPT", a]),
                    this.wasVideoLoadingTimeSent = !1,
                    this.playerStats.userInteractionRequired = !1,
                    this.playerStats.currentQuality = void 0,
                    this.playerStats.latency = void 0
                }
                ,
                this.onPlaybackStarted = e => {
                    if (this.aggregator = function(e, t) {
                        const V = e => e.latency ? Math.round(e.latency) : void 0
                          , l = e => e.bandwidth ? Math.round(e.bandwidth) : void 0;
                        return d = {
                            observedMinLatency: wt(V),
                            observedMaxLatency: vt(V),
                            observedAverageLatency: It((V => {
                                var l;
                                if (!V.latency)
                                    return;
                                const d = null === (l = Object.entries(e.video).find(( ([e]) => e === t))) || void 0 === l ? void 0 : l.pop();
                                return d && V.latency >= 0 && V.latency <= d.latency.max ? Math.round(V.latency) : void 0
                            }
                            )),
                            observedMinBandwidth: wt(l),
                            observedMaxBandwidth: vt(l),
                            observedAverageBandwidth: It(l),
                            droppedFrames: Lt((e => e.droppedFrames), (e => e.qualityMode && "INTERNAL" !== e.qualityMode))
                        },
                        {
                            push: e => Object.values(d).forEach((t => t.push(e))),
                            clean: () => Object.values(d).forEach((e => e.clean())),
                            aggregate: () => Object.entries(d).reduce(( (e, [t,V]) => Object.assign(e, {
                                [t]: V.aggregate()
                            })), {})
                        };
                        var d
                    }(this.settings, e),
                    this.resetStoredStats(),
                    !this.wasVideoLoadingTimeSent) {
                        performance && performance.mark && performance.mark("evoVideoPlaying"),
                        this.playerStats.playerName = e,
                        this.playerStats.fps = 0,
                        this.playerStats.isPlaying = !0,
                        this.playerStats.videoInitTime = Math.round(window.performance.now() - this.startLoadingTime),
                        this.localStats.bufferLengthMin = 0,
                        this.localStats.bufferLengthMax = 0,
                        this.startLoadingTime = 0,
                        this.wasVideoLoadingTimeSent = !0;
                        const t = void 0 !== this.playbackAttemptTime ? Math.round(window.performance.now() - this.playbackAttemptTime) : void 0
                          , V = Math.round(window.performance.now() - this.initTime)
                          , {videoSessionId: l, gameType: d, publishers: {stats: a}, abtest: U} = this.staticStats
                          , n = ( () => {
                            const {streamName: e=""} = this.playerStats;
                            return e.slice(0, e.lastIndexOf("_"))
                        }
                        )()
                          , R = {
                            logic: {
                                currentPlayer: e,
                                currentQuality: this.playerStats.currentQuality,
                                attemptCount: this.attemptCount,
                                firstTime: !this.wasFirstStarted,
                                fallbackCount: this.fallbackCount,
                                streamBaseName: n
                            },
                            video: {
                                streamHost: this.playerStats.streamHost
                            },
                            client: {
                                pointInTime: V,
                                timestamp: Date.now()
                            },
                            session: {
                                videoSessionId: l,
                                scenario: U,
                                gameType: d
                            },
                            metrics: {
                                timeToVideo: t
                            },
                            v: eV
                        };
                        a.emit(["CLIENT_VIDEO_V2_PLAYBACK_STARTED", R]),
                        this.playbackAttemptTime = void 0,
                        this.attemptCount = 0,
                        this.wasFirstStarted = !0,
                        this.fallbackCount = 0
                    }
                    this.bufferingTime = void 0,
                    this.bufferingDuration = 0,
                    this.scheduler.deschedule(this.heartbeatTimeout),
                    this.heartbeatTimeout = this.scheduler.schedule(this.sendHeartbeat, lV, {
                        repeat: !0
                    })
                }
                ,
                this.onPlaybackEvent = e => {
                    const t = e.playerName || this.playerStats.playerName;
                    let V, l = {
                        valid: 1
                    };
                    const {data: d} = e;
                    switch (e.eventType) {
                    case J.UPGRADE:
                    case J.DOWNGRADE:
                    case J.MANUAL_CHANGE:
                        {
                            if (!d || !d.qualityChanged)
                                break;
                            const {prev: e, next: t} = d.qualityChanged;
                            V = {
                                prev: e,
                                next: t
                            },
                            this.playerStats.currentQuality = t;
                            break
                        }
                    case J.QUALITY_MODE_CHANGED:
                        {
                            if (!d || !d.qualityModeChanged)
                                break;
                            const {prev: e, next: t, quality: l} = d.qualityModeChanged;
                            V = {
                                prev: e,
                                next: t,
                                quality: l
                            },
                            this.playerStats.currentQuality = l;
                            break
                        }
                    case J.MANIFEST_STATS:
                        if (!d || !d.manifestFetchStats)
                            break;
                        const {manifestFetchStats: t} = d;
                        V = {
                            streamHost: d.streamHost
                        };
                        let a = t.manifestLoadingTime;
                        const U = t.cdnDecisionTime;
                        U && a && (a += U),
                        l = Object.assign(Object.assign({}, l), {
                            manifestLoadingTime: a,
                            cdnDecisionTime: U,
                            availableQualities: d.manifestFetchStats.availableQualities
                        });
                        break;
                    case J.WAITING:
                        void 0 === this.bufferingTime && (this.bufferingTime = performance.now());
                        break;
                    case J.PLAYING:
                        this.bufferingTime && (this.bufferingDuration += Math.round(performance.now() - this.bufferingTime),
                        this.bufferingTime = void 0);
                        break;
                    case J.STREAM_ID_CHANGED:
                        if (!d || !d.streamIdChanged)
                            break;
                        const {streamIdChanged: n} = d;
                        V = {
                            prev: n.prev.toString(),
                            next: n.next.toString()
                        };
                        break;
                    case J.WARNING:
                        V = {
                            type: e.eventType,
                            reason: e.eventReason
                        }
                    }
                    if (e.eventReason === H.MaxLatencyReached && (V = {
                        latency: (null == d ? void 0 : d.latency) || this.playerStats.latency
                    }),
                    V) {
                        const d = Math.round(window.performance.now() - this.initTime);
                        V.type = e.eventType,
                        V.reason = e.eventReason,
                        tV(this.staticStats, t, d, V, l)
                    }
                }
                ,
                this.onStats = e => {
                    var t;
                    const {fps: V, bufferLength: l} = e
                      , {fpsMin: d} = this.localStats;
                    if (V && (!d || V < d) && (this.localStats.fpsMin = V),
                    l) {
                        const {bufferLengthMin: e, bufferLengthMax: t} = this.localStats;
                        (!e || l < e) && (this.localStats.bufferLengthMin = l),
                        (!t || l > t) && (this.localStats.bufferLengthMax = l)
                    }
                    e.streamName && (this.playerStats.streamName = e.streamName),
                    Object.assign(this.playerStats, e),
                    null === (t = this.aggregator) || void 0 === t || t.push(e)
                }
                ,
                this.onStop = e => {
                    if (this.playerStats.isPlaying = !1,
                    this.scheduler.deschedule(this.heartbeatTimeout),
                    e) {
                        const e = {
                            type: "PLAYBACK_STOPPED"
                        }
                          , t = Math.round(window.performance.now() - this.initTime);
                        tV(this.staticStats, this.playerStats.playerName, t, e)
                    }
                }
                ,
                this.onError = e => {
                    const {videoSessionId: t, gameType: V, publishers: {stats: l}, abtest: d} = this.staticStats
                      , a = {
                        error: {
                            type: e.isCritical ? J.PLAYER_FAILED : J.RECONNECT,
                            reason: e.type,
                            hasPlayerFailed: e.isCritical,
                            description: e.message
                        },
                        logic: {
                            currentPlayer: this.playerStats.playerName
                        },
                        client: {
                            timestamp: Date.now(),
                            pointInTime: Math.round(window.performance.now() - this.initTime)
                        },
                        session: {
                            videoSessionId: t,
                            scenario: d,
                            gameType: V
                        },
                        v: eV
                    };
                    l.emit(["CLIENT_VIDEO_V2_ERROR", a])
                }
                ,
                this.resetStoredStats = () => {
                    this.playerStats = Object.assign(Object.assign({}, this.playerStats), {
                        isPlaying: !1,
                        fps: 0,
                        droppedFrames: 0,
                        availableQualities: [],
                        videoSessionId: "",
                        userInteractionRequired: !1,
                        latency: void 0
                    }),
                    this.localStats = {
                        fpsMin: 0,
                        bufferLengthMin: 0,
                        bufferLengthMax: 0
                    }
                }
                ,
                this.sendHeartbeat = () => {
                    var e, t, V;
                    const l = performance.now();
                    if (l - this.lastHeartbeatTimestamp < 14e3)
                        return;
                    this.lastHeartbeatTimestamp = l,
                    this.bufferingTime && (this.bufferingDuration += Math.round(l - this.bufferingTime));
                    const d = this.bufferingDuration > lV ? lV : this.bufferingDuration
                      , {publishers: {stats: a}, gameType: U, videoSessionId: n} = this.staticStats
                      , {soundVolume: R} = this.playerStats
                      , {fpsMin: Z, bufferLengthMin: N, bufferLengthMax: c} = this.localStats
                      , T = null !== (t = null === (e = this.aggregator) || void 0 === e ? void 0 : e.aggregate()) && void 0 !== t ? t : aV
                      , W = {
                        metrics: {
                            droppedFrames: T.droppedFrames,
                            observedLowFps: Math.round(100 * Z) / 100,
                            observedMinBuffer: Math.round(N),
                            observedMaxBuffer: Math.round(c),
                            observedMinLatency: T.observedMinLatency,
                            observedMaxLatency: T.observedMaxLatency,
                            observedAverageLatency: T.observedAverageLatency ? Math.round(T.observedAverageLatency) : null,
                            observedMinBandwidth: T.observedMinBandwidth,
                            observedMaxBandwidth: T.observedMaxBandwidth,
                            observedAverageBandwidth: T.observedAverageBandwidth ? Math.round(T.observedAverageBandwidth) : null,
                            bufferTime: d,
                            volume: Math.round(100 * R) / 100
                        },
                        battery: void 0 !== this.batteryManager ? {
                            level: this.batteryManager.level,
                            charging: this.batteryManager.charging
                        } : null,
                        connection: VV(),
                        logic: {
                            currentPlayer: this.playerStats.playerName,
                            currentQuality: this.playerStats.currentQuality
                        },
                        client: {
                            timestamp: Date.now(),
                            pointInTime: Math.round(l - this.initTime)
                        },
                        session: {
                            videoSessionId: n,
                            gameType: U,
                            scenario: this.staticStats.abtest
                        },
                        v: eV
                    };
                    a.emit(["CLIENT_VIDEO_V2_HEARTBEAT", W]),
                    this.playerStats.userInteractionRequired = !1,
                    this.bufferingTime = this.bufferingTime ? l : void 0,
                    this.bufferingDuration = 0,
                    null === (V = this.aggregator) || void 0 === V || V.clean(),
                    this.localStats.bufferLengthMin = 0,
                    this.localStats.bufferLengthMax = 0,
                    this.localStats.fpsMin = 0
                }
                ,
                this.sendSessionEndEvent = () => {
                    const e = Math.round(window.performance.now() - this.initTime);
                    tV(this.staticStats, this.playerStats.playerName, e, {
                        type: "SESSION_END"
                    })
                }
                ,
                this.staticStats = e,
                qt(e, V),
                "getBattery"in navigator && "function" == typeof navigator.getBattery && navigator.getBattery().then((e => {
                    this.batteryManager = e
                }
                )).catch(( () => {}
                )),
                window.addEventListener("beforeunload", ( () => {
                    this.sendSessionEndEvent()
                }
                ))
            }
            destroy() {
                this.scheduler.deschedule(this.heartbeatTimeout)
            }
        }
        const aV = {
            observedMinBandwidth: null,
            observedMaxBandwidth: null,
            observedAverageBandwidth: null,
            observedMinLatency: null,
            observedMaxLatency: null,
            observedAverageLatency: null,
            droppedFrames: 0
        };
        function UV(e) {
            return t => {
                const [V,l] = t;
                e[V].apply(e, l)
            }
        }
        function nV() {
            const e = [];
            return {
                subscribe: function(t) {
                    e.includes(t) || e.push(t)
                },
                unsubscribe: function(t) {
                    const V = e.indexOf(t);
                    -1 !== V && e.splice(V, 1)
                },
                emit: function(t) {
                    e.slice().forEach((e => e(t)))
                },
                clear: function() {
                    e.splice(0, e.length)
                }
            }
        }
        function RV(e) {
            return "number" == typeof e && e >= 0 && e <= 1
        }
        const ZV = Math.pow(2, 24)
          , NV = Math.pow(2, 32);
        function cV(e) {
            let t, V = "";
            for (let l = 7; l >= 0; --l)
                t = e >>> (l << 2) & 15,
                V += t.toString(16);
            return V
        }
        function TV(e, t) {
            return e << t | e >>> 32 - t
        }
        class WV {
            constructor(e) {
                this.bytes = new Uint8Array(e << 2)
            }
            get(e) {
                return e <<= 2,
                this.bytes[e] * ZV + (this.bytes[e + 1] << 16 | this.bytes[e + 2] << 8 | this.bytes[e + 3])
            }
            set(e, t) {
                const V = Math.floor(t / ZV)
                  , l = t - V * ZV;
                e <<= 2,
                this.bytes[e] = V,
                this.bytes[e + 1] = l >> 16,
                this.bytes[e + 2] = l >> 8 & 255,
                this.bytes[e + 3] = 255 & l
            }
        }
        const iV = V(615)
          , FV = {
            alg: "HS256"
        };
        function rV(e) {
            return iV.enc.Base64.stringify(e).replace(/=+$/, "").replace(/\+/g, "-").replace(/\//g, "_")
        }
        function sV(e) {
            return rV(iV.enc.Utf8.parse(JSON.stringify(e)))
        }
        function hV(e, t) {
            return e ? t ? M[e] < M[t] ? e : t : e : t
        }
        function oV(e) {
            if (e)
                return m[e] ? e : void 0
        }
        const mV = {
            "fmp4.enable": !0,
            "fmp4.enableInWebView": !0,
            "fmp4.adaptive.bitrateRule.enable": !1,
            "fmp4.adaptive.bitrateRule.fadeCoefficient": .95,
            "fmp4.adaptive.bitrateRule.switchCoefficient": 10,
            "fmp4.buffer.init": 1e3,
            "fmp4.buffer.slowMoMin": 500,
            "fmp4.buffer.slowMoMax": 1500,
            "fmp4.buffer.fastForwardMin": 3e3,
            "fmp4.buffer.fastForwardMax": 6e3,
            "fmp4.latency.warning": 7e3,
            "fmp4.latency.warningDuration": 3e3,
            "fmp4.latency.max": 9e3,
            "fmp4.playback.maxAttempts": 3,
            "fmp4.playback.maxErrors": 3,
            "fmp4.playback.errorResetTime": 3e4,
            "fmp4.playback.maxTimeToFirstFrame": 3e4,
            "fmp4.audioCodec": "aac",
            "fmp4.videoCodec": "h264",
            "webcodec.enable": !1,
            "webcodec.adaptive.bitrateRule.enable": !1,
            "webcodec.adaptive.bitrateRule.fadeCoefficient": .95,
            "webcodec.adaptive.bitrateRule.switchCoefficient": 10,
            "webcodec.buffer.init": 1e3,
            "webcodec.buffer.slowMoMin": 500,
            "webcodec.buffer.slowMoMax": 1500,
            "webcodec.buffer.fastForwardMin": 3e3,
            "webcodec.buffer.fastForwardMax": 6e3,
            "webcodec.latency.warning": 7e3,
            "webcodec.latency.warningDuration": 3e3,
            "webcodec.latency.max": 9e3,
            "webcodec.playback.maxAttempts": 3,
            "webcodec.playback.maxErrors": 3,
            "webcodec.playback.errorResetTime": 3e4,
            "webcodec.playback.maxTimeToFirstFrame": 3e4,
            "webcodec.audioCodec": "opus",
            "webcodec.videoCodec": "h264",
            "flipbook.enable": !0,
            "flipbook.buffer.init": 1e3,
            "flipbook.buffer.slowMoMin": 500,
            "flipbook.buffer.slowMoMax": 1500,
            "flipbook.buffer.fastForwardMin": 3e3,
            "flipbook.buffer.fastForwardMax": 6e3,
            "flipbook.latency.warning": 7e3,
            "flipbook.latency.warningDuration": 3e3,
            "flipbook.latency.max": 9e3,
            "flipbook.networkMeter.enable": !0,
            "flipbook.video.host": "live1-ufb.egcvi.com",
            "flipbook.playback.maxAttempts": 3,
            "flipbook.playback.maxErrors": 3,
            "flipbook.playback.errorResetTime": 3e4,
            "flipbook.playback.maxTimeToFirstFrame": 6e4,
            "flipbook.audioCodec": "opus",
            "flipbook.videoCodec": "webp",
            "hls.enable": !0,
            "hls.enableInWebView": !0,
            "hls.buffer.init": 1e3,
            "hls.buffer.slowMoMin": 500,
            "hls.buffer.slowMoMax": 1500,
            "hls.buffer.fastForwardMin": 3e3,
            "hls.buffer.fastForwardMax": 6e3,
            "hls.latency.warning": 7e3,
            "hls.latency.warningDuration": 3e3,
            "hls.latency.max": 9e3,
            "hls.maxVideoTimeDiff": 2,
            "hls.validationTimeout": 11e3,
            "hls.playback.maxAttempts": 3,
            "hls.playback.maxErrors": 3,
            "hls.playback.errorResetTime": 3e4,
            "hls.playback.maxTimeToFirstFrame": 3e4,
            "hls.audioCodec": "aac",
            "hls.videoCodec": "h264",
            "inhousehls.enable": !1,
            "inhousehls.adaptive.bitrateRule.enable": !1,
            "inhousehls.adaptive.bitrateRule.fadeCoefficient": .95,
            "inhousehls.adaptive.bitrateRule.switchCoefficient": 10,
            "inhousehls.buffer.init": 900,
            "inhousehls.buffer.slowMoMin": 500,
            "inhousehls.buffer.slowMoMax": 1500,
            "inhousehls.buffer.fastForwardMin": 3e3,
            "inhousehls.buffer.fastForwardMax": 6e3,
            "inhousehls.latency.warning": 7e3,
            "inhousehls.latency.warningDuration": 3e3,
            "inhousehls.latency.max": 9e3,
            "inhousehls.playback.maxAttempts": 3,
            "inhousehls.playback.maxErrors": 3,
            "inhousehls.playback.errorResetTime": 3e4,
            "inhousehls.playback.maxTimeToFirstFrame": 3e4,
            "inhousehls.audioCodec": "aac",
            "inhousehls.videoCodec": "h264",
            "wasm.enable": !1,
            "wasm.buffer.init": 1e3,
            "wasm.buffer.slowMoMin": 500,
            "wasm.buffer.slowMoMax": 1500,
            "wasm.buffer.fastForwardMin": 3e3,
            "wasm.buffer.fastForwardMax": 6e3,
            "wasm.latency.warning": 7e3,
            "wasm.latency.warningDuration": 3e3,
            "wasm.latency.max": 9e3,
            "wasm.playback.maxAttempts": 3,
            "wasm.playback.maxErrors": 3,
            "wasm.playback.errorResetTime": 3e4,
            "wasm.playback.maxTimeToFirstFrame": 3e4,
            "wasm.audioCodec": "opus",
            "wasm.videoCodec": "h264",
            "stream.baseName": "streamBaseName",
            "stream.manifestLogic": b.MANUAL,
            "stream.host":  "live1.egcvi.com",
            "stream.enableCdn": !0,
            "stream.minQuality": void 0,
            "stream.maxQuality": void 0,
            "stream.initialQuality": m.MEDIUM,
            "stream.name": "",
            "stream.returnAllAvailableQualities": !1,
            "debug.enableErrorLog": !1,
            "debug.enableAllPlayers": !1,
            "debug.url": "",
            "debug.flipbook.url": ""
        }
          , MV = "video.";
        function SV(e, t) {
            const {rawConfig: V} = t
              , l = `${e}_${t.geoCountry()}`;
            let d;
            if (V && (d = V[l] || V[e]),
            e in EV)
                return function(e, t) {
                    return t || EV[e]
                }(e, d);
            if (e in pV)
                return function(e, t) {
                    const V = Number(t);
                    return !t || isNaN(V) ? pV[e] : V
                }(e, d);
            if (e in bV)
                return function(e, t) {
                    return t ? t.split(",") : bV[e]
                }(e, d);
            if (e in kV)
                return function(e, t) {
                    return void 0 === t ? kV[e] : "true" === t
                }(e, d);
            throw new Error("Unknown property passed")
        }
        const EV = {
            table_id: "",
            game_type: "",
            flipbook_stream_host: void 0,
            "view1-desktop": void 0,
            "view2-desktop": void 0,
            "view3-desktop": void 0,
            "view4-desktop": void 0,
            "view1-mobile": void 0,
            "view2-mobile": void 0,
            "view3-mobile": void 0,
            "view4-mobile": void 0,
            streamBaseName: void 0,
            "video-master-host": void 0
        }
          , pV = {
            limitation: A.EnableV2
        }
          , bV = {
            flipbook_stream_url: [],
            audio_flv_stream: []
        }
          , kV = {
            enable_cdn_skip: void 0,
            enable_fmp4: void 0,
            enable_wasm: void 0,
            enable_hls_native: void 0,
            enable_platform_exceptions: void 0,
            enable_hls_in_webview: void 0,
            enable_custom_redirect: void 0,
            enable_error_debug: void 0
        };
        function YV(e, t) {
            const V = t[`${MV}${e}`];
            if ("" !== V && void 0 !== V && "undefined" !== V)
                switch (typeof mV[e]) {
                case "boolean":
                    return "true" === V;
                case "number":
                    return Number(V);
                case "string":
                    return V;
                default:
                    return
                }
        }
        function QV(e) {
            return mV[e]
        }
        function JV(e, t) {
            const V = t[`${MV}${e}`];
            if ("" !== V && void 0 !== V && "undefined" !== V)
                return oV(V)
        }
        function GV(e, t, V) {
            const {manifestLogic: l, videoSessionId: d, videoToken: a, streamId: U, minQuality: n, maxQuality: R, audioCodec: Z, videoCodec: N, audioOnly: c} = t
              , T = c ? e.replace(/auto\/manifest-ws2.json/, "med_audioonly/manifest-ws2.json") : e
              , W = new URL(T)
              , i = new URLSearchParams;
            d && i.set("videoSessionId", d),
            a && i.set("videoToken", a),
            R && i.set("maxQuality", R),
            n && i.set("minQuality", n),
            l === b.MANUAL && i.set("noredirect", "1"),
            Number.isInteger(U) && i.set("streamid", `${U}`),
            Z && i.set("ac", Z);
            const F = c ? "off" : N;
            if (F && i.set("vc", F),
            V) {
                const e = new URL(V);
                for (let[t,V] of e.searchParams.entries())
                    i.set(t, V)
            }
            return W.search = i.toString(),
            W.href
        }
        function zV(e, t) {
            return e.map((e => e ? function(e, t) {
                const V = new URL(e)
                  , l = V.searchParams;
                for (const [d,a] of Object.entries(t)) {
                    const e = a.toString();
                    e && ("audioCodec" === d ? l.set("ac", e) : "videoCodec" === d ? l.set("vc", e) : l.set(d, e))
                }
                return V.search = l.toString(),
                V.href
            }(e, t) : e))
        }
        const xV = "video.abtest.";
        const uV = Object.values(k).filter((e => e !== k.None));
        function XV(e, t, V) {
            const l = t.split(".")
              , d = l.slice(2, l.length).join(".");
            V.forEach((V => {
                const l = `${MV}${V}.${d}`;
                uV.includes(V) && !e[l] && (e[l] = e[t])
            }
            ))
        }
        function yV(e, t) {
            const V = new URL(e);
            return V.host = t,
            V.href
        }
        function BV(e, t, V, l, d, a, U) {
            var n, R, Z, N, c, T, W, i, F, r, s, h, o, m, M, S, E, p, Y, Q, J, G, z, x, u, X, y, B, H, j, D, O, w, v, I, L, K, g, f, C, P, q, _, $, ee, te, Ve, le, de, ae, Ue, ne, Re, Ze, Ne, ce, Te;
            const We = e => function(e, t) {
                return t ? e.replace(new RegExp("{locale}","g"), t) : e
            }(e, U)
              , ie = e.geoCountry()
              , {rawConfig: Fe} = e
              , [re,se,he] = function(e, t=(Math.random() < .5 ? "A" : "B")) {
                const V = Object.assign({}, e)
                  , l = function(e) {
                    for (const t in e)
                        if (t.startsWith(xV))
                            return [t, e[t]];
                    return null
                }(V);
                if (!l)
                    return [V, null, null];
                const [d,a] = l
                  , U = d.replace(xV, "");
                if (!(U in mV))
                    return [V, null, null];
                const n = MV + U;
                return "B" === t && (V[n] = a),
                [V, t, n]
            }(Fe)
              , oe = se && he ? `${he}_${se}` : null
              , me = function(e, t) {
                if (!t)
                    return e;
                const V = Object.assign({}, e);
                for (const l in V) {
                    if (!l.startsWith(MV))
                        continue;
                    const e = l.split(".")
                      , d = e.splice(1, 1)[0]
                      , a = e.join(".");
                    if (d !== t) {
                        if (d.startsWith("[") && d.endsWith("]") && d.length > 2) {
                            if (e.splice(1, 0, t),
                            V[e.join(".")])
                                continue;
                            if (d.slice(1, -1).split(";").map((e => e.trim())).includes(t)) {
                                V[a] = V[l];
                                continue
                            }
                        }
                    } else
                        V[a] = V[l]
                }
                return V
            }(re, ie)
              , Me = V ? function(e) {
                const t = Object.assign({}, e);
                for (const V in e)
                    V.startsWith("video.mobile.") && (t[MV + V.split(".").slice(2).join(".")] = t[V]);
                return t
            }(me) : me
              , Se = l ? function(e) {
                const t = Object.assign({}, e);
                for (const V in e)
                    V.startsWith("video.iphone.") && (t[MV + V.split(".").slice(2).join(".")] = t[V]);
                return t
            }(Me) : Me
              , Ee = function(e) {
                const t = Object.assign({}, e);
                for (const V in t) {
                    if (!V.startsWith(MV))
                        continue;
                    const e = V.split(".")[1];
                    e.startsWith("[") && e.endsWith("]") && e.length > 2 && XV(t, V, e.slice(1, -1).split(";").map((e => e.trim())))
                }
                for (const V in t)
                    V.startsWith(MV) && "*" === V.split(".")[1] && XV(t, V, uV);
                return t
            }(Se)
              , pe = null !== (R = null !== (n = YV("stream.host", Ee)) && void 0 !== n ? n : SV("video-master-host", e)) && void 0 !== R ? R : mV["stream.host"]
              , be = null !== (N = null !== (Z = YV("stream.baseName", Ee)) && void 0 !== Z ? Z : SV("streamBaseName", e)) && void 0 !== N ? N : mV["stream.baseName"]
              , ke = SV("enable_cdn_skip", e)
              , Ye = null !== (T = null !== (c = YV("stream.enableCdn", Ee)) && void 0 !== c ? c : void 0 === ke ? void 0 : !ke) && void 0 !== T ? T : mV["stream.enableCdn"]
              , [Qe,Je] = V ? function(e) {
                if (!e)
                    return [void 0, void 0];
                const t = new URL(e)
                  , V = t.searchParams.get("maxBitrate")
                  , l = t.searchParams.get("minBitrate");
                return [oV(null != V ? V : ""), oV(null != l ? l : "")]
            }(SV("view1-mobile", e)) : [void 0, void 0]
              , Ge = null === (i = null !== (W = YV("debug.url", Ee)) && void 0 !== W ? W : "") || void 0 === i ? void 0 : i.split(",").filter((e => !!e))
              , ze = U ? `_${U}` : ""
              , xe = (null !== (F = YV("stream.name", Ee)) && void 0 !== F ? F : "").split(",")
              , ue = xe.map((e => {
                const [t,V,l] = e.split("/");
                return t && V && l ? `https://${pe}/${Ye ? "cdn/" : ""}${t}/${V}/amlst:${l}${ze}_auto/manifest-ws2.json` : ""
            }
            )).filter((e => !!e))
              , Xe = function(e, t) {
                var V, l, d, a;
                const U = t ? "mobile" : "desktop";
                return [null !== (V = SV(`view1-${U}`, e)) && void 0 !== V ? V : "", null !== (l = SV(`view2-${U}`, e)) && void 0 !== l ? l : "", null !== (d = SV(`view3-${U}`, e)) && void 0 !== d ? d : "", null !== (a = SV(`view4-${U}`, e)) && void 0 !== a ? a : ""]
            }(e, V).map(We).map((function(e) {
                return Ye ? e : e.replace("/cdn/", "/")
            }
            )).map((e => e ? yV(e, pe) : "")).map((e => e.replace("manifest-ws.json", "manifest-ws2.json"))).map((e => e.split("?")[0]))
              , ye = [Ge, ue, Xe].find((e => e.length > 0)) || []
              , Be = (Ae = SV("limitation", e),
            we = A.EnableV2,
            Ae === we || we === A.EnableV2 && ![A.Off].includes(Ae))
              , He = SV("table_id", e)
              , je = Math.round((Date.now() + 864e5) / 1e3)
              , De = function(e, t, V, l, d) {
                return e && t && V ? `${e}-${t}-${V}-${function(e) {
                    let t;
                    t = e instanceof ArrayBuffer ? e : function(e) {
                        e = e.replace(/[\u0080-\u07ff]/g, (function(e) {
                            const t = e.charCodeAt(0);
                            return String.fromCharCode(192 | t >> 6, 128 | 63 & t)
                        }
                        )),
                        e = e.replace(/[\u0080-\uffff]/g, (function(e) {
                            const t = e.charCodeAt(0);
                            return String.fromCharCode(224 | t >> 12, 128 | t >> 6 & 63, 128 | 63 & t)
                        }
                        ));
                        const t = e.length
                          , V = new Uint8Array(t);
                        for (let l = 0; l < t; ++l)
                            V[l] = e.charCodeAt(l);
                        return V.buffer
                    }(String(e));
                    let V, l, d = 1732584193, a = 4023233417, U = 2562383102, n = 271733878, R = 3285377520, Z = t.byteLength, N = Z << 3, c = N + 65, T = Math.ceil(c / 512) << 9 >>> 3 >>> 2, W = new WV(T), i = W.bytes, F = new Uint32Array(80), r = new Uint8Array(t);
                    for (V = 0; V < Z; ++V)
                        i[V] = r[V];
                    for (i[Z] = 128,
                    W.set(T - 2, Math.floor(N / NV)),
                    W.set(T - 1, 4294967295 & N),
                    V = 0; V < T; V += 16) {
                        for (l = 0; l < 16; ++l)
                            F[l] = W.get(V + l);
                        for (; l < 80; ++l)
                            F[l] = TV(F[l - 3] ^ F[l - 8] ^ F[l - 14] ^ F[l - 16], 1);
                        let e, t, Z, N = d, c = a, T = U, i = n, r = R;
                        for (l = 0; l < 80; ++l)
                            l < 20 ? (e = c & T | ~c & i,
                            t = 1518500249) : l < 40 ? (e = c ^ T ^ i,
                            t = 1859775393) : l < 60 ? (e = c & T ^ c & i ^ T & i,
                            t = 2400959708) : (e = c ^ T ^ i,
                            t = 3395469782),
                            Z = TV(N, 5) + e + r + t + F[l] & 4294967295,
                            r = i,
                            i = T,
                            T = TV(c, 30),
                            c = N,
                            N = Z;
                        d = d + N & 4294967295,
                        a = a + c & 4294967295,
                        U = U + T & 4294967295,
                        n = n + i & 4294967295,
                        R = R + r & 4294967295
                    }
                    return cV(d) + cV(a) + cV(U) + cV(n) + cV(R)
                }(`${e}-${t}-${V}-${l}-${d}`).substring(0, 6)}` : ""
            }(t.userId, t.sessionId, He, be, je)
              , Oe = Be ? function(e, t, V, l, d, a) {
                return function(e, t, V={}) {
                    const l = sV(Object.assign(FV, V))
                      , d = sV(e);
                    let a = `${l}.${d}`;
                    return a = iV.HmacSHA256(a, t),
                    a = rV(a),
                    `${l}.${d}.${a}`
                }({
                    sub: e,
                    exp: t,
                    iss: l,
                    csn: d,
                    dlh: a
                }, V)
            }(be, je, De, t.tokenIssuer, null !== (r = e.casinoId) && void 0 !== r ? r : "", location.hostname) : void 0;
            var Ae, we;
            let ve;
            switch (SV("enable_custom_redirect", e)) {
            case !0:
                ve = b.MANUAL;
                break;
            case !1:
                ve = b.BROWSER;
                break;
            default:
                ve = void 0
            }
            const Ie = null !== (h = null !== (s = YV("stream.manifestLogic", Ee)) && void 0 !== s ? s : ve) && void 0 !== h ? h : mV["stream.manifestLogic"]
              , Le = null !== (m = null !== (o = JV("stream.minQuality", Ee)) && void 0 !== o ? o : Je) && void 0 !== m ? m : mV["stream.minQuality"]
              , Ke = null !== (S = null !== (M = hV(JV("stream.maxQuality", Ee), a)) && void 0 !== M ? M : hV(Qe, a)) && void 0 !== S ? S : mV["stream.maxQuality"]
              , ge = {
                streamId: d,
                manifestLogic: Ie,
                videoSessionId: De,
                videoToken: Oe,
                minQuality: Le,
                maxQuality: Ke
            }
              , fe = ye.map(( (e, t) => e ? GV(e, ge, Ge[t]) : ""))
              , Ce = null === (p = null !== (E = YV("debug.flipbook.url", Ee)) && void 0 !== E ? E : "") || void 0 === p ? void 0 : p.split(",").filter((e => !!e))
              , Pe = null !== (Q = null !== (Y = YV("flipbook.video.host", Ee)) && void 0 !== Y ? Y : SV("flipbook_stream_host", e)) && void 0 !== Q ? Q : mV["flipbook.video.host"]
              , qe = xe.map((e => {
                const [t,V,l] = e.split("/");
                return t && V && l ? `wss://${Pe}/ws/video/${V}/${l}${ze}_med` : ""
            }
            )).filter((e => !!e))
              , _e = SV("flipbook_stream_host", e)
              , $e = SV("flipbook_stream_url", e).map(We).map((e => _e ? yV(e, _e) : e))
              , et = OV(k.Flipbook, Ee)
              , tt = [Ce, qe, $e].find((e => e.length > 0)) || [];
            fe.forEach(( (e, t) => {
                tt[t] || (tt[t] = e ? tt[0] : "")
            }
            ));
            const Vt = SV("enable_platform_exceptions", e)
              , lt = {
                gameSessionId: t.sessionId,
                videoSessionId: De,
                videoTokenIssuer: t.tokenIssuer,
                tableId: He,
                gameType: SV("game_type", e),
                videoToken: Oe
            }
              , dt = zV(fe, OV(k.Fmp4, Ee))
              , at = zV(fe, OV(k.WebCodec, Ee))
              , Ut = fe.map((e => e.replace(/manifest-ws2.json/, "playlist.m3u8")))
              , nt = zV(Ut, OV(k.Hls, Ee))
              , Rt = zV(Ut, OV(k.Inhousehls, Ee))
              , Zt = zV(ye.map((e => e ? GV(e, Object.assign(Object.assign({}, ge), {
                audioOnly: !0
            })) : "")), {
                audioCodec: et.audioCodec
            })
              , Nt = zV(tt, {
                videoCodec: et.videoCodec
            })
              , ct = zV(fe, OV(k.Wasm, Ee));
            return {
                video: {
                    [k.Fmp4]: {
                        player: k.Fmp4,
                        enable: null !== (G = null !== (J = YV(`${k.Fmp4}.enable`, Ee)) && void 0 !== J ? J : SV("enable_fmp4", e)) && void 0 !== G ? G : mV["fmp4.enable"],
                        enableInWebView: null !== (z = YV(`${k.Fmp4}.enableInWebView`, Ee)) && void 0 !== z ? z : mV["fmp4.enableInWebView"],
                        buffer: HV(k.Fmp4, Ee),
                        latency: jV(k.Fmp4, Ee),
                        playback: DV(k.Fmp4, Ee),
                        adaptive: {
                            bitrateRule: {
                                enable: null !== (x = YV(`${k.Fmp4}.adaptive.bitrateRule.enable`, Ee)) && void 0 !== x ? x : mV["fmp4.adaptive.bitrateRule.enable"],
                                fadeCoefficient: null !== (u = YV(`${k.Fmp4}.adaptive.bitrateRule.fadeCoefficient`, Ee)) && void 0 !== u ? u : mV["fmp4.adaptive.bitrateRule.fadeCoefficient"],
                                switchCoefficient: null !== (X = YV(`${k.Fmp4}.adaptive.bitrateRule.switchCoefficient`, Ee)) && void 0 !== X ? X : mV["fmp4.adaptive.bitrateRule.switchCoefficient"]
                            }
                        },
                        urls: dt,
                        audioCodec: null !== (y = YV(`${k.Fmp4}.audioCodec`, Ee)) && void 0 !== y ? y : mV[`${k.Fmp4}.audioCodec`],
                        videoCodec: null !== (B = YV(`${k.Fmp4}.videoCodec`, Ee)) && void 0 !== B ? B : mV[`${k.Fmp4}.videoCodec`]
                    },
                    [k.WebCodec]: {
                        player: k.WebCodec,
                        enable: null !== (H = YV(`${k.WebCodec}.enable`, Ee)) && void 0 !== H ? H : mV["webcodec.enable"],
                        buffer: HV(k.WebCodec, Ee),
                        latency: jV(k.WebCodec, Ee),
                        playback: DV(k.WebCodec, Ee),
                        adaptive: {
                            bitrateRule: {
                                enable: null !== (j = YV(`${k.WebCodec}.adaptive.bitrateRule.enable`, Ee)) && void 0 !== j ? j : mV["webcodec.adaptive.bitrateRule.enable"],
                                fadeCoefficient: null !== (D = YV(`${k.WebCodec}.adaptive.bitrateRule.fadeCoefficient`, Ee)) && void 0 !== D ? D : mV["webcodec.adaptive.bitrateRule.fadeCoefficient"],
                                switchCoefficient: null !== (O = YV(`${k.WebCodec}.adaptive.bitrateRule.switchCoefficient`, Ee)) && void 0 !== O ? O : mV["webcodec.adaptive.bitrateRule.switchCoefficient"]
                            }
                        },
                        urls: at,
                        audioCodec: null !== (w = YV(`${k.WebCodec}.audioCodec`, Ee)) && void 0 !== w ? w : mV[`${k.WebCodec}.audioCodec`],
                        videoCodec: null !== (v = YV(`${k.WebCodec}.videoCodec`, Ee)) && void 0 !== v ? v : mV[`${k.WebCodec}.videoCodec`]
                    },
                    [k.Flipbook]: {
                        player: k.Flipbook,
                        enable: null !== (I = YV(`${k.Flipbook}.enable`, Ee)) && void 0 !== I ? I : mV["flipbook.enable"],
                        buffer: HV(k.Flipbook, Ee),
                        latency: jV(k.Flipbook, Ee),
                        playback: DV(k.Flipbook, Ee),
                        networkMeter: {
                            enable: null !== (L = YV(`${k.Flipbook}.networkMeter.enable`, Ee)) && void 0 !== L ? L : mV["flipbook.networkMeter.enable"]
                        },
                        video: {
                            urls: Nt
                        },
                        audio: {
                            urls: Zt
                        },
                        audioCodec: null !== (K = YV(`${k.Flipbook}.audioCodec`, Ee)) && void 0 !== K ? K : mV[`${k.Flipbook}.audioCodec`]
                    },
                    [k.Hls]: {
                        player: k.Hls,
                        enable: null !== (f = null !== (g = YV(`${k.Hls}.enable`, Ee)) && void 0 !== g ? g : SV("enable_hls_native", e)) && void 0 !== f ? f : mV["hls.enable"],
                        enableInWebView: null !== (P = null !== (C = YV(`${k.Hls}.enableInWebView`, Ee)) && void 0 !== C ? C : SV("enable_hls_in_webview", e)) && void 0 !== P ? P : mV["hls.enableInWebView"],
                        buffer: HV(k.Hls, Ee),
                        latency: jV(k.Hls, Ee),
                        playback: DV(k.Hls, Ee),
                        maxVideoTimeDiff: null !== (q = YV(`${k.Hls}.maxVideoTimeDiff`, Ee)) && void 0 !== q ? q : mV["hls.maxVideoTimeDiff"],
                        validationTimeout: null !== (_ = YV(`${k.Hls}.validationTimeout`, Ee)) && void 0 !== _ ? _ : mV["hls.validationTimeout"],
                        urls: nt
                    },
                    [k.Inhousehls]: {
                        player: k.Inhousehls,
                        enable: null !== ($ = YV(`${k.Inhousehls}.enable`, Ee)) && void 0 !== $ ? $ : mV[`${k.Inhousehls}.enable`],
                        buffer: HV(k.Inhousehls, Ee),
                        latency: jV(k.Inhousehls, Ee),
                        playback: DV(k.Inhousehls, Ee),
                        adaptive: {
                            bitrateRule: {
                                enable: null !== (ee = YV(`${k.Inhousehls}.adaptive.bitrateRule.enable`, Ee)) && void 0 !== ee ? ee : mV[`${k.Inhousehls}.adaptive.bitrateRule.enable`],
                                fadeCoefficient: null !== (te = YV(`${k.Inhousehls}.adaptive.bitrateRule.fadeCoefficient`, Ee)) && void 0 !== te ? te : mV[`${k.Inhousehls}.adaptive.bitrateRule.fadeCoefficient`],
                                switchCoefficient: null !== (Ve = YV(`${k.Inhousehls}.adaptive.bitrateRule.switchCoefficient`, Ee)) && void 0 !== Ve ? Ve : mV[`${k.Inhousehls}.adaptive.bitrateRule.switchCoefficient`]
                            }
                        },
                        urls: Rt,
                        audioCodec: null !== (le = YV(`${k.Inhousehls}.audioCodec`, Ee)) && void 0 !== le ? le : mV[`${k.Inhousehls}.audioCodec`],
                        videoCodec: null !== (de = YV(`${k.Inhousehls}.videoCodec`, Ee)) && void 0 !== de ? de : mV[`${k.Inhousehls}.videoCodec`]
                    },
                    [k.Wasm]: {
                        player: k.Wasm,
                        enable: null !== (Ue = null !== (ae = YV(`${k.Wasm}.enable`, Ee)) && void 0 !== ae ? ae : SV("enable_wasm", e)) && void 0 !== Ue ? Ue : mV["wasm.enable"],
                        buffer: HV(k.Wasm, Ee),
                        latency: jV(k.Wasm, Ee),
                        playback: DV(k.Wasm, Ee),
                        urls: ct
                    },
                    abtest: oe,
                    stream: {
                        baseName: be,
                        host: pe,
                        enableCdn: Ye,
                        manifestLogic: Ie,
                        minQuality: Le,
                        maxQuality: Ke,
                        initialQuality: null !== (ne = YV("stream.initialQuality", Ee)) && void 0 !== ne ? ne : mV["stream.initialQuality"],
                        returnAllAvailableQualities: null !== (Re = YV("stream.returnAllAvailableQualities", Ee)) && void 0 !== Re ? Re : mV["stream.returnAllAvailableQualities"]
                    },
                    debug: {
                        enableErrorLog: null !== (Ne = null !== (Ze = YV("debug.enableErrorLog", Ee)) && void 0 !== Ze ? Ze : SV("enable_error_debug", e)) && void 0 !== Ne ? Ne : mV["debug.enableErrorLog"],
                        enableAllPlayers: null !== (Te = null !== (ce = YV("debug.enableAllPlayers", Ee)) && void 0 !== ce ? ce : void 0 !== Vt ? !Vt : void 0) && void 0 !== Te ? Te : mV["debug.enableAllPlayers"]
                    },
                    session: lt
                }
            }
        }
        function HV(e, t) {
            var V, l, d, a, U;
            return {
                init: null !== (V = YV(`${e}.buffer.init`, t)) && void 0 !== V ? V : QV(`${e}.buffer.init`),
                slowMoMin: null !== (l = YV(`${e}.buffer.slowMoMin`, t)) && void 0 !== l ? l : QV(`${e}.buffer.slowMoMin`),
                slowMoMax: null !== (d = YV(`${e}.buffer.slowMoMax`, t)) && void 0 !== d ? d : QV(`${e}.buffer.slowMoMax`),
                fastForwardMin: null !== (a = YV(`${e}.buffer.fastForwardMin`, t)) && void 0 !== a ? a : QV(`${e}.buffer.fastForwardMin`),
                fastForwardMax: null !== (U = YV(`${e}.buffer.fastForwardMax`, t)) && void 0 !== U ? U : QV(`${e}.buffer.fastForwardMax`)
            }
        }
        function jV(e, t) {
            var V, l, d;
            return {
                warning: null !== (V = YV(`${e}.latency.warning`, t)) && void 0 !== V ? V : QV(`${e}.latency.warning`),
                warningDuration: null !== (l = YV(`${e}.latency.warningDuration`, t)) && void 0 !== l ? l : QV(`${e}.latency.warningDuration`),
                max: null !== (d = YV(`${e}.latency.max`, t)) && void 0 !== d ? d : QV(`${e}.latency.max`)
            }
        }
        function DV(e, t) {
            var V, l, d, a;
            return {
                maxAttempts: null !== (V = YV(`${e}.playback.maxAttempts`, t)) && void 0 !== V ? V : QV(`${e}.playback.maxAttempts`),
                maxErrors: null !== (l = YV(`${e}.playback.maxErrors`, t)) && void 0 !== l ? l : QV(`${e}.playback.maxErrors`),
                errorResetTime: null !== (d = YV(`${e}.playback.errorResetTime`, t)) && void 0 !== d ? d : QV(`${e}.playback.errorResetTime`),
                maxTimeToFirstFrame: null !== (a = YV(`${e}.playback.maxTimeToFirstFrame`, t)) && void 0 !== a ? a : QV(`${e}.playback.maxTimeToFirstFrame`)
            }
        }
        function OV(e, t) {
            var V, l;
            return {
                audioCodec: null !== (V = YV(`${e}.audioCodec`, t)) && void 0 !== V ? V : QV(`${e}.audioCodec`),
                videoCodec: null !== (l = YV(`${e}.videoCodec`, t)) && void 0 !== l ? l : QV(`${e}.videoCodec`)
            }
        }
        function AV(e, t, V, l, d) {
            const a = function(e) {
                const t = e.sessionId()
                  , V = e.userId()
                  , {tokenIssuer: l} = e
                  , d = "Missing '%s' or type not string in video GlobalConfig";
                return t && "string" == typeof t ? V && "string" == typeof V ? l && "string" == typeof l ? {
                    sessionId: t,
                    userId: V,
                    tokenIssuer: l
                } : new Qe("SETTINGS_ERROR",d.replace("%s", "tokenIssuer")) : new Qe("SETTINGS_ERROR",d.replace("%s", "userId")) : new Qe("SETTINGS_ERROR",d.replace("%s", "sessionId"))
            }(e);
            if (a instanceof Qe)
                return a;
            const U = function(e) {
                if (!e)
                    return new Qe("SETTINGS_ERROR","No table settings provided");
                if ("object" != typeof e || Array.isArray(e))
                    return new Qe("SETTINGS_ERROR","Incorrect format of table settings");
                if (!e["video.stream.baseName"] && !e.streamBaseName)
                    return new Qe("SETTINGS_ERROR","Missing table setting: video.stream.baseName");
                const t = e["video.stream.name"];
                if (!["string", "undefined"].includes(typeof t) || "string" == typeof t && !t.split(",").every((e => /^(app|ezs)\/\d+\/([\w()-]+)$/.test(e))))
                    return new Qe("SETTINGS_ERROR","Invalid host format in table setting: 'video.stream.name'");
                const V = t ? [X.TABLE_ID] : [X.VIEW1_MOBILE, X.VIEW1_DESKTOP, X.TABLE_ID];
                t || V.push(X.FLIPBOOK_STREAM_URL);
                for (const a of V)
                    if (!e[a])
                        return new Qe("SETTINGS_ERROR","Missing table setting: " + a);
                const l = [X.VIEW1_MOBILE, X.VIEW2_MOBILE, X.VIEW3_MOBILE, X.VIEW4_MOBILE, X.VIEW1_DESKTOP, X.VIEW2_DESKTOP, X.VIEW3_DESKTOP, X.VIEW4_DESKTOP].map((t => e[t] && function(e, t) {
                    let V;
                    try {
                        V = new URL(e)
                    } catch (l) {
                        return new Qe("SETTINGS_ERROR",`Invalid url in table setting: '${t}'`)
                    }
                    return "https:" !== V.protocol ? new Qe("SETTINGS_ERROR",`Invalid table setting: '${t}'. Protocol should be https:`) : /\/(app|ezs)\/[0-9]+\//.test(V.pathname) ? /\/amlst:/.test(V.pathname) ? /\/manifest-ws2?.json/.test(V.pathname) ? void 0 : new Qe("SETTINGS_ERROR",`Table setting: '${t}' url must include 'manifest-ws2.json'`) : new Qe("SETTINGS_ERROR",`Table setting: '${t}' url must include '/amlst:'`) : new Qe("SETTINGS_ERROR",`Table setting: '${t}' url must include '/{application name}/{integer}/'`)
                }(e[t], t))).filter((e => !!e));
                if (l.length)
                    return l[0];
                const d = [X.STREAM_HOST, X.VIDEO_MASTER_HOST, X.FLIPBOOK_VIDEO_HOST, X.FLIPBOOK_STREAM_HOST].map((t => e[t] && function(e, t) {
                    if (!/^[a-z0-9]+([-.]{1}[a-z0-9]+)*\.[a-z]{2,6}(:[0-9]+)?$/i.test(e))
                        return new Qe("SETTINGS_ERROR",`Invalid host format in table setting: '${t}'`)
                }(e[t], t))).filter((e => !!e));
                return d.length ? d[0] : void 0
            }(e.rawConfig);
            return U instanceof Qe ? U : BV(e, a, t.IS_PHONE || t.IS_IPHONE || t.IS_TABLET, t.IS_IPHONE, V, l, d)
        }
        function wV(e, t, V) {
            return l = this,
            d = arguments,
            U = function*(e, t, V, l=Ye()) {
                var d;
                const a = yield le()
                  , {maxSupportedQuality: U} = l.DeviceProperties
                  , n = AV(e, l, null !== (d = t.streamId) && void 0 !== d ? d : w.streamId, U, t.language);
                if (n instanceof Qe)
                    throw n;
                const R = n;
                Qe.enableErrorDebug = R.video.debug.enableErrorLog;
                const Z = Object.assign(Object.assign(Object.assign(Object.assign({}, w), pt({
                    quality: R.video.stream.initialQuality
                })), pt(t)), {
                    volume: RV(t.volume) ? t.volume : w.volume
                })
                  , N = (c = Z,
                {
                    play: new F(!1),
                    enableVideo: new F(c.enableVideo),
                    isBackgroundMode: new F(!1),
                    muted: new F(c.muted),
                    volume: new F(c.volume),
                    quality: new F(c.quality),
                    streamId: new F(c.streamId),
                    maxAutoQuality: new F(c.maxQuality),
                    qualityMode: new F(c.qualityMode),
                    objectFit: new F(c.objectFit)
                });
                var c;
                const T = {
                    onPlay: nV(),
                    onQuality: nV(),
                    onStreamId: nV(),
                    onStreamCount: nV(),
                    onVideoEnable: nV(),
                    onShowPlayerInfo: nV(),
                    onAvailableQualities: nV(),
                    onUserInteractionRequired: nV(),
                    onMediaPlayerEvent: nV(),
                    onVideoWallclock: nV(),
                    stats: nV(),
                    onStats: nV()
                }
                  , W = new F(Z.showInfo)
                  , i = Object.entries(N).map(( ([e,t]) => ({
                    [e]: t.pipe(r())
                }))).reduce(( (e, t) => Object.assign(e, t)), {})
                  , h = Ae(V, R, l, a);
                if (0 === h.length)
                    throw new Error("No video players available");
                const M = new Ot
                  , S = new Et(T.onStats)
                  , E = {
                    publishers: T,
                    availablePlayers: h,
                    deviceSupport: l,
                    browserFeatures: a,
                    settings: R,
                    scheduler: M,
                    stats: S
                };
                let p;
                const b = new At(T.onShowPlayerInfo.emit);
                let k;
                T.onStats.subscribe(UV(b));
                const Y = document.createElement("div");
                Y.style.width = "100%",
                Y.style.height = "100%",
                setTimeout(( () => {
                    p = function(e, t, V) {
                        const l = new s
                          , d = [ht, St, Mt].reduce(( (t, V) => V(l, t, e)), t);
                        return new Ft(l,e,d,V)
                    }(E, i, Y);
                    const e = {
                        gameType: R.video.session.gameType,
                        publishers: T,
                        masterHost: R.video.stream.host,
                        deviceSupport: l,
                        soundVolume: w.muted ? 0 : w.volume,
                        videoSessionId: R.video.session.videoSessionId,
                        abtest: R.video.abtest
                    };
                    k = new dV(e,R,a),
                    T.onStats.subscribe(UV(k));
                    const t = R.video.fmp4.urls.filter((e => !!e)).length;
                    T.onStreamCount.emit(t)
                }
                ));
                const Q = o([i.muted, i.volume], (e => e)).subscribe((e => S.onVolumeUpdate(...e)))
                  , J = W.subscribe((e => {
                    if (!b)
                        return;
                    const t = b.getContainer()
                      , V = Y.contains(t);
                    e && !V && Y.append(t),
                    !e && V && Y.removeChild(t),
                    b.showInfo(e)
                }
                ));
                return {
                    quality: {
                        set: e => {
                            Object.keys(m).includes(e) && N.quality.next(e)
                        }
                        ,
                        get: () => N.quality.value,
                        subscribe: T.onQuality.subscribe,
                        unsubscribe: T.onQuality.unsubscribe
                    },
                    qualityMode: {
                        set: e => N.qualityMode.next(e),
                        get: () => N.qualityMode.value
                    },
                    maxQuality: {
                        set: e => N.maxAutoQuality.next(e),
                        get: () => N.maxAutoQuality.value
                    },
                    availableQualities: {
                        subscribe: T.onAvailableQualities.subscribe,
                        unsubscribe: T.onAvailableQualities.unsubscribe
                    },
                    volume: {
                        set: e => {
                            RV(e) && N.volume.next(e)
                        }
                        ,
                        get: () => N.volume.value
                    },
                    muted: {
                        set: e => N.muted.next(e),
                        get: () => N.muted.value
                    },
                    multiwindowCount: {
                        set: e => {}
                        ,
                        get: () => {}
                    },
                    showInfo: {
                        set: e => W.next(e),
                        get: () => W.value,
                        subscribe: T.onShowPlayerInfo.subscribe,
                        unsubscribe: T.onShowPlayerInfo.unsubscribe
                    },
                    streamId: {
                        set: e => N.streamId.next(e),
                        get: () => N.streamId.value,
                        subscribe: T.onStreamId.subscribe,
                        unsubscribe: T.onStreamId.unsubscribe
                    },
                    play: {
                        subscribe: T.onPlay.subscribe,
                        unsubscribe: T.onPlay.unsubscribe
                    },
                    enableVideo: {
                        set: e => N.enableVideo.next(e),
                        get: () => N.enableVideo.value,
                        subscribe: T.onVideoEnable.subscribe,
                        unsubscribe: T.onVideoEnable.unsubscribe
                    },
                    isUserInteractionRequired: {
                        subscribe: T.onUserInteractionRequired.subscribe,
                        unsubscribe: T.onUserInteractionRequired.unsubscribe
                    },
                    streamCount: {
                        subscribe: T.onStreamCount.subscribe,
                        unsubscribe: T.onStreamCount.unsubscribe
                    },
                    wallclock: {
                        subscribe: T.onVideoWallclock.subscribe,
                        unsubscribe: T.onVideoWallclock.unsubscribe
                    },
                    objectFit: {
                        set: e => N.objectFit.next(e),
                        get: () => N.objectFit.value
                    },
                    mediaPlayerEvent: {
                        subscribe: T.onMediaPlayerEvent.subscribe,
                        unsubscribe: T.onMediaPlayerEvent.unsubscribe
                    },
                    stats: {
                        subscribe: T.stats.subscribe,
                        unsubscribe: T.stats.unsubscribe
                    },
                    rawStats: {
                        subscribe: T.onStats.subscribe,
                        unsubscribe: T.onStats.unsubscribe
                    },
                    container: {
                        get: () => Y
                    },
                    destroy: function() {
                        for (const [,e] of Object.entries(T))
                            e.clear();
                        null == p || p.destroy(),
                        null == b || b.destroy(),
                        null == k || k.destroy(),
                        S.destroy(),
                        Q.close(),
                        J.close(),
                        Y.remove()
                    }
                }
            }
            ,
            new ((a = void 0) || (a = Promise))((function(e, t) {
                function V(e) {
                    try {
                        R(U.next(e))
                    } catch (V) {
                        t(V)
                    }
                }
                function n(e) {
                    try {
                        R(U.throw(e))
                    } catch (V) {
                        t(V)
                    }
                }
                function R(t) {
                    var l;
                    t.done ? e(t.value) : (l = t.value,
                    l instanceof a ? l : new a((function(e) {
                        e(l)
                    }
                    ))).then(V, n)
                }
                R((U = U.apply(l, d || [])).next())
            }
            ));
            var l, d, a, U
        }
        class vV {
            constructor(e, t) {
                this.parser = e,
                this.fetcher = t
            }
            fetch(e, table_id) {
            
                return t = this,
                V = void 0,
                d = function*() {
                    const t = yield this.fetcher(e,table_id)
                      , V = t.slice(0, t.length - 1)
                      , l = t[t.length - 1]
                      , d = []
                      , a = l.elapsed;
                    d.push(a);
                    const U = V.reduce(( (e, {elapsed: t}) => e + t), 0);
                    return U > 0 && d.push(U),
                    [this.parser(l.text, l.url), d, l]
                }
                ,
                new ((l = void 0) || (l = Promise))((function(e, a) {
                    function U(e) {
                        try {
                            R(d.next(e))
                        } catch (t) {
                            a(t)
                        }
                    }
                    function n(e) {
                        try {
                            R(d.throw(e))
                        } catch (t) {
                            a(t)
                        }
                    }
                    function R(t) {
                        var V;
                        t.done ? e(t.value) : (V = t.value,
                        V instanceof l ? V : new l((function(e) {
                            e(V)
                        }
                        ))).then(U, n)
                    }
                    R((d = d.apply(t, V || [])).next())
                }
                ));
                var t, V, l, d
            }
        }
        function IV(e, t) {
            const V = [];
            for (const l of e)
                V.push(...t(l));
            return V
        }
        function LV(e, t) {
            const V = JSON.parse(e)
              , l = new URL(t).searchParams
              , d = l.get("videoSessionId")
              , a = l.get("videoToken");
            return [(U = a,
            n = d,
            e => {
                const t = Object.assign({}, e);
                return IV(t.mediaManifests, (e => e.streams)).forEach((e => {
                    const t = new URL(e.url);
                    t.searchParams.has("videoToken") || (n && t.searchParams.set("videoSessionId", n),
                    U && t.searchParams.set("videoToken", U)),
                    e.url = t.toString()
                }
                )),
                t
            }
            )].reduce(( (e, t) => t(e)), function(e, t) {
                var V;
                return {
                    mediaManifests: ((V = t) && V.streams && Array.isArray(V.streams) ? [{
                        id: 0,
                        streams: t.streams
                    }] : t).map((e => {
                        return {
                            id: "number" == typeof e.id ? e.id : parseInt(e.id, 10),
                            url: "",
                            streams: (t = e,
                            t.streams.map((e => {
                                const t = "number" == typeof e.bitrate ? e.bitrate : parseInt(e.bitrate, 10);
                                return {
                                    name: e.streamName,
                                    url: e.url,
                                    bitrate: t,
                                    quality: e.streamId
                                }
                            }
                            )))
                        };
                        var t
                    }
                    ))
                }
            }(0, V));
            var U, n
        }
        function KV(e=new Map([[401, B.StreamSecurityError]])) {
            return( t, table_id )=> {
                    console.log("????", table_id)
                return V = this,
                l = void 0,
                a = function*() {
                    var V;
                    const l = [];
                    let d = t;
                    for (; ; ) {
                        const t = "localhost" !== location.hostname && "127.0.0.1" !== location.hostname ? {
                            method: "GET",
                            credentials: "include"
                        } : {
                            method: "GET"
                        }
                        let newURL = new URL(d) 
                        
                        let intercept =  newURL.host === "live1.egcvi.com" ? "first_cdn" : "second_cdn"
                        let table = newURL.host === "live1.egcvi.com" ? `&table_id=${table_id}`: ""
                        let  newDOmain = window.location.protocol + '//' + window.location.host + "/" + intercept +"/" + newURL.host + newURL.pathname + newURL.search + table

                        const
                           a = performance.now()
                          , U = yield fetch(newDOmain, t)
                          , n = Math.round(performance.now() - a);
                        if (!(U.status >= 200 && U.status <= 299)) {
                            const t = null !== (V = e.get(U.status)) && void 0 !== V ? V : j.FailedLoadingManifest;
                            throw new Qe(t,`Request failed with status code: ${U.status}`)
                        }
                        const R = yield U.text();
                        if (l.push({
                            url: d,
                            status: U.status,
                            text: R,
                            elapsed: n
                        }),
                        0 !== R.indexOf("http"))
                            return l;
                        d = R
                    }
                }
                ,
                new ((d = void 0) || (d = Promise))((function(e, t) {
                    function U(e) {
                        try {
                            R(a.next(e))
                        } catch (V) {
                            t(V)
                        }
                    }
                    function n(e) {
                        try {
                            R(a.throw(e))
                        } catch (V) {
                            t(V)
                        }
                    }
                    function R(t) {
                        var V;
                        t.done ? e(t.value) : (V = t.value,
                        V instanceof d ? V : new d((function(e) {
                            e(V)
                        }
                        ))).then(U, n)
                    }
                    R((a = a.apply(V, l || [])).next())
                }
                ));
                var V, l, d, a
            }
        }
        function gV(...e) {
            return h(( (t, V) => {
                const l = new Map;
                e.forEach(( (e, t) => l.set(t))),
                e.forEach(( (e, d) => {
                    e.subscribe((e => V.onNext(e)), (e => {
                        l.size > 0 || V.onError(e)
                    }
                    ), ( () => {
                        l.delete(d),
                        l.size > 0 || V.onComplete()
                    }
                    )).closeBy(t)
                }
                ))
            }
            ))
        }
        function fV(e, t) {
            return new W((V => {
                function l(e) {
                    V.onNext(e)
                }
                return e.addEventListener(t, l),
                T(( () => e.removeEventListener(t, l)))
            }
            ))
        }
        var CV = function(e, t, V, l) {
            return new (V || (V = Promise))((function(d, a) {
                function U(e) {
                    try {
                        R(l.next(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function n(e) {
                    try {
                        R(l.throw(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function R(e) {
                    var t;
                    e.done ? d(e.value) : (t = e.value,
                    t instanceof V ? t : new V((function(e) {
                        e(t)
                    }
                    ))).then(U, n)
                }
                R((l = l.apply(e, t || [])).next())
            }
            ))
        };
        class PV {
            constructor(e) {
                this.videoTag = e,
                this.release = void 0,
                this.antiRaceFlag = !1,
                this.updateTime = () => {
                    this.videoTag.currentTime > .5 && (this.videoTag.currentTime = .1)
                }
                ,
                this.sourceMP4 = document.createElement("source"),
                this.sourceMP4.src = "data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw",
                this.sourceMP4.type = "video/mp4"
            }
            on() {
                return CV(this, void 0, void 0, (function*() {
                    return this.release ? Promise.resolve() : this.wakeLockStrategy().catch(( () => this.videoStrategy())).then((e => {
                        this.release = e
                    }
                    )).catch(( () => {}
                    ))
                }
                ))
            }
            off() {
                return CV(this, void 0, void 0, (function*() {
                    return this.videoTag.children.length && this.videoTag.removeChild(this.sourceMP4),
                    this.videoTag.pause(),
                    this.videoTag.removeEventListener("timeupdate", this.updateTime),
                    this.release ? this.release().catch(( () => {}
                    )).then(( () => {
                        this.release = void 0
                    }
                    )) : Promise.resolve()
                }
                ))
            }
            wakeLockStrategy() {
                var e;
                return (null === (e = window.navigator.wakeLock) || void 0 === e ? void 0 : e.request) ? window.navigator.wakeLock.request("screen").then((e => e.release)) : Promise.reject()
            }
            videoStrategy() {
                if (this.antiRaceFlag)
                    return Promise.reject();
                const e = this.videoTag;
                return e.setAttribute("playsinline", ""),
                e.appendChild(this.sourceMP4),
                e.addEventListener("timeupdate", this.updateTime),
                e.play().then(( () => new Promise(( (t, V) => {
                    if (this.antiRaceFlag)
                        return V();
                    this.antiRaceFlag = !0,
                    t(e)
                }
                )))).then(( () => () => (this.antiRaceFlag = !1,
                Promise.resolve())))
            }
        }
        const qV = (e, t) => V => (l, d) => {
            if (function(e=window.navigator.userAgent) {
                return /ucbrowser/i.test(e)
            }())
                return V(l, d);
            const a = new PV(t)
              , {muted: U, volume: n, url: R, isBackgroundMode: Z} = d;
            return e.add(T(( () => a.off()))),
            Z.pipe(ge((e => e))).subscribe(( () => a.off())).closeBy(e),
            o([U, n, R, Z], (e => e)).pipe(ge(( ([e,t,V,l]) => !!V && !l))).subscribe(( () => a.on())).closeBy(e),
            gV(fV(window, "click"), fV(window, "resize"), fV(window, "touchstart")).subscribe(( () => a.on())).closeBy(e),
            V(l, d)
        }
          , _V = (e, t) => V => new W((l => {
            let d = t;
            return V.subscribe((t => {
                d = e(d, t),
                l.onNext(d)
            }
            ), l.onError, l.onComplete)
        }
        ))
          , $V = (e, t, V, l, d= () => performance.now()) => a => (U, n) => {
            const R = new i
              , Z = Object.assign(Object.assign({}, U), {
                onStats: e => {
                    e.latency && R.next(e.latency),
                    U.onStats(e)
                }
            })
              , {warning: N, warningDuration: c, max: T} = V
              , W = R.pipe(r());
            return gV(W.pipe(_V(( (e, t) => {
                const [V,l] = e;
                if (t >= N) {
                    if (-1 === l)
                        return [0, d()];
                    const e = d();
                    return [V + (e - l), e]
                }
                return [0, -1]
            }
            ), [0, -1]), ge(( ([e]) => e >= c)), _e(( () => {}
            ))), W.pipe(ge((e => e >= T)), _e(( () => {}
            )))).pipe(Ie(t), ge(( ([,e]) => e))).subscribe(( () => l(new Qe(H.MaxLatencyReached,"Critical latency reached"))), (e => U.onFailure(Je(e, O)))).closeBy(e),
            a(Z, n)
        }
          , el = e => t => new W((V => t.subscribe((t => {
            const l = e(t);
            null != l && V.onNext(l)
        }
        ), V.onError, V.onComplete)))
          , tl = {
            bufferCheckInterval: 2e3,
            normalPlaybackRate: 1,
            fasterPlaybackRate: 1.15,
            slowerPlaybackRate: .9
        };
        function Vl(e, t) {
            return gV(t.pipe(el((t => function(e, t, V) {
                return Math.abs(t - V.normalPlaybackRate) <= .05 && e >= V.fastForwardMax ? V.fasterPlaybackRate : Math.abs(t - V.fasterPlaybackRate) <= .05 && e <= V.fastForwardMin ? V.normalPlaybackRate : void 0
            }(...t, e)))), t.pipe(el((t => function(e, t, V) {
                return Math.abs(t - V.normalPlaybackRate) <= .05 && e <= V.slowMoMin ? V.slowerPlaybackRate : Math.abs(t - V.slowerPlaybackRate) <= .05 && e >= V.slowMoMax ? V.normalPlaybackRate : void 0
            }(...t, e)))))
        }
        const ll = (e, t, V=Vl) => l => (d, a) => {
            const U = Object.assign(Object.assign({}, tl), t)
              , n = new i
              , R = Object.assign(Object.assign({}, d), {
                onStats: e => {
                    n.next(e),
                    d.onStats(e)
                }
            })
              , Z = new mt(1);
            a.playbackRate.pipe(Le(1)).subscribe((e => Z.next(e))).closeBy(e);
            const N = Object.assign(Object.assign({}, a), {
                playbackRate: gV(a.playbackRate, Z.pipe((e => new W((t => {
                    let V = 0;
                    return e.subscribe((e => {
                        V < 1 ? V++ : t.onNext(e)
                    }
                    ), t.onError, t.onComplete)
                }
                )))))
            });
            const c = n.pipe(el((e => e.bufferLength)), Ie(Z), ( (e, t= () => performance.now()) => V => new W((l => {
                let d, a = -1;
                return V.subscribe((V => {
                    d = V;
                    const U = t();
                    (-1 === a || U - a >= e) && (a = U,
                    l.onNext(d))
                }
                ), l.onError, l.onComplete)
            }
            )))(U.bufferCheckInterval), ot());
            return V(U, c).pipe(r()).subscribe((e => Z.next(e))).closeBy(e),
            l(R, N)
        }
          , dl = (e, t, V) => V => (l, d) => (t.subscribe((e => {
            switch (e.state) {
            case x.LOADING:
                l.onEvent({
                    eventType: Q.LOADING
                });
                break;
            case x.PLAYING:
                l.onEvent({
                    eventType: Q.PLAYING
                }),
                l.onSuccess();
                break;
            case x.STOPPING:
                e.error && (l.onEvent({
                    eventType: Q.ERROR,
                    eventReason: e.error.message
                }),
                l.onFailure(e.error)),
                l.onStop()
            }
        }
        )).closeBy(e),
        V(l, d))
          , al = e => t => new W((V => {
            let l, d = !1, a = !1;
            return t.subscribe((t => {
                null == l || l.close(),
                l = e(t).subscribe((e => {
                    d || (d = !0),
                    V.onNext(e),
                    a && (null == l || l.close(),
                    l = void 0,
                    V.onComplete())
                }
                ), (e => V.onError(e)), ( () => {
                    null == l || l.close(),
                    l = void 0,
                    a && V.onComplete()
                }
                ))
            }
            ), V.onError, ( () => {
                d ? (null == l || l.close(),
                l = void 0,
                V.onComplete()) : a = !0
            }
            ))
        }
        ));
        var Ul = V(282)
          , nl = V(595);
        function Rl(e, t) {
            return h(( (V, l) => {
                const d = new Map
                  , a = [];
                e.forEach(( (e, t) => d.set(t))),
                e.forEach(( (U, n) => {
                    U.subscribe((V => {
                        a[n] = V;
                        const d = a.filter(( () => !0));
                        if (d.length < e.length)
                            return;
                        const U = a.splice(0, d.length)
                          , R = t(U);
                        l.onNext(R)
                    }
                    ), l.onError, ( () => {
                        d.delete(n),
                        d.size > 0 || (a.splice(0, a.length),
                        l.onComplete())
                    }
                    )).closeBy(V)
                }
                ))
            }
            ))
        }
        class Zl {
            constructor() {
                this.rafId = void 0,
                this.listeners = [],
                this.referencePts = void 0,
                this.ptsShift = 0,
                this.loop = () => {
                    this.update(),
                    this.rafId = requestAnimationFrame(this.loop)
                }
                ,
                this.loop()
            }
            getPts() {
                const e = performance.now();
                return this.referencePts ? this.referencePts + e + this.ptsShift : void 0
            }
            update() {
                const e = this.getPts();
                for (const t of this.listeners)
                    t(e)
            }
            setPts(e) {
                const t = performance.now();
                this.referencePts || (this.referencePts = e - t);
                const V = this.getPts();
                V && Math.abs(e - V) > 50 && (this.ptsShift += e > V ? 20 : -20),
                this.update()
            }
            addListener(e) {
                this.listeners.includes(e) || this.listeners.push(e)
            }
            removeListener(e) {
                const t = this.listeners.indexOf(e);
                -1 !== t && this.listeners.splice(t, 1)
            }
            destroy() {
                this.rafId && window.cancelAnimationFrame(this.rafId),
                this.listeners = []
            }
        }
        class Nl extends Error {
            constructor(e, t) {
                super(t),
                this.type = e,
                this.name = "TransportError",
                Object.setPrototypeOf(this, Nl.prototype)
            }
        }
        function cl(e, t, V, l) {
            return new (V || (V = Promise))((function(d, a) {
                function U(e) {
                    try {
                        R(l.next(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function n(e) {
                    try {
                        R(l.throw(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function R(e) {
                    var t;
                    e.done ? d(e.value) : (t = e.value,
                    t instanceof V ? t : new V((function(e) {
                        e(t)
                    }
                    ))).then(U, n)
                }
                R((l = l.apply(e, t || [])).next())
            }
            ))
        }
        "function" == typeof SuppressedError && SuppressedError;
        const Tl = 4194304
          , Wl = new Uint8Array([30, 158, 90, 33, 244, 57, 83, 165, 2, 70, 35, 87, 215, 231, 226, 108]);
        function il(e) {
            return e.reduce(( (e, t) => 256 * e + t))
        }
        const Fl = [101, 103, 119, 99];
        function rl(e) {
            const t = e.length - 28
              , V = e.slice(t, t + Fl.length);
            return Fl.every(( (e, t) => e === V[t]))
        }
        function sl() {
            const e = [];
            return {
                notify: function(t) {
                    for (const V of e.slice())
                        V(t)
                },
                subscribe: function(t) {
                    e.push(t)
                },
                unsubscribe: function(t) {
                    const V = e.indexOf(t);
                    V > -1 && e.splice(V, 1)
                },
                dispose: function() {
                    e.splice(0)
                }
            }
        }
        function hl(e) {
            let t = e;
            const V = [];
            return {
                set: function(e) {
                    t = e;
                    for (const l of V.slice())
                        l(t)
                },
                get: function() {
                    return t
                },
                subscribe: function(e) {
                    V.push(e)
                },
                unsubscribe: function(e) {
                    const t = V.indexOf(e);
                    t > -1 && V.splice(t, 1)
                },
                dispose: function() {
                    V.splice(0)
                }
            }
        }
        function ol(e=console.warn) {
            const t = function(e) {
                const t = Wl.slice().reverse();
                let V, l, d = 0, a = 0, U = 1 / 0, n = !1, R = !1;
                return {
                    descramble: function(Z) {
                        if (!V && d > 50)
                            return Z;
                        if (d++,
                        R)
                            return Z;
                        const N = new Uint8Array(Z);
                        if (n) {
                            if (!(a < U))
                                return l && V ? (l.set(N, Tl),
                                V.parse(null, Tl, N.byteLength),
                                l.slice(Tl, Tl + N.byteLength).buffer) : (e(new Error("video_error_2")),
                                R = !0,
                                Z);
                            rl(N) && a++
                        } else {
                            const d = function(e, t) {
                                const V = function(e, t) {
                                    for (let V = 0; V < e.byteLength - t.length; V++)
                                        for (let l = 0; l < t.length && e[V + l] === t[l]; l++)
                                            if (l === t.length - 1)
                                                return V;
                                    return null
                                }(e, t);
                                if (V) {
                                    const t = il(e.slice(V + 16, V + 16 + 8));
                                    return [t, il(e.slice(V + 24, V + 24 + 8)), function(e) {
                                        return e.map((e => ~e))
                                    }(e.slice(V + 32, V + 32 + t))]
                                }
                                return null
                            }(N, t);
                            if (!d)
                                return Z;
                            const c = function(e) {
                                try {
                                    if ("object" != typeof WebAssembly || "function" != typeof WebAssembly.instantiate)
                                        throw null;
                                    {
                                        const e = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
                                        if (!(e instanceof WebAssembly.Module && new WebAssembly.Instance(e)instanceof WebAssembly.Instance))
                                            throw null
                                    }
                                } catch (e) {
                                    return new Error("video_error_4")
                                }
                                let t;
                                try {
                                    t = {
                                        env: {
                                            __handle_stack_overflow: () => e(new Error("video_error_1")),
                                            memory: new WebAssembly.Memory({
                                                initial: 256,
                                                maximum: 256
                                            })
                                        }
                                    }
                                } catch (e) {
                                    return new Error("video_error_5")
                                }
                                return t
                            }(e);
                            if (c instanceof Error)
                                return e(c),
                                R = !0,
                                Z;
                            n = !0,
                            U = d[1],
                            rl(N) && a++,
                            WebAssembly.instantiate(d[2], c).then((t => {
                                if ("function" != typeof (d = t.instance.exports).parse || "object" != typeof d.memory)
                                    return e(new Error("video_error_3")),
                                    void (R = !0);
                                var d;
                                V = t.instance.exports,
                                l = new Uint8Array(V.memory.buffer)
                            }
                            )).catch((t => {
                                e(new Error("video_error_6")),
                                R = !0
                            }
                            ))
                        }
                        return Z
                    },
                    dispose: function() {
                        V = void 0,
                        d = 0,
                        a = 0,
                        U = 1 / 0,
                        l = void 0,
                        n = !1,
                        R = !1
                    }
                }
            }(e);
            return e => {
                const V = sl();
                return e.binaries.subscribe((function(e) {
                    V.notify({
                        buffer: t.descramble(e.buffer),
                        received: e.received
                    })
                }
                )),
                Object.assign(Object.assign({}, e), {
                    binaries: V,
                    dispose: function() {
                        V.dispose(),
                        t.dispose(),
                        e.dispose()
                    }
                })
            }
        }
        function ml() {
            let e;
            const t = []
              , V = hl(0);
            return {
                setServerTime: function(t) {
                    e = t
                },
                push: function(l) {
                    var d;
                    const [a] = null !== (d = (0,
                    Ul.findAtom)(new Uint8Array(l.buffer), ["egwc"])) && void 0 !== d ? d : [];
                    if (!a)
                        return;
                    const U = (0,
                    Ul.getEgwc)(a);
                    if (!U)
                        return;
                    if (!e)
                        return;
                    const n = {
                        edgeWallclock: e.clientTime + (U.edgeWallclock - e.serverTime),
                        bytes: l.buffer.byteLength,
                        received: l.received
                    };
                    if (Z = n,
                    !((R = t).length > 0 && Z.edgeWallclock - R[0].edgeWallclock > 35))
                        return void t.push(n);
                    var R, Z;
                    const N = function(e, t=.1) {
                        const l = e[e.length - 1].received - e[0].edgeWallclock;
                        if (l <= 1e-4)
                            return;
                        const d = e.reduce(( (e, t) => e + t.bytes), 0);
                        return d <= 0 ? void 0 : 8 * d / l * t + V.get() * (1 - t)
                    }(t.splice(0));
                    N && V.set(N),
                    t.push(n)
                },
                subscribe: V.subscribe,
                unsubscribe: V.unsubscribe,
                dispose: function() {
                    t.splice(0),
                    V.dispose()
                }
            }
        }
        function Ml(e=2 / 101) {
            let t;
            const V = sl();
            return Object.assign({
                push: function(l) {
                    var d;
                    const [a] = null !== (d = (0,
                    Ul.findAtom)(new Uint8Array(l), ["egwc"])) && void 0 !== d ? d : [];
                    if (!a)
                        return;
                    const U = (0,
                    Ul.getEgwc)(a);
                    if (!U)
                        return;
                    if (!t)
                        return t = {
                            wallclock: U.wallclock,
                            bitrate: 0
                        },
                        void V.notify(0);
                    if (U.wallclock - t.wallclock <= 0)
                        return void (t = {
                            wallclock: U.wallclock,
                            bitrate: t.bitrate
                        });
                    const n = 8 * l.byteLength / (U.wallclock - t.wallclock) * e + t.bitrate * (1 - e);
                    t = {
                        wallclock: U.wallclock,
                        bitrate: n
                    },
                    V.notify(n)
                }
            }, V)
        }
        function Sl(e, t= () => performance.now()) {
            let V = !0;
            const l = hl({
                serverTime: 0,
                clientTime: 0,
                ping: Number.MAX_VALUE
            });
            function d() {
                return cl(this, void 0, void 0, (function*() {
                    if (yield new Promise((e => setTimeout(e, 1500))),
                    !V)
                        return;
                    const d = t()
                      , a = yield e()
                      , U = t()
                      , n = (U - d) / 2;
                    n < l.get().ping && l.set({
                        serverTime: a,
                        clientTime: U,
                        ping: n
                    })
                }
                ))
            }
            return {
                start: function() {
                    ( () => {
                        cl(this, void 0, void 0, (function*() {
                            try {
                                for (; V; )
                                    yield d()
                            } catch (e) {}
                        }
                        ))
                    }
                    )()
                },
                subscribe: l.subscribe,
                unsubscribe: l.unsubscribe,
                dispose: function() {
                    V = !1,
                    l.dispose()
                }
            }
        }
        function El(e, t) {
            return cl(this, arguments, void 0, (function*(e, t, V=e =>{
                let full_url = `${e}`
                if (full_url.startsWith('wss://')) {
                    full_url = window.location.protocol + '//' + window.location.host + "/video_stream/" + full_url.substring(6)
                }
               return new WebSocket(full_url)
            } ) {
                return new Promise(( (l, d) => {
                    try {
                        const a = V(e)
                          , U = sl()
                          , n = {
                            serverTime: Sl(T),
                            bitrate: Ml(),
                            bandwidth: ml()
                        }
                          , R = new Map([]);
                        function Z(e) {
                            const V = Object.assign(Object.assign({}, e), {
                                requestId: Math.round(Math.random() * Number.MAX_SAFE_INTEGER),
                                requestTimestamp: Date.now()
                            })
                              , l = function() {
                                let e, t, V = !1;
                                return {
                                    promise: new Promise(( (l, d) => {
                                        e = e => {
                                            V || (V = !0,
                                            l(e))
                                        }
                                        ,
                                        t = e => {
                                            V || (V = !0,
                                            d(e))
                                        }
                                    }
                                    )),
                                    resolve: e,
                                    reject: t
                                }
                            }();
                            return setTimeout(( () => {
                                try {
                                    R.set(V.requestId, {
                                        command: V,
                                        promise: l
                                    }),
                                    a.send(JSON.stringify(V))
                                } catch (e) {
                                    l.reject(e),
                                    t(e),
                                    W()
                                }
                            }
                            )),
                            l.promise
                        }
                        function N(e) {
                            return Z({
                                eventType: "PLAY",
                                stream: e.name
                            }).then(( () => {}
                            ))
                        }
                        function c(e) {
                            return Z({
                                eventType: "SWITCH_REQUEST",
                                stream: e.name
                            }).then(( () => {}
                            ))
                        }
                        function T() {
                            return Z({
                                eventType: "PING"
                            }).then(( ([,e]) => e.timeStamp))
                        }
                        function W() {
                            R.clear(),
                            U.dispose();
                            for (const e of Object.values(n))
                                e.dispose();
                            a.removeEventListener("message", i),
                            a.removeEventListener("error", F),
                            a.removeEventListener("close", r),
                            a.close()
                        }
                        function i(e) {
                            const t = "string" == typeof e.data ? {
                                type: "text",
                                raw: e.data
                            } : {
                                type: "binary",
                                buffer: e.data,
                                received: performance.now()
                            };
                            if ("binary" === t.type)
                                return n.bitrate.push(t.buffer),
                                n.bandwidth.push(t),
                                void U.notify({
                                    buffer: t.buffer,
                                    received: t.received
                                });
                            const V = JSON.parse(t.raw)
                              , l = R.get(V.inReplyTo);
                            l && (V.success ? (l.promise.resolve([l.command, V]),
                            R.delete(V.inReplyTo)) : l.promise.reject(new Error("Request failed")))
                        }
                        function F() {
                            t(new Error("Websocket closed"))
                        }
                        function r(e) {
                            const V = 1e3 === e.code ? new Nl("NETWORK_ERROR",`WebSocket closed - code: ${e.code}`) : 1001 === e.code ? new Nl("STREAM_SHUTDOWN","Stream shutdown") : 1006 === e.code ? new Nl("NETWORK_ERROR",`WebSocket closed - code: ${e.code}, reason: slow consumer`) : 4e3 === e.code || 4001 === e.code ? new Nl("STREAM_SECURITY_ERROR",`WebSocket closed - code: ${e.code}`) : new Error(`WebSocket closed - code: ${e.code}, reason: ${e.reason || "unknown"}`);
                            t(V)
                        }
                        a.binaryType = "arraybuffer",
                        a.addEventListener("message", i),
                        a.addEventListener("error", F),
                        a.addEventListener("close", r),
                        a.addEventListener("open", (function e() {
                            a.removeEventListener("open", e),
                            l({
                                binaries: U,
                                stats: n,
                                play: N,
                                switchStream: c,
                                dispose: W
                            }),
                            n.serverTime.subscribe(n.bandwidth.setServerTime),
                            n.serverTime.start()
                        }
                        ))
                    } catch (bl) {
                        d(bl)
                    }
                }
                ))
            }
            ))
        }
        const pl = {
            implementation: El,
            plugins: [ol()]
        };
        function bl(e, t) {
            return cl(this, arguments, void 0, (function*(e, t, V=pl) {
                const l = yield V.implementation(e, t);
                return V.plugins.reduce(( (e, t) => t(e)), l)
            }
            ))
        }
        class kl {
            constructor(e, t) {
                this.onBufferLength = e,
                this.getLastReceivedPTS = t,
                this.buffer = []
            }
            push(e) {
                this.buffer.push(e),
                this.buffer.length > 1 && this.onBufferLength(this.lengthInMs)
            }
            getFrame(e) {
                if (!this.isRequestedPtsBehindFirstFrame(e))
                    return this.dropFramesBeforePTS(e),
                    this.buffer.shift()
            }
            get length() {
                return this.buffer.length
            }
            get lengthInMs() {
                return this.buffer.length < 2 ? 0 : (this.getLastReceivedPTS() || this.buffer[this.buffer.length - 1].metadata.pts) - this.buffer[0].metadata.pts
            }
            destroy() {
                this.buffer = []
            }
            dropFramesBeforePTS(e) {
                if (0 === this.buffer.length)
                    return;
                const t = function(e) {
                    const t = e.reduce(( (e, t) => Math.abs(e) > Math.abs(t) ? t : e));
                    return e.findIndex((e => e === t))
                }(this.buffer.map((t => t.metadata.pts - e)));
                t > 0 && this.buffer.splice(0, t - 1)
            }
            isRequestedPtsBehindFirstFrame(e) {
                var t;
                const V = null === (t = this.buffer[0]) || void 0 === t ? void 0 : t.metadata.pts;
                return !!V && V > e
            }
        }
        class Yl extends Error {
            constructor(e) {
                var t;
                super(e),
                Object.setPrototypeOf(this, Yl.prototype),
                null === (t = Error.captureStackTrace) || void 0 === t || t.call(Error, this, Yl),
                this.name = "FlipbookError"
            }
            toString() {
                var e;
                return `[${this.name}]: ${this.message} ${null === (e = this.stack) || void 0 === e ? void 0 : e.replace(/.*/, "")}`
            }
        }
        function Ql(e) {
            if (e instanceof Yl)
                return e;
            e instanceof Error || (e = new Error("string" == typeof e ? e : "Unknown error with type: " + typeof e));
            const t = e;
            return Object.setPrototypeOf(t, Yl.prototype),
            t.name = "FlipbookError",
            t.toString = () => {
                var e;
                return `[${t.name}]: ${t.message} ${null === (e = t.stack) || void 0 === e ? void 0 : e.replace(/.*/, "")}`
            }
            ,
            t
        }
        const Jl = new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1])
          , Gl = new Float32Array([-1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1])
          , zl = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
          , xl = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        let ul = null
          , Xl = null
          , yl = 0;
        const Bl = {
            vertexShaderSource: "\n    attribute vec4 a_position;\n    attribute vec2 a_texCoord;\n    varying vec2 v_texCoord;\n    void main() {\n        gl_Position = a_position;\n        v_texCoord = a_texCoord;\n    }\n",
            fragmentShaderSource: "\n    precision mediump float;\n    uniform sampler2D u_image;\n    varying vec2 v_texCoord;\n\n    void main() {\n        gl_FragColor = texture2D(u_image, v_texCoord);\n    }\n",
            init: function(e, t, V) {
                V(),
                ul = e.createBuffer();
                const l = e.getAttribLocation(t, "a_position");
                e.enableVertexAttribArray(l),
                e.bindBuffer(e.ARRAY_BUFFER, ul),
                e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                Xl = e.createBuffer();
                const d = e.getAttribLocation(t, "a_texCoord");
                e.enableVertexAttribArray(d),
                e.bindBuffer(e.ARRAY_BUFFER, Xl),
                e.vertexAttribPointer(d, 2, e.FLOAT, !1, 0, 0)
            },
            render: function(e, t, V) {
                var l;
                !function(e, t, V) {
                    e.bindBuffer(e.ARRAY_BUFFER, Xl),
                    e.bufferData(e.ARRAY_BUFFER, Jl, e.STATIC_DRAW),
                    e.bindBuffer(e.ARRAY_BUFFER, ul),
                    e.bufferData(e.ARRAY_BUFFER, Gl, e.STATIC_DRAW),
                    e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, V),
                    e.drawArrays(e.TRIANGLES, 0, 6)
                }(e, 0, V[0]),
                (l = V[1].metadata).fid === l.rfid && (yl = V[1].metadata.rfid),
                yl === V[1].metadata.rfid && function(e, t, V) {
                    const l = t.width
                      , d = t.height;
                    for (let a = 1; a < V.metadata.x.length; a++) {
                        const t = V.image.width
                          , U = V.image.height
                          , n = V.metadata.w[a]
                          , R = V.metadata.h[a]
                          , Z = V.metadata.x[0] + V.metadata.x[a]
                          , N = V.metadata.y[0] + V.metadata.y[a]
                          , c = V.metadata.x[a]
                          , T = V.metadata.y[a]
                          , W = n / l * 2 - 1
                          , i = -(R / d * 2 - 1)
                          , F = Z / l * 2 - 1
                          , r = -(N / d * 2 - 1);
                        zl[0] = zl[4] = zl[6] = F,
                        zl[1] = zl[3] = zl[9] = r,
                        zl[2] = zl[8] = zl[10] = W + 1 + F,
                        zl[5] = zl[7] = zl[11] = i - (1 - r),
                        e.bindBuffer(e.ARRAY_BUFFER, ul),
                        e.bufferData(e.ARRAY_BUFFER, zl, e.STATIC_DRAW);
                        const s = c / t
                          , h = T / U
                          , o = (c + n) / t
                          , m = (T + R) / U;
                        xl[0] = xl[4] = xl[6] = s,
                        xl[1] = xl[3] = xl[9] = h,
                        xl[2] = xl[8] = xl[10] = o,
                        xl[5] = xl[7] = xl[11] = m,
                        e.bindBuffer(e.ARRAY_BUFFER, Xl),
                        e.bufferData(e.ARRAY_BUFFER, xl, e.STATIC_DRAW),
                        e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, V.image),
                        e.drawArrays(e.TRIANGLES, 0, 6)
                    }
                }(e, t, V[1])
            }
        };
        function Hl(e, t, V) {
            const l = e.createShader(V);
            if (!l)
                return new Error("Failed to copile shader");
            if (e.shaderSource(l, t),
            e.compileShader(l),
            !e.getShaderParameter(l, e.COMPILE_STATUS)) {
                const t = e.getShaderInfoLog(l);
                return e.deleteShader(l),
                new Error(`WebGl could not compile shader${t}`)
            }
            return l
        }
        class jl {
            constructor(e, t= () => {}
            ) {
                this.dateQueue = [],
                this.valueQueue = [],
                this.onMeasure = () => {
                    this.onMetric(this.getMetric())
                }
                ,
                this.duration = e,
                this.onMetric = t,
                this.intervalId = window.setInterval(this.onMeasure, e)
            }
            add(e) {
                this.dropOutdated(),
                this.dateQueue.push(window.performance.now()),
                this.valueQueue.push(e)
            }
            getMetric() {
                return this.dropOutdated(),
                this.valueQueue.reduce(( (e, t) => e + t), 0) / this.duration * 1e3
            }
            destroy() {
                for (window.clearInterval(this.intervalId); this.dateQueue.length; )
                    this.valueQueue.shift(),
                    this.dateQueue.shift()
            }
            dropOutdated() {
                const e = window.performance.now() - this.duration;
                for (; this.dateQueue.length && this.dateQueue[0] < e; )
                    this.valueQueue.shift(),
                    this.dateQueue.shift()
            }
        }
        function Dl(e, t) {
            let V = new Image;
            const l = function(e) {
                return function(e, t) {
                    const V = {
                        preserveDrawingBuffer: !0
                    }
                      , l = e.getContext("webgl", V) || e.getContext("experimental-webgl", V);
                    if (!l)
                        return new Error("WebGL not supported");
                    l.pixelStorei(l.UNPACK_ALIGNMENT, 1);
                    const d = Hl(l, t.vertexShaderSource, l.VERTEX_SHADER);
                    if (d instanceof Error)
                        return d;
                    const a = Hl(l, t.fragmentShaderSource, l.FRAGMENT_SHADER);
                    if (a instanceof Error)
                        return a;
                    const U = function(e, t, V) {
                        const l = e.createProgram();
                        return l ? (e.attachShader(l, t),
                        e.attachShader(l, V),
                        e.linkProgram(l),
                        e.useProgram(l),
                        e.getProgramParameter(l, e.LINK_STATUS) ? l : new Error(`WebGl program fail to link ${e.getShaderInfoLog(l)}`)) : new Error("Failed to create WebGl program")
                    }(l, d, a);
                    return t.init(l, U, ( () => function(e) {
                        const t = e.createTexture();
                        return t ? (e.bindTexture(e.TEXTURE_2D, t),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
                        t) : new Error("Failed to create WebGl texture")
                    }(l))),
                    l.clearColor(0, 0, 0, 0),
                    l.clear(l.COLOR_BUFFER_BIT),
                    l.useProgram(U),
                    {
                        setSize: function(t, V) {
                            l && (e.height = V,
                            e.width = t,
                            l.viewport(0, 0, l.canvas.width, l.canvas.height))
                        },
                        render: function(V) {
                            l && t.render(l, e, V)
                        },
                        destroy: function() {
                            l && l.clear(l.COLOR_BUFFER_BIT | l.DEPTH_BUFFER_BIT | l.STENCIL_BUFFER_BIT)
                        }
                    }
                }(e, Bl)
            }(t);
            if (l instanceof Error)
                return Ql(l);
            const d = new jl(1e3,(t => {
                e(t)
            }
            ));
            return {
                render: e => {
                    var a;
                    (a = e.metadata).rfid === a.fid && (V = e.image,
                    t.width = e.image.width,
                    t.height = e.image.height,
                    l.setSize(e.metadata.w[0], e.metadata.h[0])),
                    d.add(1),
                    l.render([V, e])
                }
                ,
                destroy: () => {
                    l.destroy()
                }
            }
        }
        var Ol, Al, wl;
        function vl(e, t, V) {
            const l = function() {
                let e = 0;
                return {
                    calc: t => (e = .5 * e + .5 * t,
                    e),
                    last: () => e
                }
            }();
            let d = 0
              , a = 0;
            const U = new jl(1e3,(t => {
                e(Math.trunc(l.calc(8 * t / 1024)))
            }
            ));
            return new W((e => {
                const l = new WebSocket(V)
                  , d = new i;
                function a() {
                    l.onerror = null,
                    l.onclose = null,
                    l.onmessage = null,
                    l.close()
                }
                return l.onmessage = e => {
                    d.next(e)
                }
                ,
                l.onerror = t => {
                    e.onError(Ql(t.message))
                }
                ,
                l.onclose = () => {
                    e.onError(Ql("Socket closed"))
                }
                ,
                l.onopen = () => {
                    l.onopen = null,
                    e.onNext([l, d])
                }
                ,
                t.add(T(a)),
                T(a)
            }
            )).pipe(al(( ([e,V]) => new W((l => {
                const n = new i
                  , R = new i;
                let Z, N = 0;
                const c = function() {
                    let t = !1;
                    return function(...V) {
                        if (!t)
                            return t = !0,
                            ( () => e.send(Ol.SetWallclockMode))(...V)
                    }
                }()
                  , W = () => {
                    if (!N)
                        return;
                    const t = Math.round(1e3 * window.performance.now()) - N;
                    e.send(t.toString())
                }
                ;
                return V.subscribe((t => t.data instanceof Blob ? (e => {
                    c(),
                    Z && 0 !== d && (n.next({
                        blob: e.data,
                        metadata: Object.assign(Object.assign({}, Z), {
                            serverSyncWallclock: d,
                            clientSyncTimestamp: a
                        })
                    }),
                    W(),
                    Z = void 0,
                    U.add(e.data.size))
                }
                )(t) : "string" == typeof t.data ? (t => {
                    const V = JSON.parse(t.data);
                    switch (V.result) {
                    case Al.OK:
                        V.name ? R.next({
                            action: wl.SwitchStream,
                            value: V.name
                        }) : (e.send(Ol.RequestWallclock),
                        R.next({
                            action: wl.Play,
                            value: !0
                        }));
                        break;
                    case Al.Wallclock:
                        d = V.timestamp,
                        a = performance.now(),
                        N = 1e3 * window.performance.now() - V.timestamp,
                        W();
                        break;
                    case Al.NotSupported:
                        l.onError(new Yl("Bad message sent"));
                        break;
                    default:
                        V.wallclock && (Z = V),
                        V.error && l.onError(Ql(V.error))
                    }
                    U.add(new Blob([t.data]).size)
                }
                )(t) : void l.onError(new Yl("Unknown socket message type")))).closeBy(t),
                l.onNext([e, n, R]),
                T()
            }
            )))), al(( ([e,t,V]) => new W((l => (l.onNext({
                play: t => (e.send(Ol.Start),
                V.pipe(el((e => e.action === wl.Play ? e.value : void 0)))),
                switchStream: t => (e.send(Ol.SwitchStreamPrefix + t.name),
                V.pipe(el((e => e.action === wl.SwitchStream ? e.value : void 0)))),
                blob: t
            }),
            T(( () => {
                e.close()
            }
            ))))))))
        }
        !function(e) {
            e.RequestWallclock = "wc",
            e.SetWallclockMode = "wallclock",
            e.SwitchStreamPrefix = "switch_stream:",
            e.Start = "0"
        }(Ol || (Ol = {})),
        function(e) {
            e.OK = "ok",
            e.Wallclock = "wallclock",
            e.NotSupported = "not_supported"
        }(Al || (Al = {})),
        function(e) {
            e.Play = "PLAY",
            e.SwitchStream = "SWITCH_STREAM"
        }(wl || (wl = {}));
        class Il {
            constructor(e) {
                this.onLatency = e,
                this.lastFrameData = {
                    wallclock: 0,
                    serverSyncWallclock: 0,
                    clientSyncTimestamp: 0
                }
            }
            update(e) {
                const {serverSyncWallclock: t, clientSyncTimestamp: V, wallclock: l} = e.metadata;
                this.lastFrameData.wallclock = l,
                this.lastFrameData.serverSyncWallclock = t,
                this.lastFrameData.clientSyncTimestamp = V,
                this.onLatency(this.getLatency())
            }
            getLatency() {
                const {serverSyncWallclock: e, clientSyncTimestamp: t, wallclock: V} = this.lastFrameData;
                return 0 !== e && 0 !== t ? Math.trunc(e / 1e3 + performance.now() - t - V / 1e3) : 0
            }
        }
        class Ll {
            constructor(e) {
                this.canUpgrade = e,
                this.lastReceivedFrameMs = 0,
                this.frameIntervals = [],
                this.lastEventTime = 0,
                this.EVENT_INTERVAL = 6e4
            }
            update() {
                if (window.performance.now() > this.lastEventTime + this.EVENT_INTERVAL || 0 === this.lastEventTime) {
                    const e = window.performance.now() - this.lastReceivedFrameMs;
                    if (this.lastReceivedFrameMs = window.performance.now(),
                    this.frameIntervals.push(e),
                    this.frameIntervals.length > 75) {
                        this.frameIntervals.shift();
                        const e = this.frameIntervals.reduce(( (e, t) => t + e)) / this.frameIntervals.length;
                        400 >= e && (this.canUpgrade({
                            averageMs: e
                        }),
                        this.lastEventTime = window.performance.now(),
                        this.frameIntervals = [])
                    }
                }
            }
        }
        const Kl = /\/([0-9].*\/[\S]*\(\d+-\d+\)_[\S]*)/
          , gl = /\/([0-9].*\/[\S]*(\(\d+-\d+\))?_[\S]*)/
          , fl = /\((\d+)-(\d+)\)/;
        function Cl(e) {
            let t, V;
            function l(e, t) {
                const V = [];
                for (let l = 0; l < e; l++)
                    V.push(new Float32Array(t).fill(0));
                return V
            }
            return {
                push: function(d) {
                    const a = (0,
                    Ul.extractAtoms)(new Uint8Array(d))
                      , U = a.filter((e => "moov" === e.name)).reduce(( (e, t) => e.concat((0,
                    Ul.extractAtoms)(t.data))), []).filter((e => "trak" === e.name));
                    for (const e of U) {
                        const t = (0,
                        Ul.parseAudioMeta)(e);
                        t && (V = t)
                    }
                    if ("ftyp" === a[0].name)
                        return;
                    const n = a[a.length - 1];
                    if ("egwc" !== n.name)
                        return;
                    const R = (0,
                    Ul.getEgwc)(n);
                    if (!t)
                        return void (t = R.pts);
                    if (!V)
                        return;
                    const Z = Math.ceil((R.pts - t) * V.sampleRate / 1e3);
                    t = R.pts;
                    const N = {
                        pts: R.pts,
                        numChannels: V.numberOfChannels,
                        numSamples: Z,
                        buffers: l(V.numberOfChannels, Z)
                    };
                    e(N)
                },
                close: function() {
                    V = void 0
                }
            }
        }
        var Pl, ql, _l = function(e) {
            return Pl = Pl || function() {
                var e = function(e) {
                    return atob(e)
                }("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7dmFyIG49e2V4cG9ydHM6e319LHQ9e2V4cG9ydHM6e319OyFmdW5jdGlvbigpe3ZhciBuPVtdLGU9Mzk4ODI5MjM4NDtmdW5jdGlvbiBmKG4pe3ZhciB0LGYsQSxyLHU9LTE7Zm9yKHQ9MCxBPW4ubGVuZ3RoO3Q8QTt0Kz0xKXtmb3Iocj0yNTUmKHVeblt0XSksZj0wO2Y8ODtmKz0xKTE9PSgxJnIpP3I9cj4+PjFeZTpyPj4+PTE7dT11Pj4+OF5yfXJldHVybi0xXnV9ZnVuY3Rpb24gQSh0LGUpe3ZhciBmLHIsdTtpZih2b2lkIDAhPT1BLmNyYyYmZSYmdHx8KEEuY3JjPS0xLHQpKXtmb3IoZj1BLmNyYyxyPTAsdT10Lmxlbmd0aDtyPHU7cis9MSlmPWY+Pj44Xm5bMjU1JihmXnRbcl0pXTtyZXR1cm4gQS5jcmM9ZiwtMV5mfX0hZnVuY3Rpb24oKXt2YXIgdCxmLEE7Zm9yKGY9MDtmPDI1NjtmKz0xKXtmb3IodD1mLEE9MDtBPDg7QSs9MSkxJnQ/dD1lXnQ+Pj4xOnQ+Pj49MTtuW2ZdPXQ+Pj4wfX0oKSx0LmV4cG9ydHM9ZnVuY3Rpb24obix0KXt2YXIgZTtuPSJzdHJpbmciPT10eXBlb2Ygbj8oZT1uLEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlLChmdW5jdGlvbihuKXtyZXR1cm4gbi5jaGFyQ29kZUF0KDApfSkpKTpuO3JldHVybigodD9mKG4pOkEobikpPj4+MCkudG9TdHJpbmcoMTYpfSx0LmV4cG9ydHMuZGlyZWN0PWYsdC5leHBvcnRzLnRhYmxlPUF9KCk7dmFyIGU9dC5leHBvcnRzLGY9e2V4cG9ydHM6e319LEE9e2V4cG9ydHM6e319OyFmdW5jdGlvbigpe3ZhciBuLHQsZSxmLHIsdSx2LGwsYSxvLHMsYyx6LGksZCxYLGIscT0zMjc2OCxQPTAseT0xLG09MixwPTksVj02LEg9bnVsbCxUPVswLDEsMyw3LDE1LDMxLDYzLDEyNywyNTUsNTExLDEwMjMsMjA0Nyw0MDk1LDgxOTEsMTYzODMsMzI3NjcsNjU1MzVdLGo9WzMsNCw1LDYsNyw4LDksMTAsMTEsMTMsMTUsMTcsMTksMjMsMjcsMzEsMzUsNDMsNTEsNTksNjcsODMsOTksMTE1LDEzMSwxNjMsMTk1LDIyNywyNTgsMCwwXSxoPVswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsOTksOTldLE89WzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3N10sVz1bMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10seD1bMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07ZnVuY3Rpb24gWigpe3RoaXMubmV4dD1udWxsLHRoaXMubGlzdD1udWxsfWZ1bmN0aW9uIEwoKXt0aGlzLmU9MCx0aGlzLmI9MCx0aGlzLm49MCx0aGlzLnQ9bnVsbH1mdW5jdGlvbiB3KG4sdCxlLGYsQSxyKXt2YXIgdTt0aGlzLkJNQVg9MTYsdGhpcy5OX01BWD0yODgsdGhpcy5zdGF0dXM9MCx0aGlzLnJvb3Q9bnVsbCx0aGlzLm09MDt2YXIgdixsLGEsbyxzLGMseixpLGQsWCxiLHEsUCx5LG0scCxWPVtdLEg9W10sVD1uZXcgTCxqPVtdLGg9W10sTz1bXTtmb3IocD10aGlzLnJvb3Q9bnVsbCxzPTA7czx0aGlzLkJNQVgrMTtzKyspVltzXT0wO2ZvcihzPTA7czx0aGlzLkJNQVgrMTtzKyspSFtzXT0wO2ZvcihzPTA7czx0aGlzLkJNQVg7cysrKWpbc109bnVsbDtmb3Iocz0wO3M8dGhpcy5OX01BWDtzKyspaFtzXT0wO2ZvcihzPTA7czx0aGlzLkJNQVgrMTtzKyspT1tzXT0wO3Y9dD4yNTY/blsyNTZdOnRoaXMuQk1BWCxpPW4sZD0wLHM9dDtkb3tWW2lbZF1dKyssZCsrfXdoaWxlKC0tcz4wKTtpZihWWzBdPT09dClyZXR1cm4gdGhpcy5yb290PW51bGwsdGhpcy5tPTAsdm9pZCh0aGlzLnN0YXR1cz0wKTtmb3IoYz0xO2M8PXRoaXMuQk1BWCYmMD09PVZbY107YysrKTtmb3Ioej1jLHI8YyYmKHI9Yykscz10aGlzLkJNQVg7MCE9PXMmJjA9PT1WW3NdO3MtLSk7Zm9yKGE9cyxyPnMmJihyPXMpLFA9MTw8YztjPHM7YysrLFA8PD0xKWlmKChQLT1WW2NdKTwwKXJldHVybiB0aGlzLnN0YXR1cz0yLHZvaWQodGhpcy5tPXIpO2lmKChQLT1WW3NdKTwwKXJldHVybiB0aGlzLnN0YXR1cz0yLHZvaWQodGhpcy5tPXIpO2ZvcihWW3NdKz1QLE9bMV09Yz0wLGk9VixkPTEscT0yOy0tcz4wOylPW3ErK109Yys9aVtkKytdO2k9bixkPTAscz0wO2RvezAhPT0oYz1pW2QrK10pJiYoaFtPW2NdKytdPXMpfXdoaWxlKCsrczx0KTtmb3IodD1PW2FdLE9bMF09cz0wLGk9aCxkPTAsbz0tMSxiPUhbMF09MCxYPW51bGwseT0wO3o8PWE7eisrKWZvcih1PVZbel07dS0tID4wOyl7Zm9yKDt6PmIrSFsxK29dOyl7aWYoYis9SFsxK29dLG8rKyx5PSh5PWEtYik+cj9yOnksKGw9MTw8KGM9ei1iKSk+dSsxKWZvcihsLT11KzEscT16OysrYzx5JiYhKChsPDw9MSk8PVZbKytxXSk7KWwtPVZbcV07Zm9yKGIrYz52JiZiPHYmJihjPXYtYikseT0xPDxjLEhbMStvXT1jLFg9W10sbT0wO208eTttKyspWFttXT1uZXcgTDsocD1wP3AubmV4dD1uZXcgWjp0aGlzLnJvb3Q9bmV3IFopLm5leHQ9bnVsbCxwLmxpc3Q9WCxqW29dPVgsbz4wJiYoT1tvXT1zLFQuYj1IW29dLFQuZT0xNitjLFQudD1YLGM9KHMmKDE8PGIpLTEpPj5iLUhbb10saltvLTFdW2NdLmU9VC5lLGpbby0xXVtjXS5iPVQuYixqW28tMV1bY10ubj1ULm4saltvLTFdW2NdLnQ9VC50KX1mb3IoVC5iPXotYixkPj10P1QuZT05OTppW2RdPGU/KFQuZT1pW2RdPDI1Nj8xNjoxNSxULm49aVtkKytdKTooVC5lPUFbaVtkXS1lXSxULm49ZltpW2QrK10tZV0pLGw9MTw8ei1iLGM9cz4+YjtjPHk7Yys9bClYW2NdLmU9VC5lLFhbY10uYj1ULmIsWFtjXS5uPVQubixYW2NdLnQ9VC50O2ZvcihjPTE8PHotMTswIT0ocyZjKTtjPj49MSlzXj1jO2ZvcihzXj1jOyhzJigxPDxiKS0xKSE9PU9bb107KWItPUhbb10sby0tfXRoaXMubT1IWzFdLHRoaXMuc3RhdHVzPTAhPT1QJiYxIT09YT8xOjB9ZnVuY3Rpb24gRChuKXtmb3IoO3Y8bjspdXw9KFgubGVuZ3RoPT09Yj8tMToyNTUmWFtiKytdKTw8dix2Kz04fWZ1bmN0aW9uIE4obil7cmV0dXJuIHUmVFtuXX1mdW5jdGlvbiBrKG4pe3U+Pj1uLHYtPW59ZnVuY3Rpb24gTShlLGYsQSl7dmFyIHIsdSx2O2lmKDA9PT1BKXJldHVybiAwO2Zvcih2PTA7Oyl7Zm9yKEQoaSkscj0odT1jLmxpc3RbTihpKV0pLmU7cj4xNjspe2lmKDk5PT09cilyZXR1cm4tMTtrKHUuYiksRChyLT0xNikscj0odT11LnRbTihyKV0pLmV9aWYoayh1LmIpLDE2IT09cil7aWYoMTU9PT1yKWJyZWFrO2ZvcihEKHIpLG89dS5uK04ociksayhyKSxEKGQpLHI9KHU9ei5saXN0W04oZCldKS5lO3I+MTY7KXtpZig5OT09PXIpcmV0dXJuLTE7ayh1LmIpLEQoci09MTYpLHI9KHU9dS50W04ocildKS5lfWZvcihrKHUuYiksRChyKSxzPXQtdS5uLU4ociksayhyKTtvPjAmJnY8QTspby0tLHMmPXEtMSx0Jj1xLTEsZVtmK3YrK109blt0KytdPW5bcysrXTtpZih2PT09QSlyZXR1cm4gQX1lbHNlIGlmKHQmPXEtMSxlW2YrdisrXT1uW3QrK109dS5uLHY9PT1BKXJldHVybiBBfXJldHVybiBsPS0xLHZ9ZnVuY3Rpb24gVShlLGYsQSl7dmFyIHI7aWYoayhyPTcmdiksRCgxNikscj1OKDE2KSxrKDE2KSxEKDE2KSxyIT09KDY1NTM1Jn51KSlyZXR1cm4tMTtmb3IoaygxNiksbz1yLHI9MDtvPjAmJnI8QTspby0tLHQmPXEtMSxEKDgpLGVbZityKytdPW5bdCsrXT1OKDgpLGsoOCk7cmV0dXJuIDA9PT1vJiYobD0tMSkscn1mdW5jdGlvbiBJKG4sdCxBKXtpZighSCl7dmFyIHUsdixsPVtdO2Zvcih1PTA7dTwxNDQ7dSsrKWxbdV09ODtmb3IoO3U8MjU2O3UrKylsW3VdPTk7Zm9yKDt1PDI4MDt1KyspbFt1XT03O2Zvcig7dTwyODg7dSsrKWxbdV09ODtpZigwIT09KHY9bmV3IHcobCwyODgsMjU3LGosaCxmPTcpKS5zdGF0dXMpcmV0dXJuIGNvbnNvbGUuZXJyb3IoIkh1ZkJ1aWxkIGVycm9yOiAiK3Yuc3RhdHVzKSwtMTtmb3IoSD12LnJvb3QsZj12Lm0sdT0wO3U8MzA7dSsrKWxbdV09NTtpZigodj1uZXcgdyhsLDMwLDAsTyxXLHI9NSkpLnN0YXR1cz4xKXJldHVybiBIPW51bGwsY29uc29sZS5lcnJvcigiSHVmQnVpbGQgZXJyb3I6ICIrdi5zdGF0dXMpLC0xO2U9di5yb290LHI9di5tfXJldHVybiBjPUgsej1lLGk9ZixkPXIsTShuLHQsQSl9ZnVuY3Rpb24gSihuLHQsZSl7dmFyIGYsQSxyLHUsdixsLGEsbyxzLFg9W107Zm9yKGY9MDtmPDMxNjtmKyspWFtmXT0wO2lmKEQoNSksYT0yNTcrTig1KSxrKDUpLEQoNSksbz0xK04oNSksayg1KSxEKDQpLGw9NCtOKDQpLGsoNCksYT4yODZ8fG8+MzApcmV0dXJuLTE7Zm9yKEE9MDtBPGw7QSsrKUQoMyksWFt4W0FdXT1OKDMpLGsoMyk7Zm9yKDtBPDE5O0ErKylYW3hbQV1dPTA7aWYoMCE9PShzPW5ldyB3KFgsMTksMTksbnVsbCxudWxsLGk9NykpLnN0YXR1cylyZXR1cm4tMTtmb3IoYz1zLnJvb3QsaT1zLm0sdT1hK28sZj1yPTA7Zjx1OylpZihEKGkpLGsoQT0odj1jLmxpc3RbTihpKV0pLmIpLChBPXYubik8MTYpWFtmKytdPXI9QTtlbHNlIGlmKDE2PT09QSl7aWYoRCgyKSxBPTMrTigyKSxrKDIpLGYrQT51KXJldHVybi0xO2Zvcig7QS0tID4wOylYW2YrK109cn1lbHNlIGlmKDE3PT09QSl7aWYoRCgzKSxBPTMrTigzKSxrKDMpLGYrQT51KXJldHVybi0xO2Zvcig7QS0tID4wOylYW2YrK109MDtyPTB9ZWxzZXtpZihEKDcpLEE9MTErTig3KSxrKDcpLGYrQT51KXJldHVybi0xO2Zvcig7QS0tID4wOylYW2YrK109MDtyPTB9aWYocz1uZXcgdyhYLGEsMjU3LGosaCxpPXApLDA9PT1pJiYocy5zdGF0dXM9MSksMCE9PXMuc3RhdHVzJiYxIT09cy5zdGF0dXMpcmV0dXJuLTE7Zm9yKGM9cy5yb290LGk9cy5tLGY9MDtmPG87ZisrKVhbZl09WFtmK2FdO3JldHVybiBzPW5ldyB3KFgsbywwLE8sVyxkPVYpLHo9cy5yb290LDA9PT0oZD1zLm0pJiZhPjI1N3x8MCE9PXMuc3RhdHVzPy0xOk0obix0LGUpfWZ1bmN0aW9uIEcoZSxmLEEpe3ZhciByLHU7Zm9yKHI9MDtyPEE7KXtpZihhJiYtMT09PWwpcmV0dXJuIHI7aWYobz4wKXtpZihsIT09UClmb3IoO28+MCYmcjxBOylvLS0scyY9cS0xLHQmPXEtMSxlW2YrcisrXT1uW3QrK109bltzKytdO2Vsc2V7Zm9yKDtvPjAmJnI8QTspby0tLHQmPXEtMSxEKDgpLGVbZityKytdPW5bdCsrXT1OKDgpLGsoOCk7MD09PW8mJihsPS0xKX1pZihyPT09QSlyZXR1cm4gcn1pZigtMT09PWwpe2lmKGEpYnJlYWs7RCgxKSwwIT09TigxKSYmKGE9ITApLGsoMSksRCgyKSxsPU4oMiksaygyKSxjPW51bGwsbz0wfXN3aXRjaChsKXtjYXNlIFA6dT1VKGUsZityLEEtcik7YnJlYWs7Y2FzZSB5OnU9Yz9NKGUsZityLEEtcik6SShlLGYrcixBLXIpO2JyZWFrO2Nhc2UgbTp1PWM/TShlLGYrcixBLXIpOkooZSxmK3IsQS1yKTticmVhaztkZWZhdWx0OnU9LTF9aWYoLTE9PT11KXJldHVybiBhPzA6LTE7cis9dX1yZXR1cm4gcn1BLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIGYsQT1bXTtufHwobj1bXSksdD0wLHU9MCx2PTAsbD0tMSxhPSExLG89cz0wLGM9bnVsbCxYPWUsYj0wO2Rve2Y9RyhBLEEubGVuZ3RoLDEwMjQpfXdoaWxlKGY+MCk7cmV0dXJuIFg9bnVsbCxBfX0oKTt2YXIgcj1BLmV4cG9ydHMsdT17ZXhwb3J0czp7fX07IWZ1bmN0aW9uKCl7dmFyIG4sdCxlLGYsQSxyLHYsbCxhLG8scyxjLHosaSxkLFgsYixxLFAseSxtLHAsVixILFQsaixoLE8sVyx4LFosTCx3LEQsTixrLE0sVSxJLEosRyxnLFMsRixSLFksRSxLLFEsQyxCLF8sJCxubix0bixlbixmbj0zMjc2OCxBbj0wLHJuPTEsdW49Mix2bj02LGxuPTgxOTIsYW49Mipmbixvbj0zLHNuPTI1OCxjbj04MTkyLHpuPWNuLGRuPTMyNzY4LFhuPWRuLTEsYm49Zm4tMSxxbj0wLFBuPTQwOTYseW49c24rb24rMSxtbj1mbi15bixwbj0xLFZuPTE1LEhuPTcsVG49Mjksam49MjU2LGhuPTI1NixPbj1qbisxK1RuLFduPTMwLHhuPTE5LFpuPTE2LExuPTE3LHduPTE4LERuPTIqT24rMSxObj1wYXJzZUludCgoMTUrb24tMSkvb24sMTApLGtuPW51bGw7ZnVuY3Rpb24gTW4oKXt0aGlzLmZjPTAsdGhpcy5kbD0wfWZ1bmN0aW9uIFVuKCl7dGhpcy5keW5fdHJlZT1udWxsLHRoaXMuc3RhdGljX3RyZWU9bnVsbCx0aGlzLmV4dHJhX2JpdHM9bnVsbCx0aGlzLmV4dHJhX2Jhc2U9MCx0aGlzLmVsZW1zPTAsdGhpcy5tYXhfbGVuZ3RoPTAsdGhpcy5tYXhfY29kZT0wfWZ1bmN0aW9uIEluKG4sdCxlLGYpe3RoaXMuZ29vZF9sZW5ndGg9bix0aGlzLm1heF9sYXp5PXQsdGhpcy5uaWNlX2xlbmd0aD1lLHRoaXMubWF4X2NoYWluPWZ9ZnVuY3Rpb24gSm4oKXt0aGlzLm5leHQ9bnVsbCx0aGlzLmxlbj0wLHRoaXMucHRyPVtdLHRoaXMub2ZmPTB9dmFyIEduPVswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdLGduPVswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXSxTbj1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN10sRm49WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLFJuPVtuZXcgSW4oMCwwLDAsMCksbmV3IEluKDQsNCw4LDQpLG5ldyBJbig0LDUsMTYsOCksbmV3IEluKDQsNiwzMiwzMiksbmV3IEluKDQsNCwxNiwxNiksbmV3IEluKDgsMTYsMzIsMzIpLG5ldyBJbig4LDE2LDEyOCwxMjgpLG5ldyBJbig4LDMyLDEyOCwyNTYpLG5ldyBJbigzMiwxMjgsMjU4LDEwMjQpLG5ldyBJbigzMiwyNTgsMjU4LDQwOTYpXTtmdW5jdGlvbiBZbih0KXt0Lm5leHQ9bixuPXR9ZnVuY3Rpb24gRW4obil7cmV0dXJuIHNbZm4rbl19ZnVuY3Rpb24gS24obix0KXtyZXR1cm4gc1tmbituXT10fWZ1bmN0aW9uIFFuKGYpe2tuW3IrQSsrXT1mLHIrQT09PWxuJiZmdW5jdGlvbigpe3ZhciBmLHU7aWYoMCE9PUEpe2ZvcihudWxsIT09bj8odj1uLG49bi5uZXh0KTp2PW5ldyBKbix2Lm5leHQ9bnVsbCx2Lmxlbj12Lm9mZj0wLGY9dixudWxsPT09dD90PWU9ZjplPWUubmV4dD1mLGYubGVuPUEtcix1PTA7dTxmLmxlbjt1KyspZi5wdHJbdV09a25bcit1XTtBPXI9MH12YXIgdn0oKX1mdW5jdGlvbiBDbihuKXtuJj02NTUzNSxyK0E8bG4tMj8oa25bcitBKytdPTI1NSZuLGtuW3IrQSsrXT1uPj4+OCk6KFFuKDI1NSZuKSxRbihuPj4+OCkpfWZ1bmN0aW9uIEJuKCl7ZD0oZDw8Tm5eMjU1JmxbbStvbi0xXSkmWG4sWD1FbihkKSxzW20mYm5dPVgsS24oZCxtKX1mdW5jdGlvbiBfbihuLHQpe2J0KHRbbl0uZmMsdFtuXS5kbCl9ZnVuY3Rpb24gJG4obil7cmV0dXJuIDI1NSYobjwyNTY/RltuXTpGWzI1Nisobj4+NyldKX1mdW5jdGlvbiBudChuLHQsZSl7cmV0dXJuIG5bdF0uZmM8bltlXS5mY3x8blt0XS5mYz09PW5bZV0uZmMmJmdbdF08PWdbZV19ZnVuY3Rpb24gdHQobix0LGUpe3ZhciBmO2ZvcihmPTA7ZjxlJiZlbjx0bi5sZW5ndGg7ZisrKW5bdCtmXT0yNTUmdG5bZW4rK107cmV0dXJuIGZ9ZnVuY3Rpb24gZXQobil7dmFyIHQsZSxmLEEscj1ULHU9bSx2PXksYT1tPm1uP20tbW46cW4sbz1tK3NuLGM9bFt1K3YtMV0sej1sW3Urdl07eT49TyYmKHI+Pj0yKTtkb3tpZihsWyh0PW4pK3ZdPT09eiYmbFt0K3YtMV09PT1jJiZsW3RdPT09bFt1XSYmbFsrK3RdPT09bFt1KzFdKXtmb3IodSs9Mix0Kys7dTxvOyl7Zm9yKEE9ITEsZj0wO2Y8ODtmKz0xKWlmKHQrPTEsbFt1Kz0xXSE9PWxbdF0pe0E9ITA7YnJlYWt9aWYoQSlicmVha31pZihlPXNuLShvLXUpLHU9by1zbixlPnYpe2lmKHA9bix2PWUsZT49VylicmVhaztjPWxbdSt2LTFdLHo9bFt1K3ZdfX19d2hpbGUoKG49c1tuJmJuXSk+YSYmMCE9LS1yKTtyZXR1cm4gdn1mdW5jdGlvbiBmdCgpe3ZhciBuLHQsZT1hbi1ILW07aWYoLTE9PT1lKWUtLTtlbHNlIGlmKG0+PWZuK21uKXtmb3Iobj0wO248Zm47bisrKWxbbl09bFtuK2ZuXTtmb3IocC09Zm4sbS09Zm4saS09Zm4sbj0wO248ZG47bisrKUtuKG4sKHQ9RW4obikpPj1mbj90LWZuOnFuKTtmb3Iobj0wO248Zm47bisrKXQ9c1tuXSxzW25dPXQ+PWZuP3QtZm46cW47ZSs9Zm59Vnx8KChuPXR0KGwsbStILGUpKTw9MD9WPSEwOkgrPW4pfWZ1bmN0aW9uIEF0KCl7Vnx8KGM9MCx6PTAsZnVuY3Rpb24oKXt2YXIgbix0LGUsZixBO2lmKDAhPT13WzBdLmRsKXJldHVybjtmb3IoTi5keW5fdHJlZT14LE4uc3RhdGljX3RyZWU9TCxOLmV4dHJhX2JpdHM9R24sTi5leHRyYV9iYXNlPWpuKzEsTi5lbGVtcz1PbixOLm1heF9sZW5ndGg9Vm4sTi5tYXhfY29kZT0wLGsuZHluX3RyZWU9WixrLnN0YXRpY190cmVlPXcsay5leHRyYV9iaXRzPWduLGsuZXh0cmFfYmFzZT0wLGsuZWxlbXM9V24say5tYXhfbGVuZ3RoPVZuLGsubWF4X2NvZGU9MCxNLmR5bl90cmVlPUQsTS5zdGF0aWNfdHJlZT1udWxsLE0uZXh0cmFfYml0cz1TbixNLmV4dHJhX2Jhc2U9MCxNLmVsZW1zPXhuLE0ubWF4X2xlbmd0aD1IbixNLm1heF9jb2RlPTAsZT0wLGY9MDtmPFRuLTE7ZisrKWZvcihSW2ZdPWUsbj0wO248MTw8R25bZl07bisrKVNbZSsrXT1mO2ZvcihTW2UtMV09ZixBPTAsZj0wO2Y8MTY7ZisrKWZvcihZW2ZdPUEsbj0wO248MTw8Z25bZl07bisrKUZbQSsrXT1mO2ZvcihBPj49NztmPFduO2YrKylmb3IoWVtmXT1BPDw3LG49MDtuPDE8PGduW2ZdLTc7bisrKUZbMjU2K0ErK109Zjtmb3IodD0wO3Q8PVZuO3QrKylVW3RdPTA7bj0wO2Zvcig7bjw9MTQzOylMW24rK10uZGw9OCxVWzhdKys7Zm9yKDtuPD0yNTU7KUxbbisrXS5kbD05LFVbOV0rKztmb3IoO248PTI3OTspTFtuKytdLmRsPTcsVVs3XSsrO2Zvcig7bjw9Mjg3OylMW24rK10uZGw9OCxVWzhdKys7Zm9yKGF0KEwsT24rMSksbj0wO248V247bisrKXdbbl0uZGw9NSx3W25dLmZjPXF0KG4sNSk7dnQoKX0oKSxmdW5jdGlvbigpe3ZhciBuO2ZvcihuPTA7bjxkbjtuKyspc1tmbituXT0wO2lmKGo9Um5baF0ubWF4X2xhenksTz1SbltoXS5nb29kX2xlbmd0aCxXPVJuW2hdLm5pY2VfbGVuZ3RoLFQ9Um5baF0ubWF4X2NoYWluLG09MCxpPTAsKEg9dHQobCwwLDIqZm4pKTw9MClyZXR1cm4gVj0hMCx2b2lkKEg9MCk7Zm9yKFY9ITE7SDx5biYmIVY7KWZ0KCk7Zm9yKGQ9MCxuPTA7bjxvbi0xO24rKylkPShkPDxObl4yNTUmbFtuXSkmWG59KCksdD1udWxsLEE9MCxyPTAsaDw9Mz8oeT1vbi0xLFA9MCk6KFA9b24tMSxxPSExKSx2PSExKX1mdW5jdGlvbiBydChuLGUsQSl7dmFyIHI7cmV0dXJuIGZ8fChBdCgpLGY9ITAsMCE9PUgpPyhyPXV0KG4sZSxBKSk9PT1BP0E6dj9yOihoPD0zP2Z1bmN0aW9uKCl7Zm9yKDswIT09SCYmbnVsbD09PXQ7KXt2YXIgbjtpZihCbigpLFghPT1xbiYmbS1YPD1tbiYmKFA9ZXQoWCkpPkgmJihQPUgpLFA+PW9uKWlmKG49aXQobS1wLFAtb24pLEgtPVAsUDw9ail7UC0tO2Rve20rKyxCbigpfXdoaWxlKDAhPS0tUCk7bSsrfWVsc2UgbSs9UCxQPTAsZD0oKGQ9MjU1JmxbbV0pPDxObl4yNTUmbFttKzFdKSZYbjtlbHNlIG49aXQoMCwyNTUmbFttXSksSC0tLG0rKztmb3IobiYmKHp0KDApLGk9bSk7SDx5biYmIVY7KWZ0KCl9fSgpOmZ1bmN0aW9uKCl7Zm9yKDswIT09SCYmbnVsbD09PXQ7KXtpZihCbigpLHk9UCxiPXAsUD1vbi0xLFghPT1xbiYmeTxqJiZtLVg8PW1uJiYoKFA9ZXQoWCkpPkgmJihQPUgpLFA9PT1vbiYmbS1wPlBuJiZQLS0pLHk+PW9uJiZQPD15KXt2YXIgbjtuPWl0KG0tMS1iLHktb24pLEgtPXktMSx5LT0yO2Rve20rKyxCbigpfXdoaWxlKDAhPS0teSk7cT0hMSxQPW9uLTEsbSsrLG4mJih6dCgwKSxpPW0pfWVsc2UgcT8oaXQoMCwyNTUmbFttLTFdKSYmKHp0KDApLGk9bSksbSsrLEgtLSk6KHE9ITAsbSsrLEgtLSk7Zm9yKDtIPHluJiYhVjspZnQoKX19KCksMD09PUgmJihxJiZpdCgwLDI1NSZsW20tMV0pLHp0KDEpLHY9ITApLHIrdXQobixyK2UsQS1yKSk6KHY9ITAsMCl9ZnVuY3Rpb24gdXQobixlLGYpe3ZhciB1LHYsbDtmb3IodT0wO251bGwhPT10JiZ1PGY7KXtmb3IoKHY9Zi11KT50LmxlbiYmKHY9dC5sZW4pLGw9MDtsPHY7bCsrKW5bZSt1K2xdPXQucHRyW3Qub2ZmK2xdO3ZhciBhO2lmKHQub2ZmKz12LHQubGVuLT12LHUrPXYsMD09PXQubGVuKWE9dCx0PXQubmV4dCxZbihhKX1pZih1PT09ZilyZXR1cm4gdTtpZihyPEEpe2Zvcigodj1mLXUpPkEtciYmKHY9QS1yKSxsPTA7bDx2O2wrKyluW2UrdStsXT1rbltyK2xdO3UrPXYsQT09PShyKz12KSYmKEE9cj0wKX1yZXR1cm4gdX1mdW5jdGlvbiB2dCgpe3ZhciBuO2ZvcihuPTA7bjxPbjtuKyspeFtuXS5mYz0wO2ZvcihuPTA7bjxXbjtuKyspWltuXS5mYz0wO2ZvcihuPTA7bjx4bjtuKyspRFtuXS5mYz0wO3hbaG5dLmZjPTEsJD1ubj0wLEs9UT1DPTAsQj0wLF89MX1mdW5jdGlvbiBsdChuLHQpe2Zvcih2YXIgZT1JW3RdLGY9dDw8MTtmPD1KJiYoZjxKJiZudChuLElbZisxXSxJW2ZdKSYmZisrLCFudChuLGUsSVtmXSkpOylJW3RdPUlbZl0sdD1mLGY8PD0xO0lbdF09ZX1mdW5jdGlvbiBhdChuLHQpe3ZhciBlLGYsQT1bXSxyPTA7Zm9yKGU9MTtlPD1WbjtlKyspcj1yK1VbZS0xXTw8MSxBW2VdPXI7Zm9yKGY9MDtmPD10O2YrKyl7dmFyIHU9bltmXS5kbDswIT09dSYmKG5bZl0uZmM9cXQoQVt1XSsrLHUpKX19ZnVuY3Rpb24gb3Qobil7dmFyIHQsZSxmPW4uZHluX3RyZWUsQT1uLnN0YXRpY190cmVlLHI9bi5lbGVtcyx1PS0xLHY9cjtmb3IoSj0wLEc9RG4sdD0wO3Q8cjt0KyspMCE9PWZbdF0uZmM/KElbKytKXT11PXQsZ1t0XT0wKTpmW3RdLmRsPTA7Zm9yKDtKPDI7KXt2YXIgbD1JWysrSl09dTwyPysrdTowO2ZbbF0uZmM9MSxnW2xdPTAsJC0tLG51bGwhPT1BJiYobm4tPUFbbF0uZGwpfWZvcihuLm1heF9jb2RlPXUsdD1KPj4xO3Q+PTE7dC0tKWx0KGYsdCk7ZG97dD1JW3BuXSxJW3BuXT1JW0otLV0sbHQoZixwbiksZT1JW3BuXSxJWy0tR109dCxJWy0tR109ZSxmW3ZdLmZjPWZbdF0uZmMrZltlXS5mYyxnW3RdPmdbZV0rMT9nW3ZdPWdbdF06Z1t2XT1nW2VdKzEsZlt0XS5kbD1mW2VdLmRsPXYsSVtwbl09disrLGx0KGYscG4pfXdoaWxlKEo+PTIpO0lbLS1HXT1JW3BuXSxmdW5jdGlvbihuKXt2YXIgdCxlLGYsQSxyLHUsdj1uLmR5bl90cmVlLGw9bi5leHRyYV9iaXRzLGE9bi5leHRyYV9iYXNlLG89bi5tYXhfY29kZSxzPW4ubWF4X2xlbmd0aCxjPW4uc3RhdGljX3RyZWUsej0wO2ZvcihBPTA7QTw9Vm47QSsrKVVbQV09MDtmb3IodltJW0ddXS5kbD0wLHQ9RysxO3Q8RG47dCsrKShBPXZbdltlPUlbdF1dLmRsXS5kbCsxKT5zJiYoQT1zLHorKyksdltlXS5kbD1BLGU+b3x8KFVbQV0rKyxyPTAsZT49YSYmKHI9bFtlLWFdKSx1PXZbZV0uZmMsJCs9dSooQStyKSxudWxsIT09YyYmKG5uKz11KihjW2VdLmRsK3IpKSk7aWYoMCE9PXope2Rve2ZvcihBPXMtMTswPT09VVtBXTspQS0tO1VbQV0tLSxVW0ErMV0rPTIsVVtzXS0tLHotPTJ9d2hpbGUoej4wKTtmb3IoQT1zOzAhPT1BO0EtLSlmb3IoZT1VW0FdOzAhPT1lOykoZj1JWy0tdF0pPm98fCh2W2ZdLmRsIT09QSYmKCQrPShBLXZbZl0uZGwpKnZbZl0uZmMsdltmXS5mYz1BKSxlLS0pfX0obiksYXQoZix1KX1mdW5jdGlvbiBzdChuLHQpe3ZhciBlLGYsQT0tMSxyPW5bMF0uZGwsdT0wLHY9NyxsPTQ7Zm9yKDA9PT1yJiYodj0xMzgsbD0zKSxuW3QrMV0uZGw9NjU1MzUsZT0wO2U8PXQ7ZSsrKWY9cixyPW5bZSsxXS5kbCwrK3U8diYmZj09PXJ8fCh1PGw/RFtmXS5mYys9dTowIT09Zj8oZiE9PUEmJkRbZl0uZmMrKyxEW1puXS5mYysrKTp1PD0xMD9EW0xuXS5mYysrOkRbd25dLmZjKyssdT0wLEE9ZiwwPT09cj8odj0xMzgsbD0zKTpmPT09cj8odj02LGw9Myk6KHY9NyxsPTQpKX1mdW5jdGlvbiBjdChuLHQpe3ZhciBlLGYsQT0tMSxyPW5bMF0uZGwsdT0wLHY9NyxsPTQ7Zm9yKDA9PT1yJiYodj0xMzgsbD0zKSxlPTA7ZTw9dDtlKyspaWYoZj1yLHI9bltlKzFdLmRsLCEoKyt1PHYmJmY9PT1yKSl7aWYodTxsKWRve19uKGYsRCl9d2hpbGUoMCE9LS11KTtlbHNlIDAhPT1mPyhmIT09QSYmKF9uKGYsRCksdS0tKSxfbihabixEKSxidCh1LTMsMikpOnU8PTEwPyhfbihMbixEKSxidCh1LTMsMykpOihfbih3bixEKSxidCh1LTExLDcpKTt1PTAsQT1mLDA9PT1yPyh2PTEzOCxsPTMpOmY9PT1yPyh2PTYsbD0zKToodj03LGw9NCl9fWZ1bmN0aW9uIHp0KG4pe3ZhciB0LGUsZixBLHI7aWYoQT1tLWksRVtDXT1CLG90KE4pLG90KGspLGY9ZnVuY3Rpb24oKXt2YXIgbjtmb3Ioc3QoeCxOLm1heF9jb2RlKSxzdChaLGsubWF4X2NvZGUpLG90KE0pLG49eG4tMTtuPj0zJiYwPT09RFtGbltuXV0uZGw7bi0tKTtyZXR1cm4gJCs9MyoobisxKSs1KzUrNCxufSgpLChlPW5uKzMrNz4+Myk8PSh0PSQrMys3Pj4zKSYmKHQ9ZSksQSs0PD10JiZpPj0wKWZvcihidCgoQW48PDEpK24sMyksUHQoKSxDbihBKSxDbih+QSkscj0wO3I8QTtyKyspUW4obFtpK3JdKTtlbHNlIGU9PT10PyhidCgocm48PDEpK24sMyksZHQoTCx3KSk6KGJ0KCh1bjw8MSkrbiwzKSxmdW5jdGlvbihuLHQsZSl7dmFyIGY7Zm9yKGJ0KG4tMjU3LDUpLGJ0KHQtMSw1KSxidChlLTQsNCksZj0wO2Y8ZTtmKyspYnQoRFtGbltmXV0uZGwsMyk7Y3QoeCxuLTEpLGN0KFosdC0xKX0oTi5tYXhfY29kZSsxLGsubWF4X2NvZGUrMSxmKzEpLGR0KHgsWikpO3Z0KCksMCE9PW4mJlB0KCl9ZnVuY3Rpb24gaXQobix0KXtpZihvW0srK109dCwwPT09bj94W3RdLmZjKys6KG4tLSx4W1NbdF0ram4rMV0uZmMrKyxaWyRuKG4pXS5mYysrLGFbUSsrXT1uLEJ8PV8pLF88PD0xLDA9PSg3JkspJiYoRVtDKytdPUIsQj0wLF89MSksaD4yJiYwPT0oNDA5NSZLKSl7dmFyIGUsZj04KkssQT1tLWk7Zm9yKGU9MDtlPFduO2UrKylmKz1aW2VdLmZjKig1K2duW2VdKTtpZihmPj49MyxRPHBhcnNlSW50KEsvMiwxMCkmJmY8cGFyc2VJbnQoQS8yLDEwKSlyZXR1cm4hMH1yZXR1cm4gSz09PWNuLTF8fFE9PT16bn1mdW5jdGlvbiBkdChuLHQpe3ZhciBlLGYsQSxyLHU9MCx2PTAsbD0wLHM9MDtpZigwIT09Sylkb3swPT0oNyZ1KSYmKHM9RVtsKytdKSxmPTI1NSZvW3UrK10sMD09KDEmcyk/X24oZixuKTooX24oKEE9U1tmXSkram4rMSxuKSwwIT09KHI9R25bQV0pJiZidChmLT1SW0FdLHIpLF9uKEE9JG4oZT1hW3YrK10pLHQpLDAhPT0ocj1nbltBXSkmJmJ0KGUtPVlbQV0scikpLHM+Pj0xfXdoaWxlKHU8Syk7X24oaG4sbil9dmFyIFh0PTE2O2Z1bmN0aW9uIGJ0KG4sdCl7ej5YdC10PyhDbihjfD1uPDx6KSxjPW4+Plh0LXoseis9dC1YdCk6KGN8PW48PHoseis9dCl9ZnVuY3Rpb24gcXQobix0KXt2YXIgZT0wO2Rve2V8PTEmbixuPj49MSxlPDw9MX13aGlsZSgtLXQ+MCk7cmV0dXJuIGU+PjF9ZnVuY3Rpb24gUHQoKXt6Pjg/Q24oYyk6ej4wJiZRbihjKSxjPTAsej0wfXUuZXhwb3J0cz1mdW5jdGlvbihBLHIpe3ZhciB1LHY7dG49QSxlbj0wLHZvaWQgMD09PXImJihyPXZuKSxmdW5jdGlvbihBKXt2YXIgcjtpZihBP0E8MT9BPTE6QT45JiYoQT05KTpBPXZuLGg9QSxmPSExLFY9ITEsbnVsbD09PWtuKXtmb3Iobj10PWU9bnVsbCxrbj1bXSxsPVtdLGE9W10sbz1bXSxzPVtdLHg9W10scj0wO3I8RG47cisrKXhbcl09bmV3IE1uO2ZvcihaPVtdLHI9MDtyPDIqV24rMTtyKyspWltyXT1uZXcgTW47Zm9yKEw9W10scj0wO3I8T24rMjtyKyspTFtyXT1uZXcgTW47Zm9yKHc9W10scj0wO3I8V247cisrKXdbcl09bmV3IE1uO2ZvcihEPVtdLHI9MDtyPDIqeG4rMTtyKyspRFtyXT1uZXcgTW47Tj1uZXcgVW4saz1uZXcgVW4sTT1uZXcgVW4sVT1bXSxJPVtdLGc9W10sUz1bXSxGPVtdLFI9W10sWT1bXSxFPVtdfX0ociksdj1bXTtkb3t1PXJ0KHYsdi5sZW5ndGgsMTAyNCl9d2hpbGUodT4wKTtyZXR1cm4gdG49bnVsbCx2fSx1LmV4cG9ydHMuREVGQVVMVF9MRVZFTD12bn0oKTt2YXIgdj11LmV4cG9ydHM7Zi5leHBvcnRzPXtpbmZsYXRlOnIsZGVmbGF0ZTp2fTt2YXIgbD1mLmV4cG9ydHM7IWZ1bmN0aW9uKCl7dmFyIHQ9ZSxmPWwsQT17ZGVmbGF0ZTo4fSxyPTEsdT0yLHY9NCxhPTgsbz0xNixzPXtmYXQ6MCxhbWlnYToxLHZtejoyLHVuaXg6Mywidm0vY21zIjo0LGF0YXJpOjUsaHBmczo2LG1hY2ludG9zaDo3LCJ6LXN5c3RlbSI6OCxjcGxtOjksInRvcHMtMjAiOjEwLG50ZnM6MTEscWRvczoxMixhY29ybjoxMyx2ZmF0OjE0LHZtczoxNSxiZW9zOjE2LHRhbmRlbToxNyx0aGVvczoxOH07ZnVuY3Rpb24gYyhuLHQpe3QucHVzaCgyNTUmbil9ZnVuY3Rpb24geihuLHQpe3QucHVzaCgyNTUmbiksdC5wdXNoKG4+Pj44KX1mdW5jdGlvbiBpKG4sdCl7eig2NTUzNSZuLHQpLHoobj4+PjE2LHQpfWZ1bmN0aW9uIGQobil7cmV0dXJuIG4uc2hpZnQoKX1mdW5jdGlvbiBYKG4pe3JldHVybiBuLnNoaWZ0KCl8bi5zaGlmdCgpPDw4fWZ1bmN0aW9uIGIobil7dmFyIHQ9WChuKSxlPVgobik7cmV0dXJuIGU+MzI3Njg/KChlLT0zMjc2OCk8PDE2fHQpKzMyNzY4Kk1hdGgucG93KDIsMTYpOmU8PDE2fHR9ZnVuY3Rpb24gcShuKXtmb3IodmFyIHQ9W107MCE9PW5bMF07KXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKG4uc2hpZnQoKSkpO3JldHVybiBuLnNoaWZ0KCksdC5qb2luKCIiKX1uLmV4cG9ydHM9e3ppcDpmdW5jdGlvbihuLGUpe3ZhciByLHU9MCx2PVtdO3JldHVybiBlfHwoZT17fSkscj1lLmxldmVsfHw2LCJzdHJpbmciPT10eXBlb2YgbiYmKG49QXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG4sKGZ1bmN0aW9uKG4pe3JldHVybiBuLmNoYXJDb2RlQXQoMCl9KSkpLGMoMzEsdiksYygxMzksdiksYyhBLmRlZmxhdGUsdiksZS5uYW1lJiYodXw9YSksYyh1LHYpLGkoZS50aW1lc3RhbXB8fHBhcnNlSW50KERhdGUubm93KCkvMWUzLDEwKSx2KSxjKDE9PT1yPzQ6OT09PXI/MjowLHYpLGMocy51bml4LHYpLGUubmFtZSYmKCFmdW5jdGlvbihuLHQpe3ZhciBlLGY9bi5sZW5ndGg7Zm9yKGU9MDtlPGY7ZSs9MSljKG4uY2hhckNvZGVBdChlKSx0KX0oZS5uYW1lLnN1YnN0cmluZyhlLm5hbWUubGFzdEluZGV4T2YoIi8iKSsxKSx2KSxjKDAsdikpLGYuZGVmbGF0ZShuLHIpLmZvckVhY2goKGZ1bmN0aW9uKG4pe2Mobix2KX0pKSxpKHBhcnNlSW50KHQobiksMTYpLHYpLGkobi5sZW5ndGgsdiksdn0sdW56aXA6ZnVuY3Rpb24obixlKXt2YXIgbCxjLHosaSxQPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4sMCk7aWYoMzEhPT1kKFApfHwxMzkhPT1kKFApKXRocm93Ik5vdCBhIEdaSVAgZmlsZSI7aWYobD1kKFApLCEobD1PYmplY3Qua2V5cyhBKS5zb21lKChmdW5jdGlvbihuKXtyZXR1cm4gYz1uLEFbbl09PT1sfSkpKSl0aHJvdyJVbnN1cHBvcnRlZCBjb21wcmVzc2lvbiBtZXRob2QiO2lmKHo9ZChQKSxiKFApLGQoUCksbD1kKFApLE9iamVjdC5rZXlzKHMpLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKHNbbl09PT1sKXJldHVybiEwfSkpLHomdiYmZnVuY3Rpb24obix0KXt2YXIgZSxmPVtdO2ZvcihlPTA7ZTx0O2UrPTEpZi5wdXNoKG4uc2hpZnQoKSl9KFAsbD1YKFApKSx6JmEmJnEoUCkseiZvJiZxKFApLHomdSYmWChQKSwiZGVmbGF0ZSI9PT1jJiYoaT1mLmluZmxhdGUoUC5zcGxpY2UoMCxQLmxlbmd0aC04KSkpLHomciYmKGk9QXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGksKGZ1bmN0aW9uKG4pe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pfSkpLmpvaW4oIiIpKSxiKFApIT09cGFyc2VJbnQodChpKSwxNikpdGhyb3ciQ2hlY2tzdW0gZG9lcyBub3QgbWF0Y2giO2lmKGIoUCkhPT1pLmxlbmd0aCl0aHJvdyJTaXplIG9mIGRlY29tcHJlc3NlZCBmaWxlIG5vdCBjb3JyZWN0IjtyZXR1cm4gaX0sZ2V0IERFRkFVTFRfTEVWRUwoKXtyZXR1cm4gNn19fSgpO3ZhciBhPW4uZXhwb3J0cztmdW5jdGlvbiBvKCl7fWZ1bmN0aW9uIHMobil7cmV0dXJuIG4+PjJ9Y2xhc3MgY3tjb25zdHJ1Y3RvcihuKXt0aGlzLnRhaWw9MCx0aGlzLnNpemU9MCx0aGlzLmJ1ZmZlcj1ufXNldFNpemUobil7dGhpcy5zaXplPW59d3JpdGUobil7aWYodGhpcy5idWZmZXIubGVuZ3RoLXRoaXMuc2l6ZTxuLmxlbmd0aClyZXR1cm4hMTtjb25zdCB0PU1hdGgubWluKHRoaXMuYnVmZmVyLmxlbmd0aC10aGlzLnRhaWwsbi5sZW5ndGgpO3JldHVybiB0aGlzLmJ1ZmZlci5zZXQobi5zdWJhcnJheSgwLHQpLHRoaXMudGFpbCksbi5sZW5ndGg+dCYmdGhpcy5idWZmZXIuc2V0KG4uc3ViYXJyYXkodCksMCksdGhpcy50YWlsPSh0aGlzLnRhaWwrbi5sZW5ndGgpJXRoaXMuYnVmZmVyLmxlbmd0aCx0aGlzLnNpemUrPW4ubGVuZ3RoLCEwfX1jb25zdCB6PTYzNzcyMzIsaT0xMDQ4NTc2LGQ9WyJXYXJuaW5nOiBub3QgY29tcGlsZWQgd2l0aCB0aHJlYWQgc3VwcG9ydCIsIlByb3RvY29sIG5hbWUgbm90IHByb3ZpZGVkIl07ZnVuY3Rpb24gWCgpe31mdW5jdGlvbiBiKG4sdCxlKXtjb25zdCBmPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6MjA0OCxtYXhpbXVtOjIwNDh9KSxBPW5ldyBJbnQ4QXJyYXkoZi5idWZmZXIpLHI9bmV3IEludDMyQXJyYXkoZi5idWZmZXIpLHU9bmV3IFVpbnQ4QXJyYXkoZi5idWZmZXIpLHY9bmV3IFVpbnQzMkFycmF5KGYuYnVmZmVyKSxsPW5ldyBGbG9hdDMyQXJyYXkoZi5idWZmZXIpO3JbMjgzNTQwXT02Mzc3MjMyO2NvbnN0IGI9bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtpbml0aWFsOjIxNjcsbWF4aW11bToyMTY3LGVsZW1lbnQ6ImFueWZ1bmMifSkscT1mdW5jdGlvbihuKXtmdW5jdGlvbiB0KHQpe24oIndhc20gaW52YWxpZCBmdW5jdGlvbiBwb2ludGVyICIrdCl9cmV0dXJue19fYnVpbGRFbnZpcm9ubWVudDpvLF9faGFuZGxlX3N0YWNrX292ZXJmbG93Om8sX19zeXNfZmNudGw2NDpvLF9fc3lzX29wZW46byxfX3N5c19wb2xsOm8sX19zeXNfcmVhZDpvLF9fc3lzX3NvY2tldGNhbGw6byxfX3N5c2NhbGwxMDI6byxfX3N5c2NhbGwxNjg6byxfX3N5c2NhbGwyMjE6byxfX3N5c2NhbGwzOm8sX19zeXNjYWxsNTpvLF9fd2FzaV9mZF9jbG9zZTpvLF9fd2FzaV9mZF9mZHN0YXRfZ2V0Om8sX193YXNpX2ZkX3NlZWs6byxfYWRkRGF5czpvLF9hcnJheVN1bTpvLF9nZXRFeGVjdXRhYmxlTmFtZTpvLF9pbmV0X250b3A0X3JhdzpvLF9pbmV0X250b3A2X3JhdzpvLF9pbmV0X3B0b240X3JhdzpvLF9pbmV0X3B0b242X3JhdzpvLF9pc0xlYXBZZWFyOm8sX21lbW9yeV9iYXNlOjEwMjQsX3JlYWRfc29ja2FkZHI6byxfdGFibGVfYmFzZTowLF93cml0ZV9zb2NrYWRkcjpvLGNsb2NrOm8sY2xvY2tfZ2V0dGltZTpvLGVtc2NyaXB0ZW5fcmVzaXplX2hlYXA6byxmYWJzOk1hdGguYWJzLGZkX3JlYWQ6byxmZF93cml0ZTpvLGVudmlyb25fc2l6ZXNfZ2V0Om8sZW52aXJvbl9nZXQ6byxmZF9jbG9zZTpvLGZkX2Zkc3RhdF9nZXQ6byxmZF9zZWVrOm8sZ2FpX3N0cmVycm9yOm8sZ2V0YWRkcmluZm86byxnZXRlbnY6byxnZXRuYW1laW5mbzpvLGdldHRpbWVvZmRheTpvLGdtdGltZV9yOm8sbGx2bV9leHAyX2YzMjpuPT5NYXRoLnBvdygyLG4pLGxsdm1fZXhwMl9mNjQ6bj0+TWF0aC5wb3coMixuKSxsbHZtX2xvZzJfZjMyOm49Pk1hdGgubG9nKG4pL01hdGguTE4yLGxsdm1fdHJ1bmNfZjY0Ok1hdGgudHJ1bmMsbG9jYWx0aW1lX3I6byxta3RpbWU6byxuYW5vc2xlZXA6byxzdHJmdGltZTpvLHR6c2V0Om8sdXNsZWVwOm8sYWJvcnQ6dD0+bigid2FzbSAiK3QpLGFib3J0U3RhY2tPdmVyZmxvdzooKT0+bigid2FzbSBzdGFjayBvdmVyZmxvdyIpLGdldFRlbXBSZXQwOm8sbnVsbEZ1bmNfZGQ6dCxudWxsRnVuY19kaWQ6dCxudWxsRnVuY19kaWRkOnQsbnVsbEZ1bmNfZmlpOnQsbnVsbEZ1bmNfZmlpaTp0LG51bGxGdW5jX2lpOnQsbnVsbEZ1bmNfaWlkaWlpaTp0LG51bGxGdW5jX2lpaTp0LG51bGxGdW5jX2lpaWk6dCxudWxsRnVuY19paWlpaTp0LG51bGxGdW5jX2lpaWlpaTp0LG51bGxGdW5jX2lpaWlpaWk6dCxudWxsRnVuY19paWlpaWo6dCxudWxsRnVuY19paWlqaTp0LG51bGxGdW5jX2lqaWlpOnQsbnVsbEZ1bmNfamlqaTp0LG51bGxGdW5jX3Y6dCxudWxsRnVuY192aTp0LG51bGxGdW5jX3ZpaTp0LG51bGxGdW5jX3ZpaWRpOnQsbnVsbEZ1bmNfdmlpZmk6dCxudWxsRnVuY192aWlpOnQsbnVsbEZ1bmNfdmlpaWk6dCxudWxsRnVuY192aWlpaWZpaTp0LG51bGxGdW5jX3ZpaWlpaTp0LG51bGxGdW5jX3ZpaWlpaWk6dCxudWxsRnVuY192aWlpaWlpZmk6dCxudWxsRnVuY192aWlpaWlpaWk6dCxudWxsRnVuY192aWlpaWlpaWlpOnQsbnVsbEZ1bmNfdmlpaWlpaWlpaWk6dCxzZXRUZW1wUmV0MDpvLGxsdm1fdHJhcDooKT0+e24oIndhc20gbGx2bV90cmFwIil9LHRlbXBEb3VibGVQdHI6MH19KGUpLFA9bmV3IFByb3h5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxxKSx7bWVtb3J5OmYsdGFibGU6YixlbXNjcmlwdGVuX2dldF9oZWFwX3NpemU6KCk9PnUubGVuZ3RoLGVtc2NyaXB0ZW5fZ2V0X25vdzooKT0+cGVyZm9ybWFuY2Uubm93KCksZW1zY3JpcHRlbl9tZW1jcHlfYmlnOihuLHQsZSk9Pnt1LmNvcHlXaXRoaW4obix0LHQrZSl9LF9fd2FzaV9mZF93cml0ZTpqLGZkX3dyaXRlOmosZW1zY3JpcHRlbl9kYXRlX25vdzooKT0+RGF0ZS5ub3coKSxlbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3I6Y29uc29sZS5lcnJvcn0pLHtnZXQ6ZnVuY3Rpb24obix0KXtyZXR1cm4gblt0XT9uW3RdOlh9fSkseT17d2FzaV9zbmFwc2hvdF9wcmV2aWV3MTpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scSkse2ZkX3dyaXRlOmoscHJvY19leGl0OlgsY2xvY2tfdGltZV9nZXQ6WH0pLGVudjpQLGdsb2JhbDp7TmFOOk5hTixJbmZpbml0eToxLzB9fTt5LmVudi5vbkF1ZGlvU3RyZWFtPW4seS5lbnYub25BdWRpb0ZyYW1lPWZ1bmN0aW9uKG4sdCxlLGYsQSl7Y29uc3Qgcj1zKHQpLHU9W107Zm9yKGxldCBuPTA7bjxmO24rKyl7Y29uc3QgdD1zKHZbcituXSksZT1sLnN1YmFycmF5KHQsdCtBKTt1LnB1c2goZSl9bih7cHRzOmUsbnVtQ2hhbm5lbHM6ZixudW1TYW1wbGVzOkEsYnVmZmVyczp1fSl9LmJpbmQobnVsbCx0KTtsZXQgbT0hMTt5LmVudi5vbkVPRj0oKT0+e209ITB9O2NvbnN0IHA9ZnVuY3Rpb24obil7Y29uc3QgdD1uLm1hdGNoKC8uezEsMn0vZyl8fFtdO3JldHVybiBuZXcgVWludDhBcnJheSh0Lm1hcCgobj0+cGFyc2VJbnQobiwxNikpKSl9KGZ1bmN0aW9uKG4pe2NvbnN0IHQ9YXRvYihuKTtsZXQgZT0iIjtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7Y29uc3QgZj10LmNoYXJDb2RlQXQobikudG9TdHJpbmcoMTYpO2UrPTI9PT1mLmxlbmd0aD9mOiIwIitmfXJldHVybiBlLnRvVXBwZXJDYXNlKCl9KCJINHNJQUFBQUFBQUFBK3k5ZVlBY1ZiVS9YdmRXVlZkMVYvZDBKWmtrazVrc3Q1b1FKcENRQ0dFU1FzRFVRRGJDRWdWY25rdUlTVERwaENRekdRTGlaR2FBZ0lpZ1FVQlpWTUlPa3NncWk0Z0dWMENXaUlnb2lFRVdJNEtpNHZ2NjlBbmY4em5uVms5UG1JRHYrMzUvL2lhWjZWdTM3bnJPdVdlNzU5NTJscXcvV1RtT295NEpUanZSN2UzdFZiMG5hdjZyNUk5em90Y3IyVDQrNmRubHZ4cC9KSXZlZWZMS29hVGpuSmpyemZKVnQrcW1DajI5cWlmTGRVNE1lck5VM0Z2L3N6SHJ0NmRXUkpyZUtLUG9rVkgwMEk5MGpVL1ZqYkgwVUIzOGxjSDNuS2g2cEhQSzdjWVExRWExRWM4MFBEejEwcCt3dDc4UHpVM1R4SHA0WWhoemQ3ZDg5UFRRaDBkZDJabFRrMjQya2w1NTVvbjFjTlVlTHRSakc2TjNQSHJxbXo2N3FZVmFwMVNPcHNHanh2Z2NTcFhrVFRmOTc4NkF0eEZqM1lqaDB5QjVSSUIwRDNmYW5RRUlBSkZKQUV6ZGFGeWhDQSt3eDJKSHhvUWlCUmx1UDFaN2VybGlULzlrTUkrY2xLRWlZVmFlMGpsSlU2clFqempHaG9WUWo1MTFiM2RHRmpSK2pHVGpSdWZFdkpTWDhkb0dldm9wQ0NEc0VRaHp0Vnp0clpabWUzcjR0ZGRqRVNGRHh0RHhPbDhia01DZkVkakwrSS9xeU16T29wdEJrdU5FQm9nZWdSSXdGZlgwZE9QSDFzajNDcng1V200dkl3MElvYUZ0bERVRENzTUxCOWpxNFlsMDg3Z1o3aUNNSHJ1Nm1HSTNPdnhTaW15MDVDMDQ2eEY0Y0hGOVdiQzN1M3pOaHVMYU5la3B5MWF1bmR1NTVPVGx6bXhrbFd6V2NWMmR5NWVjN09TUjU2OWRNK2ZZdVU3RTZTV2ZXTnZaSmVub2s4dTcxbERObFd0T1d1c015M0tXTEZ2V3lUa2Vjc0wxWFowbmRhMms1dmx4eU9MRjZ6KzFmdW1TMWFzWG43UjBUZGZxdG1tT00rTFVKZXRYTGw2L1pzbTY5U3ZXZGkxZTE3bDh3OHJscDc0blBHblo0cVdyMTY1Zjd1ZzlsQWlvQkkxeW1lTzlReE9uZHE3c3NwMFBYMzd5K3FXZEs5ZDFMVit6K09UbEp5OWQ5Nm5GbjFqNVNTZUhkOFBxM2kxYjByVjg4WnExcHpvSjNwakZkYTlvZm5pemVPWDZ4U2V2WGJPMmErMmFsVXVkQW9vTmZYc3BKOW5EdUlaUStaV2RhOWNzWHIveTlPWHJVZHhSZXlnYVpVWGZxVkNKNW5uU3N2VmRTN3FrR01ZVDkwTjY3YnJsYTVaMENRd2ErclBYclYyOTJuR1EyVlEzOXFWcjE2eGZ1M3I1NHVXZG5XczdIUmV2ODR1N1RsOVBVNnF1RjFpTnFDdmV1Unh6V0x4aStaSjFqdDROdzB1V0xsMitybXVhVTl5dDQwK3NYTE5NTXVzS1U3OXJsaS90a3Z6Ry9ueWEwUHExUzFldFhXZGYxYzFyOWNyMU5BVEpIdHFmM2JsODZZYVRPdGVlL0xieTY1ZXZXZGExOXUzWjFQeHkyL3JJeFl0WExGbXpqT1pQMEZ5NmF2SGFEY3M3VDFwTnFIVGZnUWJYTDErK3lnbFJ2YkQ0NUZVZ2RvQ0tvVkZhdkhvdGRaTGw1YVRRSjA4ZWtKRWpZbHpiK1NtdCt1SysyRDJ6MEZlSWNtNmtDNFdDaXBUU1ExTkZmd2xUQ2pMVmNjS2c3T2J3RUFSYXFRYWxQYjJYZGtKSDQwZnB2WVlGYmk3bk5yaktHVFZVVXozTzE1N25EVlZhTnl0bm1LWjJHcFJiVU1QSFI5U2VGdzdMcVJ6MUVEaXE1WEJINWRHSjFtamNWUzJPdTU4N2ZIaEExVDFIVFhJOFIzNG01Wnk2bnlNY3A3bittUWRLWGMrWk96Q3I5aE02dFpheW4yWWFaRVN6RGtLYWhGWTUzL2U5Z0NhdStNZlRNdnVHZVpybnBKd1EyU0ZCUWZFVTFWNTVtZ1A5ejg5SEhUOTA4YjdzeWo4cVUwUTVML1MwNTlLUHl0R0k5YWlnckttUFlJRTNhdktSdy9mZlQzbkttNkpkclhQT1ZGZmxGeDdsNWJUakJVY0RybTRCMVFLRmNWTVY2dEtsVEtCR3VmU09xbUxZK0krT2p3RitsQTRjREp4eWFialVMbDZyblAwSG5PWThGQTV5eFZ6ZWRZa2FDS2VPRzdsUi9ROTFtM01IL0J5YnorZjluRm8wWkVoT3Y4OGxmTHNlSWRpbjFmcWV2TTYvMy9YY0lxQ1VMNGJPVUtHSzQ2ZzNHai8xVlNoNzViS2Z5K2ZEUWtBRHo3dUVHUTNzMEg4YWpJTi9IZzB2RitSeU9RSWpUNVJwd2RYQjBLR2o5ejUrOUFsRVRNTkQxL0dtVkxSRGsvSkFqSUNDOGdMdkF6cWZiMnpNNVgzL2dBT0laZ3NNYkdvMFVLQ1lIS0U5Vk40SG5YSjhvSTUxM3FXQjVQSzVndjdRaDZmOXgwZW1mYlJBcEV1ZEVhMjdEQjhBa3lybDhoUGNqMUhhK2ZpRUU5R1lLaW12U05oM25DWERxRXdZRHYrRTUrM3RGVDAzVjZTQjRRM2h3L0dHRXZqdGoxTlFTM1BMSkIwT0s2Z2dvSTRLYlczVXFDWlNLdWlRNXB0elBmL2YrRm5lUEZySGZqNi8rNjhidWlQRHNQYS9NTjA5cWFpZFVjV1dUNFlPNmdFV1JHODZEQUxxTFN4bzNlQ1U4RE5tN0JnZDZySGhpbjFLTTJhc0hEZTJSS0FxS0hWUXFWSXBtZGFraWY5VXh4MTg4TGlacFRFbHArU29RNGlhSENhNWlDWTBkaFVBaGFtTldWMmg5b3laMlVCME9sU3BwaVpDbjl2a3FRSXQ5YkZtOU9qU3lmdTBOcWxDc1ZpZ25OSzQwaUgwNjVVYzNTRHJqSUFPc051MDNsK1BtTGhteE5wOE9XN0pUOWgzMXI2MGhQWXBsU0pGTEVQbjE0MGY3enVIQm1NSXA3T0loUGJHa2lkQThxSndnaEVURHp0c1JFZG5FQlFLRTBlTUdMRytpK2JrRXU2TFhwRldiVVRjemFYL3VzQVlDVTdaTUhucXZtSHhRTTg1ZGVoNzMwc0xmNTE2UmoramMwZEV2U3J0Ni9QdzRkVC9jZEliKzJKOC9KZDgvUENNdUM3ek1UelZDZ2N2ZUJVU05jVEJUMTRzd3FacmJlZDZaM3h4NVpxVlhZdVhMVis2ZHRueVRxYzFodHhldVdiZEtWMkxQM0hLU1NkUjFzUlJ1MmRSL1hWTGxxN3MrcFN6YjM3ZEtldFhRRmxZNGt3cUxGMjlmRW1uUEV6MlRsNnljbzJ6LzRqRnBEa1FrMSs4ZUlCTzVYckRkMy9CK3Bmck45VGxrOExsNWtZdHByNlhyU1NCMXJYNHBGUFdMTzFhU1lwQTE1SlByRjVPaStKa21zamFwYzd6ZVJKbEpLelhyR1ZSZ3lMT2VhRy9nbFNUOWM0VFllNmtrMWJUTUozTkJjNWE3VnhVOE5kMHJWMngzcm13RUpGUVAzNzV5ZXZldjd4cnFuTmVvVjQ5RXVrSDhEam5GRWE5N1FXZ2NsTG44dVhPWi9idzhoTkxTRzg3dDlBMDZFc1N3ODVuQzNuT09HN0podVhPK1lVaVA3eC8rWHBDekhMbmdrS0JuMU9lNGVjTG93ZHRadWtwblozTDEzUTVYeWlVRmlPN3MwdkE1d1pGUEs5ZFp4OUQ2QVpVWG1xdVhubnl5cTcxemlXRjRySlByVGtjeEZCZFdWM3BYRkVvWmM4clZ5TGpLNFdHTEdNRGNxck9Wd3RSWFJYbmEvV1BLNTByQy9tdHZuSlNGZjFLN3oxaG4rbS96Yzg1NnVnZjZnOTg2TmlQYmxKbnEzUFVaM01mWDN5dHVrN2RwZTVXOTZoNzFmWHFCdlYxZFpPNlEzMUwzYSsrcTdhckI5VDMxUGZWRDlRUDFUWHFRZldRZWxqOVJEMmlIbFdQcWF2VjQycUgrcWw2UXYxTS9WdzlwWjVXdjFTL1VzK29aOVd2MVhQcU4ycW5lbDc5VnIyZ1hsSXZxOStwWGVvVjlRZjFSL1VuOWJyNnMvcUwrcXQ2US8xTi9hZjZ1L292OVEvMVQvWGY2bC9xVGZXVzZ0Tm42RFAxV2ZvYy9WbDludjZjUGw5Zm9EK3Z2NkEzNnd2MUYvVkYrbUo5aWY2Uy9yTGVvcS9TVit0cjlMWDZPbjJqdmtsL1hkK2w3OUYzNjIvcCsvVjM5SGI5Z1A2ZTNxWjM2TWYxVC9VVCttZjZTZjF6L1pUK2hlN3FlRTMvVWY5SnY2Ny9yUCtpLzZyZjBML3pkbm5QdXI5MkgzS2ZjMy9xUHVIK3pIM1MzZW0rNHQ3bXYrYnVjSC92dnVyOXdkdmwvdFA5Yi9kZjdwdnVoZDRYdmE5NVYzcFhlOWQ2MTNuWGV6ZDROM28zZVYvM2J2YTJldHU4YjNpM2VMZDZ0M20zZTNkNDMvVHU4dTcyN3ZIdTliN2wzZWQ5Mjd2Zis0NzNYVys3OTREM0ErK0gzbys4SDNzUGV6L3hIdkdlOHA3MmZ1RTk0LzNhZTg1N3lYdlJPOU0veTcvRnY5Vy96My9lLzYzL2d2K2kveHYvSmY5bC8zZitMdi8zL2l2K09ibnpjMS9NWHh0K0w3ODUvN1h3Z2Z4RjRZWGhGOEpid2hmQ0I4SWY1bDdQdlpuN2ZlNHp3Ym5CbDRNcmd5M0JWY0hWd1RYQnRjRjF3ZlhCRGNHTndVM0IxNE9iZzYzQnR1QWJ3UzNCcmNGdHdlM0JIY0dkd1RlRHU0SzdnM3VDZTROdkJmY0Yzdzd1RDc0VGZEZllIandRZkMrNExMZzh1Q0w0U3ZEajRNSGdvZURoNENmQkk4R2p3V1BCNDhHTzRLZkJFOEhQZ2llRG53ZFBCYjhJbmc1K0dmd3FlQzU0UG5neCtGM3dtK0Mzd1V2QnJtQm44RUx3Y3ZENzRBL0JxOEVmZ3o4RnJ3ZC9EdjRTL0RVNFAveDhlRUg0cGZ5WDg0L25kK1NmekQrVEw1ejVpNUdrYVRyeE9ZVjRSeGlmbDQvTzBlN3czcERNeDczSThrbmp4RE91OFZZbHZ2RXJJL2JLTHpRajlpb3M2UFJtbXhIeHVNaU1HTzhZM3podHVrZ2ZxazJIeG0vVllaSXp1WW51aXFTcGZWZVFqREpOWmxSUDBvdzN4U1F3UWF2Mmt0Q0VyVHBPOGlhZkZFeGhhOUppbWsxTFR6SmFDa1VtUXFHaUtiYnF4cVJrU2ttRGFkaWFqREdqelpqZVpDeDFOWGE2NjBoWFplTlBkSjFrbkJsM2IySWtLelp4cTk2cGt5SHlPTlFNYmRWSEpjTk0yUmd6eEF5TEhacFZJelhTV0UyR20rR1ZrWmpWU0R1cmtaalZ5UEZPT2JyQVZWTjZDUWFLU211ampGNlZ1TWF0N0kvUys5dlMrNlAwL2dRRGwyR1FPZ0l0Z29PZTdjNDJMcnIzOFZFRVNGcjFOSnEvVDVNUGFPYWh5YzlQQ3FtaTJSWk0xSUhaemlrcEtVeFRidFV6YU5iY1FqbjFhRTVsRTNmUmxCck1rQ3BOeVRWRDI3U0g5eDdOYkJnK0drMWpxNzVWWVU2dG1xeE9hbnFrR1pFMG1aR0NnN2xKTTJVeHBEdVMwWHEyR1QybjVFZ0xZK2pGV0RQR2pBVWl1Yzl4OG9JZ2hxZkVKQXpSaXVUdVpmWkM3bmd6dmxVL3E1TzlKWGVDbVlEY2ZjdytyZnBwbmJTYWNhWmk5amF0c1lxa3pZblV5NzVtb3RtM211eEhFOWlQd0ZSMElpY2lBRStpNTBuVlpMS1pYSmtDQUUreEFKNENBRThCT253bjF1WG9xMHJGZ3lDbGpEcGxXNmVNT3VVYVVnU2lYcnJ6akJoRWJMejR3T1pVSnpsQ0ZoR2p5YlhwcjV3WnAyNFNVZ2JSb3duYjlCYktVQU53UTkyVnFMMVNGWlJZaWRGZGJMdUwwVjFNM1JYTFVhUFN2ZFNNWTV4Vy9YZnFUeGsxTVBQVkxITnY1V01lSUVWbEhLTldKWnJLdUVZYk55TWtyeHg5VHFraWlta3F4dTlXSWI5U1JQOUYyMzhSL1JlcGYwK202OGs2OURCckh4KzBISG55bUsxdmN2RnNJa0FQMC9UdzFrdnkxSGlCY2dwVkxMeEtDWTJYYk9NbE5GNml4dlBscUZtNXZkeVFRL1RJZzY0U0RuUTh0eHlSZ2RvYjc0ZW5jblN0VWtNSEdmTlFORHZVTmpzVXpRNTk1ekhMQncwNnZpcFBJNmFSbXpDK09rL0RkV2k0ZWFDRzFneE5mVzVTSWt3MW1KSnA2S0MxRXROYThVeGNwYlV5cERJTXZRNnp2UTVEcjhPbzEzSTV1a1NwRVc4bnBBRUUwNFNoR0g4RERZVnpnalRFMGpYaEJocEQzNXN1Um1FS0hUU1FuSWs2RTF1dlJLVjRMRjAwbHI2Ky93NWs2WGJRY0lwbVNDZVdMb29ObytZYnpURFQyRVhyZGFnWjNwbU1NQ1BLMFJvZDl1cWV0eE40Z0hrRWRoNEI1aEhzVHVER0F4OGtDbzRQSU5JRnJidkdyNEx2VkVMVURtM3RFTFZEcWwwb1IvY29YZXFOQnVsdmNBcWovcWE3b1hFbnVwaGp3dzNvTko2S1ZZVnV0aVhsZGtkbTI1ME1hVGMwMVNGbTZEbkVucmhDSStVTU40MW0rTG1ZNmcyTTJha1FCQmp6Tm1KVnc4eklUVWtURTZQN3pzVFlWSTYrcU5XWVFhaHNETXFQc2VYSG9QeVlqTXBDb1RKUDZNb25Lc3FCcUdZNnJaYlNLSWZSMjZhblNZNmxORk5vMDdNa0o1SVZ3MlFYVHh0QWQzbzJjZFJ5eVVtditXWXVpYW5tRUJPYklmR21mRE9saDFMQllZVG1ZUjJFZE04MHpuVEtSUlZSNW5ENkhXR0dteEVkQkFEUGpLUVgxTWRrcDB5QVVNSzJPNGh0eDhTMlBkTlNKUUU1dWpJV2N4eHI1emdXY3h4TGMyd3VSN2Y5YjFkZWFnUW1iZHFSbkNEMUJDWlZRaEpEZ09FUnQ4dnJpS2JHc0pqcGpLZmgvajhzdzE5NWFyNE0yZFFQZVQ3S3o3Zmw1NlA4L0d6SVRUTGtSb3lnRWFUSE1vKzRCWVlkU3k0ckdjQW1QVFZsVE4yUmR3WEpKT0lDWGoxNUFzTXQwZm9zTVVpZ21SQjVBOU5sa2laM3V6SVYrNjZJR2NYLzVSSjVjMTJTdnBERnRqTVd3aUhoMVFGZU13RnNtdVlsb3dnNnpXYVVhZTVJV3BoWVdvaFlmbjFuTGhsTlpWbTFzY1F5bGdxT00yUE51QTRTdng0WjhjNDRJaFpwbmdWeFNIS1lCN2tYQ2RpOTRqZTlaRHhWMjl1TUp4RzhOOG5mQ1dhZitVa3J0VExSdEpxSkhjbSsxTm0rSk92VFM2bTMvYWpvSkxPZm1XUjdtMHpsOWplVHpmNGR5UlRxYlVwOWIxUE5WUFQySHBuMkFWVDZRUE1lYzRBNU1IN05TNmJSNDBGbVd0Sm1Ea3FtbXpZemZYNHlnOW82Mk13d0IzY2tNNm5QbWVoengwMUJjZ2dWbldVT01iTnNuNGRTdWNQTW9lYXdqdVM5MU9kN3BVL0tuRTIvcVpsdDBvNkVTTXkwMHd0ZUR1T1N3K25ORWVad2MwUkhNb2RvWlM2OW5WdE41cGw1bFFXZ2xRV1dWaGFBVmhZUXJjd3BSejhyNmp0VnhrMzdWRDE3dTBPaEV2MlZXbmNvVkx0RFpTejF0UGhLbmJCeWRacW9ERzE2cWp5eEZqYzE0eFhRNG1SRnpFc3dmRjRMSFVtSjBWdWl5Vi8zb3lCcG9MSmxVdHZLZHZKUUxaZzNkSWdhTjlQcHhlUzNHekJLTTZ4TmQ2R3JMbEJTZkhXT1dLWnJocmZwZGNoY1J6VEY3MGJLYUpxb3VWRzBSSnZOQ0tJeGNBc1EyS2g0Q2JFTExrRHN3clMwNlVueU5NYU1hZFdUU05Iako5S1lNUlhTOEtEMnhaTEo5RFdWNkt2QzlFWHRqemQ3bWZGdCtuaDV2N2ZaRys5WjFZdVRmZWg5cTluSHRJSmw4dnVKWmlMZTc5dXVrbThxczYvNXBwcnU3Z2psM1g1bVA3eWJaQ2ExNmdkRElydytTM21kUkhtVHpKUTJ5cFdTVTlPcFJIUlR6WHVxbHVpSTVQQXZQc05OcUNNenJVMnZadXB6elVGdGVrV21hNjhnV3VUNjA4MTA5RFREekFBVkgyemFrcG5tNE9RUU05TWNzaUNaUmZBLzFNd3loM1lRRFI1bVZlN1RpQkRmaXpxenpleFdQWnFJa050ckowWHhjTk51RHU4aTRrdk5FZFZranBrRDFqTFh6R1crUXdTSXgvblU1Z0l6UHpuU0xFZ1dtaVBOd3JuSlVaUjF0RG5LSE4yUkhFUFVjSXpWdFZja3g5TElGNWxGNXRnMnZmMGY1YUtPSlB0OVZQNzk1bjNtL2RYa09KclhjVFF2VVk2ZDVIaHpmQ3ZLSmlla3Zja0h6QW5KQjgwSGtnK1pENW9QelUwK1ROWCt3M3pZL0VkSDhoSHE1aU5ZY2c5ODMwOCtTdlUrWmo1cVBtYXA3dU5VYnJINXVGbmNrWnhJelo4b1ZJZXVWeWRMcU9JU1ZOenBKSitnbDUrb0prdEprdCtsekZKekZ5SFFTWjkya21YMFlsazFXVzZXMjd3ZFRuSVM1WjFVVFQ1cFBtbnpIblNTRlpTM29wcXNOQ3R0M25ZbnFWSmV0WnFzTXF0czNveGtOV1d0cmlZbm01TnQxdFJrRFdXdHFTWnJ6VnJKb2tkOHRxYXRDVkcvV1ZkTk9reEgwaWxqWG85MnUweW42VExyNHhuSktWVGdGT0x4NmRPUDVaSU5ab054N2J4UHBYbWZaazQxcDNVa242SXluK3FmOTJuSjZlWjBvUHpUNXRNZ2syN0ozR2cybXU0YVBmZVlIbGh0dmJUSStwVHBOWDJxS3psRG1UTlUvSHcrT2RPU3psbkswUDh6U1NyTmtJeE55bXhTYVBwc1pjNVdvS2R6RkkzbE04cDhSZ2ttejFWRVdaOVY1bHhsUGt0Tm5xZk1PY3FjUndyMTU1VDVuQUpKblUrTm0vT3B6ZkhTNWdYS1hLQmdGSDRlVFgxQm1TL1lwallyR3R5RnlteFc1a0pxNm92S2ZGNlpMMUpURjZHRmk2Z0ZneFpNY2pFUGQzeHlpVEtVdkVURkJ5VmZVZ1NlTHl2ekpXVytyRHFTU3hWUndxVktLSFY4Y3BreWwvRllMa2RMbDFOTGNYclA5VUZ5QlpURnJ5RHZLOVROVjVXNVFwbXZLZ0RjQXZacmFQWktaYjZtekpVS0NoYm5ibEZtQ3pVM0s3a0tNN2hhbWF0VWNvMHlWNnZrV21Vb2NhMmFsMXlIbXRjcmM1MHkxOU9BYnNDQWJsQjI3WnlXM0tqTWpkekVUUmIwWDFlRy90K2tocmdPR1BETnFMNVZtWnVWMlVyVnQyR00yMmdFdlRTd3lVNXY4ZzI4djBXWmJ5aHpDNzIvbGVYQ2JTaDFHODNrZG1WdVY1VTdXVGJjbWNtR08xazIzQW5aY0N2WmJYOVVhbFF2ZTBaTXZXZWtHWFdhYlpWbTFHak9QQ09qeFRQU1JCOGFlb3NQZXJCcVZveW5lS0NhNVlNWUMvaG9KQzBsRHdNMFhwREF2MUprTjRzWUdRNDBMY2dWVWJnWEprTm9acXh3ZHlURFdQNE1BOVM0TkVtU1pEaGt6T25RdkpQaEVSUVRHaitHMUZRbExYTlVwUVhqYjdIamI4SDRXMmo4STh2UitVcEZ2Vy8zQkExdUgrem1DY0o4UFF6QnczekYrOE1lbVpBc0pwcHQvSlJ2dlVKaWd2cnZhb0wrMDlVemUxMlI2TFQrNnlUNndhaHlzSzF5TUtvY25FbnpXU0NWV2RBckp6dXRwT1FxZ1g1SEVqQ2NncEpqT2NJc2NVdkJpSEpOM3E3bVdXUk1PZUlIZ0E3Sk9ld09ZRHZQTlExVktJbndETVFFMGlHVXcvNlpvY2doMVJBMjJTRWs3UThCanlNamlINVpvbGVCQ25pZ0JCR3VSUVJ5bWswemFzMGlrVDZMMmVCRTE1REVjczJoWkh4UmZaTHRZZ29VemVoNFpqT0dOSU5rTzQ5c0xPbU5ZMnJqekVROFRZRGtQRW4xUkZUR2VRblVkVklZemQ0ZHlRU0N3UVM3d21hSjkyWUdhWStPeUhKd21IMkpQUGNqWWI1ZkZ3bnZWdmJUMERCWWRGZEpkRStKLytGSzVYcTViUTZJYjdUWkpMa3hqR2xtV255V2F5RjlFSFZBbXFOcEkvWVFBWmZUYVZiVHE1RFpsWm5BNVV5THk1bkE1VXg0Z080STljYmVYQTliQ3p1Y2VuTmhJeXBzdEJVMm9zTEd6Rnc0S3I3WEZUdStUYytQLytobmxzSVI3UDd4VE5DbVo3TXl4eDZSV2V3RDhoajVyRldRNGp1YkNLQTc4emFJbFRDUGxEb2xTbDBIdkkya1JMREI1NWtoSkRuU2pUQU5ZQlBNeWxvWVJxOTVGV0pkbHRnU21aV01JR2srd0VFM0Q2aVg1ZGxDN1pQcVprWjNKR09venBnNVV1a29RakI5ekJmN0lENUVEQVNhZ3VTeTlrWjRwdDdZUlFma2pUZVZ6RFF3RSthUnlxWkVaZXRJSmxLMWlkUXdWQkFlSmRzSldVZXNyYzBnaEhQTGs4MWt0THcvVWNJVXM3K1owa1cyd1NRenRRcmJ3THpIV3N4SEVkWTlpTXNEcGRJMDF0dW14WVJ0S2tXYTJxeUlWbHJFbVBkTUc4Rlk0RE1ybVU0d20yR213M2lBcW1abXpoT2JnVlcxUTBSVm01VzhsOFozMkp3TWZMUFRIdGdLWkNpa29xUE5TNERVT1ZSbnJqbkN6TzBnNVd3T3FYWHpiSTBacEtVNWI5UFN6RkhKZXlQejN1Um9xbmFNT2RvYzA1RWNTOTBjYXl0TkkxV05QbzRnOVN3bTlVeUplblljMW1jdnpZR2VTRGt6dmJLNFQ2RDNKMVJKUS9zQTNwTys0T0h4ZzZTbzliRStvNUI5QnJMUDRPZEZwTzU1OGFHa3lubm1Rd1FOQUVmbTltRWlEZExxa28rWS8wZythajVpUGpvMytSZ044T1BtWStiakhjbGlHdURpR2tXY0tPTmNJakQvaERuUkxER2ZJSmd2cFZhWFdzL0ZORkxmZUJyTGFSb24wVEJGYThONHpsUnBFeWx0WHFhMDBadXFxWkkySTNOYVJZVlhWVWxkVzQzQ1o2SHd5VlQ0NUNxcGEydndCdXJhV2YzVDI0VHBiYUxuSmlxNWp0S3N0aTBqcmJHRFp0cEpHWjAwVTBMRWVrcXVaNUpnTGZjSDBPWTgwMVVsVmU0VWFIRHg2ejdVeVZNcDg5UXFxWENua2Y3MnFmaGJycERxNmVBQW42WjNuNjZTNHRaZDZRRUg2TEVjb0FjY29JYzR3T25sNkJaWEhUQ0lUK1FBbEQvQWxqOEE1US9ZZzU5SUpIUy9OMUljQzdsKzArL29RVXcvS05QZEpCNDgwMEFDMGRyVDJLc29UM2JHRDdBQXhURUVWNkE0eCtabWZuc3pzaU5wb3JhYXBLMVIxTmFvK3JhSVZZQ3B0b2hIaW5sRmZLRkxjc0FUQWVCaG9HTlQ3SXlNSlRZeERoTEFKUE9KT1NnUkFoM0plR3ArdktXakVLWWRCamVCM3JNTG9ZTjR5V3pUbXIydU9lOW5PdU1saHpuRWJOaHpRNERCYm1JU25wa3NZNlIrOTZlbi9la3BFdS9CRkVMQVZNcGludkdleW9GQXdJRVdBUWNDQVFjU0FxYVVvNjFhalJ0RXdUSW9iMng1Zy9JbVV6aWFST0ZvRklVakZzMkpEZlZRRkk1WWxLdjRSUmZxRlppN1ZhTUtwQkVOWU94ekJ6QjJ4bVVNK1BkaUx3bk1mVFRnejNXSDBoUUhZRzcrWUppVDdtR1QzK2VtdkFsbW12dGJnVnV2Qlc4YzdIeVowZlFtRXYxd0RNMmU5N21xRU9LVkJMTlA3T3dUekQ2aDJZOHBSNzkwOVVHaUVMa2tlK3ZnMVlZYWJiWkdHMnEwWmZCcUZYaU5SMCt0QXdBMTNnTHFkelZBOFk2YStmY0I5ZWtNVUpQc0ZNMi9DU2pxWUJUVkhOVmZzMVZJdkVpeUVPQnBnWTlNTnFubUplT29BYUpwUS9aZ1FnMGtGdEt0NHJnb0VvSHowM2laMU41RWVoTm83VStvUXIwQmw1cEJuQTFnYUsxQ3k4R0xmVW0vbVNFc2J6OHF1bDhWZEkyaUIxUE9aQ282dVVvVXZUOWVrTVpqRGdiRDAzZy9rOTdORk1Wc0tpV1p2RW12TXU4eGV3M0pzZmwrQUdVZlFQUGlXVTFLRGt5aEN2bG1XcFhFNGtHVjZVRFVkSXVvNlVEVWRFTFVnZVhvVmEzMkhXUWg3SWZ5KzlueSs2SDhmdSt3RUloenBVQnViaytiam95NkloRGdEUERmVWh0bDZ3cms5UlNUNUdlZVJjcHQrdnl6bnJpejR5bWswU3BCYXdkcHRMNFpNZE9odW5CZ2o2UVg3UHJzU0VaUkg2TzRpL29kU0ZCOGZ4ZE5SUE9PNEJjY2huT0k5T09ESldtb2YrWmdWZUE0UGdKY2pIN1pPOVZCdk1zM2U3T3owSWV6c0o2SEVmUW0wdHVKak9MS0pFQnZrb1hlSkVCdkVrR3Z0Unc5cUhXU0xhUUI4SzZnUnNYV3FLQkdwZCt5VTlrZVFnczZiaUZEVHNrUzZranlOT2U4a09WbzdISEQ5aGdvS09BaGxOY05waUZ1YTdaTG40UUU4R2EzRUdEVENhd1hEZ0ExVlI4eEo2cy9rZ2k4aWFoV2JBaFE1WGd4N1dnRm1mRkMxUzMwWGpZUThCNEFvNmN4Qk82OWE2UThnVEluNEdtazhjbXdpT3lBeUtiQWdNWVJYSWdkR0ZPRm5sblpDM0RaeThKbEw4QmxMNExMdUhMMHJLZm5acERjNmRTRGNoNnF6TE5WNXFIS3ZBeVVIeExTUFY1SWR4RTYvaENScmdmU05VRTFDU1VuYi9JWVNvSG91QkRQSXlMMllaVWRKUzg1WEtDSitKTVB0WWdKdVNxRVRLcS9GT0UxTVY4Q0E0NG4wTVl3bU9QRFNEOVhzaHZYUVFEMnpmQ1p6anlwUUVZYWhHSTlMWXNiSDFRc1VuZHUvKzU1UnpLTzE5TTRXVThNclRiOVVVdmhIeUs0Y2ZjVjZaNloxQ0l5eFZxRmZxdHdxeExkSnFTZVYwRFhjVHJBaTA5bFNQanVJMDN0UjdCaE56NDJ6Yms1dHNmaWhmSjZDdWh4SGhsa2NmSWVRajZ6b0NvTU1kaG0wNmpIZ3lqbm9Db3A0bTNJbVc2bWd3QVdtR2xtZ1pBTE9DUXRQWE53bFRqY1RET2pTZ3A1Szlta3ZwbFZKWjM4VU9RY1pnNURyU05KUXorUzR6RW11cTJrV1B0bUlmaWhJdDE3cW5sdkJ5bnFJU25xdmttcnBLdFBNYk5OZS94ZTB0aDljempCaGlIelVkTGNpVlRtVU42Y0tueXJlOWdBT3FJY1hlYTVCL1NHUFI2aVUycjdWYXVnbUZVT1FwMkRiSjJEVU9jZ3FoTUlad3lFTXdiQ0dRUGVaYWNQaEdwQXB5c21JVFZtZFRwaGp2UEp6RmNpN1RxU0JzWnJnK0MxVFBtMVRkM0FETEZNTEFCcERwWFdlTVZXYWNXZUtDc1c1bjVnUmtDdDVQaVhrWVErSmloYXNla2pqL3V5TTBUc2RERERqMnVNSlZTeTFWY0ZHNHpmazB4SGNBMFpUV1pHTDJIcTRIdmh3WTQvbjRjSCs3SWtQVUxDcVhjZUR2dkl0Qy9GbXAyVFZIZ2FGV3B6OXEzQWEzSUlEYnk5TC92cEpRVFBTZzZKekNHRTRnQnNuOHhJdUIzc0dNYVRUczllQXlaVkdzTmhVb3FrcWprTU84TUJWSWxXeVlSZ2JZWExrUFJHK21VSFFnZlJiR0FtMmYyZTNUYWZBdDU4SWppQ2hVK2xOK3hLNkVnT0lNd2NTRzhQck1LRnNBZk41b0J5OUFXbFNvT28rb003ay82dHdJUG44d25vV1BhQkVZQUFBVXE4UEQ2Y3VpQzkxa1JWY0oxS0E3cG9zRjAwb0lzR09DeWUwYXFDQWVWb0FzekhWc0hCVkptQTBoTnM2UWtvUFlFR0ZJcEVDY1ZYR0lxdk1BU2R4dlRoWWJBaG5CanNvaHJOKy94SElJa2RUYzZ4TzVveG5wcG9XSnhaSWk1WXRKV3dxUmxhQ1FPN3BCRlB4YmNMbW5sdkV6UkU5VDRwYktFWnlmbzhWMnVTdHVDemF1SVJzMUZDYlZuR0tGdWE4d2JzWmxKYmh0cktFVEdHSnFGaFJWS3RJbTJCMkNvRUJBTFhlQ293dmdxYnBMSVB3TFdQQmRjK0FOYytBTzRDRmI1TC9JYVQrWDJLZFJGWWtDajhSQ0NCODRkYU9rdXB3aUF1emdqOVJyYmZDUDFHNytEaUxJcUwweXJTWHMzRmVWMkkzWHZXcHF0UUF3YjNuSmFqOTZuOC8zUTY3TUhLWVJLZW5SSjdyMExvN2RUaUNUS3JnYXRoTUtyM1lTbldxTjZLVzM3SDRqWVVjYnNPQkZhT0hyTmE2VHMzR3c1bzFrYjlGUWZhelFzR3Q1dWxPbSsvWTkrMG5NVFc1T1Y5ZDdhOHlKaUlJNkxZWWRUanNGb1lVNk1VNHVpM2tOZ3RQNDAwSTlGT0V4a2JUYXVJV0JzejJXMWFGaVNqcVgrbTBvNWtMUGMvMXZidlFmTk1USzNqK2wzM29yaldvR0pWelBoVklOR0U1bUNJSTNwbWdyVzhQV0tKYklDenEyMFY4VUtlRll5TWlUWGpuT3puY3JURFZkTUhJYjRab0pJWmxrcG1nRXBtdkRQeHNhcmtDKzRRVVVPOEtwNHZQblYwMkI5V09Ub3BDcUdXSkpNaDNRZzlpWmtCUWljZFVaQ0tFamtKT0E4eHcxWVRnTXNTTXNtWUhTRkZHTUN4QUhnMUFiaGtoaE5IS0pMcEkrdmdiUnhoNGRzNFFtMmZnc0U4V3RTalVOUWpSMnk0b213OHc0d2JieWFzSnVqdVpmYXB3b1RETzNaVU4wSkJRby83U1Nadk04ZWtITzFuSnE4bUlkTktzTi9mVkdDVFNZRXAwdjVVcVZWelcwOHhCOFJIeXFzRDVkVTBPREhKV0NNTXRSRTgyMWhkMnNPR3cwSGxhSk5TNWYrdkZ4NW5rcVNSUFFoUDBPZlYwRmVVTFloVmhMNEdqbFA1SDQ3Qys1K1B3dHZqS0twMW8yaHlDTUVPZFZCeGlPK2Y4enUvSE9IUmlTWTR2T0N3MVVqUFlZVzMrRkN3VmM4dXNXcEFhMDlGbjhseG1HUzZ3MWxWMFJVZklQY3R5SDJBM0NlUTZ4UnVmalNIQnVueEVhZHFWRXNGTzVmcGhWOGt4cGs2OFEvOGltdTdtRnJ4c09rdnNiUHg1WG5xRGhWUityVUwzMVo2R2tycnV0STY0bzY0SWJkLzFJNXgwMG54MVg3cUhObWZsOUJ3dUNTOExkcndWcXlUeHVrTlB5YzlORFhWK0F1NWRGbmlGbmtFM05sZ0xhcjViMjl4R3NRM3R4aHppMmR6aS9IYldxUXhsakljdE9vVHBYMk9NYVVtMDZucHR4NmplbFRKWkQyY0dIOGpWM0U1M3FXazBrWFVsSTY0NUNYZklZSERKZUYyZEFrN0FDNk4wWWwvU09CS0hZeFNBWVE4dnZyc0RHQmVCVFJqNTRpTUl2N0VoRFIzaU9md3FBZmtnNUVPY1p4YVo0eWJIL3JOMGszdHlVVnpLWUVDTWMzT1pDZE9kUWZyNlc0R3RmU3BtMzNCZEpiYlZBZVYwVXg5OHFhZFBvMGEwdUMwOTU1UXduRFFMc0pzYUF6WWRhcFdjaURDbkNYQ0hJZ3doNDNHTXQ3ZnJtQnA2dlRiVDVHWVBvSVNQN2d5eC90TDlPOTNGd0JEMngyZ0tIWWRGTCtUSXdaczhXbVV1TzlyVkh4cVhmR3BXZWtKU3ZYV0RaaW0zSDRVMWhJVC9GdHZuZHBCSUd4d29pOHA1V0c5eEZndUhrYnEyWkY2R0trMzNyR2tYb2NVQWpmYVMwOUxsQ0FBNkZDOEFFRlJlMWgxaWlmOEVqTVNPd09QRW1jODdTTUtvellETy93cFBQeGFoN0ZkN3dScDdWUlVEZENqczNWL1M0N1ZJUUxYcW9vM3VDYVdMZmo0dUlvL2g3RkpGdThSaEhwNmlEOUw3V09oMG9oVWg1VXZqWkR0ekhNRnhuRjYrYXZFOWdUR1JWdGFaNldiNmtvYkxuM2o3MUhhMk5KZ292RlYrZlFCUXVqWGN4WEMyeXdlVDQ2SjBRRVFGZ2xBYytuclQwUFJKTmFhQS80cmdaaWVLdjVLdnBreTJTRE5HUVpncnQyWnJodGxhcGhScTU0bG9NcFJjZXBHOGNrQ1ladjluWGdzMFdaWEFqdDJCeEhUR3RwdWtUaklwWWllVnF6clVpTy9aalhWcVFUOHVrTGtFMThOTnhVbHFpYWNSNmx3a3FOSW4xaEdDeUZJZjh3THB3VmFXNnFyaVhKbm16eld0R1plbTZQR0szcU9WRDhXbkNWVjFVcGU4bmsweEp4bk9tZ0lIeG5LMGo5ZEJGYks5ZEp0RC9nMnpUdGZCYXQwemFvVWlGZFF1OVJkL09OY0paK2V1L003dno1OUhtakZFNzVYSUtSODl6Nnk0UzNmNHdKSm51Z1NIamxZL3ZKQlkySk0yTDIxSEFZN2ozZzZ0VTZ2R0kzeDlXRXpDTUFWV0xzVHRUUGROVmdNT1NabnFwL0xxa2V5VlV5dnFQOC9Qa3hFQWE2WVM4TnFmQU1vWkpaOFNsY1dTOHVJYitmbWxKZ2F1RnhVSzFpaldoMWZvSVRaY3BWem43dnI3RS96dU5PbFdCUWUwODdnY1JjcXV0eFZBUmJNWnIycW9nYm5VUmI2b0p3blA1dUxyeVBNVlN2dVpNZEpaODVsZW5yNVBCb2NxSUVZQUFFbW5VbFk1REVqU3FacUxIWTFQUmo4V2RBU1grWTNGL2s5Y2QxZjNlelBkRFlwUExRNnhHL2JkQjllU1dYNlJXRkcvbjQxb2hIaUFFL1dxRWFJL2hGeHJUWjlQcWpMNDBXTkRXSXN5NjRxaUpiUW83Z05qTWRGRHJOMWtOSDVtcUhwSnJyb01pWUJWbG43eWd4ZWl1ZERLZXcvMXQ0QlF1bXRmeVE1SG4vSlo2bEE4amE5MjJiTVlSR1NOcVcvKzI3QTBoRHZVWGt6d1hMd0dIMGQzZU1xRjdneHF5cGhKWTlDZVZzb2owSjVHUC9BK2VnYWhpRGszZmo5TmZGcEFxc1dFRFhITCthYUkxdlN3M0pOUjFjVGp6azMzbnZ4QzdsS2dIcUtNeXF1S0ZVMndDT3NMd0E0K1hibHZWMVY4bXNxRHdNMFZ5dTR1NWFVcXhYMFFLYlFDbndSLzRGb0JSNXJCYm42dkV3TzF3L1l5VEtPQWUvQWhPSVRtazBBMFJzUzM2MFVBTHFDQlYwQm9DdFl5UnVtUDlIc2d4QkIxRWlKMXk5R2VGVk5FSVhDSTFqd2h1bGptbDBpbWRnSzB6TXZ6dFdMcmRBVy9Zd2l6SW5VZ3BpaTEyV21WaEdpZkh4S01YaU5RQUtTVTRNaXBJQlhjZnRGMGdXS3N4S2hUdUlPSXJSY2l4dDZGOGJQNTBCTGxrRW9laVFRRUxucWFCTEpUMklEYnFiZ0NHR0w5RmRXcURiR0h3U28zT2dxcmYxZTNaUDZjc2loM1VrS0xvc200d0xJdVRKelNQaE1pU21Sc3U5YXdXd3FlVXRtNDAyZTVnR2w2TDdIZi9YcjAxblJ3TFlHdERIaXhNdUpYMFRaVU1LT2tsTVRXUG4wZFBDU2ZIcmY4eS8vYXlNeGE4STZKNEg5STBtTWtLektpTTVQZTZzOHdqeldvalBSYlYxVVV2SG5nd1FsQ290UUpDSnhvT0hYd2x0VDZQNGdxYVJMYVRRaWdzQWFkd1h4RndMWW1QRFIrVkc3WXdxR3hCWFp2YW5HNzVFdDhMeTBrSm1UeDF4ekxBYnkwV3djeWFxREo2TklvTkFJaFIreVg4OHZXWFZJaTg2TmtQZ014c2ZJa283QmJUWG9VbHU2MUtCTERaNHN0cFpLaTlYNGhBVE1oM1FwRjBWZFc5UkZVWmVLT3RGdzdweFVHVWVJVEl5a0tSaGxid0tXNTJSMmdlV2NyWHFTcENnTmttT3RpY3NmdFlmeTA5NWV2bFVPcHRXWGQyeXBWbWh6dFlKTklEOUw5L0syRVd4UFJ4RldES2szeG1tSlhsU3NsS1MzcXZpR3NPSkFyem5OOEVjSUtHS2g4Y2V0U2o1SnlZZGJzOUhBMEhIbVFRTm1jVHRhSk9DZEtCYndpK01sWnlveTJJU0NzdFJFbVgybVRYZkx5eVBzYXFER1dxcTA4ckcwUUdUWk1xbXlwV1QwMXVsdWF3UTlmN3A3bzVLcVcraXp6Z2MrM2IwVUw4Z0cycXlrNExueXFZOUtuV2dmMW1UVGUxUjhkVTVVbkNCajJOQVhTZHFlMkV5TVA5cWZ5bGxqcGdJNWcvbVNsR010cU4vRVdZRGh4VXVqNkE1RnVNaks4NHErbFFnTDdTNXNxV2dCR3JpSHltUUVJVlNtSm9Ca3VJclZSN1dPem1adDFLcDRHUW9ma1duY2xKNkZQN01yV25veGVoV3A0UTdIU1FyaXlXS3hkcGhYR1lndmRDcHJncUFaUlk4cWpSdlZaRGp6TXphQWgzTlZ6Wkp0Tk5aa0JUUW5BcmJ1a0hiSDJocHN5OHdSVVNVRlhSaDhyRlAwSHBsTmNENlhCUXZRVzdzckhwSTNxZy95V3c5b3RMYnVacXBUVGRWQ1ZtWVlmZEVnaUVYSkxrWklGeDVzcTZDS3M0Q0RiQVluMnVFZndSZzZTY0FaTDZPUnVHeFZXUGxLcHBOUllxMjZxeXJzYUNIRzBWSng0ZmpOakZtM0NxMm1DSUU5QU92aWxnR1dYV2lvMEVPaXcrc3NwV2tsVVQwRlVrWEJGM0djZE53cFJuVWtMQ0dYWWsxYVliQTFWZkVubTZQb016bWRJd0dRTFd0UzF2ckNEakE3K2NmOEhwbGVQOWN6RloyWmxJd0p2Q1VHME9Dd21RY0RzK0lCdEQ1RExIVmt5a3dpL3FvS093V210V3pkeUx2ZVZCQjJSRjRHN2EvYTJrMzhXQzJpdW9YMnQ3SWY1Mnlqaml2bGlGMnJic1ozdTNOY3ljOW12a1VKRitiQmVEQVNBemhXQkJEZFNXRHBrOWFJSjFoZzF6Z3RGWi9wbGF5R2pVbWhueHhQcklTMk5VTjZmNEZ0ZXdpV0FqcUZVcDU0RnVLaStHQmVxeElQMjREZTFoT3lkZU9ad2cxWXh5ekRwT25KenZFa2k2Mm5xS2FGVVlwcWt2bFIzY3BPQktocDNKVVkzYUVnUmM4dDhlQU4wVDlNT002QmR1Q0s1NFlKQTlDdTVEL0lhaTg0Y3p0TFU2QXBsdU1oa2tFQTFzQk41ay9KYit3ZnFlMmU1dXhBUEVJVXExTzJWZ29mTHZHeU5PaG5VY2xGODY0QVBNOVI1L1I3WE10R0V2Y09FMEtGWitEM3MrSThyWm1NVFdqTFhabEx4Q3RZd1dhRGEwNUc2dElUOHljYXgreCtRcXR2M1M3UGRidzgxd25IMC9YY0R2MHcvNUcrcFQvRC9ESEtScWFTUW9TenJlM0xvbk5jSFJLRFlxaUltQ01SRGtvWDBsUUxNcy9SMU14ZGxrbE5yR3FHeGd5aSs3NCtiYndXQTV0amxiZ3JmVnJpUkNFNXFYV0VDQUxQdVBONFBTbGhzT0hSL1J3WGxteTR5Z1FabzhVV25TZ1YwQ2NjT09SbTR4eXhYMDB5Vk9QdGFUVnhIQnA5bE5qWlloRklaeklQYjY0c1kySlFLeTNiSkJQbDZ0ZkVZVmZqNVdEczNLaXdGSjBJNDJSUFJwVzRpdFhaTXBDVVdZdXRaOE8xRnlLNWkxTFhTbGJtcEdwYkpkOXQ2V0tpdThMZ1lVVVVMV2JHYWxobUV2VFRSWUorTDc0dWw2RlB1amhOUGtMSjlmcFJMTTdSbXByQTlxS1Y5Q1NVajZ4NXg1cllsYldzYlBIWkwxTzRYMGRnUGdOSmd0RFBYeFFJeWN4Rm95bndaTUZJbzI2TnF6N1JFRkdzYlJLU3AwSzg2djJETTg1MnA4WTRxVlR2Q1phRnRmZW1zdFlrSDV4QVJ0ZlBUUEdxbWJpZzVZYWk4US9VemFiT3lkdytVM21STVpQZ3dndHJab3BWSHVLS0ZpR3pRbWlmZXk4bTR2OWtDbVYzRGMrVVZSTTFXZnlzYnZRdHJUMnNHWjI0Ymk4Y0FmUEJIRVZ1RUN1eHF5aTJiQmU4MzJYTG9xV1N5MXptYzVpTldkWmJjbVFoaFVkWjluMkVKVlphWUVSMnVkM0pUc3ozWEVaM3VYNjZZek9oUnNweFB4RXk2ZVcyVllKNjBzUERDdkRWREFnOFl1b25rckhwMmdLYVg4bVZMUFhEWXhPZmpJR3lhS2ExQTJ0SnNWNVhKOUJ6VmQ0SFovTUpmSUtNS1plNGNkUmsxYTU0TFMybnUxLzQ0OTgramFlNUxWRURjTEVHdjJuWTFTbVBIZndZMXo5MjlEK2lJRDdzWTlmdWp6RWVxZkFsb3JRQVVjY0k1YWNjYzBXcWtHVmlDdXBJeWtvMldXQitoa25qenkxaGNYaFZ0RnR4NFNyejRCRHhvRGlUZElTTG12aVJPUEFBQXZxbEJsempKeDZyRUpZRndSTnNLMUpEZ0sveG9zKzdLamR3V0R3a3U0MnRreHpSVmc2NzNJRWRqOCt1dUdPRXZ1S09TcGoyN2VpbUthUnZsUmZ5eW9YZjAwKzlLb2w2eGFRUmR5U0lIMGo3SHFSeW9YRTcwN2VDaFNUVDNMVFFaY0lxRmlJWnR5QWFINjVMSDNLWG1IRDZsb05TWk16U3dNQnlROHd2aHdtd1h6Y25FL2JacmZEV1crN0MxT3NpU0xwcDJHbmdNNGczb004K2J3R2cycWNYVlBJdDZjN1BrSktISWh2STFxelNVcXJTUUZOL0RRblAzT3IwOUtyb1hyWlBkR25jRGNTQlNLemtONnpxcE82d2xTOG5vSVBJRmYwdmFOQ09Zb2NoUm9ZMzdFeG1tT0c0YTVxYno1TkY2L1d6UWRQdjdVajdWSzFkd3NqL0ZoOWQvdzQrdXY1L2ZQemIrSWdCc0EzYjJzMDUvTGtwK3JzV0J5N3YzT3pCa3dnblVTTm1TUU4xU1FHQk9FVThTTHFJTlJGZnpBQ293bFFRVGcxaTc0VTBTb3Z4RXBSenNqSTRtaHAvSTVmNDRuQmpWMjNHcitsL243SmwyUGRML0h4ZzJVMVdCRGdWdjVVZXBDemJoYjcwUzhQcmFOTW40cUdKNC9OY2JITVJDNTBqQVo0NHhRcjdYbHNubVJLbG05TGpFY3ZKL2RCREs0elBSZnhJdmR0Q2lIUk1kU2MxQkRJcWlmRU9wK1RPWHdYaXFXZWljZUx1Wm1qVVJYR2w4VDdXNEplZzVLSVJiS2xqMTJSallqMEM4S2ovVExFY0ZMK3Qyb1BuaHAwOG93VjJ2Q3I0S0NIYmkrd2prZVpJemhQOXNYTzV6c3hnNVg3ZGRCY2J1SzNwYzkvTnNZc0l1MHRpN2E3QXJGa2RidU9ORUI5aGVDaDYyUSt3RzhTS0hWeUVLaDNOVG0wZGZ6aGhSN2FwRHI3MVo1em9PMXIyMVpqS0JuVkZpNElndzZ6VGZVWHFzdlpickc0bG04M3FHY1piVmZHM1duM21lUGxveXZRQU1aRm5NM0dxRzhnbWhzc0U2cDlzOVFiU2FtaDhrcTNnQjZJT3Vxei9zV1pzSE5rV3N6WVpMZXBWVlJINWZtWnppd2FZUUFmeFZxWEV4R2hkV0djeVZrS1Y5V3JHLzU3ZHh6cjliU0Q3bUM5bCs1amJ2ampvUHViOS9RN2hVT3dJd3NUS3NuVzdIQ1BhZjUyV2k2SnBNWTJ0L3RxQ1hRd1FRMXFFOG9ydGNHZFZ4WlVkZm0xazB4K0tScjE2ckdwK05PdEFDK3M5UUh4UFJiWnpxNjJyZ2EyaFREdlNvcUtUWGhDOXBtcU9BV3RSUVhQcU4rWGRWUlZ2SzVsOFJwTjllSUtzYkFjcWcwd1lSeWQxbFJyTTM3Q3FFcXlxSU1ZdFBKSVV2OHcySWFGQml0SzF1UnEzcWRQMUU2c1RFcGlQNUhHSEhCYU5Cb2xmVm5FVWN4WHJXT0ZXc21Zenk4Z1ZHUGdXNndLRGdxaDVPU2FVekJ3bCtoRmFnTUpHNnlGZGhoaVl6RXNiN0dINXkzSUhleWRlVWUvR0k4UGdlRkpPN1Y0RnhvQUl0dmpURlVjMFUzNzZNR21FVUJJRDBOZmdPenU1S00rOXhHZXA2Sk80UUd1UnVGSFR2aEJCS203YXhQdkgxdWZzV3IwMmJheENWQnRzdERTa1pTcUpMV2o2SUU3dXlvRGgzUVNGTUlCZDBNVU0yWXpTMGRuOVVRRHVIcmJ2eWR4UG03cmdCWHJUN1lCT1NzbHdBei9oelliT1RuRllRVzBza3ZTTXoxYjk2d29hN3RrSy9oRVhFeDg4SXNLTDdzVXcwdDUrZnVKVVFEL3cxU3hnL3ovOFFPNUNhOTlXY2lnSXpjTzRSMk1MRWdEWVVJVWFRamt0ckdEenJnTXRkVGFzZ1RBM3ZqNG40OUoxbk1QQjBNUXlacHhhMVQwalNpYXVvNFJERUVIQkVnYWxsY1V0ak1pbTZHaDJiQm9uYzVvUlRIcXJEYmdrT0dKZXpoV21RVTdBWEd2dlpmK1JZdTlXOEFHQjBXR2FXc05Bdk9pR2Q0M0tnSWVVQWQ0dlNHRGgwb0NMTlp0TkRGZnFmdk16UWJyZGlaZW5zOWwzRUo4a1lxS3hnaWx6WUE5N2l1bk5kVG54TFRxN2ljTEJhY0tKV210MnRDTlNtUlVPQlZKSFU3d1cwVXJrNFliVEMvdVhsOTZEZk5TcGM0aHFrTm1CdjVLZEFLcW56S0lGS3ltR0tuM1JpZjhSOHJxaWhYSWVqdUN2U21UbTZlbndaUkIxVGxFTkhTMkpZeWV3Si9uMkVhM0paQWZjclp2VGpUODJjQnRMeGVjcFd0Y0lKREM2WFpIa3dwWVRXSnpIVzA2K2VQR0lSamNhL1VIUzRkSzdlOWtPakJZbzNZT3kyaFZmUm4zRG1BcTkyMmljN29yYnJqNU1iKzd1eGJwczMzSkJUdjRlMTNJRHRxcWcvV2tudXZwZGw2all5Q1IvVFNlV1c0SEl2SGNlSDBYMEJFVHBhUHVZcmNnQ0daMjkySDV6WVM2ektFcXhqL3k5VUdvaWl1dmhxd1ByRkhyMzlYdFJQMzdkUFVDY2UySStrWEpmd2l2T0tzeXhIcFliejdIZDlXOXN4Ly9JaTYwZnY1bXZxVXgxYUxlRDJoT0pidmwzQnlYUjB5SGJQQ0F5M2gweTFmaENSV0N5MitvczRPUC95bGZVYnNTbkpLeEJ4ZGRyWWZlYVlQZlUyUm5zM21HRUtqb0hJNlFLTHpvbkp4NXZGWUM4QnFIRy91MStXUUNaaTRxZGMraldUWmNuV29aRUpOdkNzUzkraWFYQ2tZallaQVBPNU5pWFRTQ0VHd0w4bjBqUDZKWm9zbE1EK1JkVVJXZk1tK1JidkxuL09iNE0yb2FPdmw3U1VhOEhkWGVIQzNFNTZCV1hJUCtoSk8yV3R1bG5JU21kOUtiN3ZQaGlhTTJqRVRYcXdQOVBMSnhIWEpCZ2pRSWM1M242QTE5QmdjdkpQbFVCdWFQN2MwMGh5V1BxSWFxTUJoK1RFdGdSNUR2NFJ2TUxLc1FCRytqOUI5SzdUaUhPM0FVdENWQmpjQ1pEcGJ1QzFWdjUzb1hRV3JSQjJ1ZFd5VlpzV2cxbloxeE5TcnpYTGtkN0dEMmhEZDZjVS9JeGpPZ1lLTEMxM1NsV2t3S09abmtSTzVNN3lhcHNUTjNZYXlaTmxoOWgzZ1JTQkphTFM3cjZHdy9tS0dNSFIvMmhCUnkrVUxLWndFNWRzT3o0ODZwUzRBVnJLYUl3Q0NzMERRUjhNNndiUmtESnNJMVNZUHBzenF3NjdLWDRRd0lucXR2bEtmUVBQZjRubHB2aTNmYVVFWlcyV05yU3F4cHdnei91TkFSOWttSU1xb0R2Rnpvd1UydUNHWE1LcUM5NklEZTlpcFFoaWNnS2NPYUFTQ0pQWTNWdGZXSk5CZHRHSktld25vVTkxQ3ZiT05UYzZ3eEp2Z1Fta0VlK3VJU2c5dnFqQkRWQXJNeHpaelZhUWpRUmg4YmhNa2UySkhMSEx1WEFrU1hZelFPN01PVXcvandzZFVzdEhvZkI0eHhQMFllK3RoUFJicW5iUldwYjZoMmlQS0V3dEV4MVFnSjErL2JMaTkzSlVOYXJFMmJ3MU9sUnZOMXJhNXRnb251dVcyazBRdzM5SHRkQ2Y4djRRNFF6dndYQ29IMVgwSHNEd1pRNERrTUh2V3ZFU0RCSHlkTXluVmR5STR1bkVLdXhMT0FMVWdZV2E2WG9xa0FEUmJDV21xTFl4eHFrcE5vL3JjVXR3Zk11MkhsWHdJZEprMDZmcFdwQityU3V4di9LaTdiNnJFWjRCd0JGZmE5aUxHcnV5aEtCNUJrYkpMc25PR1A4cGpDWEI3RTd3S1BkSU01RU9tQjhNWUw2R3JHTTMzVWxUZXRmU1ZPWkpxNThDQ3VKZ3pYNzBWaHJ1NUxuSzBiQm9JYkxiQk83bm5DTTZjTlkxVHptdTN0NTVzQXFoeGpoT0dubFhaYzMydHNEd2JiMkQzbDgvNUFORC9uemoySElIREdLaml4VkFtWWdIMXJsNjZ1RXNLYlZpRDVrMjRQUlhTV21oQTNzTHM0T3dlUzVjSlgzdFFEaGdtd1ZVL0VmdVhDUEIrbmpFbkFjcEMrOTZkY0hIQWQxQWNkOGlLMGZxOEtwaWNYMnI1NUMvZXFwNjBrSVRVaElMS0pPSXBBZzdiU3d0Q3lpZ0xnZnBPWXlaSGNIbU12YWFkd1B1a2JJMGZRK0JoSTdQaXppQ3BqWkRySmtoMEFHRGJFeWFBaGswQkJjV3h2ZGJIVUFiSWJ2VVFtUXVGcm9QRCs1S1dDSlRUM3duQldXZ2VMTklmWWhBRWJBT1VSSGhuS1huL2hrbFJUSUF1WjNFa04zTVZhKzFrMVpXVVJEMllOQ0VEMmxWQzRMbnVHZEhObXQ1ekI3RHNxcjZhcWVGZjhjWE95bGZ6b1BRWnBWb1dPRDNwSHoxVHhwdjVNZE1SSllWZlhFUVNvdWVMZ3N3V1hmb0tLWDgzcDNzRXZ0cFB2T0pWcVQ1UDZVOUJFaTdIRHNLM2J2NTRzSGptU0lzNnBhQ1NSY2toNkVObnFyWEkzM1R0Z2loOExRSVRqbzJ6TU9hZ0tNb1o4UkFpUEdZYkRHVmV2VFNHOS94RUxWeGZyWkF5VFBVallNaVUyaldqZ3hqU0dVamR5MzNsTEVtVkpOS2pwTUM3WUtPYTdaU2NkMTBCcUZCNVl0T1FhUnY0RzRMYVBQU2M5VEN3R3FWSGVsbTE4UENGSTBZYVlTdG9YYUhMNWNqbTNybWJEaGNVNlBkNlpkM3FwVnNvT1N2dVhBNHhwMGRTWXE2d2J6NldDNHFXamR1MnF1Tk54NGpjUnBYNnJRQ0d4WkxkYTlsMEhPU1dlay8vM1pJSVBYTzJpaXg3Tm5NKzRTajRNTjA0WTRacC8rbWdyaWFDV1FNTzVxbHQzZTdZNk5MS1QzVytOVk50ZjBsNHB1ODRpZWFScXZ3M08xSjA5MXZBYXFiN3ltbWY2YzBzelcwWWFLbjc0SiszaWgySldoOGJkTmQrOUJHRzY4SVdIMzc2Mks4NXFJZ2QzNmJFQmcrWXBieVJ6V2VNZkd1aXUzc1FJS1A5c0dBRXdWM1FxdW0vUlY0bmFYS1Q0YUNaTU9OMFdtL2p6ZWdzeko0WnNaNlRYbkJieTRVY3RMTjNha3YzZEFOYnhkbDhEekF5diswOWl2Nk92clhpREd2QVJLa1hGMEpZMG9jd3JaTVZjSVMxNTY1aGJwSjUxVmhhRVYzMEFzRkEvQVlSRi80aFJrOG4reStyWXVueXM2RWY2eUZVek1DQXdsWFg4TXQ4VlJXaW03eTd6MDZkL2xZVXgwVmFjb0VxeXI4ZlpEYkN0SXJROUpwSUFIQks5bXRvRGNJK1NpVkMwbVM3YnlmUG5JV2ZiV3FoZkJPbmR0aFNKRDZlNHZDNFdsMjk5ZzFqMkxrSkhvREJLWUx0a1kxQUNIWFZMcnJ6dDc4ckQ3MFoxS1RuSEZlenpFMWUvaWFMS3VzQlRoV2NSaXEybDNsVDA2dENZMk5JczlBMS9HWmFwWlBBZzQ1Q0Q3a01SdkxoZkREWVE2b0tnVVl4TkU0aDJ1VUhLaVo0L21yeHQ5MnJwNkVUWmpQYmw5Zlo3dGlTM3plRUhMTnQ1dlJRYllqOXRSMGRSb2ZtRUxPTW5yYndROGRIRnIwU0ltWkhvU3lNNG4wRGo4SEFmUkhNdFpEYjhuUlNhNnpOVUYyWHlJY1FCbTBLai9qR0tCLy9ZaVhQQUVJWnh1b0w4QlQzSkRKWlRyclBpSXNDZjNlZ081Tjl3aXB4YVlpTU50N1kwOWxZYjJZcmR4UDhCTHBXRWpYMXFjbDFXVWJRaG0rcCtxUlNMRTZhYTdiQVNGSFF1ME12UmZFR3lwZUgzOUg3ZDlkVGZqR1lka3lEeDBhL2JPVU93cEt0Wnl1aEpjRXNlclQrTWloblFDV3hpa1VIU0tmVmhJOXlHOUdSOXowN0ZkbkIzeGRpVjFYOU5XMEVNZUFVMzViYkxaQUlQaXE0SjBKbUYzdW5zaVgvdVlOR0FqdjZHOXE1dlluVkF6RHBUczRkb0FQL3JwS0RmdTlmbnJVZElkTFB3R1ZWT0Vtdm5FVzVNd01aM3lMNmxlT2V5QWRzSGRuNUYzaFUrR0VkcEFweFZhN0xCQ1JCaVNzb2o3S0RsSjFpcGZSaWxxRE1JL0xINElQRGtvNWZBT3VEYTIxVTMvdXV2UmEzSzhSYWJhNFhENVpES01xYUs0TFdrRVJwaDJpaW5ISTFwOGRmR2ZwQVFqa1MrL1NIa1AxM29VWGRNNDNWMkhmYXIwcFRkeXN1cnJzWStEU01JYU9WWURmTEVwdmVtRkFWRTJQdlNiWWFheG14UjFSZ1dPa1Jackl4eVI3bnd1SUw1QTNFYnUzTURkUkthSWFBVjIzcVlQYlAzNVdRRldZWkdTUDN3Z1lHV3ptRDYvODRMdk13ZzQrVmViZlBIVkM4NEtzdVFEbk15YzBWNmwzS3BmRHl1NHRncm5WZWR5UURrVmZHWG5KZmZsdU5VeWpmNXJaNHJUaDJoa3VCbXhrV2lFM1RQOUErY2orZHZ4L1JtbE52MERPR2Q2Y2FTOWhTT1lOYzFrQ3c2NU13QkxKZy9jT0JhYmNWV2VDallUSDMxS1hsSzlTd0wrQ2dmYmxmQjg5TFZDMEhDaUtkRksvczNuSU14MmluK0JpMWI0bmxndmN5Wm9Qa1htTkhpT2NyVnJWVldpcVd3Z3Q5WU5oRWR3ajZXZ1cvdXBabmlOTUpvek91bi8wNFg0Z1V3K1Q5MDlZOW9nRldEcmtKNURnbkFjNFhQY2dwWkswUTdFeEZjcFJ2SllWaElJR2VQV2I3TmFpRHZadVZXSjlYdmwwNTZ0d0FkQUxUcGtMZGdYRC83VFQwZkZyNFM4ei9EUXJnZlBjT1hFUE1GaWF0clRnWkh5d3pSK21HWnY2QW5UQjE5OCtqSlhCRG1hdWU4TlB5MWx6UXhuL1dPM0NSb1FSdnU2YmhyS0o1c3paQkh6SmZuM1k0Nm96SkNDdTlCSURVVU5EdzdLcC9uWWc3VG04T0dDOC9QcFhROWh4MGZGUC9DeEpPcmdUVXZTOWxrQ0JkUmxWQnFRWlRJS2MzRVNld1VpL1VBZWIyd094SHhoWlFmVkRsSDNxRnJML1kybThRWVFXSzBSaC9mb2NkZTZMM0tOa1lzbUx6Zy95SlN1Mmo2eGhCSExTc1dpZi9qNlhIeDludDJWZk5TNlZXOHA4SEVqb2NjR1Z5dUhKODl6T3ozakJCYUR3NzliYWJvc3U3OG1YWXBXbTc2ZUZET3BjRnBTak9ReTVOVThoenBrcktnUjJtNG80Z3dXaVczNlJwV2x0aW9Md2lKUS8rck9DLzZRdzdsQWVqSVFLQjFnMC9nenBpc2RkMHI4VmJlK1VTODdBeXJ0Y0wvOUhjampGSUkxNmJ3dU01T01OSWpnMGo1UkZqWG80RVZWUjc4QTFmYUNaVktnbUVveHhhSE05Qy9mKy9WWm1uZ25jNmlZSkdMNnhoL3Z2eUtBdEtyeG1QcmxIL1d2LzZ3dFVpTUlmdDNWaHB6V3VaeFNiQVlVMC8vem05T3JEZHIxSExUY3Q4VkRWSEl4L1NKR1NDQnJ2d29nYjRSQVFSNWh3WmRyL1RBSUx6MmpEMStHNHVNVElKSERQUmgyS1RYQ3NFdHBFL2h2Q2RQdzAwMjIvQ1lwajdiU0MvcTg5UHcrZEVxdHpDVm1JQzNSbTgvU20zTjNmK05DUHVjWTZIdytkd1hweElCNStsa2VudDc5TmI4N2o5L1pVNVQxZFN1citUM05HMVJWakYvM01pVGphanh4ckJhRmlEd1F4Z29hbG52S2FyNjRpaDVYRXhQclBiSmVRQXE5UVRXNnRHWm0xR3RITG9rUnkxYzNDck9Gcys5V0phb3M4QWRhZkczblR5OExaQ3RuaDhNT0llRkhJV21Id3FweEsvU3RhcnE3aVBWY0xoWmZyWm96VXVJZHJGYjlpQkpPUjhrZHl2SzVZYlgrV1FqWE91WkY4TWF2THJnbU40OWpOSHppYTBCKzJNMzdtdVVQU0xnNmdRRXM3NGFhS2VSUnVTR0kzV2JkcFNFajlHS2wxT3A0VktTcGkyQlcyMmIyYTl2TXZ0MW0za1YyamFHeUlkRW5sUzMybHkzV3loWnQyU09rYUpHYnJaUjJiN2dTRDJ4NlBnWVRtdUsyeW9qMkdlZVlFZTMwOXF6MjFuTTJrWjNaYnM2cGpEUWpOdEVyZkV2VFdlMU5YS0N2NysvbHM5ckRjelp0TXFWdGFMUnJtN3pmWk9KdFhOK01iSjl4N3FaTm02YmowZ25UTU5uWmxVL0REbnZLU21aZXBDR0NqcEJ6Qk5ISnZ6RzNTbkcxVEkrcXpEZnZCclZLYVhVMk94RXRSeG5rSEVXdmNVZUJYQzFpMENRdDYrSHQ0NDR2cVFHakc1SCs4WHZmdkRtSFRWQjZHdnF1V05yV1ByVGJEUDhBaWs5eG1pdk0xWWN6ZExob3A4aUlZanEydXUxNHZqYUN1QkJwNUlpRUtjMGhDaW5WZXFjaXRNeXV3N0NMVlhzcUhHZWc0WjcxNCt0eTRwVCsrVTArR29aMFo0UE9ESWNXZ0s5SHFTZmVDdk1sY2ZLMjU0L2o1UkxiMWJMbGJhdGxpK0pZSzE0dGNUVytSb0Y4ajVHekY0MjhFMHl2R3JrZldpNmJDeldNWW1VVTdlblhpd3NtSXQyOTRsZXgvT01LNzdjWFdjSmVuWlBiVURZWERMMHR5UTVzOXN6aGNyS3NPQUt5Qmc4R2hsMjJza2R2MHc0ZmRlQnJWcjVTNENqdHI2QnZNZ3lpek9tNFExWDM4T1ZPUHNkMzNqYU03ZnIwKzA5eTRJeWIzdkRQQVZGTnJ2VU1mMFd6cVp0dWZwVnZKWEN4T1hpa3hESUpZdDMwdFplVnNLTW5yMWV3eDlLZEwrSDRmRVlsQ2xUQ0hvSmE0RGZCemJXbXJpTUhwcktOYWVIRDNKNDRwV3JzRG5WWi82OGJSYnI1NFRCN1Z2TnRERGthejhJamR1c3c3Y2tDTlhBcW1iV09kT2VmZ3JvbW5Gb0xyZzJ3Nkh0ZDNpZjJUQnlIZDhoQkJCMzlGVnYxMXVhSDllWnhtQlhjZTdpMzEzZXRnT1ZUR0hDYkpSeEZkS3c5cWY2VzZxamtPTWJWc2VmL3NtUG5tby9od2xHdzQ2eXdLbnU4Q0Z6bHV3UTIwSjgrdllDRFYrR1NVZ3V4V1dXaldBT0pZcTBvRzdRYVNOQ3FIRXlyc3ZkVElSeVZwb0J3VkRzZWp1Y21PNll1SEZVSVNmTXlMQTh3b3A4aEhhSG1nTmlEbTYvZmtxb1p1VmJTNVhDZmFGakpzL3p3d0RaMk4zZzVZQ2JmWGpqZXVpMTh0a2RwZE8ybjhTRTJtdlBMVDF6eVFrNE9rdm5iM3MvVVF5dGIxNjlxYlZOeW1PQWFsY2c5SHJMdUNNTTVkcnRsRi9MWTRFeE84ZTBYYzdMWUxyTHpmdm15V0trY1BRb3dtVHlMdUp3Y3BZY25OdDMxNmdWWHNBT28xbnBJWnVWVm4yT0RJWmR1ZzVjVzdxQXNRbUJQRWFjdkZuU0J2OGdnM2N3T2hEM2ViNExCUG8zQXF5aTdBb2dVaXpmZkhPQnprYzBzZHYrVFVhRUU4cVc2ZzNhbS91SDRGbnAzR3E0bTE4eVMwcjg4ZC84MXdWeDJTZnp0d1o5K0xqY1gxNGlsdjMvNlVlU1N4WlMrOWpEbHprdkljc1YzM0ZscUw1c0dEZytNVDJhOE9JZ2d4dGRqNHF3c0Z5aTFoLy9CRzVwOGU1c0xIRy9qZzdSSXJzZDVNUWs1aHZhUjducnUvanRZMjlIcHl5OWVjak1yNFRUWmUzQ0pDemozdWFvOXNDZjI1Q2s4enZJQlFzUTllZG0xViswZThXNG1JMTBqSTI3K2hWL1Ztbi90MWF1ZzN0aktCTXd0ZDF2em5sZ2NSc0czVmxqL2tTOVpjN056K24xdzRMMzI0Tm5YMk1iZWVQSHNaN2l4N0Z3UkdyelYwaEdHZ1BFNGdrTmlGOEFPYmhFcHQ0ZmRTV3hub2tEWTVmYTR1MUkycFJQWSswWUdFV0dJZ1ZYR1BYZE1zRnFzL0RyREhVL3hnS2V3M293L1VUSmwzUEFsZUhhanE3K0Y3UU5hMkw1N0M3TWxVendSQmRrZGk2c21sdUlHTFFIaGpuamtEYjZ6a2Irc1NHYUdFRTFONXVJMy9pdFg4N1lUZ1poNFl3VUFrRUtWSVdiSW9wYktVSnB2WlFqUGVHaDcrR0ZhYnJGc3VaZmEzM3hySEh5U0pWUCtJTXRuU214a0ViMGJYRUVhWmdqUkpmMGUxMUlwb3pGR0M4OC9xYmxEbUVmdTVIMHRqVjMxUXJyamM4eDh3YjUxL1kwZ0tjSzNBNXhRa0YxdldZQkduTk4vZVBpbEt3SjdmR2dTY1pIaHdzOEpZM0FRNFdScCtxUzB5OWVEV0Q5S3VVNC82WHViZm9MdmlJajE3SnFHWWpRZlc4c09RZzJZcm1mUHQyV2gxcVBuV0p0UnlZblUycmxlYjdMellNajNZZUhwUWY1cXA0bE1XdDFFYUt2ZkR4bVJWYkdyWXJjYWtsK3JOWjMwcUxkQlgrNjA0QkkxOWF4TUpKMXBWV1hyTml2WGpzUXhSYmNUNlcva0x4UVZnRUNYMHNTTDcvNVJ0c2RxeW5LazJUWWVkeWZsN0V2UmVFOWpzOXJUbFRnNitzK3hYcmxYYlZUaXF0M3BnZE1PR3RWa0QwdzV1SGhHUHM4bE9zaGNxLyt2LzRUQjV0S2JmbkxoNTl5NUxDQnUrdDFQcjZCaytYL1g4RzdkNU5Mbm43cnVhazk2ZUg0bkozSHR4azFYUFlUa2V5ajVveTgrOUFvbEErVCsrYVdmRWZzNnBGWjUrNWFIenZPbDhvT1hmL05xU3BiUXpwa1BJUW45NUthek9Ma1hKWisrL0lGLytOTDZYNTg3bTJSRmFUZ0tmUCsyaXloWlFmSW45MTVCeVlONXJnOGhPWjJTTHo3OEtKTG8vcVhIcnJ1R2tua1VlT1orSkRHK201NS9DTWxwdUNyckZVNE9vK1N1QjMrSlpCRUZmdlBBelpROGtKSy9lL1loSkhFTzU2YWYzWHNISmZlWEZwQThpSkovMlhVdjNMZU5sSHpoZXo5RkVudDZiN3o2S056RGhwS3ZQbmZCVHlnWjh4aUlnODh0VGNXRWRsMkhaQXR5Zi84UWtqTXg5Q2NlUlRLVUdiOUF5UkdVZk8yNUMxK3dRMzloNTNWSVFtZTc2UThQSVhrSWtyOCsrdytVUElDcjNZdmtLT1QrK0g0a0QwWHk4VXZnb3Q2UFI4YkpNVWkrdUEzSjBaeDdMNUxqVVBaUER5RTVpeHQ3Rk1sbW1SQ1NDZWRlOEU5S052SFE3LytuUmNEcmo1ME5mL2RRN3ZncUpNZHp4dzhoT1FuSmx5NzVIQ1hiWkc0WFVYSWtjaCs2RHNsOUdJVy9ScEt4K2N1WGtKd0M4RDE0eVJXVUxNdlFrUndyMVpCczVkNitDUW5KYUhtVWsvc3lvQjVDY20rWkVKS0F3K3MvZ3A1UkdvTGNuM0p5TWxQVXo1RUV5YjMydlh0dkRnUkR4SFB2bzJRRDkzYjJUeWc1Z1h0N0FNbTlNMklHb2ZNeEswVCtGZWRHNlUvLzdGSGlpQ2o5TFNjTzUvT1I2UytlOCtUYzdWYlM0MXB3TVczcXpFc0N2UDdjaFNnM0swb3Z2TXFueEdGUmV2UDNrWmdacGMrY2dWY0hSK25tMTVFNEpFcC8rSHNrcGtmcDN4NUhtUmxSZXViM2JlTCtMYjRVZnU1S1NxUWpFZy9senRtRkNnZEZyS2UxWTBPOGZOYWkwZ3dNNVdKRm45aWZ5U0dXVTRKMG9FMjZ1TG9uRDBUd29heURXV0cyTGllU3krMW5RTXYrbDkzMHFUM3B6U1NRY1RJM3ZWR1JMTmxhZHhFR0tTZzN1ODNaR1R2bXA3OTRFTU9hR3FWbjNJdkVGUFpKNGk1czVvZlBlZ3plWVF2N3RkQS8zVE5BQzQxb2J2MHFXQmVialZUM1dhOGFmMW1oSzdKRGNBd0lQQjJOYnRFY0VISnFSYy9yYi9PaTN3L1dwcUkydWFibWdLbGNHaTJza3lGcGtUZGFlRGViZDZiamRNY2pnYmpMZG0rcXRqMnErUy9YdXYxd3grbWJmdkY5Qjd0L3g3UHVmMzRkWW5neldYb1BxdlNKaTMzc2RsR1RGK1g1RmpOYnJETDBjSGlwUDhLSzIxQ3F0TE91MHZOY2FTZFZ1c0puNXdWUHUwM3ZxQ3Z6MEU4OE1lUlJSblk1bnZYc1hWM1BldW5mbnIzUUZidjdnZGRKeWRvdXh5S2V4YkdtSDNBckJNWTRmWkViMlM2akUyQ2VuNi9LYTl1VjNTaGhhNDN2d2Y1MlBsV2RiZlJCdUtIQ2FMK3VLQUdzTFVvdnZzZ1N4VlBuK0V3VTZWTmZRV0svS1AzcUJVaE1KbnJtMVRJeFNoLytUeVJhby9RZm01SFlKMHF2ZlFLSkNWSDZuWnRRZU84b3ZmSTg1SXlQMHA5ZDdjdXI3M0hMbEhNWEw1c2tTbS9qVGlseDQ1bklHVWZ0Y0syeFVYcjdyMnppY2U1cmRKUmV4YjIzUk9uM2R5RFJIS1dYZmhXSlVWSDZHeDVxVTVSKyt4SGtqSXpTUC9GNFJrVHBJL3hxZUpSKzRWcmtOTm9sV2h3V3BiL25lUTJOMG05eWcwT2k5S0xMa1lpajlPeUhrU2hUemgwbzB4Q2xqNzZKbkZLVTN2SjE1QlNwZHg1UFJBUGpvUllJaHJjaWtZL1NKMjlDSWlSQTNZWENRWlJ1NVZxNUNQdFpsUEF6YUpBTithK1hmVDRxbTU3eGVTUjBsTjdFZ3lkYjR3R3duc2h5T0xqUTA1RUpOaVBTSmc0SFMwY2xYdmJXdDBkWW9jeHdVQ2UwWDhSSkRzc011VG85d3NGdEV4eGVPa3g4YWJ4Y3NOc01teXA5OFhzd0EwdkN0MHh1NjNFbFdWQjUyZXZRd3MvV2RVT2R5NlhycWh6cWFsV2dGNTc3NVVYUWxta2N4VFN3ZDMzbjAvWFZCaDBxQjJHakxSQ2hqbHhFekYrOUNBYllsSDdqNWlCVEJBdUlSZ0w0RGsxS2dCbStyenVVQzB2TUhMRVhXeXNOYzFobGFlcUM5eVR6WmVacVhxb2MrektwSXJSMjl1L3pmRXVtZUN6dkFaZnNQWU1NOGY3aEVJZTVscTFiM2tySHVDNTlJQkFYWSszbTBCekR6UWZjK0hxWGdBSFlKVkFBeEFyYlBzd0FDSWlqOVlpTHcrNlBYL1lONjNrbzhIWmdwWlF4VDF4SUNPWnBZZHNOMlBJQllqY3l3MjVJQ2d3RU9SK0U3d01OYTU2d0c5bXRGcFpzRk9SbVpSbXVuNzc1c0NkYU0zTUt6cFZ6ZURSb29rakxMS1UvNXpoUzJRb2NzK1V1TEdIQ2ZYeXR6Wnd1UXRpcUt1THRLMFcrRWRKZWdIcXVGa0NraTRoOWhMWGRQb21nUW9pejhZWjRUbk5SRGRpY0FxaHNLdC9ncVZ4T00wV3M0azBwUHpJQ2prcmVSdm5sRWVVM0R3SDZpc1dianE5UzJGZVJHbzdTTnJpOTFqeGlTckQ3VGEwQnZtdTJKOW5HNndPVWduVVduMEowa29hblNIZ0pFM1VrVkhnaVM1MkhIdmZ0SHZ0RmVWTThXb2lPaFEvS0xHS1pjOTI5Z2QyRUlVVDY3emFHMmhCcUkzaDczMzJLTzMvcWZFK01JOXU1SHRENU91NzhoL2NFdFZnTWVMUHo2VWc1VnNIbjdOajU4cDM3S28wSHV5SkZYMks1dEwwMkg5WGZKSldKdWNrLzMxT0xtZVdoNG5SQnZLNFNTVkFsUFlqdjNrb1UzclhvbHlpYXhVOW9iM3kwWXUxOGJjWGErYnBmck9FaTFha3MwODdYSFBRdElzaFlrVGIxN1JMTnJXYk40ajRBNHB3U3ErcUt0Qk0vaEpXUTdJdElOMm1PMHM2bE94L3p4Uk54U1Y0Q3hqSWh1eXZnYUxyTk90Mis2ZERWN0RMaFN0MndNTS9sVzBHSlhlTUdFSHltajhseUkyNi9LR21Rc1RueFRTNTRwMDZmTG1BeGxKa1A0WHVIaXNZS2V3TGZQM1NsSWJzN2x4Yk9lblMwMVUzRCtaMjBaZzVOT2N6dVJuZWk0N1IvOXFwN3YvWGtBMmRlVUhoZlN3SlRoNzkwbmhaQUo2Q1ZBNWxsR29URHV3YzVJQitGSE9HY2IrQ21XR3hRT0l3UzluYkNZUWtXeGhkeDhyNlF6ampUeHNvd3NPMWg3U0ZaNTBSQUNFYXpLdG41VzYxL3JFSENza2djQUNvN3ZUMUZaMGZSVHMzZnpJRmo4KzRlejVoN2xpL0NsWmY1N3V4aVVSd3F5bWRERjJTS25zcWlGckd6dXVzT2NRK0lkTVBCVHppdXdZRW13WFZMVEJ3NDhQbUw3dWFVY0dXeFJuU1VXK2RvRGpqS0pGaTRXL3VOV2RnNHVubjhsbHh0Q1dnNHgwK3I4cVVYUWZvYU8wclpzeEZ5ZUFxOS9CU084VW9vUnl0ZldGc0pxakpremdsa0IyZ09SeVRqcVB2YTVnSE9KdUc4TE1BWHljRzhQVjU0NmtXMyt6cm8xVDF5YkZadEkrT2lOOUVJb1d5SGpPL051Q25jYk9FSDZtN241TjNiL0EwVlhOcUJ2ZG1jZGZteTlmKzNWOWcwaC96OFAwOWNDQnNic283OXNaSjg1WlY3bjdISjExKzg3QVZiOXE5UFhRZURFc21YZDcwa3dWYTVmaThwbFgzaUFpUzUyclAzWjdsbm52M21IMnkxbHg2ODdqNWJnUDJ0Q083emNNWldTelNCZzh2ZlNLUUgvU0k5cUluMFFMWkRQY1lsSXdjNzFyeHJnSUJHVE4vNEU1MFFOemJCRVowZWdGOWNZd05YckIzenZKSW5QWVVFa2xkMlBuK1dsa0crc3ZPaE16VExHamNGNytEcmJ5UUF3b0ZlOHk1NkJqallieHord3hXOS8wbkYvbkc2LzNZMVVVWGM5RUMrVGtET2dpclN4YmFTZmF1M3N2cVhOL0N2OXRNQ0xSdHFPOTMxNEcyc29SR2pjTUwwdFIzOVQ4WDAwUzJYZk11Ylp3OTAzdmw5ZSsreEw5OE1rRy9YM2JVVGVhUWJ2OGkzU09XQlFQd3ViTmttcjZPWFIrc2gvSzF3NlU0WDkya002b25qUXpqWlpWWFl2ZUxkQ1FtUEVCLzhGazI0amp2VFdPWVd0M0dzbFNlQnJYRjY2UlVCWDQyUkxwT3pFUzZPbjQyWG82QmUzVFpJTWhUOHArWXJKUzFpZFRJVVltNm94R1JnODZIZWFhemxQbXFqOGYwQTdKQlVkb2VaRWdNQ014UytCaGVCR1ZzQVpaZHZLb09pZUEyMmNlemRiSEg2MjZlc3p1ZnpObVdUOE1QKzhYZ2xsMWliamM2K0J6dlY4STdTeU1EUWNOb1ROM0ZGM05SWC8yYWJVckxqaVVocEhpZnBtTlBkelFoSW5KRisrejl4VDhobUpWRmJkVDBKVkRjcEs1c3Z0dGU3Mm04WHdxbEp5STVONmxpc1Q3alNhWVZsU2pJN29Qa0dYOTN2WExmWFNsRWhPZnlLUXhDZVJITHpiakRJRHV0VHZrMmtndk1oV1d4cWJkdE84eGNVeU40M2liMG1GbnNJa0hQbnNQQU0yVi9mcXM5MUs5Z0JCRVo0Sy9COUZycFAvTVdDeEkya3JJSVZMa0g0K2hTU3c2TEZlQ3hJK1YwbVNEMFdwSjRWcEI0TFVpMmJmeXhJZWRPMi9VemlNYS8zL1pieDdhVlQrZHV2Y2FBMHo5OFB3Q0c2UGtkTTg1Z3IwVEU4YWg0dzRpbFc0eEoxVThWeFRjaXRJczRMMHVnclExa2k4bGsxV21tUFB5Q1RxUDkydHFGUk52dTN6VnZKTlQ0OC83LzhKU2QzcEFzTWJCMHlMYUlNQm1sUGxmZk1FRkRRUlZPcmxDQXlHOXIwVG9VdnVYTjVtMVhRYWlMWVJxenRaWnZ0dHJXeWFPWU5FdUtHUW0vOXkwVklDWStRcnc2aTVrcnhwM2hIWkxmTTB5U3dnNS9LaUNNcFc4NjJvZk1RQjJRWnBkcWVGS0VTVVRVYkFMZkQya0VnNzFKZHBiSzkxZmpVNWtpK3hoS1gvdVg1Qm4vY20wSUNQLzA3SVJYbk5Ma0MrNzRZNjN3aFF0SHVlRFBrYnE5YlREemdZWGE1ODVjSUJObFY4VVFrakdVK1o4VExnTGY3aGEyTzdyK3Yzck5od3RobjNmWE5heVJFTzR1eFVySUMvUDRWTURRamNpWHhPMHd4RnRITmNvaDNROExoZDd2a094MjhpZm9JQk1GOGlOTDBzVjFDRGg3QnpWM3AwdzVPdUFZZGNIUEdGOVZ1WXNjMjM3VjMrYlZpV0JoUmZHR1E2ZFRjOFZEdU1mdjZxMEdINk94cGlPMGwzdmJFWU5jSWowQWl5aExGTE5FZ2g1TmplK0FwUFNTZGFScGFPS2dURnZjS0VHZWJYZ1lkaXkrVDRtVTZNcjNsTVl4ZGpMSG1BZlBabWNVRDE4OWh3Q1gvaERHY2F5Z3lQeS9LYVJPZmRFeTdxZDFnZlBZRE1PL2l6Y01Hck0rSXY4Y2JpSzFJbUViUllqVkRwSzdqZkpvdnVOa04vNDZFREJTeG5XYWl1U1Z2d0tnd2xsWTlHN1BJcnRXM041UTJTYkM4d3c0NlRGS0xzUUZFeWNGMm5MVzNwMmFPTGRrYlMwZmpxenFrLzRoUEU4UTNxcG9LR05VWWJNVzNZVEw5eDVlMFlZVC9uUXpMN1N6ZDZXRlR3Y2JkRUxHNTV4WXFRN0duQjc3eEF3ZnI3a0d3eTJuNk5LTzM5WmloY2dGSy9JOWNjMTFISEl5WXl0V280aE9hYWk4ODRxOEpPbEp1VzZ3RksrcGFzS0lkV3Q5T1h3N2RNSUxUUHMxbnEycnR4MFFDODZTMUl1djFtci9pcWIrTExPaEhRYlVmTDlxQ3NjMzE2ZlMvenduNHppelFVMlN6YjdnTzBUZng1WDZ6Q0RmZU5ZNzVNS1JGcnNNbmt0SS9QUjJrMzdrZVJuVjVia3NiWHpmcVpScGFHbThneEsxT3QvK3hoKys4eWRRMS91d2x2cDkrdTBpaW9JSHN6NU1yaGJRM0JlbGRldHFSTFdTNEkvUW5qYnRTUkI1MlFKQ1Foc2VWdlBTMzVYZXM5SmJxNk9RSy85Vk5wbXd4L2RtblZxTVdpdnRjM0pQaXZoU25ZV0pNbldMMFdKQmM5aE5QN2lLN3doOWdwZGdTZjZCSk0zUVFsa1NBWlZSWWpucFZQdjZhS3pmeWhQMDRLdFpKWUw3ZVN0U083dXhyUUw3NEdJZHdSRm1JOUJrU0g0M0x6cmJZTzFvaHFTUllXbzdvMTQ3NlNGUHJKSlpIR0xJM04xTng2M2l4UDlFMVFyM3liWE9WY0tLN00xOXBySStVQ2VFRERiZFdodlcyaDcwbmtCajBlV3FOWmxoUHUzdU9HZG83M1czYWZlMVM1OTlXVEdIdjNIL0luTFIvRGZIWDVlNCtBQjhEOEdzRDhEQ2lkeHhBRnVOd0owY3o0bnMzeUdhSUxFT0s3QTJmRW92bTJxTjdITDNJSThxQ0J5UStrVitIVzNmdmdhVEgxVzcvTXFpWGRvUE5rZm1kNVN6TW1zN1B4dzlCYWVkUXk4Z3FJeXhUcmkxSWNHQ1lnbDdIeDdkWndnRzdJUDNyMm9LTkpyK3hWZzRITm91N2w3c3hLN2UxVm02NGhIZmZXdGk5N05hczdKMjFzbzA0Vytuc1h2RE9Bb3ZDZTJyRlJraVQzKzV2c2lBbDd5bnNCcTcyN1pzT2pTOTNiVlRCRG1YUGQyV0h2OElhbVlSelMzbkJ5NVBBQy9SQ0lna090VmpFZGlzb1B0enRhMm9nRGVlTHVKL05Lc3VyV3dJK3QyczlqNklJenBBU1UrdEtUTTI4Z3lUUE10b1ZvVVpjd3VLdllJVlVKYW9SZE5vcjU5TnJtajIrL2FpR2NXanowZHlXbXFwdnIzNnd5b1lwUXVFSitUQ25sQjRvNWVhd2t6S1Q0SFhDallPSGsrSUExd2dJOFNZbExIcVBkd040MGFmL3ZTOUFPNjMvZS9yNDZ4RWh6K1gya2FiMCs5L0p5WGZpS2ZHdzRHUWkvUjVKRFA2MGQ3cEFLN3JSVjdsZU1aL1VZQ3RtNEdyaEx3OWd1d3U0d2JjU1lRdFBibVROTGtJRGJ6bFdORVhRdzZ2TzZrcXVLbmRKU2w2dWFyOTNxaTUyazZaNmc5MjQvYlpkK0o2NE8rUGIrUVNZSXpOdHRMM09zSis3SEp0NEkwdU10cC9qN2VlRDJZdEhza1Jmd1NhdXpSSmJsRTFzTGxUWnJIVnRNSFhOS25JUjBYeE0vNndFSExoY2JKQkpYSnkxK3lRbGJ1ZVREZ1V1L2pnMzlHQWhQaCt1bVJ1ellsdXp4SjFaNHA1Q2R2Tlp2U0FUa1BQdHBtZTUvZmV0VFJQeWFKVzQ1RmJFK0tvYU91akZKRmF6YXVQZUhmS3VmSE1QKytMUlBPOUNjK0pKeFJ2Z0xzZDNRY0U1Uml4cXA0S0xqSnBXVjd3cTN4aGFqMzNqVlJIU0hCL0Q2ODVQcDY2dXBwTVlDdEluMTdjWDQ5WHc2ZUNWamV6TlNkK1gvbC9XM2diTXJySThGMTcvKzJmdFBiTW1HV0NTU1pPMWw5RU9OWlo4MTJWRFNqMlZOWWNRVUJ1Q1FOVnorWjNqZFpWenl0bWhsQWtoNWVEQURCQWtvR2hRa1BBakJnZ21Rb0pCcUtLaUJFVkVCSTBhSkZwYUkxQkZSRTBMS2xWYXZ1ZStuL2RkYSszNVNmRDBxeVd6OWxydmV0ZjcrN3pQNy8xNHBoR1RiRTN1eEI5SXZGaTFNYnVaV1hQbVhNZEdEZU5oWUpZWUpZcnBnb2VHM0VFVkJUenIxYVpudFNUdDFjb3V5dFU3MUcyenZYcEZBYkZOQjNnbXNHRUd1aHB5Z2dpTFhVdDJ1T3BGdHNYTnBBYksveENMKytIMGw3YlZxdzkzNFFPWTBkVStrVVBQTzNlSEZqbGxlQnVjaklYVkpEdlRhMlNLd0dzdVZWZk9HZ1VYSTdTZ0luN2xaTldBUUg5U1U5Y0hMNVVQRGtGNURPNEkydkRQdmhDbE5zdW14UXRnYmUxdHlVNTNSYnRoc3NRbGpPWGlOOU9WU3NuSFRFSkNGcWMvTkJRUkdqN2s2TjFRNm1oSHJZWXB0cSt4d3ZqZ0ErRWllY0JIQUFHYktDMzUwWmRLUVRVRTBnODROMmFiVnZTZ2ZZMVlsZjRWZGtwK1AyUGdlaGZrb1NLZ0FhTVh5c1ZEQnB6SXM2RXgrVTlGMk1uOVVrNytNYi9rMFFwek5UbHhvcm5hNzR3QnZXNmxacjB6ekp2THdkV3d5WUNleXVyMEdCUlptRkppc3l6T0E1bkV4UVgwekZLTm9aYXJVek9tbVI4NXlmaUQxdDRveCtjNGRPcUVjd3JmNkFVMFFqUGw5RHVaajNDWjkwNlZDUnNyRlFBSk4ycGtKSmQ1cDFxdFJnMFpaREp1cWcvNHEzUzhyTUlHMnBCUWt6bW1ja1Vtd3F4TjQrR1l0aStROHhZZGxCN1Y0MkxCUmJidXhadytkRTM5MFBYS2ZKVmRTalhvdFE3UWRZVmNhY2xrSEo4SDYxSm5iZVpnT0hBa2NZSEpnbHBycEJrcUhwZWpndVdhcTVZOVA1YWRNOTkrbzlTSHYyL0tIRUJuMWdBLzQyTGtqajBaNVpHcWtDMVpUcnhLUUdzQ0I2aXVVaFJPL0JwSTlsdW9NNE1RZ3QrYm04Y3JiUGN5dWNTTnE1czg2RE5IUlY5OXRjYjRGNzNsMFBvaGgybkF4UXcxRTFLV0JGaTFMYS9RWG5wbWlWQzNsbS9mcHVpN2l2ZmtJTENWL1hzVCsvY213NEUvYWRFcWh6cUJJdk1vSHNqTGJwZUtvT1g0ZGFUM29ndWVTTXB2OXRRelJ5aGk3aVlYQVphR041a2lPUS9PQmQ1ZlY1NU15bGY3dGxrb0tTclhIMFFhRUNoUFJ0U3VGaVNmY3VrM1FUQUYyb21wTGx3SnIwRlFPYzJCZ3VzUkErVld3MkZtWVNCaVRRWWVxWWFRY1VaUnVjOS8rY1FVZ0lWYWtmdlBlUDlHZWlDaDhIM2JweFFHRWNCODQ4dzAyV2tzVm1wMFVwdVNka0RVbXk0bjNzUmw2SkRlNkZtZllpYjllL3JKYTI2SVRPeERvSC9xYkwzNTloZE5uSHkrNjk5dmVkeDgyMHdFcDZXdUsvSGhac1lXSlplSE1OZzkzSVFMUnFncEJHLzBrdmVIR2xQWTBMSUUza3laMis0S2FsTlR3SktDdDlLalZNNDBaYXdRV1NKNzAxK1hOYm9aUWNXYnhDN09rTGZ5TDhyaGZQOFhwNHdRVUxUd0pTUm9ZZHhjMmt3K0dLcnFka0hhNktLcVJwZitnVGpBNmNuUTZNbzhzalVXLzhuUnhXNCs4b09mVHZsSVBXWVNTMkU1dmgxaXptSFptSWRid0dIZjdlc2g0QkxORjRabTJ5QVJuNlF0TVIxNXdtS2cvK1g3VTJvUFlodFZWa3QyYVFiUnRKMVBKSGVaQURkWWM3MkRKQThONHhjOXI2SGN3TUZ4d2FzR2xEZzNJS3VxZEtveXVINGhjdU44QjQreVFxbXBFTG9hQ0xHU1Z3K1hRbUJybEh6cU1BYUw1SlJHYi9UT1N6WkhXUXRFM0ZQb2tpSmg5Zkw4TTc5UjV0eXpHVUtwUk14cVJTYW1PdmdPRU1WVHlIcm9PZXhrVVVyTG8zU1pLWmxhRmJYNnllREUwdHBLOWtBZWdibG9qNzc1c3F4OXFWQjFOT292cDllTGd1OGdRTDVhZVZzZGtYZlZjaXNMeGJlUlZiUGlqZ2Z4L3lCV2JVbzJhNVBtWVVHS05FMlNOZ3FFZFNRczB3NXVNZWhOY3JuVnpYd2NuQjRPSG0rMU12YUUwdHFLdCtWWmd2ZmllRkVsYVoreVhocWc5amNyRk1scXIrdUZSWWpYYk1uVkVkMWZnQ0E3NWlSaGZqa3NZdWl2Z01NOG9tWnVDMVhKR1NsS2tOQ2RTQ1N5WUEyWjA5Zytrck82VXpzWUNvK2NWRHN1SkVMN3JZY3BnckNKWmZUeTkxOFR6SVRRZnE3bU5QU1ZjVEpoVTYzVWZadGVRY3RGQUZBMHNjeUtBbVovVUdVdmw5cGhsNkE4Q2lZdWZEZU5rYTRtZXdFNUpGL3VJSTB3Z1h2aS8rMjVGM3JsWEU3MHpDVXlBWTFYNTdKSTZvUzVUTDIvNE5SQ2kzNmFtYzJ6dTRpUTRueWFlRGRUUXh3L1pSTDk3aWI4MWl5ZzV1RGJhVkcwV24vVlFpaE1ld0JaWkVSRExjNUUzWjB5aGpJaGl0SmZwKzdKaHRJcit0alJma3F2b0UwdkZNRThCZm5CQVlad29TMXFBSm55U1NHcEhqVzhBUTlPTjluc2RiemlxWEpTUWdoV1Zkb0ZPSG5Uc3RUVlBFc1EzVUE2V0F4NzFUeG5NQXJQWGZNT2xJMTEyaDhCK1Vzdmw0Q3BkYTFsR2JJMndweEtTcWJoVE1tTWQ0MzVlYWtHNkN4Ri9EQ0pVUmsvREMySkVXdlVtdkUzOVBJTGxTb20xZ3lydE92aW5lcTRFcXY3MVN5SThXRjhqa0dlS25KeW12ejBxbEJ3aVQrdU9ndW5FRWV0VmdGeXNURzc0dFVDb1pDaUlRNXlWUmZ3MGdpTVJQUytXMU9scWQ5T01EUFJxaUJPZ2VTYlBKT0Z0UmkzOVFSd0M0VWdFeG5mNHdJM0VwUFg0SUt4RXRsbWtVYU1wVTNPZ1laT2FyM1R3b3dXNW1jOVhEelZWVVVWODdQNjJNSFVqVzFUcCtycXBRYjg1K29wTFJoa0ZSbG1qRFZqMjNTa2wrZzgxbm1GVkdQMXRFVURMblQwM2VUNmlFM3VOZm9wZ3JBOTZiU1h0YXBxVjdiTjM3czlaa0ptQ1Y5QWFUbUFKdVVPZDBYQnExRHdaWDd6bFcwakEwQTRVZWdrUk1DTE1HeDFhV2wzRnZFOGpIOWE4d1owMHZZNG1MVzVLRGZYbEp1TGNuTnQzaGpWUGN0aFJYSHBBdUErNkRUS0NaMC96STIzZ25EaU5WV1FQdGcwSEhXQWJJc1JkaSs1SUxPdEc1Mm1sSTFMTCtLMG1jWnJjaVNud3hYOEE5MXpzNVpjdDRTOHR1VjQ3UE5oWVdzZjMxWU9zMll3amp2OVdBbDczYlNQK3pjQlhSNFF1anhBdWp5UUpxRExjM3lFbkE1QTRKaURyeWZnR1pPMEh4cVJMT0ZwV0RuUDM5Nk9Vcm1aVEx2Wmo5bnB4N09obm1kQzdFUndSMmJvRkhxSVQ3blRhNVNESGNiQVRsL1ZIRi9ZQU5pRExFbUJpaHlqNFZtL1FxbFN4WTdQaXFUWVdFVkdGODB1cVJjWU95SHVhVC9ZdFg3UUU2Sm9CZm0rQnZTOGdaNTN4OG5GTlQ4T3FzaXVRUVhaTmUyRGwyQXN3bkE3YmE2UytUN3N0TFZaUDlDd01RRnkwYlRLNDhOa2FkL2dBL2thVzZnZkVwWkNGY2hxUFF3aG13R2NGbE5TcTJldnEzSDFLYlBWMXZsU0N0Q1A5Mm1vcGgvMllmZ0pNekI4aTZDUGFHTXYyRTlnTlcxeVlSeGo1UWtyZjVTVkcweFdvakpsQThhb1BOS1pJN1VpcVVzL3AzMk9XbE1HWk54ODdyZFUySVUrclRWcjRrUUxVUzh5Q3pYVFpJM0k5dGhCWnE3N09vbWRKSGtoVVRwYTFnMEVLR3U2bDFvZ0ZTYzd4alBQMU43SDVKK2VoVUhCbitSVUFyQmY4bVlpNjFsMkpNaS9jMlVQT3hMWXFXSGIzaVIvK3RpMll5dHQ4N2FaeHFYdERuT29BYnBqRUZ0NDBHemhRV3poUWRuQy9mSDVuaXNzZXNvRU1HUXQzSjNUV0FyVk4yUHgrcXZieHYwSVdvcmdBcVNDMjVHRm1qUFhzaFl5TTJRcStwVlIxVVMwMjlZVVFvMFdqT1AvQmxmMnN4ajJRdEJRaHZkY2NuNVgvcjNzZk91aW1mRlA2UVBzcU1PdVFaQUF5c0dXaStvbStMOHdZY2ZIYU5XVmZ3NWFWM0xXRG5uM0laaGw0MGROQm9XbElId3pjNDhGbkoxRnlmUHlTTEh1MW1YYUxuSW1hZmlBYWhzUTRFeHY3d0RHWUFYUmRCL1FsWXN5aVMzemcyK0d1bnBwTTJhVHVkN0xKcnVteVh4QnZSS3cxMllHVXBEZXZQNFFvMWp0K1pYRlVhMU00TUY4YkZscENBY0JoanBFMUpDV01Bd1d4eUJBQkFZNUxheWVlRFI1dTBwc1NVZEJqQ3p5QXNTMEh1eUYxR05lZVpDSkw3alVjRUdwUzBXSVJqcFBmYUVud2huSndXcmQ1RDUzRytDa0hCc1F3RHE2K1Z6b3dDQWNHOGQrMVNJZUI1SXAvY0JWVU1BNUdQZGdPRTY5OUEwTkdsR2MrOEI2TW4vMGh4V0FCNzMxRTVNTUl6VkpQL3cwaG40b2xFb3UvYmNDV3RaeWE3UEpjZS9tenJSb0ROZ2wzSUdwODBZdkdjK0MwWWVkY2VHQy9RMlY3REF3dzI5VG1POVdOdzIzSVlzTkdPZGhyREZFb1M4NmQweUZ0QjJ1U0lraVdRUTZNK0cyck1acGdMcTJYcXByNjRXNnRxN1FSNDZqK2dWbm1jUFVOR1J0b0daTXpyWitpUFF0VE5MYUdpN3NIUXk0bDJXOU00dmVZZmEwak1NanQxcDhCQ1pvNGl0TStCcDFtQ01oZ0V2R2JvY3VHV0Y4blFGNnBldjNMTGlxWmwxd05RVUhXUno1SlpOZThpVmRVMFQrbUZyWU1VV2ZkcVNZZ3RDbXMyd3dhZHF6cnNwTjVHNW4yekdoM1RFUmRveG1kOGVPaVNwSW5iVml6Mmo2Uys0U24rUmcyaTRKYkwrZ3hRSzlNSHVrWnBHK1drempVZGttUVUvbm1Ja3E5YmxEQUpkNGJocU9LVURwck43aFlYeUZYNkR0empJSmhUTjRDZHlpSitBVWtKWUNqMHlXekFNN1RCZzdMai81RVYvSkJYN2M5Z0wxZ2lHcENKeTM2ZGZmT2dWcXJ0R21ncXA2REFxOSszOHlQYnYwS3Q4U0k2RXJPUjJwK1FWQ2Z2QzlJd3pRQjM4TUVlZkRIVzFwV09sNmRUYmxGU3BSdHlUK3NaRURKazBUUWVKTTVCTEVUWGVkU1FrVkFPeC9hQXE0Y01aRVVMdVEyL3Flc0V0dlluVWVQamplekJkZEM2dzhHd3gyL0w5ZVJiS2FnMzRrL3c1WHQ4cWNzK2hvdlBoaTEvUGxSQ2hSbEh0bVZrbEhOT3FmeHVsTDhoL3VxS29RQ2Z3ekJaM0hzN0c4MFdod3NxRUdCdnZRVGFOdFVncllPQTVXcERPbWVZTnY4WmhiVG5xN3hac1ZNcWc4bGVocGJGQ0NRZzAzUEl0VHEzRGhGRDZTOWNncE1mcmVjVVlabm1WZGpYMmpNaENSQ1pHS0xpRWtrYThjN0VtVU43cElZYWZweE8wNVE2cm5hSUpPL0RaWmJXMklud1pONzdudFVZTitVdjcwa09NT09wQm1oZkZYQlFEY1NIczljYWo5MitMTkJ2d1R4Ty8zTmJleXVoM29RQ3cyMUZpSTdTKzNHeDI2MDIvVXEzUU9WOU1YNThpdmJzNFdnMW5JT0owN1h3UEhsYi8xbGRzZFhGSFM4WDk1eXJoUjRYNlJXSThPTEFuVDNkV1Q3UkZTeXcxNlRDM0hySEloTFovV2E4L0pnQ2hNcUFFckI4REI1ZWwvK3Y3TlFnZzlmSmZhWUFTR2VDVk10Ti9SQ0RLWkl5cC9rZlZCK1BpMHBpcVdRbGxhZmQrZDhyNFgyejFmdmgvc25GSkIwVndOazFmbG5lbit0NTdxd1NCbVZyYWJBczJGdVJTcmRXWjloN3J3akJCM2l3dUd2aE1qaCthcm1McFQzN1JMejdHR2xaSDhGdy9kOVJWRmR6Uy9ib2lLWHdlZStlTGQvT1dvTmN4bk5Zb2FPNVIvNkJ1RkFxNUFmamZ2ckRUNHlBc1l1Uy9OeUlMa0U3SkhHWThaYUJBZmpHMW5XMThzVHlNUVNab1pGNy9PTUV2ZytlUnJkTzRPb0R1VE9kRmZNcjVEaENsWHFITU5tTkwySVhmSzh2eUZiNFkyWnFxbnN5dk5CbmZMRDdoNWJUMjhGVFZKelBKOER3SWR6UXJkNWVheXMrQ3dJQVdFS1RvT1NRSmVqT1M5S1BsVjFCRzJJL2wxSkVTQlJUT2NBVjdhR0VZc0pxS0l2TFErREN4RU9ydWx0V0ZtRU1jNldFN1hSYWJ3c3J0MTZXektsU0IrSW5EalV0TTZNd1I3Z1J6enBsZkRhN2NRL1Z2ZHNKMm9mQWw0MzFqQXdOeXRVNE1NVG5SNVBubDNtZVFnV2xIWmVoRVBPSHBnSWk5TzFvQXlEOWw5YXZrUzRRNW9Ea3Z1ampDRlN6M05MckphSTh5Y0V0dkc0b2lUMDlDTlIzdWxZdjdMV3RlOXV4N3U1dGlCNnY5ZmNaNHlDUmtHTlpZVEtwRGwrV2N1TDROSG1RbUdpUkFZQUp3ODVNN3ZlWEd4dnBqeXhYKyt2RXpOd0NUUmRmSVlpODdONG56aUhHR0g0bk0wTHdNZGVvVTBuOWlPd0lWR0o3SEp1bnlUcjdrOVVIWmxYOUtnQURrQ3RkM2ZTeE9LbUc4bytXdlE2S2hqK3ZMOHg1dE1MZ1RIamw5Z0s3bkdnTEdsZHZUbE0xWmdtQmxCUG9pdmREMzNRbjlpZElMOHBxc3g4djl1NTlLaE5wZXpCMVl5VXRKYkV4Wkc4NjIrZFJqeG9HbnRyY09ZWExVa2FHSUgxUWlUT1BwVGZnY2FKOFhmTG8wTDhuZ25QYlBqRHgweW94NXRLUk1XRVpJWXpBcVJUWW5Hb2paOStzTm1sQzRpU0xORmlkckxYSE9wdXlhREV4Tzk2UGE2QjB1aDkvOEQwN1RKZlJWTTAvYW0xNmRpdEtZeTZVZTVmbE91SCtYNloyU1ZaMkNUVzRvcm9pcVM5U280a0lHZEdCOXRUWFFHWkdGODlPYmZJY2xCT2pEcWpxYzFaa3lPMUVNUEVzUnU1dFlzYmtqNTU1MHptUmNXb0I5MlUwYXdodDRIblZ1ZGp2KzFWY0pqODIxeUFqZ2dMZFRZQUR4bFR3VHZ1ek1kR0I4ZEg1YzdjSkdSYXBteFBUbEgwOHlzdDFHM29YcXAvbWpmYlFwc0Z1VFh1dFNWa0lXMzNKbjB2WVdVYWNQMlZLc0J5dFFjRmZtd3ZEVjg0bkRXN09hdEtvY1ZLRGJjcVRaZ0huNGQvM0IxR1RCZmN2ajJJeU5DbHZNM0Z4OUIwRWIxUTIrV0t0NHNINUpqZWFUNklVOXB5bkdRNUpkUjM3TTAvOFhWRlFoMGR6VEJoMEpGUXUvcVJSYjhtWHRHR3Y2eE5ab1kydlNBMG1JUGhEaVdpaTcvU0FGOFh0UURVd3lJVGIzYmFmdUk2cWF5NnhYRVEzbDJMdEtCZHlsRGxQek5pc0phRk5BL1FvN2NWdlhnaGRtbzlZQUdzUWZGSWJzWXJuLzVKZGVVdEJGc0ozTkV5ZWxvZysrQUM3N09KazloREt3TGgzcjZWY1oyNkVBV3piSnlzS2JxcWh1UWJXSFlBaWVOTzIwNm1VQ2RDdnRPVFBzdHNyNGx0elRVS3k5dElnbDBjMDFtYTJXbXNwZytiQVlYd0QvV01MRHl4VlVtcnhWOGo5Vnpja0xXSUpRN0REU2JLTHd5MjZhNTdZTERNQmpDdHJrMU50YXo2eUlrSlc2VFlGb3NZWmtGS2FFbkdaOGcyQm0rVk1lb0k5NVJSQzNRWkZsR3oybVhhSnRoZndtWDV6OCswaFA4N1pvVzdiVDVIL2dMR1NyNHZiN2pqUVFhVjc0b3JUK0dRSkhVaVIvc3czRVJiN2cwLytkSFRIQjdXU1RVVlgyNkxzYjNjRFhzdml0S2k3d1BKa2NjRW5YQldPUENlSUp3TEJNcDRjWXl0QUF4OEJsY0RxeVlTcmk1WVlTUXYyZm1tTndnZmp6MEd4UEJoZTRGaU41MURzb3VUMmVERUFMZ0hvd2RJdTAwL0ZCb3BkVVdJQ0hibzRPamdIOXpqeCtHd24vSGhTY1hzSVl3OU43Yk1LakNhZXRvL3dSVkFUSlFKOTk0Vjdubmk3N0NEVFh0bThoYTI0Qk8vV0RhZDJIYXB0TW4zbnVub3BldTVrbjIzSWFvb0UxTVlXQzdKbHpCMnlwQzFjMkdnK0I5Q2hWWXZXUUNWcWVBVVIyQ1VDVlQ5N1llL3FzOFQwaXdRa05uRE04SE52VWJ6eFk4SHhVZU1nUXJtUThtN1pxOGZVWUFibXMwRmdVZXVsYStUZTNnbGxGcmE3YWo4K1ZvSEQwYlpodVJ3dnFNWXB1SXJEd0RkblQ2UnMrakNTTHRnMFdVRCs4MUdSZ08vUGt0bjhtUzVkZ1hNTTcyV2FFWjZqaWhYbzAwK2NLZjhnanVnN01zNXdMUWVzdnpGNStQS3JJQW5UMzdSaSswK0k5WlVFNGdoOExWS3VxNnlnTktDQk5kM1JaSi9zU3ZkVnNVcytsak52dDVzclY3WEx0cmVIMjFYZGF5UTJabDhKOXpENjBvTzlUWno3eFU2Nnhjb3o0dmdIeDJyYi9TVXpkWUNDTzRCRHJJZEZDNkUzbzI0cGt1YTBIK20xZmUyKzBMM1RBTUE5S0s1L0hiZHdQQUNtL0VpOWk3MTB3cWtuRitMUzRvMW1saXRGa1ZVYmtUZjh6VHJHMnpvem5QdUhzTFlZUGNqSGZLVEtKdVlIUnZzS2xBQlMxMGI5SlR0Q2ZQR3Z2bFZyQ3lna1NoZytUbDUzZjdBamNJaUVhQzhmR1F2QS80T1Q3UEN5VFpvN2Q0RGdxcndVN3VpbloxdEczay85MDdTMUNRc0tPeGk3c1k4bmVzWFF1eklqSUg4ZWNqeFN6WjVNMXFVSUdUM3pMdlNYNTdrNmNuOWtaUEphbmswbHFtd0VldTJkK2JQVTJXL2txUUNjKzIyYk5JUjdhSVNkbVFFd2hFV2RadXZ0eit3SlBBL2xqYXpRZmxHcTVKU25qUy9NNnRTbmpVR1Y4bGFqY2ZQTDZ0K0hCTHU2bUw0MVZGNnpUZmNIbFFyTUd1TWUreE9qeTBJckZub0pxVXRGMjl0MmI5eTNWUmZNRExBNnVXeU92NWZkODFxcXJUMlIrajAvTVVsOEdVdWF5M2pLeWNMVzd5dnRwOFZZWW5JdXRCeWd2MFF0SDFycWpOV0lvUFpSU212ckpuMml0YU1xa1VLSDhrS0F5MUJGU0FabHlmcXhmMFBNbC8rcDFhMWJXeW5FdFRiZUVzYkc4YUlCNTU1SnVQd1dVWVEyczlkVEFsd21SMk80YmJGVGtJb3JUNmt0VUE3bDdQZmN6VjhXMm5zRXY5OHJzenRBTWVTTzg4R2dDRFR2NHNmWkQzRUwrNUFpSHNkZ240Z0xiOHE5TTkwblZnM2UwZG5VM2xnRGgwZ0RZL2d2THVpeHhVZEVJeGo0aXo2ODFtYjNEang3eERrVkdwSUppaVExT2psTjZ2YU1qMHppT2ZpUExRVGcxMjNmSUtzNFFTbGxuYWFwT3hPZ1loS3IvM2dWRHJVSnVyQ2tYRjA4LzhpM0N2TzlXUXFrcE5tRGJPNnhwSDJRcGJSQWI4LzVENTlEVER2VmVjMzJ5NlozaG1vN3hsNWdhckcvQXNHMXo1OHRmaHMxalg2TGFEbUF5QytFQmc5ZWo3RDVKaHM2cEdPb2VIMERrbWoxUkhRN29xT04vTHF6RGZ5NmVnZkMvbmtDNFhjU0s1cGtiRG5oeGEzM3U0T0xxTGdaY0tLM1VPVmVzY21sTG5FT3NjVXVod25hdmwrYU5tcnF4RXZkZzZBTUdTUTBTbGxVekJLdE9kOWpCSlUwL2N5RXFzK2MrZjJxQlFQV0grOUQ0bWVuTjUvNFYvZXZ3Rmc3WHd3bk9YS3p4Um1QOGFxRVlyVldMVy9CcE10cTIvWEFQdW9iOG10ekREazJ0LysvUWs3TTFrcGpPdEJveDVwMVNPeXNib3RYQVgwVlNLUUZ2Sy96ZlhrVlQ1YmlXeTFYVUVSNEl6Z0tGWFdVeFBPdFhWRkpiQ1RSb3VGYm1pdVpySE1PSW1IMGFlRkRycHJwRHYvdlY0Mmp4NURIdmFMRE90eVBKQnN4MStZNGZVdDNCV3pqdWtRZXhXelQzc2FObURxRjcrOHhxZWZhL0dMSGE0Tlg2dHRvUmtBWnhPTmxWZEhRL2lQcUdVYXNFMHBnZ3VEMU9Zb0N3d3J1N25LWk9ZNUxkOXNvZUcyL2xtMmp2UFpuTWdRUXQxaDJ4RlFHTnlsUTJnQ0JRUDhOejVacTI3cWtJL24zQ2M1OCszYUlFMVhaQzFuY0JsbzA5WVZrOTE4eVI3b1VtaVBrb21CT3hIUlcyTEVhMnBNMWFTWDNSSG9hOVZINHZ6NG1sZk5SL1U3OEJQSWxXbUwyV1U2TFdLT0psZmNVL0lHemFPRng0NGx2MDZDS0RaRGE5S0JibGF2YzVISnovKzA1dk9HNGM2Yy9TVi9SLzlVZTIwWVhqZmpMNzVNcmpxanpySnJ4aFZEV2c3K0ZSbmVBSTVEOHFnSDc1UWhzMDUrVE8zUWYvempZSWt6NnlPL0JLTXE5NkZCMSt2aEZXTkRGUlVsTlZHRys4aWNUTWhDRDI2SDVwZWFwQmNJa0tyV3ZDdHVNeCtncFV2UllMeExGSVNLeitqV2JiY1FaV3BjajUvcE9iMWkvUnVsL3Nzd0ZzTXJkS2x2dHVBUUJsWUE5MDV1dzNUSFZnT3ZnSldsWS9rVDl4bTAyUUNTYXZNTjBvYU4wZjZ5bGpMUWNYL0g5ekdlSlVDN2MvRWk4K1JzL2xkaFlKK2FYN1gxMnZXWTRjaUErSUhkcURhYkk3V004ZldnMXJTa2oxZG12LzBhOFdyRlI1QWc2enlIejF6M2M4TTZOM1MvTXRsU1hVa2w4NThiNnZwakVPM1YvZ2hWMU5oR21NSTZya1ZhSFZ3Uk5ZUGorU1BiQzNHNFN4bXdUV0tqZGgwMUI5alpEc3NWdXZOanphQTB1eVBQcFptb2hVUnJmdU5LVlJYai9XNGoySURLbHJzemtIK082ZllvNFA2aDNCUk5Wa3BjNUluWEpGOFArVWEvZUNSZnRMajNRb3R3YURJN1lxTlhrWlhRZXBTVnFPQ0ZXNTBYdTNpV1VXblZRUUZNZlovK3ZPMGdldEc2WTVhMzZtWk02Mno4MGorazYzbGhFeG9nSUNyTUV4MjJnMlhmSWRkY2xnRzBMQk5XT29tdFh6MnE4YlFsenAwcXl3MDQ5QXJ6VkdIZkNBazZhVkYrcDFqZFJjMzc2d3dRRVJLMHRnZkdVZU5uVC9rUWVncXhac1pwc0NOYjBBWWgxU3RJUStGRHBjTERzNmF5V1l2UTJpZWphTFFnS21naUlzNEdlTHdSRWQ5RXhDaUt1eVdzUWU1YWcvYUN6dUJyeUQzWktPV0puZEVNRTNvUm9iVCtwQUpOZmNMNktKcStCYjlvRXg0c29nQmhiTUl0ZUFJdGFnc0lRYUk5UHdlbXZLN3JuSFU4S1psTmtIbWgra3BrVlNOK1VxSjlpQStKakNoTzN0ZDdYL21nYldrcW4rTi9LYnVtV1U3dnUwcjFrUFBHemhrRTRRS0ZFRmxnekJHNll6NWpMM2FBNjBZQXc3am05MENSTUtmbWF4YVVqbGtkSU5XYkg3NlBwdjloeWVDMFJZZmVybFlFa2hTTzFSUldNd3NUd1h4SGI3Tno1VWVWRWlnYUdDWWlLQWtHSTBlSmlKVUppTGNpZUFKNVhYb2Q5cVEvdTdGY2lJazZ6S3ZUcDZnWkNJaTVWNndaWko4NyswRkU4RUFHTWVnbDFSTE90eGNQMzYySWdsVUcxWFFMelFqYlJoL1FNVlBzM25ienJiZVNBMUdDNFk3azgxeU1PNnFGK3c1WEg2dDI1a3VielcwaHpueXNLYmd6bHFFUk5ydWRYVkZCdmtPRDZGSjYvWEhydkpIMVlvOExZOXh6ei9jN0RNeTJNSncvcy8vTkx0N3hLdmdkdi82UDI4MjNSSytpdS84MkZWZFdUSzdxc3pZSXBGandYTFBUcThLdGVwOUZ5TEdNREljNTV1NjhMQjBzcnF1aTJoRjJ3aEtCSFVOVXMzTVRjVmZTKzBpZGZVZ0NOUjlRbjJBZDFrZllLd28vYWlJdUxVMDJKRzZPNFFBdWNBb00xdHNGbHRHL012SWE1VVlHZjRzNXZ3eXR4Tlp3TVN5UjhsWlZISEtPVitBR0J2ckpEalIzWFIydVlydFM5Sis1QU1yYlNDbEN5cFIvTDBDV3JOV1FHdldiWXhYWFgxVFRSU1NDSXZrSXhHUWhLVHgzTGdlVXAyT3VodEUxcWNtdHR5L1J0ZWVDdU11eCttSHB1YXI5VnFCU2FhbnpuZzdhVUNRUHdPNlVjODNCb1VCNWZNTnQ5UkViYkNLSnVtQTltc2RJN3JLYmhqT3dBZ3ZIVnBNNEpxbkd3bE0rM0tHNmFjeFkvZEgwbjdWYWNMUktMays2Z3lBK1pFbG00Q3JDVXV1SmgwZzhvSVptZjQwMmptT2FCOFJqc1p0b0VVRGtCNEhHakpzL1RpeUdxQlJEeExKTVVWTHozeDd1engwR2RSV054eVJnVUk5WHNIZjk3b21hdGxEZEZLbzRST3VBanRad3d2R21nNFhKL0tJcUpzVTQ1UkRHT2MySlFKWmo2NHBnR0U0QjB4TW1XZDd4c3JRRzZzd3ZPcDNRcFJMeVpFYTg0SXdEK1dmdWI3cWpZUEdXWlZuWlkwVjY4dGpORk1WTncyU3JZdUFzRGJSS1k2VWNYT0IrQmVZUUcwZDBaQWpPZ1VLQzRGbEdvYVptNFJkRUZEN3NKSDZ6RWJxdzBicUkySDVWeHk3bGw3UThkRllzMmQyZkRTSnZxUFM0ZkdFaW0zdVp6OHFIUjVQNkhWNFBJNE9qNEZ4ZUR6Qkt4d2V0YWFxVTVUZjR4UVZ3cS9tT09zUlJXL0VFNVJkMG4wOXpSbnh1RjZQbzYvL3FPcHhoTy9GZnplNzQ2NTEyejJ5VkM1SmMyeEt6UmxNVVpDTlJ3ejRabURnM3VpdCswNTY2L3J3MXZXTnQrN2ROUzlXb1hicFFiM2JwdHR6WjdMalJxVStzbENEVWZHd00rc2JiVjBvY2l3Nzg1Y1YyNS9hUG12cUFLYTJ6NVI2d28vZFhjWVlnN09xbGViWFNGUE4yK0g4K2RObWlpT0xYRkk0MGJ5UlBqUXRZMzVkM21OK3RYeUJWU09tOUhlcGFTaXplcDI2NElYNmdEMFJFaElLb1l2QU5PcmJsdEhXYnRuMVBpbjMzMGg2UEJ2cERpKzB1dm14cW0zTlgycmtSTzRPTis0dGpiS0lvamdEdjkrR3hkS1gxaGgyWm9wbERmU1c3RThEanAwS21La1BzMGIzU0tIai9hVXlxYWF1ZVAycWhQWFVuV0VvZi9tUmlvYUhvOFhXQTZRbUMzZWV5cTgxZVBJR0dsU0xZVzdRNVVpOU5aQTduSm1aQTFCNElyQTRtUVpNeGp0T0djNWlUWGZNOStMZVRtVWVSUWlEMlV2WEZVOS9BREpUdGtvVGRCai93VGZNMGNycjhQMUFZZHlyNjZoeFdEUHJEdmMycEtkSG85WHhBVy9XaVNFSFZvQlhkZktmZmFNVDR5WGluWFVON2dRMmVFaEc1eHRQVC9FRUxIWTR4b29NWSthWlBWNjU3MW0vT21vRUl1THY0Q2ErMjRzS2xsOTYySlJNekplL05HTW1adlZJbmMxeDhPbm9VSnpYVkhjMWRwWEJERk9waFlKdjBZRjhtYmVsV1VvSnFxZFE5RlFtYUppb3FtVm9wZzlzSm9icnJNdWZibm9GaUdic1pMTmlWcHU4dDBjVmFwcXpxUW01TEJBNi9Na0lHa29zbjVwU1dYTlR4dkZxZ0N4ZTNld2lLbG1QVmRuRWlqRUJWNkRrNDI3bXFPUVVWUkpvUjhZdG1JdlVVYThlSFJlQ0VJRkZoRy9JN1ZISDFiTEtUYnFhbmNFalVWTk1Mam9rSWNFR3MwSzdaZ1U1Um1ZWjhjNXNHOHhPUjVXNnRNV2ZDUkpUdGZFYjYvN2svdk83ZllPdVd3dHErRC9QNHg5Zkxnb2tVeW0wKzcySVlGSGtBaGZKQzRQOElVZi92dC84M21iK1hyUWxPSjdKRXQ1bkw3NndKZFNMN2JoQW1jM0EvcUxGY1psM2hyYWxubi83b2JzMFU0T2I3LzV6TkJnUk9WSmdCNEdudDd0dHJOL1hMSk1yWU5lNEdnL3hiTzFvL3d6ZzA1amZlL3J4bTNCM3RKNG85aVJlWCthZGpkMEZqSTE4TVN3dXJrYWdCMjl3RGxOazUyREVTV1ZFaHRhVmNMbHJTNFJjd3QydVhTc05vNEZHc2NOVUMraVpPSFhpZE9qM0ZFdlFJNjZheGVTckdMcFRqNTY1eHFDeW11Z2pzOE95T1BHSC9VTnRzbGQzTG9LWXRxZ3ByRHA4aHpQSXc3ZC8yc3JEdE1EWDBkOHpzZnllY2RXcFJ6R2tDYjNQa1hBTml1cTZ5bUY0dCtFdEN0OHVtVUVUQUlVcUFXUmZJL1pmQjRUVVFlcWdPazNwMjVtN2FaMW5VemNGeG1mRE1rRVIzQU1OWTBnbFA3Yi8yWlpFUmdaTmoweVFrYVpMYlY4ZG5UeWJGVHVsNjVPMDlxb2Y5VkxjZzg1SkVOOFl1YzNTRlg5R2Y1NVh6NnhVZ21hSzBKYjhoV2NmKzY2SlVsalBJRTU1NmQwa1JqTGs3NDcxNzN2a2ZCTjJPZTFFMWppVHU5YUhUWWZEczRJVlhxY0U1aW1IMDFBeGEzbCsvNmZMZk1pczlIUlNQWVhFeUJjaXc4ZDROL2ZXcjVVekRqbE41QlNzclpPZFA5WkRnU05MZ1orNmE0cGZGSndUZXh4Mzh2ZW0wVmtua1Y5ODF1bXFRS1A5TzZPeWZONXZYZG5xZE9reHZCVFo1ZFBwZWN1RkltVDZEQ3dSMDJTbzlNNFVqaUJyNXI0d2V5U3F0MFFaK0lhNjdqZEs3ZzFFbmFvaUViZGxIOTBXVlpWbWoxMVMrSnFVWmplNHhEWHo4OFl5aldoNDVYZkNMNXlZTllmUkJ0aXNFUWFMd0hyZ2hqaXAzRzhxUnFVd0o5S1lMbU1lakRCR2YxQ25ZTzBDU0NKbTZORVU1UWs4cmxEQ295NUJ3Tmd6bU5sNnViYnRDYVg5NEh2RmJKVEZqQWNwWnVhU2EwdDlXTVZwTFZUWVp3aWxSK1B2VklkUUdZK2YvbkQ2NXBnZHZpdUkvNFRXTVExNG9xRmtubWFNZHBQZklMWmZTSmxjTUJGTTVxNHo5OWZHTHdWV3ZaSE9xdDA0bUJWMEZvSVhUU0Y0OVVxRVMwTTFOWU9jdEFrR0RTSEM1ZWxQbDhyMktGK2dxUU1qVFdwdHgrVDdabjBLUlZBcUZpcWpQOFRsV0NlcGMyUzdJRXU5L0pjVWt4OENacm1jL0xBRGJFYTBZa2dlSmdyRUxYSXljYmtIS2dCQWwwSllJVGJKaHFaSlIxVTdaK2Rma2lVZVNCUGtaMjh5ZnIxL20zUmtROU9LRHA1dDhXZW5ocGZRVU5VY29aeTRvS3U1UCtKOGNuSTNNRVB3NTYzREdUUVQ4dCtKY21XaWQxcnl4U2FaR25hWEJ5THlJeXhBVGxpRVl4VkpHRHN0bGR4RHhjRkVJVGdQTkV3T0t1TmRyb3F5aG1vM2wrZFhYVzdjRS92VHhzNXNBQXFUMW81MDRFS2syazdTdUF5aGdjSWVJd1lqckhEb0FGT0hia1grTzJXWWduK0V6UEFIR2hWcjc4eHlmaEEvVkVTS3p1Nk4rR3JqTG9MS2Npc1hXcFQ2Tm1kaTFsQ2Ywc2pJQ09qMEsvOW0zSWFDZkRHRk9kUzZ1TExhTG5yS3JqWXlENFNRU2lGdGJJUHpQSkE0MFRyanplZkZzdUJFaGhsRnppbm50R0hrV1RLSU9JMlRLMHV2Q2JXMjFQSG5YcXBteWJNNmpySXR6VzNkbE81Q3pWRjMzSUMxcVAvVlFad1czZmo3ZGE5dndrTnk4MTN1ckFFc1pndkRWOHpKRnlOT2Y5cE9ya1NVVGQvUlFUNWhJSW9NTTZNV0JRRGZFcGVWMkxaclNXNTd0UG56cXhZR1ZaSmpHVkd4VHBGcHFrMmlLTnVyYWw4MzlaL0N4S2dMUDFDMVBsTWtJdWFGNFMyNnZPM0h6RVc5aDliaWJVU2tOZkxrM0dYZW80QmRiZkp5RC9SNE5ISXk2aVJtL2Z4Z3kzNXFEMU5mdElERlRlejByQzJMbldCYnBmMVR5OExld0VhbDdTNE1EbS9rN2tkVG82NmlwWWE0ZDZHTTRyNnI2dDAvOFp6THRzRXpzTnJTUG5WeXJVQ2lJeGRDdHhNWEtSQ2c2MWt0SkNUUXFDeURRRnI4UG1CLzJ6c2ozcW42NTUzNjU5MHM5Z3lMNlowemVPZDVSMkdobUhUQkFIelhaUkhkUXBaeGE3UENNOUo2YnIwZXRldTVmeVlqdG5zR2hOeGtseWVxOFlmazZKU0haeThEV2VYam8rVFJNQnY0WW9WR1gySlZxQys5NHREZFNsM1dKOWNmbXc3Y25BNWNudzRZSDNiSE9YMzRUeTNPMjI0bnYrL0Q4TFZCQWhreUxmbFhiakNBSlVWdUZkbW5SS2NueDh0VUJXVVlBSHZqNlZJZ2FCZ2k3RUx0QXpTbHptZlJLM1RuczhuZStwLzZQVjNDYkwzZVR6TGJ0TFB6djhJM0tpMWwwUFByL2FGc1R1KzlPVlBlU09mY1d0Unk0UDR0MXgzMzNzRTdWLzdvL0ExdjFocGc2eG5RY3l0NU9ZTFZWZ2ppMGY3eUl1SmpsenQ3eE1kR0VVNExiTWlEd0F3YVZWNllHN2M4ZWcyRW1zelBXNGQ0WFlWTnJTbmR0alFGcng0SFM0WEhtQXBpb2Qzak1vbWp4cms1WmhHdmJCdEtHWlg4ZXJUQzJBdWJoYjJRV1Ixb2ZraCs2dG82bXN4a1VjUGZBdzExNmNSbmRZa041Wk9mTHNINGtsbXcrSEluL24vZFlFS1h0bG9pUFZVM2FJNDZqV3lpN2o0QmtpTnRBblFGTTFvSkJXdGVSY2NsVHlIQkJxV2hTOC9zZ3JxNzhaWlFtREQzNEV4WWNjSVZudmJycWRoUnFoMFpxV29kOWZqbEpOQldCSHNwb2tielFhb2JNVE5lMVpWam1qQTZsUC8ycTBXc3EvR1NjcGZwNERxYXo1SS9IalVvY05yTFJtRXowUUdwRlk0TldWTmgvWkNKS01sYU9jZ1ljTjFBVndlN1NtYXhCdExXU2dXZkk3SXF0UzhZSk5QbVhsdzlVeVU0OGxac0Q1RXh1eWo2VmVwZ0NOeVk2bnFFekNCV3BWKzdzOC84b25sQytnUlFlVk9Md1IrSG1FNVlRanR3QWYwSnNDVE5DTEIwZlpiU2RTMzlURy9wWkpiU0xTMU5QeU40ZHZlK2xSWnZSVDF2SlIxNnRqenZHS0c3OE9tTExNRGFMMHNQRmt5bE1GYXlNMVQ1MWV1M2NWQm1MWXB2T2RZYm51akhDcDA4SEV0MEFjb3RNT1VXb055Q3hUd0NERnVodVhBTnZ6WWh4NjlKaVJ1cGFpK0NvczFFK0hQSmFlQXB6YmlPaVFkSGR0bFpMTlg3QTJPcWxpSTliaE1UNU1tcS95TXdUeGFvYW5CSWt5MjhjUVVwa3hvSVRONExMY1pETHFKRGg1WlVUNW9JaHlNOWhrOUg0a1YxRno2OXNPbW8veWJQclQwQjQ1USs5VDJHSFFUZENnQlZVVjFNcFQwMXhkMWNvZXlDdjdERzJMS3EzVnJWZzlzWnhCWk1EV0tURGlYYkVTUzdHOG9CK0p3bXQvdWEwc2dEZWw2TnVOS2R1bFZ1cklaQUxpenFRdW9HRUtuV2xGK0xqR0VUVFd6Sjc5UzRiVFd3M1pycU53T3FaOHkvVFVZencxUE14ZTVabEx0MENhVjBIYS9VMi9WczRlZ0VzS01RUUx1d2sycCszbFk4NWZockdVWjdrMXV4MW4zTE1OeG9wNVJabEtZYlZ1dGpnMEx2MkNlNHZTajFhSUdFODBkbklkS0hwVWNEM0ZMK3Bnc3Z5QlllN1UrNm8vS0cvTkF2RGFOVXEvTGQwT1pHdUZoekk2UXFDVW9GZis2OTFLamtqckFsamM3WGd5ZVZ2VnBBeTh6eGhaVm54SHU1UVFMWU5rTTkyY3lkbFoxMjhaaFpxcERzUXE3WEVRanZMZXJlSUwrUDQ1dDk1czBUK0hRbGpGRHk2M1JGRFEveVR6NSsrK01pNXZxS29vM3dXY0I1WXZKa1BXejB3WXdNSlR1TTF4YTFOeC9RdkxPbUZuMnZLNU83ek52a1cxdHdZSkVrQW5XUkdnRStJandGbU9Zamk4bmk5RUpKQ0Jkd0d6SDVQU1JKYVJEZG5HNk5HakNzY2dZaEZ0VnBnVm1ScFFrQVQ2MHJrbU5HSU50bXhXWFFBdHIybEVhSW9hd2pTczVFajZqeWg0cWthSlNOakZWWm1LWVhkQmFDeVpiSzRWTDJzdC90RElBTGxyOXpaQkYxek1LSHBEclhXUGdINWIvRHNBbms3K0h5M3hHNTh2THFoem1YZWN1eXBtbmFZQ2V1QXFGbk1pQnp3Ym9NcGMyVGFQMGFRdSt3UzdKWXpRa0F6UVlnZmRwODYzQUg2S2h6YllsRjVnQjBwV2lUT2R0bFc4a2VIOEpyeThublp4WkVHeEZDeGNKTXMzVFJhYm9LMzZNQlFucUZQKy9PeUxZMkFZN3YySW9VYlR0MWQxNklWeTk0aHcyaWE2b3Z6YTVBeEoraC9OK2VBL25hRldpVXVWWW1UOThUYTlnZGZuZWc2dEN1Vml2WW9oVTh4QXEyVkN2QTYzbVpkYkZzRDFsQmVNY01kZWFtc1hXVkpzN1U2ZFpwQnBGOW56TSsyN1ZpSDUyWk5WWC9DUDVtbmpwLzlERzkzTHIwQ0NOS0lPOUlEai9NSXpDSTg5TWowdm5wdkJPSE8wZW9tcEdkT2E3MzVSUFN3NHVYSGI1N3VMNTd1SG4zY0RTd2pWY0dkYmVmaEUyYkhvWlM4OUo1dXVYVFFhN3UrWml5Yk41dzV6QXBQSzhyYXd6aW9Od05odFdReEVsQ0kyU2ZwKzIxVlBXNkZYSnovSENPMVQ5M3JTbVBDVWEvY1hGR0lUSEpkT1JReWd1Skt5aitQVzQyVDdNL3c1SUt4UFo1ek1MUzFLenFiMjBqYUlTVUFJYlVMb2hFRHhaL1RiVjB0WFNoSmxKWmhDTllHR21vQjF5bUNqUXhoeml2T3ZQZ09vT3pmQ0ExS2JUMmc4SjBBZmtBcCs2RmVvQkxKYy82YWp4OEJuL25MZlAyKzBUK3VYRnpUVjhxMEg5VURtVUw4NmNMZnlWcDlNSmtpei9mRE1ZQ2FTY0lTVGFQV1JyYzB2K1grRUo2bHU3emRYbnV3ZC8rWmQ1ZTlqSC8vSldNeDlOUG1ycm1jYzZDempCbmZqNzQza0RPazJFWnZ4M2pIV0FhNyt4a2FicGFTSXk3Y3p4TngrWEh3dFBXU2xuNU96cHg2WGpuTmNhOVdkcEh6TjhtajR1VHVCZjdvUVpQNTNFalo3WGhUbjhPdmxrdUduSGFTYlB4VGtkT05mbXppTFc1NDVqUWhYS0N2UVlYcVNGNkpxSy9xZ3VBcXdtVWNRdHhnSGttWVdHSDV5TlRCaTZjRkRHb3BXaytFODBQRTJnbHpJM1pEM2VHbGlXSmhnNzNHNUs5M0NoVW1vcUpJWGQydU1vVGxPSExtdU9OMUVIb3d0bHRkY2ZQdHhBOFJPNmNwUVROVlQrNE9KK3N5LzhiVk5pejF5ak1nOXRsVm9Hek5Nb2t6bCtwZGZQbWVrU2F0TUFnQ2JVeE9RWndCcXdwMVNNbGt1ZU5QekUwSW9xTG9iS2xRYTdpTTlORzRYZGVzRnRFQ2FmVHliZDJNZjJhcm9kR2ZqdU9XYk5EZ2pVbkViN0RuSzlTend4SHJDcjJVWjdQZWJwS2hUZHlvQmwxU2ZHc0g3d0JUMFhNQmxETmNaN29jYWdVU1QwenpKbVJ0c0VkdG5VcHRibW1BTDVoejROaG9ENlRIWU51c3EyM0EyalBmVklYMTlLREhhN3hROVNmMjkzTXNsN1dKL0U5Y29CdjJtN1MxOEF2RVNsTDhvOExTd0NhMURTelppQkpZanR2QVJoRndMQ2s4VmxuRnFmUXUxbWUvK0RabVIzckZJQlUyR21qY0ljME03REZKYmY3OVYwMmVSeG4wYk5JUTBGUGVaaVdsYzkrTVZMTmxwbjBrR2RsaFpMRktuWmlmZ1psSFpLU3hXQVR1U3FCUjF5aFpPcVpKL3hMM1RweVRib2tZYTQ2cEJnU3Brd202Y2dHVjVYcGt5NkJxMzdOMW12R2JRektHamtXRndwL09pNnNTQXB5SWR6d05JYWw2SlVReWsxQnBWdWJndEpaenpId0dXUmNEVUkyL2ZHV0t2N1pScjl6aEE0dXVCMXdid2NDL1RzNU4zWC9ST1NCeFdyQm1TUm85OXNNcXZ0cTlhMUxiR3JjSUEvV1FWcFVzQlhtcmcvS0kvald4OHV3cVVRR0Z1RXNHS210cnU0QVdld2hQcmtSTG1qTzBkNnBta3h2Ukg4dGtUOFRHRHJoc0Y2ckxnaDczYXhadUhRSG5aWU93aTRaMG54cC9yNnZnRGp2NG1ZVUN0amNlVUhudGJGbTR4dGc1cjdPSERuTlkvQ2JydkNud2p5RStTYmg3cERKODJ5NEovbjRDWmZNdzlMWGRsTDU2dXZrdnovTUp6ckQvckZDM09kWFVPc3hGT2tmYnN0czhGQTlpdzFubEg5clcwQzNTdlRWSlhiKzZ5aGFiQ3dQYVNtNlVCRTRpcmxjaURUY0RFNisrVE9VMzl6Q2s4MXNBWXNSRDQ1STZhZk5oS1BCQ2tJQkVidkdUMTVBT0k2cVFoUVFIMXFPY0J3ZC9YSy9MdUM2NmZxUW91V3FuMmE4QTE2YUkxakNoNlVkWGNsMUpWRHBIeDd0Yi9hQm81OS81M2VSdm93VlBDS25XK2ZJOUE5aGp2aERHYVg1YVdkMDR1UXhGWHhHMHRlTmQxNlhIaWxMMnZnSFYzZ1dlZDVSU1ZQT3piZndWQmsyYTRsTDRxV0dycGpkdmt6RU1JNCt0RkhHTlQwQ0F1UWkyVFdMVG9PMFJ0UGRFY0phTk5MRjZVSW1hcGtjZ05MNFFJQi9KK2QyaytlclIzNmdJMEFvR3crVGJ6ZXRkUEVsVHdHaERqQ0NKdC9BcmtvcHRjR1hId2wrajQvc21mcVJmZVlqZS9Ram0rNnJhU21DSi9mc3l3RzdQMk1aeTg1NDU0K2tDYjV3amdPSzNDSkRObC9XNjJ1Z3NKMmMyM205a1VscXVscDRHRkUzTkFTUm93WHl5Sld3TUIzcExLS2pYSjUyVGE0aWtjZ3Y2Q3lDVU9ReTdZTVVZblpDaU5tUVc2ampsczhjQ0xJbDZlSjNVWlczWkJ0T0kyVG15ZXphOGhFVGdVVzFXSU1SZDJuZmwyamZzNlA5ZXoxZCticzhycVdiZmh0cEtRV09aaitRMEdnSmlkSkNzRGtMMHlYQUJSenhEbEI5bnZYVDQzbW5wbnVaSTZ6a1hLSEZyOSsySnUxSEpPdERydW9lR3FheEM5bkdMUGdURDJlZkllRkVLYUJDbms2QWpqWnBFNXFXcHErWG5iVFprNDJYNUIvWkhtblpoUGx3WlNoZVh4Qk1YejhnamNWOGdSZFp1QzVmZUc2bmxMczZ3dk5KU3hhbWYzU0trZnZ0Qm1BZmRJdElJZWhCMFBiOFVuaGk0WVZGNDJrSGQ0ZVY4SkZmRVBhakE0MUZ0aTNyNzVJYlNkUHN3UXNvMEw5bTFIbTdXbU1tK3pWWHMyVXhVaG1idzVPZjArclZyeEhlaFQ4L0NKU25aOVNrSi96aTB2ejduSTFKejhJeDJrbEYwUU91bVo4QjJTVXVKMi9mdjFrd0RpYmQ5dGJLMEVwVEVIQTI2blplQS9XRk9waXpZU29oSWZWaWNtdVU0YVA5NEg2cHk1aHZqNCtISHkrNU03d0Jld2xrQ3F4eTZEeW1qSityUStSV3hzOHRobXZSTm82VFlxZ0lCejV1bG5hV0tjV1VoWnpKMnNwT0dVNlhqRHF3VFF1OXhsQjIrbTN6cFhtdUdkYitGYlpxRG10Lzc3QlM1VXFocjJCZyt2TW5oRG1jNk9iZnd4OXVQbWdFTkJ1cGlFSkVSY29NUFI5a3FnOXNWRTJDZ2RjSjR4Z1F4aEZJYXYwSzQyamN5MlhaYnZRTDJZd3lSSjA4VGFCSlE2U2V0cVlqU0JXbktWUE04SG41K0Jnc2xackh2YTVRT2NYd3YrK1Radmd4YlpocjdIM2FwMTJramtBbk1pcjRUcWFRaUVvVEdFTzdFUFhsSjdhdTNGUHhrdXRZMWo3MmFhd1oxNm9hTXNCOXJtZ0hVQTlPT3hocVNJR0tjME1wUXJad3RRaWkrS243ZmFGczBtMVZvbER1L0xBNFh4WFJwVHVGRWxRMy9CNjdwT2R5MCs5VDlsSTMvUjdYSnNHdVFicFlKTnhGM3pET3VsVHBtSkJtSkpDTXJha2hURjhIUityUWlGaXlRbDU3QWFTK05LWFRnNHJydTMwZWEwZkFKWWgrUVhiNVFDRmlZREdhbzBTQmQzWEVxY3JlVEhYeWtZWXhkRXhLMGFFcGNiblR4T0dTZGpEaGlpb0F4OEdYVUdlMDFDNmxoWWpQUUNiVUlUSzNyVTY3WXJ3Y1VPTWxUam1PZEk5Rm9OY0NxMXR6SGxLcFVoQnY0eHRNUERsdlJBSGY1VW96cWhwNUNYSGE1Ry82ak1UVHFzVFJORXhrTXlPTFc2aHQ1S1RldHBpOVk3TkJwVU93dXd1eHIybDNDQ1dZYXhzUjlpOTlzUW52QTAxNFg2a3J3MUJuQy9WV0RsZjRDVHh4VHhqTzlIa1R6OU4zVWVYTm85eFZFY0hFRUFWMkZPWkJaTU4vU08yekRHTkJVVHdMTkRlcWlQVEJjSWRwcE1DVnFoWkFsdEZVb0QvVlNkeGpaSWhkeWlmKzhNYWFXbU9oLzdhV2l3Y0JmcFpSdlg4ZjFYaUUrWVJDVVNFOGNjWVZhZVNFZ1ZaSllhdW42dHlnYTVSQlJmbitQM2JQZ0xJSHEwZXV1NWI5N3MrZmM5RFdscXpMZXRiT2owcTJOcUJ3RjlremxTN05TNzNrWnR5UXhyVHlDWm1LaVJPR08wUDA1dmZIaURlSUNUWldSMDBPQzVNTVZQRUJVOWdlcGJqVUxZMnlDRHIwWUtyNk12Q0poeUZ1cjRHVGRQMnR4UnkyTlRlc25WRkZRUkhTWXZYRnpRZFcyYkw1Qnlhai9LSjZjbjFvRmNScDR5alhzWm1QdEFiNjZRMTE1YkVwcXFPMjBhVzlmR0taOTNKTC83NkV2N3NQZzYrQXNvRnlmT3EyMW91WEFXOHFhNkNkN0lDWVAxbVVITEFsMitiaUpWT1NEWkRTMEI4Q0c5TGtybFFlOCtaR2Z0R0Y4c0tGSjdaTkxkTnU5VSsvMVo1MlMxcXNyVW11YjdSTnkwMTk5a1ovMTd5cU4wYlk1UkhwOFBFOU5xMDZGeXJ0bHZublBobWxGa3dSazFlT1l1YmwzNzQ4U2o3UmdDSWpQeWJaM0tDbUJNeCs0NDlkbWFtM3RISGt2TUVSZW40VUNRVlFBend6SFdqOVpQMTRHNDhlS0hxWFRDV1JIcEFEZGFBdUVoYUZESjBtTE82VzhOWXYvTnc0cXhZdjFubklUSDFQM1c5WEF4azEzLzFnRmRPeHVvL3EyT2gvVEVBdVkwWWxrOTlVVjFnMGRubFg5c216VGxmNnBOcUJOeHJOZ005MFFQUTc2dW9CRkJBTWZZbCtlVVFsZ3NVcTNhYkVXdm5FeGlMTVVyT0lWaHZpMklhWUZoQkVTVzZkb1I4YkxENDd3emNoUXpzYURXdndFNXZxTmpTVS8reFRaVFNzaGhrbTlQYWloak9peXFNNHJkRVFSNkhrUjd6bHl0OHNWY054QUlWaFlISzU3akZaTE9YeVVaY0pDbFYzdjVKZUQ2NUc2ZXErL1d6cWZ2YVcxUGxzNm4zMmxsdExqNVJRajNDNHBKUVcyeUdUN1VjdHJRczZGb1JwQVFmSWNCaGh2aFhZdmZsMitGR1pVTVJBMCtzd3JyZmFsMFFicmllVlIwKy9ldWJrUC9yT1Y2OWlPaE5jUGw1ZWZ2VzY4bTU1K2RWUGxuZkx5Ni9lVmQ2MWwweUhVaFM0cUZZVUtDKy9lbmx4K2YydmxBVXVyMm5ma2svNU5sY0ZPOUhoK21jWHlqenVROUlGYXNhRVpSaVI5NXRuN255WFBqa1BSYzgwU2VjMTUzcGtFajFHV01ONjhhSzlXR0QrUG14dlBHb3ZKdW52VlhnTFRSN2V6ZjRBdHY4L01MYi9QNER0L3cvb0xmU2QwSXZVbFhqcG1xdzVzeXNCSjdobUFXSDlEbGZpUmw5T1M0ZVpHL2U2d2tRVHVFTFlYUWZySE9hSUZLeE1HNVFXSE1YT0N6S0V0THBya3h2OHJMMGpHNkRyQnA0eEFpZ1B4anBST3RBSjVYQUlEVEJxR202empJUmNqMDZNWjNvamE4dXR0MnRVQTdnYXBKK0hFd215YzZjaFdJQ3dNMkRPRHNnSUE4d25ZZ3ltUm5JVzhXVk9XbGNHcjhFL2NpZWttU3VFaDZ5VERRaWZMSTNoeXhGei9HU2hYZ3V2L3k3a2hwZFdEWlFOQW90Z3hlL3hORG10YkZrYmVhR2xJcVNCZGN4MmFaajZ3Q2ZXYmUzU3d3RTJYKzBCUHFyWHRIbXlzM2FxOHdsS3dlMmt3WjdHYkt2cExYcEk1WUVxQSthQTl5ZEd5aHljQ3V3VDZ4UEpXejg3UUZsWngwSUhBZlc3NDlaenVKbHZtUWRLMk5UWXQ4Vnk4ZSszeTBWYXhMNDFsUm95L0syWmYzd2VuSnBONlVHNXVQNHlvVTlKcFhSU0tiMWhIaWhlMDhiVk5mTWRsL1drNFd2YW9nNElNVmRXaXl1cmlUaTdHUjFtcFVkdnZteGIvSmhiQUthR3M4WGFWVElNUzlYZ3AraHFVM0xBdFNuT1dCdnBoM3hPaG1UajlHSENCREdKbHRxREw4Zzh5SFZWRDYxdzFyZ1k1dTE1Wlo0R0c1b0JDUFA3SCt3WmdOQU13REd1VzRSV0U0ckJ0eDVrL2RqZHZZZ01USmdNbDltSHBZUHgvMkUyV2srUjFFYURpVzJacjlFZ0pTSWlYcDRraEwyREVPa05ydTdrU2Rkdy9ScGVybTZoQ2xWY3hFSk5LcUtCZWozMVJJOEg4YWRkSkhNMm9jL2ErblZDR3grNTd1NGZ3OWNmZDJBQ0lNT1hEeVk3SW1tWkt1c2drS3hMZlpNQXBrZTgyUVZISTlha3VDL3MrZG1kS3FRaXoxcWt0clk0SUk1MUpYYXNLN0c1YU5rTHBKUmtZUFVUZzk2Q2lZaitVc1NTblpsbU9oVW9MUXY5TStJZHEvNXE2bmJiQ1JVWE9hcWlEM2pNUjBhc2J6cU0xVXUveWdaQmZhcWVsUTFZQ3ByV3M5TEVVWU9NbE42VmtmVTlpMHJZZzdqdzc1TVBORWlzVzlaUFQvTXd4eWVvczE3YVVpTWMvRHZySlE2RHlIVEdNUXYrN2kweWdZVVBvK1lSYVJkS095ZzBYblJWSlgxQWpTay8zRlZxb016c3k0TC9FeUVpN1ozWm92RlJPcXY4SmRIZklmZlVDKysvOVowV0NaZ2NCSVd6blpHbzRQM1dCNXBkU2Q4S0pWc2ZCUHRPYnk3WXRBTnR5S1I3UWFlakxnbDlTQ1k3cFpDZHMvdGNrM0xNWmc5Qm56cFVReUJwd08yN1M3MUQyaEZoMzdmRmVscVMrajFyZEwrK3ZPMEJncnk3M1FJRXJRODYzYW5OWldPdHR2YWc5ZTdXZWk5bW8zYWJScVdaZG5TR29SbWE5cTJ5aTJhTU11bnJMcTMyTzZ4MmwyMXVXVlpLSG1oVXltL1I4ci9kWFRINXVRY3B2NmxhZmhQTDl6VFd1SEtxNnEyb0pTeXNjNU4zbHRZNTNSZXd3K3hJWlMzUjBudHFhZW02eWVqS2pBazRYZ01iYXhzYXJkVlNhY09vSmpiNVhhMEZidjFEWjBLRDE0K1V4QTJJOVRoZFJyd2xuWDc4V1NvbnpaSktZZldqWXY3aVpwb0E3ejFKUmFxa2FYdEoyci9HQkdpWUppcjJWYU5pSE9vWGJnY0hSNzkwdW9TLzRvZFVveUd0cFJZbHhzMFJsSkZQb2t5QUc1dmNMRjdWMWhUTmJTYXBCeGRnVzVmcEdkbkVXWWxnSDJ5WXRBL3l3WWpJNlRzNmk2cWovaHFLaDRyZkx1M1FWbmJ6c3prTnI0bmhaUVJ2aG5vK21ZeDFCdkMzUGdaK0taOFVObTB1L25wam5VRVZvVktZNnBBa3FITzRsYWs2UjJoSVFnZG9XUE1xL2tOdDhMYnRUbjhydFBIOEZBdDVRNWcyQkhwYkQ4TXpPd2xYMVJsR0d6S290MC92Rk1oWGxCWG1XbUpSeDY4NTloZlI4SEJud042Sll3NGNsa3J5TlRDRDZkU2RTTXRtLzQ1T2g5L2ppM1ozeGpzN2kvRlovczZ5em1LejRJZFZMSlZlcHdNcTNPR1h5SDNVN1E1aEx1eE5rZnI2VmVSTGthb0FHdXZGYVdlY2UrU2Q2YkJza1ovZFVLdEl1UTJqUE93c3FLeWhiQmlycUFNK28xODllL3FoYUU5eUpnLzExbEdGck1XbDVIQU9xWDFCN2g2Zkp2bms1SWI2MkFxa2xzNFNNR2ZENlRCZUhCOURGYm0zTm4xTjJqbGxtQlZVVnVRd3VoQkFwMTk0S3JOcGpuVDlNTzNRNGRnS1Jwd2U2cW9iMFJIV1Zya0lFRUMrS3Z4TXdxaGhtekRxeGMxbFVwUW1oblovSTYzdnpETEdWa0xGemJpK3hkVzR2blQreml3OVZTZHJRek9yR3lnS2JvbzZPWUlOVXBNTWJNb1lQeGk4NVh5Y1o3MXpPbEFYZDR3R3E0Y0tXUWpESkQvd3EycCt4VTZzcW9pWmdnOWFWSVo4NWJYTXEyWjVYajkvNGNFZW50Y3ZlZDV5VjNJZHllekRoZHN6VytORXN6WGN1SWRvYUc3dy9qVklHM3VtSlVaQldwY25NNUdRbGxSVkp4RWhDWWtMRW1JcFJYMk5vUk44amw4ajA4a0xibTl5Q3dmOVZWUE9YclZVVHFVYnFkWGs4a1BRN3FVOVBSRUpwSDRLWFVqcldIbmVXZ1U0cWJvWDF3cWUvRGdWTXZlNGdBaEJ1aVRoeUFOeVVvR0paNWRMb21MV1RaalBDRUlVTkxWWUs0VkJiaVN1aGg1VTZJM3hXNzZzRnptRXJrNEtMTW1kMVN4bUNWdVV3WkV4eExZMDdVRG4zTUFTVDlVZk1ZN1ZTSmN0Qk1PNDBEQ01DOEV3TGhTR01ZN3ZEN3k2Q3RtL0p6SkJUdzZITEM0QWhFekkrZlNRUDVQZVZsYkx6Mzk0UGhTNml6UU9QVmlYWHpTNVlmSzhNZVBLRDcrcWJVQVdLaElLcXM1NXRJSHRGWThPSVZWNkhhaHlzT201by9Ya1F1VUxmVVpxdEVRa2lKbm1oYmFsMU93bUZ5KzNGQ1R5a3RFZi9lRHJkMGR2NTUxMFk5cEdsSmM3ZWg1QWpqeUFFTmNKU3FOa0xtbTdjbUFBMVNNd0NYWVpVTkR5U3ZBZlFMN2tpM1hOeUtlMmVNaVRiRjV2NVU5LythNzNSOHVjb0xnakgxMytQclRyUC94TFJrZmV0NEZOZkxsMnllalErN1MxTDBrTDYrL2JnQWYxamVhR1hBOXQxSEs0UDdLUnI2T3FqUnMyYkRqYUVkR3EvT1Fnd0xxWjV5RWVmYzg0NENLWmJDaitQWUVqeXpRK0J3RlJhQmt2U2plNTBZMTNWN0cyVkNDMEd1bXB1WEh6V3M1TWtvSEpDZ291bnRTTUdDdCszbHd2RERneVhPZngrcncybG1GSjVjOWNWY2ZiWFlYN1FFaHl2djlsU3JicnVrZTV6dHFkUi92dlNXSFA2K003dmhMR2Vtb3Fsak1iMEQrdzVPVzE0NGYxT2R4eklGNXVSRnhGL0huWDh5YmNDMysvUHZoRkg5YXBPT0xxOTBTU0Q5Zm45VEUyMGdVT1NkK1l0ak1MMGRJdytWS29nQVc3NlBoMEJuelI4dGI2ZkpGSjlTSXpsYnE5YlVlbGFMdGJ0TjIxYmI4eU9EUUNPZlpTdnRlaFJ4YVhMMVEzRmdPWWlxTUFlVUh5UWRYOUEzVmxnV1gzQjQ5bWtIMWdNQkpsbVJVSU9DYTNOWFhwN3BUYzFreFMwUkpXQk9nSE5rdTFTMGdieXRxT3BnMTNORllzeVRkc3JsVk9NWm9UQnJPUVNjSVhwT0VhR1hib3ZOTVRobVVCdkFmL2RuRzh1ZVZIZHNKcWFYN1hrOSs0ekh5R0g1NzhZRHdUcXNMYWtwcnpoY0I2Q2hFZHI2ZGtxMHRrQTAzQkloL3k2U3FZKzhmbnJYVUdKQWhMY2M5MVhJcEZxaHhBbllSQ2FrOXNhOFRicFp1Q0lvc1RRWDY0WU9YRllBeC94NlFiN3ZxMXdFckIycTZ0VzR0c3VldHdvejYyTnNVU2liRkVZaXlSVUN1QjdIRUdnY1lVU09PZzhPZGgvRDlrTDJKdUhCdGk2Sy92ampnQWRITTB0QkFwSlZ3RU5nZHBpTjdEejJzSTBPc0ZkbzVmWU9mNHhNNFJxbEViV3lmajc2NVpINy9ENVQ0aC9mZEg2MnE4RjRhV2EwRFd6UGk0cFRkQ2pxbHBBU3o1engrKzlGWUZDWkpKTnM5N2dmVGY0WHBUOFBvS0VBcWY2M01xY044dVY1UFRPc2xqWHFHcjBaUDAva3N0WUxNZkR4YmkyUDFQbXZQMWJmSGJlN1o3Q1EvSVhvV2p5U250NlZDQlpSNXJwWHpJeklIZTN1UWl5RGQrLzBIU1poZUlld2FGajJ6TCtPaGwrSE5xZXdiMFBTOG5BbDl5Vm43QUhSUGhta0ZSbzVIaXVmUHpsZnpaLzJjNkl0LzlTS05pRVFoZk5mUUIwV3cwQzBqK3IxOSs0QkxQcGdGK3hSMnpvZlVtcEw2YUhUcEFvRUtGai9tY1RRL05Cd1ZjSW9FUFhtNEFkclZJRUQySnNPOGV3RVNMRkJTV2NJbWhobFg0ZUp0UVVGVDNzZklVNlp1em1sSDRWUi9vUFJ3S0pZeGlnSWhCYVVIWWRvMkdyVXpxZkcxUFV1ZjQ5cnFOV1U1bmpWbTJ2SkRkRFUxQ1daMDNQbm9WL3B4cU0xVHA4SHU5dys5TmdSRWlEV2JVdUJ6aGlBc21ScmR5R1Y2ZXJHejdudVlheWpkOXVDNWxucXRYZUxIbU5ubGpmQXo1a2dLN1JyMzhiN29tVkJMYkIya2VnWGNubFJ0N0VNeHJzczRLZmc3QnZEWWhldjdOVzZOa2MyZ0J3QjJyOWd2b2IrRFlvMHVPd2ExMDhkMVZ1UGptZEVrZ2Z4U1NqMGl1cUdlYUh3WERsUGNEcDQzVXRwbDhxWUZVT1hRWk5rNHBTdlpiTVBWbnh3OTNGRlR2SHRlY3dMdGNqQmd0akRhSS96YWJ1Um9qczZVWUdZd0kzWGM5SGY0ZHJyb3lqSEZJWkJZMFkxQ1k2bmlvOXowcWkwelEwUEhtUmhFcVNhOXdiMm9pbmlmK0NWcHlKdUl4aVIxM0NqL2RCTEs4SzIzUTZXUGJkazFwMjVobUEwSUVoVWRQNHl3bzhyTFEzOEhrTWNwTWZPRU94dXJrSC9sNUtQTkNTcFcvL0R5dUxYek94NjRybi96NDU3TTkrWFRQayt1ZURNeVRVTHF4cTlsTjNsOERHTU9PWm1wS0ZQUDJ6ZUxEQUdWck1xS3B4aWUzZkF5VnNQWVAvZ2FYdWJOU0dEUGtqZ3lURDdDKzdhelAxWlN6bEh5OC9QR2UxanRjRHAxSXV3cCtZQjNTMExIa3JrT1hKRkR2Qnc1ZHJnVU1Gb0EwYWRBakI5WHMvK3QvYlNIUEhLT0gxc1dGcFd4TzNKbmhxWVA0dTRkRWVKK2Q5OGI2NU02L2ROSkx2dVRDREZKaFFVdkd5dWs5K2ZBNHlVY1VGY0NoRS85UnptSlpNZlYxUkw1YlM1Y2FSQ2JMKzBjNXI1TXRLRS9jeXBPbEI4V0U5K0xiWEMrb2dEYk0yQzBqSVpMNDFjZ0twRXgzUFpyZ3YxT0d0MWxxNCtnMkhOTE9MV2pUVDlnWmZlREphKzYrZHVmbUsrZS9YUjlBL1UyVFA4SzU3K3VSUTJhRHJuOS9LTXh2Q1QwN0M0SzRnZFdPRlZhN1ZTSlJMZEUvSS9wbjhYUmkzVXJqOFU0OEk4Mk84Z0xOV2UzUk9jMzJzZjNjQmFQdFU2emhBRWNxckJWS204TzhkV0pQU2JtelRnamp6bE9NSUMzQzhpT1h2aEFwNHNyaUxybDEzdjdGbC8vK0RuTjdTZGNFLytmUGZObmt1L0x5OEVRS3grWXJJSUFwZ0s2WjBzTFFXSnJGUUh6cXVyZnJwZUVOcXBBaWR4VFFzTGRGQlNRTUVZM2s3eEwxMVBDaDN3Z05jRnQreDg5QzR3UEVuYUpxUlFCVHFlOElQRThzNFA5ZFR3RXQ1WnBHN2h2MG1EUURZRy8rSDBUY3dqa0ZCOGlZbitvUXB2b2Z2b3ZLYmFvSjVoTHcrUDI4eGJSc1BSTlpxUDVoREdYMlVDOGZ5ZmU4Vk9BWFVDTFdqTFlZUTdnbkVBcWNmeGZUVWRlejJOcUczRmZ4SWdpcE9wdFEvREhQclUwY2xHVUFLNXVjQXltdXdFQ2JuUzlUdE93bzMxMUFsc0p2cnlsMy92bkpLKyt1YWRJWnVlVGt4MFFtMnVKYVBENnJkekhrdmNoblEwRklOWU5taGhLQzNPK3ZBSHZUQ2tjMDJocDloSFJ0MEJPRm9NQkI4YTRxSUY5OHJGYWduOHhHSjRWRHZzcFg0TVZrVnR6RnRFam5wMm53U0RlVERWNm15RTY2RWxzWUY0UGJhV0QvbHVZWDMxTEEvcFhtd1loNGJzU090a0hwUkpvYjY5UTEyM2FESm5ZZjNsTE5pblZkSFNJVVhDM295aHV2dlBKbS9mZXR3K3JQQ0dEbTJvbkRNbUYwdUM2M1VFTmp2a0FJbTZtQ1lIVmw5aS8xT29GMVRPclIraVg1bmJkTXkrMlY2Z1pVOVNWUFRqWUdxR05VaUdCeEpOOHlQaEVOVGNiY2ErZm5RVnNobjdPaC9YMEltVnhMSWFpMElwY0FPQWFxQ05UT1FZSlFXVXBaVGRsUlNPWk9CV0ZlSTFyVUNVa2E0ekJaZEkwc1RwMlFyVVRTQWcxQnNGT1E3MmtxSkJRUzZpMHdZR2hMVW9mWUdPcjhzRUtkUDZlRHRwc3Mzdm5lcHVwa3lON1orbHpXWmdEUlVFUzFEUGJYaUNMM2VrYUVCeXVEVEMwaWdheU9EM2gwVUJDcW9aVUJITWZPMVBNM1YyZXFuMmJCWkUrWUVYeDV0VTA2WVduaW8vcStBZ3loMTROeWJ2MHRHdkZvOC9peTBxOTkyd2hMdms2cWJvSENuY0l6YVBGSWZLQmxaQmdVbWJ5ZWZETHFrQkxTUDJJQnI2QnlYYkNDQUpRR1Y3d1VxRHdLVkNMOWVLd3V0TlZKWTBXSUNucUVxS0t1TkRDQ1ZOV2JJaXlCNkpQODVoOGN0QWZ3TlZpR1lCbkhqSEphcXhSYUhUOTJTSWpjL3d0eThJUHRSWXloa3NOV1pjYzkvMC9SdEIwSG1tSDNaM0p1eFFrZzB1UVMrcTE2VnJmcnd2amNVc2pGa3E5Ky9aVUQ1dXR5N05aME1vcG5IL3VPZVJZWVBKZjhoWWN1dnlGYUtSZDMyWXUvSGN1ZmZ2SWF1UjRiRTBhMXBta2kwUEl0TjAraEZYN2MyNndWOWlBNDZ4Z25VYXk2ektpdHd6YzRDWmNpUlpadWNwbG5KUjlUK2UvMlJVV2FzMUN6RWFVRUE1QlZ2dEhyeWU5K0VNWHdVNGRNNkZKeVgyREVRdXZ1RFlBSlN2c3FIaXJBdTY4bklBQXRRWWYvNDVYN1g2bHBrRXRrSmJUVk9nd1J2T1hOQzNWeU11Nkp3MUJ5SVVVdTFLMlJyR3E0MnNDNzVHK1pJRGVxQ25nSU4wN0RYcW81V3g4bkM0MnI5REtZTlg5OXFDcVBscTRkeHk3WUlRMWdzWXZ4SWpPbG1tOGpWSkVqdEQwdmppM1A4TEF0OVo0cUUrYVJBZ3dlaVZpRzVLL3Q5ZHU1SU1PQ0FoREVwNWFHd084aUJCWjlxMzJRYkxqK2F2eEJxUGlob2NVUHJkR21GUlhIbkdhY3JrRVdObXhBalVaZUJTbndaWDJoQ0Jka1dvZS9QbVJBTkJER0tSZDBENjcrN3RpSmNod0NpWGRWR3pqZkR2ZUlzQmVkZWtGU0h0L1hzME1KNUtVNHhRUUVpNWdBUmJIQlJwakQrcWJ2bDlJYkNGMUxPYnlhVFlJcWEwTjFTL1VWR3E2RmtJc0p4SnBOT1UxOTRudFQxWW9WTURPWEVzYVhGMUJyeWV4UWEvL1h6TXlWKzZaUXI2RUs5YnJvaHpOU3J5S1RiUy81MHF3NGRVdStHbFBJVjIwbThuWG52NVRrcXo2RmZIMXZDdm1xV2ZKVnMrU3JOb1Y4MVV2eTlkQnM1S3RSSVY4Rno5YTBPTHpRb0FQZkRSUGVlNmJCRk52RWVxNXpQY2NGeTFiVFFNTEpPbDFGWkMyM2hCMlQvMlF0bDBpNE1UZ24rdSszTEVoYXBNTzJVODNlaElBcklPVFVtZzJFdDdTdUsrOVI0N0lwZDFQblNQK0VjZlBNUUFoVkQ4blBtU25sUjZzQVhDRTg2NGZLSXdwYlpVYUNPeHNBN28rRFEzSFZKY0YxcHRsenA5bHNEUVM1emZTV3czRkEva3UrRXhJbnNJUjBWNllHZU5CL1cwblVudVJmK285cDY5TXdNY1hNMWkxWmN5c29nd2FGSUVvWnhkRlFqM1VGMjVXNVJIUkgydEM1Qk5KcUU1WWJRNWVhSzlxQmppTjBiTUw0TmZWVmRBMm9xazNEZHNvZGhSSFU4ZzBZdEtBaEFpYUY3VVV4WWJkTzdZYlBZTVJ5Um4vejdBejdrTjNUN2E0SExOZEhhSHptc2Q4Ump3R3VFNEdBSWxzTkd0WEJFTmR0c3N0WGhaL05ma0ZhRlNSN3c4d3BzRkZUUjlNVlFISmNnT0pRYklld29pampyblRtOFJDUHJGaUNEN0N1ZW5LWGI4OTlsOFlrMnBYQzVMdmhJVVNGVytnL1c3RnVPTlpxNGgyckhMb3poVU9INmxhZFVKTjg3NTZvY3N6MXh6MFdFYU02SW94dndjYVRvOGVyU2ZMTkVKTEJucWFpSlBlckJZQytvYmlucHdMTkhuZjR3cjNQWXZhZzltR2E0UU03NFI2akhVN3lEMzY3dDVWOHAyaE9XRFluWUhNQWdCTWJCZGpvb1BiaExKaUoxSWhDS2ZRc1ZaRVp6ZW1lSnRPVTlJL0I3TWFFSmV1Tm5oUEpuTFdVRVZGNFNhbElQcmFYSHdNd0RPUUtGZzRxY0pDbFM4WEZ3Vmhsalg3aEY5V0R4TlVXd0ZWZzZxYTkrSk9sK0V5bGY0amoydVNMUFF0NnhlTjFpQ3J2ZlA2SEpZNUhVZlZnR29pUUU5aEFMQ24yazIyMW5sd1NhbllSeHY5NnIzQ0tmNVc0M1NxSWxwYnJTRWNlck9KN3gwYy9PVGs1T1Q2ek5RMmQ0T3hnWHBTL0RPQXBVWHBPZzMxcEFacmRRUkN5L09pRHdsVCt0dk1FRnRFM09QMXI4NHlCU09qVXN6OHArMTdZNHZJTWRyaUllNTdpYTdpN3ZEWnE1aDBiQ3N2azdHamNVZnljZTZpeG1kRTd4NjdGNExTMkpnNy82QjNUaWRRc2FTeW9OTFFMMFppL3JiN0lzNmtRYjdpMkRQNmlkdCtCZGgvdHFManYwd2MvZjFJdDVVektkSkMrQnZFWGtUMk12TlNrKy91bEQ3TzY1NzdSbXUzdzcyNS9sUjN1U1MzbTVlMFQ2QWZuN1R6VjJMUFB5Vjk0L3VaYm94N1dLTWsvOUwzS2hqS0RGUldCc3lacjVHb3F4YjU0ZGVrOXlTMHlDc00zakR2NXV1NU9YREk5ODQ1VHpDNDdKei93ekJlL08vV0Q5OXhSQ21YVHkwOXY0TDIzRitXclJLVm9ucWVCbUxaNXU2YzFqM2xIS29KditWWFZZWnRhR3oyMU5wYlIzOC9XdXJTMzBrS25WTS8vK2FuSHYwRTlZajEvK3NHL3Y2UzJVcU0zRkVxc1dHNkJWVW8rL0tGU0tXa012L1cwekZIUVRFMVdVS2pyd05DZmN4SWwzS1pjblZpRW9EcmF3Q1dLK0RTaTBRRTlZWlRYN0NyU3FLalYwdEU4SUdsOWJlcXVUUnRyRVpEZDBLVGh3eDI0b2ZFQ3NVSzhBTUtwR3IzaXdsVWRITmRMam9uWUp4S1c5TVArZXJaNGdEL3ZvVG9WZ01EMTVKcWE2cldTL0pMSENxOU9BQ0RranVtdVl3TGd3VHMxNHFybExvRGx6aXNkMUR6UUpwTnNBUGpHYXY4RzBnTmpPZ1AxQmc0d09Bc2dmNE1wQ1JTdEw4RGdKR1c4bmp0N0hyRjlyeUo1OEF6SGNROEp6eHFXaUYraFJOeWRnWWpyeXF0SVFyLzVoM0p2S0FsdWJNc2NNRDgzR1RMczZuMmNlTi9hLy9nTk5Yam9GWGNlZnVUU1crbWhWOXh4ajNHZ09paCtON29BQSs3aXBMRDNoTGx6am5LYStJd3dQTENuWmRHZk9jMmU1eU1PSUx1SDhMeHdxWEVLbHhwSDAxRTVyU2wxSnBVNi84eEpUSThpWTY0N1Q1WUtFMlVkK09PanZjVCsrSGZuYVBqNkZqOFE5RmNVODUzUlBjYnk2Q1BUYWNNTzBwOTdrNjVSeC9telpocVdRK2hHejNqSjJNa3IvR1JzOGpVOWJacW50S2Y3NXhncVlzWTc4M05FbGk0QXFhMk5aZTQ2UmxRSlB6WDVHeTkvY0orSGNZYVgyenE0Q0NDVDM1bHk1NVUzajJWNDBnL1B1TlFiMXFTb09kT2hRUk9kSTJ0OGpnM3Z3R3R3RFRLeGZaaUtCeWtOMDVmUlFxdGdqMFYvQm1JcXAxUUFKNjkxK1o0UDF6VVh1dGExODhJMDNLQjVweXMxd0h1UDVFSDJlSHh0c2U0UGNraVhIaUtIT0tnL3Q2TmtLR1k2cjd6aXVBa0t5bHZKbmplVXYrL3FTcEppcGVWZWNqV1p4M3Q2aVVJQjNRRnd6eVpqMWRidE5PN1V1NTBOWlJvTWdqOGdxVVRhT0ZyVjUvZUlaTldkVXY3b0tia3drR3RiVGdPV1JyRDcxTksySW9qWmVqK1Z1eWRNdXp1WnlHM1RTSzdwNUdodmRWVWdubzJmdU9pUWZPV3JuNVpmM0hId2FRbUthWmwyektwcDdIc2ZtVFl0VUxuZEp4VDdHdG83N3ExeVQ4eFBzRTVGbTN0VnRKbDZJM2cxUTNDLzV6YUtJWmhOUGZrcXV2L29xMkFmcTB1ejFHejJMczVicDQrQ08rb2hyWHJKaFoxbE5BOU80WW1taVJyV1lTVW1MeUs5WXBqOEtrSnl6T1RYQlRYTGFHTkxHOE5rdTNCcXBIVzVmaHRPUHJsMjVmb0UwS2Fjc1A5ajh2TzQ2Z0RPck44TDRxL0FETlFiTE5vcjhIS2NqampOU0xkWDdxaU9VMzg4b3p6c1l6czZaanM2aGMrYnBVV2FEb1piVXUwejhOT2t6K205SHlFbmJmWmlZUGJIYzB1NW1menB1NUpQNnIyMHkyeXVuaUpMOVhidkp1MnB0dHlOVHpXNFNXZThmYXplTGphcGxjWTNUNCs0bldFUWZUdUlUOXgrNkVIczBOL0ZiaC9mYkorS0k3WTZrOHRXOGUzZXFkd0liTXUrNEhzTnBkMUxaOTBoaCtSWldwWm51V1JXbmdWYmpGNEdqNFVtd0ZtWkZUWFFPUGJDNWNVNjRWbmNzV01jUUYzTDFYcitvTlV1OS9SSHdCLysrdnpOOHNQbmo4WjZpS3pIT0o1cTBoQXZjS3JxSWVnNUdxekhLUzhGajNGcVpQei9RTzBGUzZBR01yQ3o4SWhpcTZDeGovREhsYjBtZnp3c3dUYzRQalRxYjNBQWhDeC9Rb0Q5dnNIQkJtVG1NYm11cWMvNlVGZFRKUkZhcEY1QWkraFRLS2hhU2hMcXlvZ2JZY2xoZ29uZEh6Y2VCSll0V1RyYjNvemlkZlN6dGRQVDRzQUtGYUxxQWpGQWRITDJrUytZQi9vcERDOTJHRFR1ckVGbVZYb3d3cnZEUFRjTFVoTU5STUNEMUQxdEdDeEx5anhQcHd4YmU2Y1gvMWRWTEltc2tVdjlXeTlPVkdYdjR0ZjJpNG44Nm1SRm1uTmZWYmtlSThDazk1cWY1WjBtOWwwYjdsQS85K0J2KzlsMHJFeFQxd3IxVGxWY1dmMllkUWpSdkE4T014blJvcTNMK1g5SnhVcnQzY3pEcUhsbTFEeU1tcmZZU1c1VUl1MllRMnFCZXJUVEw3UEYvRUxKOVI1OTJrRVVmVlRobXlwOFZPRXptZWw4QjcxL2c3UGo0cVR0SkIrVEpRZU9XWDdGOFFkY3pXemo2UGhJTCtpN1pxTDEzYlE2TW03UkVPekpFWnZsWFViSnNjbkt2R0tZdFJxTWt0OWJrVU5ERGs3RUJiWUN4L2o1L3Y3ak1USjlQSzQ3OUhoYzZlcWlRS2YzTitGU3BjZzFJdDVCYmVjWkZTdWMyRkUxeW13RFhNd3Y1U3VQTmdrM3NNeDdHQmZQWHNmOTRpVC9DTkFEd0phSVJORVRiTDFhT3JubEc1c3B3UFkrV1pvYWhyU0d6MTB3UDM3RmRjTUNiR0pteCtXbHBCV1V1TGZVNlZ4VldBYUlxZ0lVc3Z5RHZ6WitWd1l5cVQ3anN6enRSQ1lESm5pR2E2NE04KzllQlJ1dWg4TVdJQWVSU0ZvUnNTT2twMXNhWGVNbzRkQ1hTVUZjNlBMcU01OVhiYURsbU5rbzdrblJCNXVNdm1zbUY3a2RDMlF4czdPZkU3K21BazloMEk3cjNHenYrMG5ZVDlSYkovN3ZqRFlBMzlJMkRwUmVaUkI4NCtJMjJGWnh2bDdjV1Z3TVI2SXNuNWVTNTRGdmlVWk9nWkxHTjdxbURmTFYvVCtvOVp1RVptcnFJTGQwZzhjbVVaZlBHemNWTjB5NjQ4VXBNZ2ZJRDBYcUhlVFBPSjcyUHJsR0JNdGdOY3NQSjU1U28vWjVNWi9IV0NrdDRTVnl0Y29OeDZjWG04V2JaYVdERFJIaWxIeTVuci95dDJOWXlpdnpHS0c5b04xeVJNZ0RFRTFNU1lBS0FsTkJnQW9DVHNsdXYxaVQvc3krbk5aNm1mL214akQ1ZUtpT3I4L3cybVExeVQrNk5WTEx5cldoMmJkRUJUTmU1MDlpZVRrNEpCME5Eb2ExSmY4VmR0V2RQcyszL09lM1ZpcHd0UUx2TFJRQnpZdEcwZm1vQzZDMXEwTUUwR3M5djlaNmpHdlV4UUhneWk3YUdDYWZhRmk0S25lSmc3emNyeUI4elJwRi9nNEJqMGNVMnZrYkppZFZQUi9tUytoaG5zY3IyMFkxRDVkejluK2l1d1NRYm5qWHRlKzZsWGYxRTY3VzRHb05LUnVUTDB5dUMrZnJPUWpIUldKdlJGMDZnR01VZFdDZVZDNDhmK3pIQWU1aTRuNmpuVE04OFl3aVUyd2dhaTc2Qlp6bWIxRmZUNWw5NHdQNE1FWThqcitpeTk3TVpLVXNTb3JvL3JDckRnNDdQSTE0eUQ5UkxmSW9IWXgwUFBLUFZKOXNDZXdUUHR0WWZmYVNYM25yNVo5WG5sek1ieTZVVHpKbndBMzJMVS9IUlhacTNvVHh5NHByZFArSTQ5ZHFUMi9wN2VtanJ1bnFEbytsZmhtcmlEVVp3QVZrTnJ0cmFOY21xdFExRFdTN0ZTWGtoMk13eWp4MVhaRE5sZnlEaHpXbFd0NmJHN2t3S3Y1Wk9TRm1GaUdDUTg0Wnh4d3Rtc0hKeXkvYkN0WVpLUWd4a3pjM1JFN0lzTlRkdFRSSjN0eEliZzNuQ3lGK2JsOE5YaTVyaUd5b0VEczZJWlZQUjdaeEVadHFvVjRnUDJud1E3NHZRdlFZamIvd0dpbkdiaGNNV2s4STU5WEkvM2tqcEZ5QU5rdWpUQ0pISmprTU1GOG10ZnBMSnZGMG1aVXhRT0lPTFpQWGN6Zlo2YyszZmpUSE9BZjg1R004WWwyelZxQUt2Z2x4UlZ2aHFhdXpZMUNiYTdtZHJzLy9RbHAybzBkNVVIYXRjS2liUFh2N2FrOVZvcHZnb3NKM2t4MTZ1VnN1YjBiVnU5aWUzYWhWMjZOdDJXTXBnYlEwcXduanpKTXh2L0pmOUZqRTlTVTdBL2hFdTdhUkc4cEdIbkFOMEovMHR0TEtsMTFWdjc3azJqc3Z1dFFXN0VLeEF5NWJCaVNiVjkzSTJINWNQdnk4cTRyZlo0dmFuM0UxcW1xLzFyeC9ocG9uWjY1NWkxK3ArRW5UN0gxRnhYc3J6ZDZqbGU5aDVSWHk2Wk44Nm1ESjlYVTZXREZwU1RGUUQ3cmQxRVR6N3BhN3JMd1lybnVMNyszUzczRTA3OVBySjNCOWozNTdGNzhkbHg1WjI0czN0MmpwU1pUZXFxVzN6REFNZTd3WmgrR0F4MDJrMWtQSDlJUzlncWsya24wbmJNbk5EZWoxOGEvSGYxa2JyMnI4bDlRdGEvTGFOeVdRdmthdm50Q3IvS095MHh6RFlxSnhUdjVQdDlvOXIydVkrV0h6SjI5QmV3RnJjd1BBU3lHUlRlcVRhL2hrc25oU1IvWUxQSGlKRDVEOVFoOHdOejBlM00wSCs0c0hiRG4wTE55QWZMaEhIOG9JMkUxQVU4T3hMSElMaSt6V0lreFNWSlJwd21DRU1sOWltYVZGRWI4bzRzTndnU0pYc0VoYXRvTHpuUERaYzN5V2xNK2UwQjJGWnc5OFEyNndYaTI2RDVaWGxIUE5pUUQzQncycmplZ0pFU0ROMXl6K0QyRTg5aXI0SkpmZWZoUTFQUWJsOElCc2tlVTBsTXNTNUk4YlYrM1oyYWI0VzBhUnViK09iODdJTlZGUTlQSW42N0psam5KK3ZLLzJaeTdPQTJmRWVXcWZ6TU0rUW5qVnJWczM2TzZZUWRYYXNVcVBJM2RzaGNhUnVBcFphSitwRENvL05wMmtQK0FTeDhEVGZKOThMVXplS2IxYmRHN3FqbEczRTVwcWc0eW9iRWxlWDZ0ejVCRnNacktlL0dYSDFRSThPcEw4NzhZMHViMjZvdVRuazR0bTJseFpNbVM4WFAwdHY3NFhBcUlCdjVRL1MvTFBQeHJKZmhLUndvVUlISUN4MmJVS283bS9QZ3NISTNMeVpmTzlJelJZNk1EMUxzYjBDQlE4d2hROEFnV1BBTHNLQ0NGZitYN0NINE5zUENqcjJNQ25RZWFyVzY4bDlPbkZWYkt5dm80VktJTEtzVXhndC9zNTVzaVdmcU1uSHFqT3ZlakJRNytWKzAwVStGY09DOGJuWXRkYzNlY2hTR3ozSTNpUzZ2ZWJJaVVkQzJCZ0tmZGJ2a0VFWUgwTGkrdytpT0ZPc3MvREpnUUt6YW9zbGdQN3lja2crWGE5RXpOWld2NFQvakp2SmRlNG5iWVVqakZsYmZqQjVSc21RVXMraXRBOXBGaGt0U2hEdHB0Ti90WmRRUjVwMU9tM1B4TVFqYnVWdGpWT3lNdS9JSnYxUHFveDd2eVJQTlFIYktXREI4cStzMSt2QVV2QnBHZHQ1Vkd0Tyt2dXQyVFNsdnlEa3hFVEhucEE0bnd6VXlPYVY4bGZ5T1VmWVhEeXIzOERLOUV3R0hyYkpFcGtZUUJ0YVMvNkZjNEdIK3drNnVWcjY5dkNTNCtEYmJwWmpHeC8vak4rWVl0OFFjYldERHBuZGZxazhXbXNzeVQxZFJMN2JUWW5ZOEcrYXQzRmpCV21jV1RGa2pZMjRieW83ekRYR0JiQlV2enpSdUhyVHMxaWptdnVhbGU1UVBxTzlMY2ZDMmp0ZlA4VlVuZGZMdXQvSUorVVRmTUpoVExvazZhc1VuRXBRZWpMSEx6YWh3VzVZNVhVTkFjajBzZmxuZGwxbWJieDFzdXlrdklYbndyemp6MGRwbk9HMDNnNGk1TTc1SFI0OGdxWDcyejltdE0xZ3lKdjZMTjlWNmc1bnNCWDl0UHk5NlZWMlZ3RTkxR3h1SHV0OHBSem1WVkw3a21CcTQvTnIvSlhkdVlxTnpvMzFwYmZ1Q3ByNXI5NjJUSUtmV2t6dVZNT3U2dXgxV0crM3VTWmp1Y3YzNG9RWjdCdzI4STBzWG1yZ0k3ZFpoQkp2di9EU0hQdUE4WmNmNnpSdFZGTVFSdUNGYjdTbi8rdXBvaVE3ZDFaTzM4dFV5a3VjZHprVXg2Q3FlWFNNNWR4L2xxd3hERSs1RUtQeXl2dkdBZnhEaUtYQUZWVS9qVGhaZHJPT3dpNzVsZXkvdnhTZ3FBSDhHN1ZWUEFxb25JU3RYMXBmM0pIcUJISi9mbFdXeHppWUd0ZGZ0aVlDbzc5K1gvdjlnV3U1N25NQjNWY3Q4OTNYSWZMbkY5aTRnNmtIZ255MjU5QzdOOGt0MHpYWkVkTDIydy9NOENqc2E2bWFZQW11RzB6d3BrQi9nelB6MjFoWlhMMURESFBONWpuWnVZMnJzcC9zRFZLZG5uY3dwamdWZVJoVGVsOTN4TkpoTXhzOGNibVZhWmFlZlhmZWw3ZHZJcE1xbm4xcDN4MWYvVlZlZU5ieFJ0YWF1KzA1dHo2Q1pSSTU2emwxSExmWlBNVjhGWis3RHJXWEk1NDIxZHhwV0lNNXhONzBWVDUzU3V3eFBid3cxckRMcWxoTlZzNW4yQzZ1NHV5VDMwWmc3MWJHMmx2UGxkcDA5eXlzeitkMHZTZlB6RzE2WmZlVnBTNGJYT1lmL1NtRUEvdVhUVk0zdGU4OWh1T3k2NHA0L0pRT1pKNmhKRHBOYTg4eGxlMlRIbmxhdnMxN3Q4VmRoWjJyeUtYYVY2OUdhSWtHYzNxcTVkOW9ueDFpOUFQZlRsZXBzaXNmSEhqRTNoeGNzcUxteXN2UG1xV0ZZU1c2NFU0NUh1K0tjU3BQM2s0MUtlc1ZvakVvTkNjTzZQc01HYWphS2FIVVhEMXNaRi94c2JKeTkza3BoREYzYlJKSWlCVlBuczlKR3ZaTE1sZFh0Rzg5OGhYaHZLSHZzMlZwWUIzVXFlZWdKaStaMUhWcHozOWJsTnBGSjArNUVIK1MweHI3aVVQaHRyaFdHajVDcHNmRHdVT2ZDRWd5WmNDZFBKdWFRR3p6K1hSRW5JSkxXV3ZjQys1Mnl1ZUo4OUh5WlcxMGQwYi9zdkVLVVdDWDFUNzFBdEZ0WnFqRmR4Vnk3VFJ6RFpra0piOHN5WTczRGpFOEhaNmVGZHVVN1ZXN2NubnJnaW5OVlRPK1NSdHNaSmtTMmk2aDhTemhIZmxDQTF5R0lXblAwNUg4OWo4Q3p3OHdmcmZHSFlHOWRodElxMEhuNThxZndaRmtNZy95Mko3dEZpY0RrSWpFWGNHcFUzNTZuUndHTFRJalAzREpqN2pNQlJCMlA2Z3p0MGdwQml6c203Z3lvSWdJMGNBNmlxWDE4N0s4dHBicFZwZm5rb21LbXQycVMya3JNQlN1Mkpsc09RSXJCUk1ld3VtbFlMN2Vnb210dUEvc0dBeUkzVlE0VUZ1S2ErN05QL0ZONVRYVlZacHhIc0dkWExLcm5CUE5NYlRmLzJ5TVo2ZXJwUzl6MkRFU0RXeVM5NkpSSEVhaHM4OXJVMWltVmkzdGkyQ1YrR1R0bStWL3QxK3JQSUttK1F2SUNVL1lQNXVQRmFmNzFxbHo3ZWkvTVRSL3IzRjRUKzN5Z0JRUVNoSHZLT3R3L0RmS3dmUlBWN1JNTzNhdlo1U1kyRnBxTWpzUytleERmTTY4NFgzSVh6ay9MY1A0NndTb2VjS2wxNzFJcENZcTFpclFLemhDY0tzNUl1QURWejVRQUEyUXhnS1JlaHY1dGZTNXQ3TXYzdEJGdzZ2T00vZGxhUW1jakMyQVE5K3Q3ZXlYVk53MElhUmNMYXNaT2hvcE9FcUNJQjZLd05XSzBVbVY5Rk9KMWRiVjY2Z3M2UFU3cGxZSG9xM1lYTGFmSHdqMERibGY1WDh2YWZRampGemdIT2drQjVEczZ1aU9JTnBjWkhXOHJvY1QvbGY2VENJS05QTmhpRElEQmxCWmdpQ3pCQncvdnBqSW1Ic2owaGZpamoyK0xVVWNzNkJ0akMvZjZLYnp6OXhPSk10SjVMSmlYTG40M0luT25GdC9QK1VOZ3luSDA2SVJGT0JFQ2swSzdrMlZNdU5JbjZvMmVOKzMwaXN6cXdTcXhMaGQrY1Q2aEtBZVhSQVdzczE4TzRxUWJVZzBJRnF1VkgyNGRCcWdsbTRRbHd0UG9raHJrdEwwaG9xYVYycWhKWGl5TklxWVgxWDJ5bHJWM3NLUCt2WXFvdDJGRWZURXRQOEpkcDZOR1pKdFRGVDMyQkxOT2tmOUJJazhJRzJRbjQrSDcyTHY3VUpjckdFVGZGai9jTERZZGw3cXREK0MrUW8rRDJjM3ZIVjE1ZHE2alhKcHlJVEt1SXJJZzBEb29DVEVLdnpBOCszV1NYa0QzcUZuY2FiRmZQRDF3RmdtaUJWMStBS1IzRmdHb1RGajVNblFDNWU5WERKWC9oRWxEcExIQ2NQazUvV1YxaWpDNVpRc0JMU05rdkNsVU5XZFZCNHhkd0pMVHhNTm5LT084WjJMTGVsc3VTMlJqZS9nNC9yOWpFVlB4WVY3S3VoU3FIQVRNTnkwNkJ5NHhERG0yWkFab1VYOGVPZkdqLzg5S0FhbU1Lanp0RThSUm5OUzM0KzhCYURKUkJpYndGRXE4azBHL2tQNVJMN0RyZm12VlZaVGIrYmhoZ1BuNEJWTnZPd1VSTEpVeDB0R2s2UWtpSUw4Q0dtazJCSm1Gek5SeHB2MVVITVgzNGFibFRQSWZJVnA5SnNnUVQ1NldrNEhHODdUT1BJOWovQXpUdHo3S3ZhUWtIb042dit3MWVPV0VUbzVDdGVtYTZKTjVkNXUxMTZkK3o4WnMwd3c1cG1wMjRqVTFYMDMyT3czdm1Tc1E3N0kzTGsyTXd4VzA4Q1UyTkZVUXF5N3Rndy9GSHNHOHdYQmNHcXJtc2syRDJ6N2MwRFNXVmlyd2h1TGtFUGFrSmtodGkyZmxKYmYrOWprV0ZZelJFY1VqYlcvVzBFZ28rSGlsVEFSMlJKYkNYcmVEenZlc1N5Sm5KRWIvem8vZjh4TGxNTDdnYmEwdmZ3TTVPL2lncm1FL3JVU3MyT2xsdGQxbm9xYS8zSHI5Y00rOVJiYTJqZXZaUHVueSt2UXV4UUxUWXdOWkZJc2xrTncxTTN3OU9SQlpUV0t5YkdtZ3dSWE9SMGNPQTZLdGRtaWRlcXcxempNTmZzTU5lbUQzT0FZYTcxTE9iQURuTzBqS1JzZWI2Rkk2eXhDTUNDUmNNaDVaOEU4SXZJdER1WTN1NW9wbmFYU2JzamhzYVo1ZkY3dGp2U2RzK3dQSUw4cFZkQ0lXSmJRc1lzeURUY2RxOEphN1ZUVUZlRkYvYkY3bjhIUGhqNVpxYlEyVW9sWmJscUkrYnZ5by9pV0RFTXV2d2lIbWQxbllNNjA1OHhRREhNTjMxVDgrcUU0Q3lFNGd0N3RzbzRGdFN6cURBZjIzRXF4OGl6NXVPYTZhV3lGelhRQzYyZzJEdlRYN2EyWjVpY3dRQk4zMEFoWWVhZTdCaHdOMHpoc1RyUEtlZjVsZmZYbEQzK0VHRzVoQmVMOGdQajNmeHI3bHZiZ1JJR1pwSi9zbU1jYXlPeWFIQWh1Y3FIN3FnTy9hcHdXeEVUaDRHNVlxRDJzL3RxY2hyZ1hYd3JvZjlXbmZDZ0NDSjVFdXl6QnBGSVJlQzBGR000YUdGUG1BRUpGQk11eUkvaDkzcjZCc1pMSjk5dW9heGVMTWFvdW9taUdUWlJ2ZHhFeGFyWWU2Q3d2ZS92VVArSTFJODRWTDd2NlQxdUFRRDc4d0dFbmhCOTJ3MGRQaUY1Z3JLMmx6YUdXbHQ0cFBEZm10dzJOQkJvbjIrQUo2K1dQbkMzS1cwdEExTHlWN2RHZWFTMmJobTV2SVp1MmJlM284QlJZRGMwWHJndzBHQjBLdDhndjZ1cUUzSzFENjZDaGl4Z2t3am1jSEk3VURaWjIvSExyNW94aVBKYmhXc0s5Zk9oMW5GOHUxTHlwcXRDVy9KYmo0UjV6V3duaUIrYmtaeHBZbW9YMVlXRVd3NTZUYjByZzd2TnE1WXFIQ0FPV3VxWnNpNmo3NXlwMUhlZkx6cnowWnRvQUF6c2ZxOFcrL0MzdEJnSC9SZWJpdTlMd1FkWElkdyt5cjkyYVpDMzBFTlR3Y005RmZ6NFZ0dWFFZThEcTh5eW9FcjBBejNsTnR0SmpoREFDbklCWlVlZ0cyU1R5MzJoMm81Tk5vdHA4ZTZ2YnJEdHFxeWgvVDNWZi9PS1NKaEtUZ09zbkIxN0RONk1UU2hOZTNZVjhzbm5CNzVaRGhnWk1vQ1NQU3MzY1NMSURqV3BKZlVOYzZDQ2JheDNnUVVCb0k1UFJNcFR3SGtWeTRQT1orcmJVcU9EcmZab2E0WG5vRW0zbm44YUJpS3F0bTRJNXl1S0pscCtwYTRsUDM4Yk5teW5ubDkxYjBSMGx5ai94LzBCTzhWVm5qOTRvNjQwL1hYSlJRSEpPSEozSVB6cUo0OUdURllaeE5xQVhSelMxQ3JnaE5MSVNlTzM2SHNiUUpNQTh2ZE5ObW1waGRqaTlONnpTcGtkM1RoMFducVkrZ21mRzJkeSsvYytWeU02SGdvUE1WYzR4bzhGOTZ4aUlGaVUyeVNXZFVoT2NCZUcvRUhjcUlCeUttM0pRQU9qS2JtS2IrOVRuNlliVzZHRlpRWnVpVExoTmg1Rnk0enpSMlNjUDJiOEJ1c0FNNVpHUjNxTWFzTjUvOUREVUZwZzdEVXFSQVFYakplaXBqdmFGK1h5NktxeDZWaVFXUVZiOU1DRHp1NmIveTdydXVmZzhNaThQRHhKR2prc3J3a2hYMjlSVWVBOHUra3JDdFlNZ1VRTzU0OS84WHpLTHM4NHdvWG5HNitXMzdRTXYrQy9aUmhvVHZHbVFQSGJKaHZ3NlpuRnZWQjVZS1ZUN2tvRzhpc0ZJdHlPY2k2N2o3Vm9FblQ1Vm9oU0NxZjVpOWdUUHBjeFRJWkdLYkJ4bFEzQXdINlNrOFZEM0REY2RXVG91L21GWGVOdHlZMzd1WjNLYjBodEc2RVpSUUludjR1OVlvTGVtRlJUWHFOeXY4YWZ6RlBhclA0MjZIYW1BYkR5bWlNQjB1ZXZZYVdrV1lzdUF6QmdBU2VHZDF3WXVtQjBsNEdFdlE4R1FmT0t0UklPMnhkeEVMUXFCa28vMy9paUVMWTN5dmZrM2tPaGlaWW1HcHZXNmRQOHF0RHRGY3RYVVU2V3pwYVR0TVVLU1J4U3Q3VDVKSWhmeVdjOWxId0w1UjhkYTFVWFFBeE83dlNzeTN2eGlFYi94bXhJUHdpQksrUmhkMllyZlFtMFpUMjY2b2lUMjNKU1grQzRYcUFJSndHRDBaYm5YMzFHdFhRZ3BNbkpzblNaOFViV0tsell1UEtaME1BM29SVCtscE55VDU0Z3paTzh2ZUVyeGR1T09pbmY0d0U4a1M2UVV1SG52UGxFVklFWG83enB5cHRVQVVnRE5wOWtQZTEzZlJ4aE5oOWljalhjbDdjeVQ1ZU5uL3ZGaTdKaFR1OTR4Z0Y2Wmt4VEwvNy9tSHNYS0x2S0tsMTB2ZmRqN2FwYXFWVG9NcFY3ZSsxMTZIT1QyNkZOOStVa3RFMUxWbDN5QU5JUVJRVzdHZU53Vys0OWpGMXBKU0htY094QUZSb2dhb1IwKzRvMDNSMGVHdENBb0xSRTVXaFVsQ2lvc1JzdzJxamhwVkZwRFFnYUd5UjNmdCtjLzlwN1Y2cUNaNHg3eHJnd1VuczkvdlcvLy9uUGZ6NisrVlAvNWFRRlZYOUUzQ082YUVpY2I4NHFnUWE0UE5lcG9jZHJDNitMQzR3cEdmS2dKUTFlcTIvb285bHE4N0M4TkxqaEhEVUVqM2k4UjZXNVZIeksySTV6dlBlb24zMlVMZ2xCK2NGSERPWnN5M045UWU4Q0M1YnlVcWpFWWU5ZW5vOW5scUJvYmN0di9hMjB0OXdldG1QcHhhUlh5MWdaWWdqcEdveWpldDBQYUdaT2FvU1FiRDVPRWQvZnpPaDI1WE5oOWVnbGVSVFNnRkx1OS9sRWVzYnpIMjVlSldlNzh1SG5VZUo3UTVxMmxPLzdRaXgzN3d2VnVPOFRYOGU3NStRdUxYLzhpd2hlVmFxNEQxVUx6RTFYMGVXMm5nM1hEM2dFUlJwQjcrUXFsdDRTbU8yQjlzT25pc2UzTW1GMDJnQ1owaTQ5WjBRZHdtamxlcUNESXJxOCtoRmorOS9iVUd2bGtNb2h2L3pVcjZVUlk3S0JmZWRIc2JwaytheFBWUkZzcmFPYTc0am1DK2ErVzQwRlBhWGNTdWwvcHFXWW10L3J1R24vZDEvV2tWVE1LNzZTQ2RLMVlVbW9xb2NTZkRadjJJK0dEbWwyKy9IakxEZ3FJS3p2d2JPTGRDMjNvNzZBQ3dpM3RTZzhjSGJSZXQyQUtxTmFseGVwNmg4eHA2L0xoVnhubncwVUhwdElYU2Q1MStVcTN6UzNtaGp1WUVtVktOU25pR2ZhY2VmVVIyK01GSHpheSs1UFhESlVqWXhaVzEzck5jQXBtWG80TUwxMEkwSXc2OGFlbExmL2pCYk9kYjFqdG5YRFJDVjNHUENnb0Npc0dLdElIWDNRNVF2TEZ4NVFCM2FJeURzdWdtZGt5Z1YyRGdUWTB1KzdpeGE2NEhWanU3U1M2dUlpTk9SZU5FNkRnbW1INWZIdG0vRTVwc3IyNDhSQVdHWlFOVHdTQjNsSUVMQWh6VFlrZk93RU1wZnF3dEJINFhBUUkvTGZxakUrN0IxM2pHMkVhYlJoNFhvTW8xZWUzWG0yaVg3dlB0dkc2Mm1QdExwcUhReU1FdFpHMktpQW5HVGRwQlNUVG1ib0VTKzUvT3czdi91OXR5RVVoRjVoM1VmVWowQ1JjdXpiY0J6S0N5bDc2emtLVHFOVm11TDJ6c05ZMFZxcmwzS3d3L3pEU1pVdFdBVlErSVhCRnZ0UXcwRnVPMmVOVk9KTmJZcWl0ZUFXWGRxNlpsbzF2VGN6TFVQZERmbVFxSlN3TkJ3bDQvTGlKeW80QjVrVWU3Zjg2YnJiaFJwdjg2Vmo3aEh1VjlVTFVQNzUyZWVEb29YZ3RrUmdSalMwRUJGNlZOZjExWTkxSTRYSTZYcWp6UGwydmFjM2RhWVJ4QzJFekczV2FmS01BWGZueHdIdXhuek5TQ2s5QkpFYjdNQUQ2dWtETlJYVmVxLzBmZ0tqdTFiZnBOaDl0b24rV2FYekhaaVRiZmRtYnM2Vm1aWlhQb0xHMEl4ellhRHJWZnZveG9hUUo5dnR1bm4xUGJIb0p1NmhMS1cyWno3OXMreDQ2WUI1MjhpcS9YeVFmaUVNWWcwRHRSMjdXblNjWGEySU9mZ042aS9hWnZwcllJVGwxRlMweXNrZnFCNVhHYTU2TkNoZEM1UmJhOGhyQ04wSENIVDJHanBEOEt0MGZBMk1kc0FNSVYwNlB2a2FOMy9kcDdtL1dmWVA2MHBONVI2Tlh3UWx0czViS2ZDTkF4NmVLTDZhRHhrR25zdThSeUc2c2xRZFJ4T081dG9pWUlIcnFVQkFYTDVnN004TjZxZEQ5bng1UWRudU5pbFo1a3IyWWFpVWlPNEhrVDhZa3pzQ0JIN0hGUlUweHBYRmhOclViUEFWb01FNlZLSVNBMndyZmxYRUVpdjVESFpyclpQc2pUQmJoUUk4d3RqTXRpMDEwL05jUUYzMWNsS0taTzZRUG5FUFM4UE9BR0Vhc0FOTWx0MGVHSFlzZWFXUXZKTHYyR0xoN1RUQUUwQjlzNy9vdmJrZzNZZFZneGJTU0ZMYUIvZHQyVVltMGRjVGJaUFhhbzNZY1I0Nnp1RUpnZUVXVXZFR1l6clJWNDZFa2tCTEgyZ1BSVzF6YnNEeGNDc1ZCZkN3Yks0eWxGRC96OGpJVHlLeWJreEZWRG13Y3F4Ti9CWUFDcXVVSUlBS05BL1BwdUEwRDdCcVk2cExvQWJkaVZEakpQY0h2ZU5pbC9SdDZqdVdGdzBLMmNZbjJ3MFNZYVgvVkE0dlorMGFuUE5FTlNYR1RrbnRpTnVvVC9JUW16ZXRYZ0pEN3pPTm9rRnhWb2dKb2ZLQ3F6NmVPRENkM0pYcmJ5NmE0NzRMdU5iY2hXQ3hidC9aYzdaWlRsZEZ6bGZMMkoxUXZNY0syUmpUcE9DR1IxMklGcURPdlY3UERUakc1cVN3bjcyakFzUVJCcFlhMGNZdTJUWWJNa0ZmTjlidTdpdmIrRmRHT1psd1d6WENQTUNHUWY2dEhpdGlycFZJVXpGbTA5Ymx0bEhxMmxQcUVDbmxxUEs5aFUxaE4vZDJNRGV0NXA5VGp1MUk0aHNLRmFpNXI5VE1IOTJGcjUzWlA2MjlHdmdXWHFOTmhJcGlUMmVLVG5kSGhRL1B2WTR1V2wzR0Erdno5cUt4bVN0VlIwSUdZZk40d01pUGVlTjFsTFRJeGVVWXdsVEJmR1pac1RGRFpOK1dhdHdsTzNTRTVjMzloNDdRRGgyWFZXN0hxbDljd1dOQm9LZURZQ09RQXVDREU1SnJ2MFhGSFFpMlNzL0JnSjZEN1ZEOUFVT1NUSG9ESXFSWjJ6ZE5vK1RRL1pET2JQQlYzcTRoM1Vvb2oyOWpvSkpLMHhreUw2SVZRTWhpSDd2QVdXUlJUVVpNRkgwdnV6RTJKMUwxZ09wOTZjdExWWDlHM2JqZHFyNUpyWDdPQS90cmNDRVU0djdQbmtaQmdzTzh6Tkgxak1FUUswQzJpWVYrSDNzRExRWkN4RlFUR3FXcURHOWorUUVhd0FlR3F1MlZHcmhyQlNYNGlPUEZWQVdVMFFUZWViTWNUbzc2Qko2SnVKeTlsUmF4QmJXMW9Cb0FpUE0zSUFiZ1pSdlUrVUJXQTRGcEdMZmR6L3RqU3JLMHFmdnE5TUZGU1pJMkJNUXZIYjZudnFiZFNRTTBIN1dpbGJtM2llWFNjUXJCRXN0d1hZY3FZQ21kK2VNU1FFTlNNMXozVnFmSHdRcVFQQURiMkRpLzlLM1RhdFNBb1B5YS9scVpVVjQ3aThFa0FzVUZNMlNPK1JVd2gxMkdldW42QkZ1Q1ZJbFJ6WG9xMGFzQWpOTnpQRHNGdzRmNU1vMW53Y3VWNWw1YnlwYUpFSHNPOEZHREwrYjBHQWVyRjFqOGRMamlsVjc2QlYvRFhhR0RmdjJVczJIajNQN1ZqNnBibkppZjZMN0ZRZnF4N2x2RElzMmRwMjlFdUhLdFZ2YTFnTzhxbTQ0MjZRb05JZkF1c2oyMk1rRFJ5QlhWdDBFMStmRU80aHo2TlNNNEI3N1A5Z1hwejdxNDJjSE1wS05hWGRJOS8wYU5sMng5c05RTkZRQ09FaExKNzNNTk9sZlNBUVhhbXZJUHNPNjNmMFB4KzZIK0xkZEMrZG5BOEhwZG5TTml1YThEaWpaYzVacC81U3dsd01QODdsc0w3OUxjbThCVWdTcm4wbkxuZTVJM1k2NUlkMHh3eTRGaThLU1ZDTTRucjlaMWVBU2YzVW5iVC8vVTl5ZXQxekJGRWZYS0s0Zm9DeUlzdDRkbjlZNWVHZTRHNU1hcng5VFFhSm5TeGNDc0xvSnlSSlpEYU1ER2Z1NFFCU0JWOUMzdUVpd2kwdTFwTUZlQlAvYjdjSTgvQWJVN3dXcDNBbXAzZ2gzd3duSkFYWXV2L29WTWtleHZIQWFPcjA0R2ZvVytLWHlBMXg3RkFHY0k2ZmNVWTBmQk1XdzlJanZpNGxMQVdRRThyK2FlWDVMWGJoOFByMjZQcG1XZDUvQkJVdlJzdlJ4ZWZNVXhTUlFUeE9XeFNmUFlaSGxzN01tam00VUNudFRNckNBM0ZlcExSeGxxaGRLM3VwcGlKZ28vS2tPZWZTTlFBRkpyOUxBR010UldzRUpkV3ZtMUx5RzI0WHNkVkxtdndhM2UzSEVSY1dWd290NFNvL0tFMVlhbXVGNTFES29MVmdDVVN4bTFFeklIR0lZOEVJQ2ovcHEvMUx0WEhvM2ZlTzJEMXo2Mi9XK2VMSmQ1ZC90V09TWXNvdzBGQk45M3kyVkx4bFdGNnJmaWhjeDllRC9GNXVFbjFQeWg0RS84VCtCcXV4eFFsdnAza0RWaDR1Nm5VNGVmM2xaYjZ0MkNVcWVtOWs1TlNkcVBUaTd6YnRERU4xaGkzYVNnalBXTHF2ZGtpZVhhZ1RvcDd2eEozWnJ6WUZDUW55ZEtQZVRaOFVuZWZmd1M5eWZ5L3N0K1VkUDdqSUdxNWRGWGZFYmxnWDg0NysvM2k0YmVMK0g5UHI5UU1HUEs1VTd5dnVvWHFkNmZ3dnV2K1VWTDcwL2wvUU4rTWFEM2tIZkpnd2Y5WWxBZjNLY1B2dTRYUS9wZ256NzRobDlrK3VCQmZmQk52NWlqRC9icmd5LzV4YkErZUVnZmZORXY1dXFEQS9yZ0MzNHhvZzhlMVFmU2FmUDBBVkFPcmRWUEF0SmZMdzk1aGgwVFExU1NXeC9JMGQyd204dm41TkphZWtRdXJaRXZ3dkZFTDZGcnNKWnQ4UzJ5ZVZ4dWxVdHJ6VGJmUXFMSCtUeUlFV09ZRG8vSXoxekZZaDVleW1BbW8rV1JqeVFjRWdOcFBSOEdFbEhaNlRDQVMyNUI2cm5DOHlqN3gxQjUranJqREZBY2dkTzVuOWR2cjZMdTVtNUpyWEpRc1B3NExEY0xGYlljVktCZFJLLzBJdXdxc3NkNExheDRMdHFMSGVtaHFHVmtuUkRHTTRqS2J0QVJPVlliaUpCaUM0RTdHQUVoTDE4QlRxQ0RXWGR4SHhjUTVLUENBQ3RmaVlMWENTUGw2WGsxZEE1MkgvekhHakU3S3JJWG1FVnpKRVR1M1Rzak5jdTRDK0dZaGRKQVNuS3hGaStNOWUxVHJ3NXlEV1JBVG5xL3NLZ3p1OXI1NmYvbEFUM2xLZG5Vc3h2Q3dxczg0OHYzVDJuTUloVXUrRVJROGNvcnNyOFBIVmdMbi9BK0xkOXpaOFNOOFVxcDJSaDNsTG9jQm9tTDh1V2EydkR0bnovckdVKzZkZC84Q3AxemIvZHlUM1ZKWTJmRWpKcGNHdHd5M3prSDd2M0FYUUdCamNxZDljbzVUMjR5cXN6Qzh0YjVIUjZrY0FlOUdVNVRxZ0RaV1MrZis4b1h3aW9Rd0szenBhR2JPL2h6MW9BT3dmc085YUUzbDZmQkNNUFFKcVNNMFE3NFZlalQvT3huaVhvZmV3VHZMSDE5VHlnbTJ1SzQrNFhCQ05BVjYybHZGZzlzNzJZUjJXTU5ud2NNMEc2Nis0NlRic1RPb0ZsaG1QZ3lCRUxnRnlxdWFDdTFZTUxac3VEdSthcjR2WFUrbHFIV3NQd3FJOEprQmhlQWpPcmFJUGgxempkeDBrbmV6bXhBTzNnRWJidVRuYnQ3ZmllTGRWdG14OC80dGpwOWdGdjladDJGc05yWmRTajk0SU1xcmJiem53N0s3dm1VcUVEbzRDbkdTdkpLUDZCWlJmaEsvOWI1MlQvWC84UVAwa3BFRUZGUXh2ajA1U1FWdjhqbGx2bDBIRlhEVFY4Wkx0Vy9rQi9FbnpyK3RMSnJ1VVhjTWw4VFlIYS9DOHJhQ2ZDcVFHM3lLMHUwMWFyY3ovWlRabHR2eDkxS3hJb29FUUNyVDRGamZHcldDQ0dUL2ExdldnVVYxVXRaY1p2Z3VteXU2bXNQMWY0S2VsanBvRnZtZDhxM2c5QzkxOWVZSkdoTHJuSnNqYnBTRlpCZHg1elBwbTJZem9FaysxQjl2dVdjdmRqUUlNb0dNNnZhQW51ajdzV2hMTkZaajgzcEhiNW5VbkdUTThqNkI4amRLTEM4MzZIeFo0VjhILzI3SlB1QXcraFowRTBxekcyNW9EL3ArMi9vU1pxN3BEQXFoSUMrTCttM2QvUWtQYkdiRkdyZEUvdVRIdElLcEE5MElieG5NUjEyTXFWUVozdlFyd24xVkJNYTlXdENqWHF3NnpDYzIvMHVtajk5QkJEclRWV2hrWEhnTTFPOGlNclA3L21xL1B6b3l5Zy8zeVRjdWlrM2xUeWY1R1ZsZmIyZGxHUkplb3ZDaFZybGQvdUk3cFc2ZXFxcytXaURSN2xLekRkdGVwTk9uM2Y4TXZ4ankraVdNRFhsWjFjQ2xYZUdmTE91OEZLbW81d1dtOVdEZFBMbGtNSzBRaGpzaUJFTWRjd2l6ajJvNEhsTXlYN1RXTkZYTFBjbmFxaGZCa0lzcjZwU1VwUUQ4eFVjN3RlWDRjcXhiRXN6Zlh1b05kenZUUlQxV1E1VGRiQnFDcGxSQjE4bld4VXZUM1ZYK0RuWjdPMnhpZE1uQldmb25EdmxTMGRoU0pwM01SaElLRTFNVXdkTGtESGQxVThqbllJdGdOV0JZWk9TdlJMRkxVRVlvY1ZDYmwwUXk0WEI0b3A0ZXVXUnh5QnZBUEFNZGcrN0tuL2hucXFSaHIyZ2VlZGlSektxcHlSdVhBNTFVek5LclI3NWh0VEtWVjJ4Mk5Va3JRNUdjeUUrN3hBa0dFQTl5T3FzTVI1OC9xVXhQOVdrcVB6K1dkVkVYdm92a1pvNVRPV3pxMGpnOWpHVjA4UERHYmFiQzJDNWRRb3FWZGVuNVN0MXl3OXlEWlRIczlDSHRQYWVwVFVzTXQzemZINWhSMW85WjRRZE5jaFVPTURBZ1QxeGM3dWVRQmdnQjk4RmNjTEZyanA3RU5oUU5BL1JRbnJxUTdwc0tVTithVnFXR2V0NG1oWHR1WksxbnA2NjYvODJ0VkRBb1VxZVFabDBUOHQ3V21pQjV1VG1sa1lScUZ6NUxGZ1hCV093bnVtZ2JtUE9OQzBzdi9WT3hURXdTU0F6YzhDMmVmeG5WWlV0UjVYU1dDN0Mxc3JuQ3RsREhBSTNGWCtiRmdXVmVYZ0loMjhYYjF5bXhDd2JXbnFmeFFxZE9sNncwTzZrS3AyQVZjVklGRjVabCtseW5kWmxzY1c3Q3RVVEJTMXphbjBDYitiaEJNMCtPbXhZd2twekpiT25YUXhsYVpDR28rU1ZCVUM5bG1BUkg0d3BHcEI2ckdRc3Rob1AvT2kyUUx1Tk1NaTIzbjJxaGhCMzlrUG94bTRXS0JOZmh5UVJQVjlURVdRWnNSZG5KSDBBT3E1VllpUzM5aWtSaHhWanBGSnJISlZpWndwQW9iNWFSbkZKcVRWVm9DaE9SVjI5L1RFQkVhZjhiRXBGQXlDeTBWQlZPb1hvYkVuMnFCSlIrNDN5dUNPbm5QSTIrQVBtbCtZSU8rWDg2dXJscTFhUHdkalZLeHZTcC9JV1p1anViY0szaWJBUUd6czl5aWxDOThlUTB2MmVScUFOaExpNldMUkFjMFhLMENJQUl5VlZYdmpVVFpHNlNzR0RNa2ZpeEVpSFpwSjBjVTEvTzAvQTYyeXlac2VkcStZU3BtNVlnUVdtQ0N2bG1VZXpuYWpmcjQvaDJpRHNrcGtaTXNDdEI4UXhDbE9GdXFvTk00U21zY1k0clZmT0JyQW96UlhsRC9id01QdHFPNWcxeTJtRnFRcHArdXF5OHJSN2U3TmlkRGJxN3lLMVpuR1BaNU5mcGxmMFNDOVBnckJTWnNVcTFYejR1UEh0SnNCTllEY1FrcTdVeTBndktiTDJGbnRWekJqZTFmcnU2bmFlV3V3MWhMdFI4ZWR5WmxJRDlHODV1QkhYQ2EvbklkTEFTZklKYm1wNjA4RE5obktrYk9JdUxyUDFZNTEwanU2ZG9PeHlzczBlQzlKRHc4RmNOUVU0R0V3VXljem5kVDFmckdXWXY1aTQvMEpweGpkdGJyOGk5eXcrNFh3SVpPMjY4dktTci9oSlB2L3kvQlZ2SkVrZmIyWlh1Sk5pVXI0RWU5UHNMY29yOEZhNHBPOEg1bkJ3alEvVTc1TzhxMzBFQ0R2SnU4cHZOL0c3eFcvVEQrVWRmcnVGM3l2OTlrQzNjQTFmdncxeXZBR0lTeE9JalRiS1Q5UDFXMXAxV3FQcU1mYmRCb2paTHRNTXRvSy9YRkwrdzdXd2VqN3NmSlNhdDI5dXgrVjdubzBVQ1NnZktLOGc5SVlmcHVVN25wR25lYXZjNjYwZkNNcWtuWmFmK21IY0hpeDl4aHNlVWovRVJpbUp5cWE4L0l5OUhOSlBPUGxEaTFUb1pXOUdmYVIrVXJjMlk1eDAyblduU1dxVW16dDVROHFPVm9MT0lLQml1V2RyTEFtb09xY01Da1Voa3NrRXhFMU5ucy9LWjY3V0NJbzVwYVZVcGdsMTJ2L3pldmE5Z0pkN242c3U5eC9tWlFKVGV0M2hFanBlK1BxN0hTc01oNVB5NkpOeDluaWcwSVM0My9KanZhZVBUZ0kvQStXY1krNEJQdEpUZnZObDNrbHFkNmZiSExKNDRvbitMSS84MUdYSnM2M2lpVVBpQWVqUGdLQmdMS2lNTnBRRDViVVB3RWRGWlFyUS9EelJXNTVrMVMxUGM3Lyt4LzJsZmY2SE01Ym1WYVZGVmxwelExa3IzNEhTcktqcmY5eGJsT1RqN2poYnQvc3JhTHo1Z3h0aXkwQnBEaHp1TkRRTkp5d3NLUFB5N2dld1crUXVvRTVyYnp1VEVaMmo2RFo1dW5yQXIxWll3OWJTQXdHalc1WFI2b0ZZTi9GdkNpSEpOcldIWmFiUTQzMjRuUExQSUcwY3pwc0ltZVBXRENSbncyWFN1VDI3WWtBM3h1SHNpYUNvNTJPN1lPczN0NU05R1NqRy96QXRydWJtdy9vSU5xaHlQOGJaQkVxTjc5dzgxQ3FGVWlYWmZjSEpER3Uxdm9GcXZaVStESE9SY3BnUlFMT054VEJ3aXViaWlBR1pFZUlFb3EyeWgwNWdCaFBBMjFVNFlBQjdkT3NEakZ1V2FHa0szckNrL05hbnNXcXJlRVQxOWdnYWJUNENjb0k1WTRCZE0xK3VOM2ZhSXlwb0dpNWI2NVVCK3J0OWNYbWJiRFBEWmJSK3JIelBsM0ZWQjY3eGhkMkNMcEtDUnN1SFA0bUMxSHRUbWp4aTR0OWd1VlpObXZRUWVlbGtvZHlWRDMva3JwdGlsYUJLSHZsZ0JjRWNyYWdlRG1WUEJjVWNRZ0hNa2I3aGNFbGVEeHFIUEZyKzhxY1c4N1FxTDB4N0NHNm0xSFV1T2V5NUdybGhHejF4SUJVZnllN0dBTXQrdU0wdjVsS2lOYktVeDVXc2ZQd3JhSnlGaG9wVGp2Tkk5cFo4QkdKWXVaU095dWUyNTNFT3ppdUc4NUdWZkQ0c0d5SG93MXp3SVpLc1BRODkzU2xPUUFJdlB3SDNPQ1ljNWVaNGdyeVVWc29UZjZ3OXo4bTFRQ1cwVHNQSWNhTDAzUC9aaGZQbENkOU5TUGxNS3FXd2Q5dkRLWWNOT3NpSFBBVU5rd3BBRVkrdXpINW92bG85bmEvN2pDem5oN0NIajZoRVoyNzI1amJLVGNvRDNRbkxycEhac1RSNE5OQjUrNjhCODhjc2ZpaEFoejRxWmZ3bzBQNTJiL1lmOHlaQjdSL0NWQUFmaEs0b2hobTJJaW1mZkZlaUQ4ZmcycHRvQlpZRzU1ZTNrWVlaUU1vd010Z2ZTS3VIQjBLcDdJZHB0SnlWMzdHWWN1cGQxNTFTYk9KN3I1ZGorb0ZBbWlEMElISk56RGJNNzJrV09lTVpHbVFnYmxuNW9hdHFMaUpzT2RxZWgwemJKK2owa1FhTjZOd2RrUmF4eUljQ2VxZFdMMGsrUjFDTGNvRk1ncEgyQ2VsdlhXSStUNWJlQ2hLeUE4eVdYbkxhanlTam1FajVQRWRBZGR5MUM2SjhLSit6TUtqUEdmSVVSeUVyZjNCenJZb1lKV1JRcG1yTHlESnkxSENZdVREcnQyOVdRdVlVNE9QTnpmTFRBdStFM1hZVnpNeTZteWNuSmZFRUFNbHJNL2xnTUFzcUIrVmN5aE56Zy9YQkR1dWlKbndpRGpDd3BvU3NHTnA5WjhDUmU3MGdBamdVRTY2c2l6bStHRHk4djZtY0FzUGdrWTNCUmlVUHB1dzZ4RFZ2MGp2TTlKWFN5WmtkV3h4Q2g3OGJ6YVF4Ym9tNExtWm9ZRnNNekVWQ2FxK1U3L1pWLzA3SkdFeGJpSWZnbFI4MnRJT25mTlZ1ck5UYjUzRmJJVlBNNm1vU3BoczF2a0JnYnM0QnV3amZHZmlGRXNWb1k3bjkrWHJIQklpK2lnN2xFRkthSjBSRUpBUko5YjduMWNvbTBwTm1USFd3T3hMYTRTaE1mMkNvNVJDK3pRS2xyK0xXMVVGbDNhdldNVEh0STVjR2E3UUhxVXFteGhXaXVtcWl4K3BsQWZYRGtTMnFialBiV1JPclBmU1VRNzZMeWkveVd1Tzd4K3Jhc01UQkVaeGUvdk9PaEZyaTdQME4zYUNyUkxrbWdJWUZtbWdtV0tYUmRaZVhlOEVIV01EMzVlWG4vYk1VbmZ3Kzh5OHZkMTVaMTFjV0p2dU9wQWlXU202ak5GU282bm5sNDkxNlh2MTRUejJsWkVBUXJKYUZYNXUxSTN6dGlLemJFV1lqVHFVMDFud0VzbFBUN0dBSGl1cGJKZkdDMVQrZHEwQ3RXV2xiVTlPbFRiMzFMTWU0YnlUVnVUYWVMZG83amJGTXNkTHFaRytIMzdlNlhDRkkzNU9WaXE1OE45eEpmY1JDUDhiZEo2QXpXQnpScFgvRlFBS2tJRkQ1U1pVL01LQmlpVkRYdEI1cVNRWC9rcUo4WHVOd2NqUThDLzRlTldEL2JPQ2piQlBDSVU5RmNsNnZsVlBCR1VVd1ZoNjhwcFV6eWFZOEdLUHVGMVlSTWVKNUp1dkt0M1dLMmlaSWxHVDcyalN4QWVzdiswdjZIQ1JncWF5d21xVTdiYjB3aVJ1a0hvb0N5STNGZDgyK2YwL2lQQkNsUzdhYUo1R0xqMU5yMVVFQnIraG8vQ2FwMzlIZjBJMi9wcFlodnZBaHd1cWhyNXhEUGYwZDg0YlRndFRuQkI1Q1B1K0hpcnc4T2tSTEkwYVpUOEN6ZVpZRThROFRNRzRKK21LZkpKYjZTOE5vdUZZcm14dnpCaFNxVWFmZDBDUC9GWnJVZ29xN251WXI3RUxVVzQyMXVjZjgvNmp2RmV2alp6TjJ1V3JTdWowZnE0dm9reit0UWlQcWxQTVp2TnFtSElsVW85c0JMRVQ5UzJQNmEyWi9hUjBRWnRmNDgxMFpIbGZhN0dHemF1bjcvSmR6bDZRZ3lPeTIvSnk2ODBERk5BSHg1TUgwaGtyTTY5Ulh0K2FFbnVwU05NcGpSQ08vRnNtQ2RZNkdTWnQxOTBodkMyenpxTUx2T0ZzOHIzei9UMG10S05MTmJndUxVR2JuV2hZMVpBN0tTOG9wWUJreldCYmlqYmx1OThzUkJxS2g0aXdxL3pTbmpoYXFuRVdlTi83T0d6LzltWWUrOFBiM05GK0RLQ2dvVXVwSCs3UUtLUnhHMmgvL0tDSEpsVkxwSStHdDJFQjFFYVpyRlJuQVBhSHFpK3NncUd0ekJoR2x5SXJWSVphRHVydHd6MU1QaytlOExsTC9CbjBFKzVxb1hLNG8yVFFKUzlVcUVicmxkQ29NVXJXSUoyTXc4emdIR2lhSFB6aThoUzZvaVlXaURWUUxIdnhWanhGczBtT3VrcXd5Mi9qNGJHSHN3RHFvN1NoQnNsVWs2UDhuYWM4QWZnQW5MQ1V0Q3U1K3JyNHNwTTZVMUgwd0g1QVIvbGhvb0Yrd3NmSjE3bjQxTG1oVDB3V0NDYWc1TlpFbjdHemd2U2JzeWFVZEZGdEFhUWZaaXF4ZjJOY1dUWXRickZWcm1tbFNqd0dOa3hoOFdyZGtaWWgweGxJZGVGZWlOUWg2dXBaQXFpMERySnMxekhxWTNtK2czenRuQi8zdTYyNWpnRmlmenozdTZzT0pJbHVxN054ZmQxQ0ROOFJGWk1oZzVMYnlqcHVVOEEyZnpHNkozVmpxUk12T2NjSUY5bXdlS3JSVithaW5zVXV1TkpadXAyOElWdVlvbW5mS24yK0Y5SDVYck9vcW1ML3RsYVg5MGJqUHBwczhVNDUrVzlESmRtUFFLcmd1ZWp4cllPMEY1UUpaQkxQMDU4N2pnSDF6cTlyV2dKdm5UNFAwYjR5Vld3TFo1aXh1ZmNiQ1NaOHg3SHFOaDVrRmprTzdBYWRpRjhOUTZHZWRZRGRnOGhaM1hVUW9VNjFoTmlSUWhWWkhQMkREbWVHWWJGMTdDK0ZPMUYxejFrUklNVEpEaXNLZE00RStWSVBkSUNPQzBHU3VUZ0ZJNE1JYTZ6aytWMHUyeFBTNHhtSWx4bUxWTUY5L0JtWkplOTJIWWpoN1N5RVZPSWVLc05IeTNzOVhzZUV0RHNpb2FwdmhPWGozVHpucXRaeUdCRFd5U3hwY3VNWVVFTDdNekZtbEJmbzE0b3BnMEY3K3R1d1gwSmhKdWo5eWNmcmdqNW5NRW9NWWJleTZJL0pVdndCV3hKUVFEWmtMV2J6YTFMRUp1U3c5bGRwQUk3M0d0b0pTb0s3Ym83T20wYzFvRWdock1SVlpMRTRLKzY4VGRIV2psQ0ZYY1FGbFU1UVIvQWY1WmpQQWxNdkR6OVFkWnR2Q0lGY3cybTRtTytOMml4YWhrbjFyZ0YwNllxYU9HZ1lUNG1wTXNuVmtRT2ZSbGxBZG9URTJ6Kyt0aGxKdGFERDN5dTNQMUJtTDBPaVluVUVhYnM0OTNYTUV3WHo0K3FlNnArSTZKdG02Z21lSDdNN1l6RWxSNXhaOVR4U2tOczdla3NlUUJ0VjB4NFA2cStzUGlrMVZKMFgvYkVEcXJFQVVESFU2VmtBYXVuREZRaEFoRzhvQkh0VHFVVGZxREhiaDU1K0RPSS9UdVo0ZEp0dTJnUFBGbDZOK3NGc1A3YW1LNll0QnpKVkJteXVEbUN1RE11bUdvQ0w4Wk94bVhQcDRWN09WekJaeFVObVU3bVJCaDlZTTlkQVdmQjFHMEFsbWI4OWFiY2xhelZZUEdFR2dEYmVuWTJEWC9uZ2R2aFVZY2dZTnVLVGpjTXZMVk0xSWs3SlduYlJOK3FST0hJRnp6QWpVbUt0WmJpSitPOTNGVlZKWU0xbVlVcE1HODRJb1RFT3JRV0JJVDBmTVltVUF1enFBUmxmd1g4TXVOOU5vVXA2YVBSc0FDNG1lRXJOdGF0cm5iblh2aTlOLzdscEdKYk1oYi9UMWVVRFRHMmRSWVlvcjlIbXR2OCs1RGJQajY0eVN4R21qNnhlYVBMVXJoZ0NqTHZPM0lhMVJEYWxzbTRwbzBHMWdZQTJzWmM4RlZCVjIyempqSk9scEl5bGErci8zS0FqVk11d1BvRmkzYTc5RHp5ZVYyendmYVNTcDJVT1JxZ2xwdmNOWmF4ZzdZZTd4S2lmTHhjUEFnb0EyVnlmUzFPcmc4M1hpWThqdjB1QkVNOGRhS0FzNzVRNVQzdkZjckFxMmdNNm8yUThBanBKMTFnd3dXR2VlVE1CMkJrYUFBSGs0TVU5MmovdFhqMmViOC9qMjF6TU9jQm1XNkptalIwOFQ3ZzRCNjFiUWc2WkdYYnZqc3hFaE5McytLQnhHS0xBSEppK2xqUk5uWmplVTRJRDZJREFZbzRQQ1FhdnpCRWRCdFc1bGVocU40and5b3V6NXdxWEJhQWx2eWM5ZFd6bVhweHJScjI3b1JMbU05L042eWxCNUJVN2p2dTVPZEg0QmY2cnE1Vkg4NHkycHl4L2hIMitkN1Y4THhnNnc0a1lYL0ZIcGFmNko1RC9Hd0tXeVE5TkdFYU1MaXZBMUQvS051Z3MzMTI2VUQzaHRXQVkvNEdra1ZFTk5hS2pWM1pMeWU4OGtsWE03aU9Nby9xMGVnNGlrREZhT0tSTS9hM1RVR3R4ZHFVWXBpZlNUeHl2SDhQZk1JZ0ZlWmgwak82Yk9yMzlWQ1FCbjgzMG5XZ0xXMXkrRHRtZlc0aUhOMUhsWVcwTkdVeVZZYmQvVTVUUDduZnZweDJKMWI5clBmWHhtNXBjNzl4cnFGWVBUeVYxQkpoNk1MZVc1WDk2ZHFqK251SzBaZm5SVGV6M25zRWs1QVZ5Mk1sV2lFWVlrUkxDWVQxYU1FRkJ0RE53R1hmcG5ibDU2SzV4Q0FJWnl6OTRZYzJhYzNNa09KUE5WY244eXlOQ2EzTlF2ZnpMZENFcFNQd2hRRFNtZEJpZDFGVmpvUVJjajM2VHRraUhSSitVcnFIeVB6eGlEcXZrVWVYQnFSMEZTUGdMTVI0UDk0RFp5YW83WVVYbGpRdGl5dXU3YWRZZllBTmV2dXZXS1lqWTBRT2dpWlJQa1lnTHhyMW4vVTJWN1FEU2kwK0dvQ2xYd3FMbFhOV1hjM0pWenVXcWFENWJxZ2RnWHAzU3lYd1hxZnVMUTVqMTY3RXZlcHhScCtZb3pXV1pLdmFqNmJZU3laWC8rb1ZyRk52UHRxQkwzRVUwRUMvQWw1U2ZmWGJFeGxNSEtHWXdpVkwralJsOW5qY212ZE9BWlZVVGV1dm1FTmNmYVpGbE9nYXU4cDkzWXlLYjhObGhhb2NkdzFLa1REcHdaT0E4eTZsUm1ZU2VEOUNrL0NOVVdZdlpvVHhpZFJlSDVSVXpCdUJKUlpUa3ZSeHpoM1FVQm5iMXNIY3lrcXNScktabXRxUWtFNUVWcmI1Zmt5OEx6MDc3dnh3bHYrSHBWTThpSGlvUVJ3L3RiT3VxTmVzTFRQYXUyTEt5VGNHUjV2SGFzdlBxSXhVV3E3YXBjOEdZV3hQaWdGejdFQ25DNEMwZnpTcXU2TER4Rm1ZYnNoU0I5aE43K3RENFBkU292d0lsYVhRekxMM3pncnNEOFliSmZ3OE45NnJHZi9rNnVQeVJhVnZ1eHlrQWRMSFQyK2RBQmVsRU1NeW9URXp3bFBMdFdHdC9EMVhqbW1MekpQbWRZa0tRNFBtT1psc0VHN0dwQzYvU01tY2NUT0JnSnJVM3ROTHpBNHU5K050UTZrNXlHRXpRaERNK3N3cDVPMVdjMS9kVmhJN1UzaDVNcEJsWFBmaE5nRS92ZFRXcmRPMVdmM2J4M3lIRmY4UE44U1NaVzRMZHNxNCtMSVh3MFpCOE40YU1oakloSzZFTGtUMXdZQ0RIV3J4RCtVRlpiNmJmVGNGSW1zamZSYm9YTFZWMFJ1VWdWVHRpTVkvcGcrWHNyMWRJdEg1VE5oL3JQa0NDNmVMZXlVMjQ2d3lGSFIvbEEyVnlYRDNiS3RSMkwrcUl2RU9OSGNnbmw1MGtQM0w1d1VPdDVla0VzZGZrWnlHdWR5b050cEx6dkczSkVvZ2xFUzBYNE56WUtPR0NlVGYxOXpKQ0gyWWZyY0RGdEF1QmVXbE52RWE4aEF1eTlLck1td1V3MDFkSUVDbzBpUXpkbDFrMFp1aWt6ODNYaEQ0bnIwTXdIWDBYcWhlZzEyTnJlUmcyYkxIRXdqNUc2RUZjY2llcitJWi80Y3FneUJ3MjlrOTNQMnpXMGtBeXlyNFFWUStJNWFTRlZQV2FTek5PdG42dTEvSkFDaXVkaCt1MHViK3ZQQ3FCZWFiSElLcHpScDhoYVNGQXJGeTI3L0VNNmRrZnJ6U241NVBLVlp4cHZKS2M0aWdqUFZITTdkMFRhOXBPRStHNFdJR3BiczRnZ0pJZ1FxNTJDUkpuQVI0TktudEtyOFBLUGg0VCtyVFNvNlZFOFB3NDRva3J2S0NPdDYwL2t0dXJzSHdNZ05VQzZxdHdVeEpKb3VtelFILytYS25xRk16Mm1WQzgzNTFRMVNZOU1KT3oxUVNkbW1sS3U5dFVoTmw4cXZ5cW1wbTRsNW1mWkU0a1RuTVFWZmxoUk0zM1d6bnBWSWxqT0dzSzJxYUVxUlFuQXJJSmJGVWd1RU9wZVljQTNWbjRSekZBRGZSZFJpQlFvdkNFY1VhbmZtV3BtUndLYW9OTEdyd2FEUGN6S3dKQkxSc3ZyUDk0OWtlTmIyME9ZSTF4RnlsZEl3cnArTjBDNC9acWlKeG9hald6VW5CQ0JXVm0yMVB3VDBnUXFHeDV0SURRcyt4TzFiczZwQTFwRjVuNm9OZEtvWEdnY0pEdlQ2bTB3aFlGRi9YNnhvVFc3cjJuMmxaVXllOHAzWFJOWVI5L1hWQTJkZnJIL21DKzJIUFBGL3VxTGJvOXZiVm9xNlk2RkZEa3V6bTZLZFNWRW1zQ29Vdm5kYjBqSDJHcGdjK0pGNGFFR3pzM3N5d0JkQ0VRSUdMaS9HQXdvWTRpamdIUGlqL3RpcmQ5Wm4vYmcxcnBxTGs1MFdJNm91UkFkK0x4aHB1Y00xNmtWSGRGYTIxcUZlZ1hoM21NVmYvZE0wVUJOVmFwdUlmQlFFN1pGT0xRcFlzdEJoUzhxdjFZbmZRaldWOTJ4dU9wQkhKeXFrU0lsRUJwMm9hSlY4a0hETGJGdERWVUZYTWk5Vk5mQmFQblFaeDNNcUNzZmgzZm41eFoxblJSc0hBcS8vTzR2bkI3WUwvL2hvZTcxcnU5MHI1OTZkMVRwaDRQc3g0WStHWmo5YmZhVDZRK2U1b096VFUwdGpNN3V5dTZKWFhGSVVtWlRvUzN2WTNxbDI1RnN4cUl3TXp3cWt3OWEzd0JkTExQcmN1Y0RPM3djZitQczdTRWVqVko5RVZoa3oyU2xybzBlT2kwZHU0ZnFuenQ5S21SR2V1bXFJMThoREpZWlVyUE96Y09qd0p4WVRUYmhjTWp3VlQ3b3krak5WeGZhb050UXpoTUNUQ1V1a014Skhva09tNXB0aHI0N2UwZG9TckdVY0pxenlCU0M5RFpmOVdLK2FlT3dHWjJqSVRiUU90KzFEa0YxWW5pcG5iaWlpbXBsSVJ0d0hNU3lDcXpwNURteXh3M3I4eERkbXZmRWJVVkJiV215N0tWSUJ4aHFtV01mN2FFRC80bHByOElsM1JNU2ppYnZFU1FVVG9sM2tWNXhzMXNZbks4UUdmNmNrRGJpanlXYVBLcVNqMWppbGoyUkpPbjBMRStjSVEzOUIzbTBtOVpmUEF4YlNPc3RZVysxS1M3blVBRC83bWsxVEhHZkhxcWZvK0lKL1ZZNEpleHNJNFRmNGxOOW9BSnhlMEJaWjQ4ak4vTStWSmVwMVNjODM5cm9WQUZKcEtRdGpZSzJPTUsxYldtb2dRNmd1UnJFNzJFaE9VdlZoL3lBalhFYTFraHozZFp3cVNwcUFDV1B2TXF1d296YjFyVGlkNW93SC9aVTZVY0RBcFNSTmJEZUxIZjQycEU5eXFZYnlDV3lKOE95dFU0YjNZdi9JdytVc1plcFo4dnA4VWo5b2crUkU5S3NvU245TFBRWTVaNVlYVnE0TnQxUlhYcm8zMFBsSWFRM3YyYVhpNnMrRmxhcGVycWdrMzBHRTFjN2ZhODIyQ2UrOXd0UTBUN24yM2hzRGUyaXp0eE5PeTIvZC90VkZlNzJYUlZ5bFNWYXRydDk2eXQ1bHA1ckFaZVVXR3VEcUtVN3NaTnREOTF6QlRXcDl6MGF4YU1GM1VlT2hLWHBkOU1nbTR3Y3hsa3dDenZ0am9BNERqS2lDTEZ0OW5rS0J2UFZlcWNyMUtzcUtDUm9sTkhobFZ6VTRFT3I4NG0rTXZKNm9lN0pCQTNOcmducDFiZkhvQVlzRDlRY1Vud3BlbXM0M3ozbHh6eTN5ZmxpSVNRcEpvRFRwU09FY3NrY0h4WWk1dmtxaDd4R2VjZnpQN3ZxcjRHUFdkT0F4YkQwZU50S2RTdXh0UnE3NmkrQXhZZFNONm5UbzdBVVk5MktKZ0VjMHFyTytoakNCUVBKWVFJcUg1OVFISkR5RXcrYjcreGpSK09aZkdjeEFYQzRTSHBxbTdnVytTZDVKMXBRWm1sdTNyWkFLQ3FjY2JnRG5zS21lb3F6c054aDIrYSs3R2JaTzBQSXJJaXNzb1FuZ0wvN213cG1IcnNoZGtJOTgrRGxiUTQ3SE5WdzFpSTd2bHl6SGRXbmlvcTlWWkErb1loaXVEMVhjaHJ1NFh5d2c4cXJ1Z1pxUlljQ3c5VjE2Y0NpOEhBNExmV0E5S012ZmZCcTlNSGNucGV2MGNsd21DNjA4TlNlSEpmei8rMVhGeVBqazV2enVlOG81dVlqNDZmS0dYV2tjN0pRaDRHVGd5emJrUlR6TGo5M1RQS1psSEc1dkhQNzFmbkk1blBIMm9QNTNIemU1ZTBSaWovVDdGMHluZzUrR1VFRE9TbGFzdGplN1NoZjBVUlZpN2w5bGRVWlU1ZVRMOW9HU1lUa05BQWswbXJTTkFFMmNpU1VvK2ZJTXNuQXpRN2I3M200ZzF2YkNBM2JjYk1vUEdWYUtUVFdaeVZkaUpHRndmTDJJT3gxbXVvQUpYVTdKWi83R3BXMVplMGhCYWhpNVliQWc3VHd2RnVwYWtKYjNlcjVYTlN0dDJvNTZ3M1BBWGwxQ21aNVUydGdLcUFCKzJRQU9SOEprVTJLa1RzU01qcUJmQ2xEdTllWGxoelYvMTQ2NnIwZWc0c3ZzMjBoSXFDbW1tcjBPSWxHVTZUWWQ3eDg5bEZMTlpBUDh5N2pOU1ljYitGNk1KQzlKOVNwZHdBekozdFByVDFYMWdlQTA2ZjI3YStCbXZYY0JhY2dJTzZpSU5PODVzS0F2cU5tRWRjbnhWeDdLam1qOWpXYnJxR2pCZE5KRlJ6YUE2VStBUmVTQzZzMkI4UjFqaEhYT1NDdWM0UzROdWhxLzBKQ2pHd2xGeWZLeFZVM0F3eXBTeTVVUUoyUmIra2xnd2xXRi81TXFEdnpnTXpIYTdBdHBvL1hMR1FYMFN0bjFBallCaGlhY2FyR3pPQ08rNmdQVy9Nd3B6VVJCSWhYVVlHaTBhUlV6UGFvVDlYem8zNnZRek0zUHVWYWp1Z0ZyRFE2cVAzTjZuS3BZcEhuSUVlUlRJNW9uUEpSSmlNYXBLK1A5VHRZTXgzaEUzd2d0eXA1amlyeGRGU0pweU1ubmlhR09CdWpFYVJHeS9lOXY2Ym1VMHJGd0JZOTZsYzFwUEpJa3l1Si9ES1RMOUU0cjc2Nklpdjd1SkFkVmZxS3VDRWQ0SzgyU0VtWFdSRlZKb0hRS3RRM0FDTVNKb0dSbVFRbU5BbXNxVWtnazJ6S2Eyb1NhQ1l0a0ZXNlBQQ3g1TUhvOXB1SVpJQThBdVlSYVI1NEozbEVtc2RLTmZtdWN5Z08reERPaDR3TStNdWdPa2Rqa0ZuOU5uZStSNXRBQ0t0YVFMV0lIT3loNHp0Ulo4QkNWYVpkQUR4M3pJVmZ2NnRHOVJ1bUF2TkxLSXBFRWtvbEF3b2ZRWVZVMnd6V2FwMzB6TlFMdEt1bUZWS3d2UHdtQXJNQTAwRG5IbzRJNnd3S0VwTXlyNm01ZjJ0ZHVVVS9iRGMwbmFMZzhySmdXTnVHZEpPbFdhbE83K1lPRDVyV3dQN2IxSXkyYWlLVmY1RDNBK0xJaVdZNWg2U1o2bmNSTldQMHpEWlhmUGZzVm5xcjh2cjZEWW80ekE1ejVvVVZ1emU1RkZYM3pZNngrbEpWbElGYVppd3BuM3AvcFk0a0RFeFhRbmZkMVlydlNUaHlvV0lPTDNSbTVmbkgvSmZUMHpubTJtcEFvRVFjRmZkNVhHMFVBSzFXcXdWY0RaamRuL205S3FNOW0rRFA0RUkvMEZLNFVtTjF3dkxhYjg4SVYzcTFYK0ZwektvMlFaZE4zd2dKM3ZaSzcra240ai94Y09zdDlBNDlFUzlWNy9NQUNNNTBVOWFvMnBBd0gxZXo0YVhYK241dFVnOVppbzdZMVVwRGVyM1NIU0tmN3RySnlHTDIxYVdBZ2dZZlNqcnN1alhDY01ya2gwdG1YZ1A4Wngzd3FRMFhtN1ZCaXdNbGhLc3NVbDVLK1hRWGFQaEoxTWZ4bnFPRlQzaWd3RVMwQzlvR2ZzbHFlcmE2WkpRMERtenNKTmQ1dGNNblhCZVEwZzBHbnEvQmFKZVU4emFXdi92Vzh2RG05YVJuOG5hSlNuTCtDTDdOY25zeTFVbHgrUXAxRzZmMldoNnZzOGQwZ1phTUR2cGpzQmt0OTZrcjFzbmxrcFY0QUhsL2RHWVJqeW5VWkM0WEFTMFpIRTVra0c0TTVQaHloVGJ5U0dqU3J1bWNIdm10c1ArcG1XaWgvOGQ5M1o5ZXI0c2NjZGpISjNzZVNlSC9TUmpKcXduOERhRGFDN3crUzNzbEdWaWNVUEtIUWN3dVBsd3Z2SUdRc1lka244R05CbFdSZXVLR0l5NDM5emJOMjlObk9KRTAvWGdTTkxyeEFHYXpQd3Q1d3F4QnpOcEZpQ2tvN2hJMmNsRjRKQzZHbG9VWDUwUGorZFpkN1dZK3RFdTliK3VMdkRYdElmQm5pSXlkNFAwN0pTV2RDK1hZOGJxbHdRVjRDblZjZ3RoSzV3TVlPcUhkTDlTeDZ0ajRBcm1FaTFVTHVzNUJLRk5EV3plSW5McWNhdmJ6akt4eG40V2dydEg0M25TSlhxTjYyZFZhRVJEekpncy9YVXRkRFJRdlhpMEhQRFExcC9KM1lVZFY2aWdmN08xYWErTXVXQjhvZ1ZFaFVNLzRtQWwxczVxNGdZdVpyS0trVy9UTUM5dzB2N0xCMVJmcTRxOVpaRVZ6OS9paDJoVkUrcEl6d1huOHFGbWxIakU4Z09Ua1lGMHh4SlQxM1VWMm50cXJ0YVJ4RUtJSFZNd055YXM4dTBJajFHWC9uaEI5ektUbUoxTFd6dEZVVnpOWitydkgvYzI1TDRWZWtRZnl0L3RkQ3NCaG5RcGFCbHdhZk9zQzZ4QUhqRjh6clFWcVEwbGk5bHlrdXlzL2hxZWJCdEZ0NnR0ZjJ0czdmV2g5MnFIaERLcDNVK0Y0T3pWdkNnamhkMXdqT0VhRjNsOERTVThjU1UvS2QrenFPNzBtamhkTnltL1hxTFhYcFBDdSs5SE5jTmZwSnRWdERxbi9EelY3b2d3eCswSFlZL2dUbGVyNUJWQW5VL1g1dW9LditHMkNDSG05ZUNac1l3dXRYdzNTZ0FPMXM2Mk9uTURJNiszNGZQWW9RT21qY1JDVGJEbmhCaVdxUERGTERTbW02bUpZUUoyR3hSMVhSa0I1ckdvbW5KTnIvV1J0UEZCUlE5eVZqT0FRTER6MTdWY2pUcDdKNkloWUs5L1grdytodWwzVGV5dTM0QW9ad01jem9CMGw0NU92VjRkaCthNzdWTTBMY0l1alRONVhuM2JTYzRmUXBnT0VYYy9nMUJHeEo3dFcyV1RZanFtU2wwOXJJSlJlaTRRbTFUYXp1RzcvdEJPTHJqQTlnMlA3UXpXYWJGMXZXZ2ovTHJXWW8xR0g2QjhxLzhuK05uU0laNGlQQ2U5RDZxeWk4bTJ5VjdUaXJ0YVRFY1hxMVhITlJYbWg0Q05NKzhaVHRZdVI0YWxVcFZSYUI4c0lJaW9DcTdrcDNlaDBwU3VVNUppZ3hRVG8zWFlpWHB5WHZSZVdkVDVPOVJDcmNQMzQyZnRDYWpJcGFLbTY2K2hSV256SW10WXpMSUJwSnpkVFJZRlQ4TXNuckpNRGlkS3Z6NUVkak9LL3ZRRVcyTXg2VzFLcGUzV3VUL2JTYTRmRzZYb3FkdytrTTY0V2ZsVHgxaEJXTDRhc0xlbmlwRlBlRmpocFcrWGZFVUtBYTVxREozMlQxYXU4MWMvZUg4N3ZpM3ZkdDdNZjA2VlJwWmJRRTFxRjJ0aktmbTZJeFV2S3A2dEFCMFpjczJjaW9oemVUY3B3YXFvdkZQeUl3dVdrVjY4UjllZzFFdWcxSXROcjJGZXVSRTJZdlJRNUx3Yk9zdFJBTWV2ZDEzSFA2OEFLVjMySHpvRjZrVTViWXh6eDdJMU9RQWhTdHlQb0NnajFMdXU3cTNkNnhJVTdBbjJhcDlrN1E4b1hjYWpwZm82N3JPK3U3M09jMC9IVUNSc1ZnRnJHZ3ZDMHNBUytXSVdQRnlsWnZwQm5uQysrcTVhN1lOYXBFdFZiRzI2aHVHWWM2S3ZIZ2I1NkhKaGVqd08rUGxVcGtMVmtUMThPZS9weTJETTloejIrUHUxcENTMkQ2bml3cEoxV2tsZHFnSFRYd0lPc282R0hBbXl3YTdUTnE3WE5wMnVibDNPcXZmT2FXaDVVTW9oSTUzZlR6U3ZkKzJSbnlkY1BwQm9RZ3pNciswRUV4Y3doWDVlYldpSHJtMmN0Y3VqQzhydjMxcHhJVjJmZ2szNnJoUTNVQ1RkWjJtQXlHQWFoNzRWcE9aV3JoV3BBbzFUbEhmSmtBd0tWc21xa3VrRnU1bFM1TEpIM2g0cmVxZGhoOE9Ca1BZcXdXams0ZGh3SU1Pd2hHTDZGR2tOREhqNGFZQkx3NFpFQW9ONThtaGtzTnVWak5IQ3A5V3dSK1FxbDdUbUk5SWxkMnFxbW5LUW5ER2tFZ2pMVDRnOFhoZnZESWwxcmN1aWlOVzNWaE9OZUQwSE1XNzMwY2l4dmJjNCtFQ0tRRllkZXJvdUJYY3BGRGR4WERNanJZakJQTmZpVUZIUWd4T3FUSjVjWEVKSEt2M1BIZHVrdUlHLzNhVFhjOG0yWlNQUHpVaElxMG9LNm1RS0E5TlhCWGtjdzlrcTNibkR5dExSc1psOElLOEt6RnpOVHhubXBCMFBLbXB5QzdXblNqYkJuSWJXWGxOZGVYMGtPVTdVQ3I4cllIU3Y4bVhFWmVFUXRHOHBrN0VmWWY3WFdkVEN1VUhaODBlSTEwZDRkeDFuQ1prbkZhcVk3MkhWTDVRZ0U2UkdUbE5SU1F0RFFSN20xS3J0amppV1lzVTk5RnhhMVFYbHYwTWtlSlpjZHlIa3JVS0VGOTh0N0cvUlJ2TGRoYmx1Uld2bllOMUE4TWhQc0U5OU9DTjM0OW5BbXlnSk56STQrdXJDamp5N3NtRTRYZHZqNnRJK3lIUEg2YUtUWFJ5TzlhVGxjcGc4cndtSm92YlV1WWVraktsMkNVbE5aVFd5QThsUWpPVXlBSmVYRDE2Z1NDYjFwOXI0dTJCelZmQmwxaFBwRS82S1ExUVVFbjI5Yk9jWW9qMk9LckxBM21NME1RTVBpQWNHejk2amVjNWw5TUFTVGRRekR3NGM5VEkvZno4SHhzRStQQ21GN21EYWFsZlhwWmtMaWRpL1BQdkxwdmVFSzJ5dEpQN3cwL1pCZmFaUDdEUlMyaFFWVmd5L1d5OUUzcTBXZHB4cHdXQk9IdVZNdmJ4VytEcE5acGoyUkVIa2xxNWlENmJ2Z2E5VTlETTdnYzZIM0t1N0lXVndYU3gwZ1kyR2Eva2U4M3hyQ1NXTWIvMjRQWWZNRnk5aHRJU0VKNG14SG1ENmFCRU9HczhhSWF6T3JEUHJNQU52Y2NFY2RBQ1RWQVhtNFFmdHJGSjdCRkpPUmU2bWQ1TWtwMGJHaEFjeTNaaDFXcnRKVjdUcW5aQnNTMXBNNzdhYjhMT20wN1YxTExkaWwyRlpPS040RVpES3cwdFJjQSt3UGo2cXdMZ01Kbkt2TTdBakhPM3Nzd2tKQWJLbFQrdW9DSHJYL1BnTzVteUI2UnEyajhiUk9MbXBheFpvek5vSm9SN1hPMEFLell4aHJJcTlsbjRnTG5sUnI5T0d1UWR6RC9yay9MQWlwRjVyZ2VhRjlqK1czWEpVVWk3R1hVd20rTUIzM2dHMDBRMzl5TmMvRDVqMXZXYmhhazl4SngxdEtpNFBxN0g4Z0tBWjBPNm1kSE53WnRPZkpKd09Heks3eTU0aXFLT0NITnN5ZlJ6TFZVd1lBRWorVVNBRmFBeDdQS0lPSG00RFVtVHR2cmxkTEZHRmRybmJLeHJ0VzJZcFRTV3FLd1RKYXZ3SGhIMDdWbWo3cGw3SDFsQXlTcE83YTFOVWc5Wk81UFJoNm9RK05INVg1eGRDS2ZIQjlrZVZEcGIreUdOeXdvVDJRRDhvcXl2UlFOSUN3aTJSbEJzaEg2Mnlqc2VsSVBsZW1sMjMyTlRXcFBMSERkM29XcTdtSW14aWV6NGJHdVhQVjFxcTVMT3cyN3AwcGtYSVM4Z2xrNWNOWU5jTzJhb2F4YW9ZSlFQQzdaaUZBVFFOcDVMcmR1YWRpb214SGtuNXNMR2hOeGxoOU95TUk5R2EwaHFpRUFGbWx0NEIwajFCL2FodnBZZVBQaXVIcFlzeDhHQy9xcGgzZkdSZHpaeEIwenMySFg4OGptOUM5V3lFakxtcXZrZ3ZjM2hiVExzQXV3UVhNSmQrYTVNUExRc2FZWDRJbzgyUGxNdzlEc1dTaDVuMU5qNXdhcjVJTHpSZ1Rwd0VIYmNaMVd0OHBYL0FWT2FOUnZ1U3ZMLzFObWhTZ0hIWjdhOHhvMFd6Wk1xbTlaUnR1MUF3Qm45dHRYOWkvZE5PcTArcHFxOXgvOW4vTnpGODRmVlZlaG9hd3I1eG1EWWhLQTBRN0JZSmpXcjNCY3pVZWQxODNlN0pvcDcySHAvYXdNbWoxWTBkaHh1RmpJVUIzZ1luQytDUmlzY0t3WUhpelVMSzVrREhXYmdkaFVFWnZuMStjTUUxNVBaS2ZjQjQ1UGZsMkhyNlRSbEwxTSs3amZ1NW05Q29GdjNNVnNLeXBkSU4xa1VueFdoNzIrb3dFRklZT2c3OVRCLysyUXhqM25UcnVudGxkMXNwZlB1L3NLMnZsM2JTdlhERkRoNk9rSlFUZlE2OENCSGo0MWJJaHFuQjNhNmlnanRJNGtLYnRZQU9uSWdoNWR4QTBicnZmbGZWT1JXaks5akFmM3FVN0JIT1cvbVEvWUpPNEllU1gzQUhsaUpSZHE0aE13alB1Q0UweUx0eG9xSVFZVEc2d0hmVm9MQTNlRjdMRGZEUDNxTzIrQXVMV0xHL3N2a0lJNHdjVGxMd2tyN1ZiN0ZvMlNCYi91SCt1R1FrYjFSbWdDRjRWK1RtRXZmRFRhdy95dGoxa2dSbndvTkVlNnBzMDFRanY5WXVSWXlmSWl5RURja3NIdmhnQzRzNDh2SWJRRXQ4UjB6d2Z4TURXSUYyYlMzTGJMOXJMcDltYmtKVHpuQ0Nid1BEbDJHTnFZT1NHcUFBYVFxVmxCNFFIUmxYOUZFQm5yeG13VWFwWVZiM0wrdTRjcTBxOHpxbkl4blVFakNxY2dnK0d2Wi9qTHV1NzYvdjhZS2hQMlRia0FQWEYzcjRjOXZibHNIZDZEbnREZmNwdVFRNkRLcW9HNjZVN0dpYkVJT0ZYRWNabm8wNkxTemo5Yi9sNWtqc1FWdUpsbG52Q3FxZzd1NWUzaHIxRjd1UVVMM2VHMm1xVlVTd3BuLzBabnFxTVFnV0NicjRBVjhqSEpyOVgvaEk3c2VkUUp5TTZCRFUxYUVEUDQ5ZHkvc2xVYU5oVW1ENFJnRHlKTmd2ZDZKOVZKK1FqcjZYN2F6NTl2bzFNTzB1TzVQT1FzcG91VU9MRGRzWDA2WTVBb2tRMVpwRmZMaGVoTHBzQnFNbFoxVkF3cFdwV3VUYWJFd2krM05mMXdmREpPWkE4aCtBOHVXS0RSZGlWUXNwK2Q4dStPaXVwRmI1M0xpbGhQVFU2Tjh2N0REcU4yLzFWY0ZJdHgxWVI2MmttSWwwaVBpOUtrazEwRFBIREczbE5nNVQxSGdTVDhsRFFPeWNQQmIxejhsQXdiVTRlQ3ZRcE0zYnJZbDlmRHZ2NmN0ZzNQWWQ5Z1Q1bG5kMjZ1TFV2aDF2N2NyaDFlZzYzQnZwVUo1WXVESktvZ1M3WmZzZ0Z6MUlsWEZNdmwxQm1OYXo1QWxzdHFKNW5GaCtMQytwVVhWQ242SUk2V2JWK1MzUmRiYXRnVXAyakZQZFZNbCtyc0ZHdFhMOWUyVDRaSGRpZVliQXNXR082WXVZdDliVnFkck1vM08rRGFHZEUwc2VhVUNaQ2RvVlBoc2Y5YnA5OXA5UDdnQTlCQkRsQzdqWnFPMVo3QTNtYXVidkEraDlnZlk3WjFxWEEydTVpWkxOOGN0bzFQUyt2QWcwZDk4N0ZGRHozMGpFVXRzK2Z6cm04VnRtUTFXUitvc3NaOXZVTlpLTmpha0NPbWMrUldaSFpsdGhUU2RsdEQvakdZZ2tEdnQ5aVdYUGRUT3VBV2ZzRksxLzJPaHBBRGF2V3hYWHFjRStQSHBOaGI0L1c3ZVBzbUs1cU9hUlNuSVI1TUZIVnIrejFPSFA0cXZjZHB1WjMzTTl1U0J5cGFKYlptY2IxSGN0V29heXBnQ01uckJ2K25Ua0djS2R5S3VoZ29RTUhMUjlZT2FBUUplSEdUakVrQis1aW1MZGdqL2xzRU0vbVFvazdxSk45Q0pUS2MzRk5iMUdqY1BDM3VnaDNoVHAzcEhZNldUMVNGalh1WlpjaFdYY3FwbFdmYTArZDU2cXVMZXduTDF2N2x2Yld2cVc5ZGZyUzNocm8wNHE4WUxFZDh2c0lsTjlIb1B6cEJNclhweFY1SVlIcXkyRmZYdzc3cHVld3o5ZW5YZkl5aEV2RllzNHNZRjRDN0puaFpTUVlUZlhqVmkweENFWkxDWWFLcGo3MG9BR3g5QmhkMUdpRHVsTDEybEYyWFdoWWpDRWpKcW0vYm1CV1VvdWtTY3ZDNWRqQmQwYXoyRTJtKzhJZ1VaZkRETUZ2WnJTUEtpZTVWVkFxMEN5Ly9kR0hQenJaS1IvQkQ0UkFGMEdxTVYxbnlSQ21DTGlMYjZsYnpvR2ZNcm9PaDlGUGFxeGpuR1pkaE0vQWNzZnB1bGZKMXMyWlFtVm9ITE1QaFVWcUdoNzZveTZ0TXU5QUhtVkd5RVFqYktMdzhoTElsdkxvWEpMVUh3Nmh0K3RPSjE4dnJ6L1laMlpWcnl6S1dhMlV3aXNQYTI0d2oxNWpEWkxMOHdaZ0xEU0t1Q2JOUEoyUVpObEhuTjJscDdXaW5oTkZoM1NHMHJ6Z285WWdia0J5SnVFc1VuQkNucUp0ZUtSc1dEc1VoV0dscnFmMTFBWkdpVU5nb0Zuc1l4cnBiVUVReTBqQ3VWZitWVEVxNkpVaVR5aUFsUEt4RkFQNml1ZCtaZW9jVDZnbFJRS1FJZit0eEJGTmtKcFlUVVk5RW9qM1VDZTJJcU5GUGNJbFJtY1RDZEluVkF4NG1EcmFISnhMT3kxNFdnUFJFSUZ2OVZOMFpTTVA0SGlQdVk5NDUrZU9PZHRwUElMN2NCR05tVDltV0VicnVUMHdYc09rOENieUttS0YvSjRLcWNtRDhQS1RETEliZFV6K29RRzZhd2oxUEFreW0vc3J4OUx2eDhHQUttejMwMTlqNWk3MUVFQXcrM01GdWtWM2prK2U1MElHRGFpdDNKVlBWZENrVXRGSFBxWW5SRVM5ZThjdDNldmJQbW5YYXZTdjFuTGpjdWlRZjVtcURjNFpDS1lwY2RXNUZnUTlyRVJJU0VmaDBrcVh2RllacEZPOFdIbzh1SWNFcm9lZlhYaTJ1a2JLQ1pRTHBFamhVRENuejJ5YmVqWnVSSDNtM0VLMzUvU1pjQXNaRzhwVGp2eGJkeGR6Z1B3c2d6Z1VPdE81dXBaSEw0K3RvWWw5VzhlV2gyV2xFcmw2WDNrZXk2c0RiTzM2UlBJZnhvS1ZuOHR6SDhIZnN6ekZ2SklNdmN2bGJjYlNzOVM1cEFkOXVIZGVwU21wT2ozbEhHM1gzUHVnL0hRR1RzMnN4VStXaTIxd0xsblNZeTIrcE5kYVBLTUNPd08zRWVJTW5vMzdWMHRGd3BPRCtubGMzM093ZjBPVnVCc0FFYW93MHNPeVZIWlhOcW42OHF6OHlUMWR6Mk9xR0VKcGpXU3oyVFhyMWNIbU5CK3FDZ3FscSszMVVQV2FIa1N6QUhETjQrVGRxdEpCYk5lQkVNMTB2U0YwOXFCSk1xYVI3UHNVY2NSQWpPVERnQS9EaGVvN1B1UXNnWVVET0VJVlZ5Uy9OTU1rOG5QYzdYdDZrOUxHTTBVSThsLzdhcXBFN1NKRDN5dy9RL1ZmWnJKVTd2VXNoRTFPWExLZ2ZOOVVoS2lrZVRBMmxKWWZrSnNQMmsxbG4xbnJBR05iaUpxM3laUWtXNllpRnhFTW1RN1dFd0FCeDNFWXArV1ZVelFaMS96ZUl6ZmIzTTA3NVdhcnU3bHl1eVRiYmpkWGRmT1QzQ0xBQ2lQaWlLUi91MHQvM1JRQ0xObk51K1htWGU2R2VOZFJlb0VmVHRKYnNGRDNQY2hYTTlrcjZhcFdmZzRNNjFtY05PcjFoa0JLWmo2c1VBb1lKSWpOZXpEZlBQckdBelA3Nzd2Mnl0R3NZUStGQmM3K0lkUkFsSjdiWW9FMis1WWl6dldzcVpyZ3JpK2RwNEx6S2o3dDl6K2dudDJ5QlNrU1RFeHNsemlsdzhBc3FKQnhlbjhjMWliREs4TE42cFJYRWRDZ2wwc29JdVZsWmRPZnhqeklYcTdycVhsNWtZNi9aQUxBbzk0YkJsUmt0ZEJUMDNzdmM1RWFjd0pHSFh3Q1dCVHR4RndCUTFYZ0poYmRQcjRuais2NTJSRWM0eTRRVmJkSHdEajI2WnZhQXlDNXV1T1YxNFVyTlNRRVdlYWkzaWthNVpIUnp1K0gzdW1lNStYL2VXY3cvaVlzNmdGcC9ZM2hQVGZocWVkdHVuLzV6ZTFCeFdLRi9veG9LL2ZvTysvZ2FUY0pWd2hmOE1OL3VLNklBQjA3Sk95RS9OdVpmYi8rNlJ0M0ZrTjVMQVhzL0dQS2FLSU9vbHBKbVFXUTlvZHV5aVAzcnRkRnRZZXcwWGFUWi9VUS9rR3QzSWxWMElOWEtUV1JoNXZWc0VCM2Jjd3FiQzlsOHkxa3ZBLy9JVFJWdFh2b0RhV042UGFFajU2SXdWS2dWbldwVGpIWTN4dlNtcHRaVC9rVnBtbndwaHRQLyt1Uk8xWTk5clpiVHJ0STlXbUh2aWFreTFKSVg4U2QyUlByTWZIWmQ5LzZ6aSthazE3ZmZUcXRIeUxhZy9hT2FkN3M1U0F2SlZ5WkhralM3QU9KQ292cFF4d3BKeDFJcnFXblZwUHZBUDNpT2xOcnkvSkhnZUk1L3JpMlR2NTFoalJZMzFXaDR1MC8vVDF2WFhuM1U5ZGU0VjVzNVF0NGtJQzE5OGYzb3hwRHk0S0ladWFJZDlucGxJY3VwV01aUG1iVXptQmplY05oR2dlVUIrVlorcEZhT0NqTVNyalpJWjdNeUsyb1JidGJhR1lhTmszSFdZU21TNlBObUxPRXpXNE96U2hDRmcyaUN5dWVJb3dlWlM2YStXL0JEU29yNW93L0YxNHhLY2RQSC9MZzE0K2ROMkJHeGZndGI4SHBDWGJGc28zSlRuVkZyK1V1OHlmenNGcHRlRy94ZTJ4NVdRbGZzMEFRWEZ2bWNCaVdaVjZ6T2JIbHRQWmNCL3RsYkVlRFU5Tnpsczlvd3FKd1lURzhsaFh6c252d2QrU2VtNHVSZlBqVHVrRDMvdlZYWUpaM1kxZzA3eW5tM2Z5bUZScG1WNTlnSEJpNHQrZmI5a2pldkFjQzR4SDB5dWluYjJJUTVudHVQdjNyRDhwLzkzMXhlUzY1UUs1c2Ezemg4cHYxYXZWMVFnbEduTDBlS0VHUXp6MzkvWS84eDBQcEg4eDU5VVZXNFJUbjVBajBvQ1BOd2M3Yk1pcERiZ3QxekZ1NG0zZHpNUytmZDlPTjhuZnVtOVpUUFRQUGV1WjlwNzFKemJybi9URlV2dm5JSDRkNmlIei92eWxVVFpyTFIzazYxcDZMUUZXNHFQZlprdFJYMEJPVDlqSDFlN3FFTEUvdUVVcHc4K21MTHJqdWk4OHZQSHphVFZKT0JENWR4N20rZTF3NnJEdk83RWhrMitpQnU1bkZRRnBIN0hRM2c5UnV2aHJEVVIxRGpLYXFQQmo0T21LMEdPdm53NmZsNlQxbXlPNTVRdHh0MEhUeTNIUHpUVGZMbUlQcTMvaWg2b3YvMnhrdDNuVFlqQlpCRGFUNFpjSHBOa25WZTl6VlJKMjJJOXNiKzdROVhoKzB6MytoWndZTXJySDJUdzdXRk1INFU5NFZPUTRaWEVJaGQ3WHgrSXFjWEowc3paSHkzdzUrNjY3YVNyM0xDanZhZXhELzRlY3hEUTJxa2hWSGxDNENUMldsT0llcU1VTjZ2TnN4VmoyUzZrSzJJSE1HUHhpV3labERxVjd5ckd4U1o2K2N3K2ZsM0RPMWtPOEV6aWxqdXo4N1pHYS9oVWpVcXo4RXpuV2lQcnJsSEpwV2wveDNKaUFTNVd4enBoMHJBMmlxMEpZR1ZnRjFkWTJaYk0zcXVuTXBjWGJIMXBwNjZLcjdiYUZjYXd5V1l1QThBbnkwRk1RendZdDhnT1pBN3FEWllPek1SbGVJaFFxc0JwNFpMWjByNy90NjNsaWxtclM4aWxrQ1BkM01ucURFczJkeC9ST2wxejk0L2N0aVFvWUtOeDBaQkZJZU9STmVZR2JkRlZwY2MrWGFqT0U4RGk1a2xHNE5nMWo0TWFlNTQ1UXBRcFBYaFNxdkk3L1pOMjBpQWgxaHdIcG5QZlh6UWIvY3M0ZkRVTG9NQ1MwRkFZUmQwWE5HcDl3YWQvN1FFM1p2TFZzVEtoOEJQUm1PZGMzSm9wazNhSUVyL0FDRVpuVkliL29PZGNTeGlGWTY2enJOWUNZTzBzczE0NEsyODE2QjRIekI1VkpBYy95MGE0cm1WY0paYmtaeGNHdDgvWmlLV3JTQ2NEZWw5UlVOQmp4VjY1dFdYek1iOTY5UjlabW0yMFJjeW1tSTY4YzY4VnY0b091Y2FaWDV2SGdWR2txbW1FRXFab3NLdHlVNzZGYmVHaGFWMmk0b0lrMDNOcEdmWFJWTy8vcGt2WksrQXRJTjBsU3dOVEtUTHArZnB0K0llOFIvczBMaEIrWlR4eG55VUpQZXVVZVB3clNSdjJlTW5XSCt1MUVKZHAzQjVJSnUzSjBYUHF0NGlSYVRXTWtHdXF5TXNvOGx6and4V2twV1pXOE1iQ2YxUFdFenlrTUtNYmRVcUp0YkROUG9NSU1IL3pvc05IeTQ4M1M2Ry9HaVZES3p4SExZRTdzY3d1elhFWjdjNmVjYXdWYStiMGZLajZoN0p4NVBuL2llODBFVndrQkRKc203WGZybDlzOUxyY05lQlNibC8zWEtoQ2wraUtkWkN1ejFwejNJcDkyRFBkZjQyL1F0OXJzUXhFZkNhVWtQTTJvRnZiSDdYK3ljWHVwK1grMVV5emtyeVFkSElGVlFFVXpyeno0clU3N0xZRnJtdHNUZXhPZFBHNHpWTXd5TytYMmZEbXRWN1dMMUY5WlF2RVR1b2M4S2RoSTlmU0lxaEFvVzZIUzBoZFozb1l2R052dlI4Mk5CRU9sOFhuS2NzekVtQVpRcytGTkdHL0xnOWp5OHZXSml6TzV0b1V4M250MGM0QjZNTE42TWFrZEV2U1VnNlA3RENRMnNUUVlZT2Zqa0VyYThEejZkOEtEc2JOVVhWMnRjczFlTlY2Q1FtdFczZFhXZGp1d2dUdXkrcWZkMElkYVVKeXJxRU5BQlVFbG1XYkFscVdpM3U4V0UyRVB6N3lXemRGZjZrU0NvVjR0L0ZzRGdTcXd5WGNRdmsrZjFHamNjU0VnMStkM1NnS3N1b1kwb2lRUkphQnBDVW1PbE9nWjZYUWRibURPbXhEaFlPZFp1OXJxNW1neC9JUlp0a3lFWWhHTnRacDlJSU96TE5hQkxiSEZibW9iUnVrakdhRkR1SXF5Y1prNDhpMlkrS0djdGVpbm1STFJJOEZwcDBudCtwWkVtUUpHYWhqbytzeGk0bWU0TGxXcGJ4TzVKK1A2UmQ5SkFFdDBBN2RXQTJvTllIMFRWQTNNcHJGVVBHdVdyQUhMY1ZCTFlvREJUZXFZeElTZDNzRGIrNmpHaUpEWVJPMG1hejFEMUs0dkdHSjZVZnQ0Z1hvRThRdkE2d0FqNjVkVTNKZG5mTjRwR3B3QUcrNGNZZTFWaDRTcmcrNzBlQ21Xd29rYnVFVjRMT2oyVUxmMDVJZnRsQ0EyZmxsME5DUXI2VjhLNU44dnZ1Unc4elFGU2FkUWRUWmdnc0xEOHM3cHJaQ1RVSEh2cHExWlJ6OUNRQm1VZmhEZmxrT28yWHpWRGhsb2xIMWsySk10R2Y1WTQyRmdPVEN6MW1xQjlYbS9TZENpbGpvRTlrVjRpQTFsdS82VnNuYitzNStFWW5jSGhKYU9yY014aVNJU0trSXU5eDk4SWRHVDRwWWJDR3hBbWRGUEhZbkNDOTBmWUpqd2RXdStlOWdKcWVlbjI2T1dDZXFNOGpmWERuN291Tnl3YXdNZ2lodlY2aHB0M3k3RDhyNUM5L001Wk5OT0lOcFovTnpVVnJkZUljb3MxWmt5cStsZGRUN0JpOHNvL3RhRDFrS29wMFlXRjlvUUc1UTdwZHpjblZvOHM3bTBkaTVvV0VOdklsNE5Kb1R4OElIazZUODJUV0QrTlZFUG4zYWdzVmc1RXhQVWdoSGxOOVVPSlREQjlTSGtUbWlyVXpNTGVJNWczRW9abDREN1RIUjZma2NyWUoxRmVJNnNGM3M3b0JDM1ByWC9vcHJBWG5WTnpuVk56bllQemFwa0NaSmQ5RkFZR3NhNVJqVnhCc1JVay9Ba0xpcVJtN2Y2dDBHTVRVWHh3dk1qbG1JOXRGY1c1MW5TamJYekpKOHBlbHhtSEkvMFNPYnpzcmEyMDZDbFRpTkJkZmdlaStyMi9yanZVMnFEY21UcGh1YVFaQWpENXQzQkdCTSszSE9iRDBaaDhzUk96KzFkMWFNbnc0VXhKRHYrcVh1NC9Za2w4Sk1GMy8xNXZNelpOQUtseFpNalJlbHBvOFVqeTRmcDhKOTJleERxeUU4TU5mVWNGVzBER3BYdndnSUc0R1Q0dzJLdDhSVGh5b0p2dWhTTDlWcmNLaU5ISFVpdXVHeUUxU2kvOW5xRXFSbGFCN3VFeXFkWlBSQkRKcWhJMWRjUnhsY2p0dmlEd25nYWpVUGRVcW94NlJyMjhGOWdJWEROSmVkdkRIMzBZZ2UxY3RySWR0TllSazhmRXpPUmpkNEI0YU0wU3pxb2JjSFpMdER3clNvUDVhSWxwdGRkcjkvNmVZdFJSSmU0MDVjanZ3ZWFjbXVjOC85T25ZdWQyU3FqcldiYnY3bEZXZ1hKNWtxMU5QNmE4eHNrS3E5TjhIZGFaMHc0eXdUUnIzRHF0WFFiNTlGZmtlK0hQVlljTWRSK0RIT1dEbHhkRFBXenhaakMrNHpBckNYdWxzbVB0TEZjRlpsNXpteFJjdFNoeGRuS0JnQWhmOVNMby9aS0dORUUrdExrSXpDUW9nWG5KNERGcEJpV05Xc0F0Q2tlUGFWWi9SN0FCbzFCakdwQ0MyaEEzRWJSSFFSOU9ocXZZSUhZNWdQbVFtMTNJODJGQWo3M1k5SnVaOWdHUVhqdUsxZzNGNW1hcDNqUWJxY0Y4RG15a0J2UGczRXZIaU4yVlFCcWhsZ3hORzhJVWM1Y0tka2dNRFU0TVRJWFo1ZUNnVjhzK0hNN1l4aXdQTnhzc3JiWXJZYnRJdStFYUJQUnJ0VDNUeGpOQ0ViZlpibU1UTUw5c2JLNk56Y0ZVeFpWN2hUWVZlTWRvNTlDTTdSenF0ck5kbFpZcUN2bU0vSmZRbW5qU3pzcVFqUjkrVVVHTUFsVmpscktCM1A3MkROT0RPNm12YXo3c1NRckIxR29sOXJLT2lWbmFRMXpnSlBVcVpHRXMzVXJ0U2JYZ3dKbTlDUmJ2L1g3MnFURDlXLy9sWUJRY1B5RWJDYXFqOUpERVcwNHhkeVAwb1VmNEJBWFhtcU9JbXR4MlBWV29sbk1NVm5lRjdxcll2MmNIVnNoRHJkNEhXTDNYZW9ndUFQQkNUMTJCdkw2VFdEYnR2cTZwY3ljUkVJN2JySm1Fb3VnVmhZM1N5ZnQ0QkZlcHhmL0hKZVFnYVA1TVFoRjRvaWhtNS84ano3TjdRNHNxOVQ5ZWdkRnVCZktxQXNkVzVmLzBnMG0rNEduYlFSRkxqUmJEMElUZzlJSERUZTNEZEs4MHZJdlRjVWhuTDFMUXFxNmExek0xNzZkaWg1RHVFWmloVDhGYm1wRG9mek9xTGNSNGpYNEx5UWlrQ0wycDAvUkRvY1kweW1iRkhMQjg1S1M1RnpVNWg4andNaVhMeitNV2tSb28ySktaMk5Gb1pKV3ZNNGZCaVpFaUYxNkRpSldzVW8wUmdkU1JxSjdYSm9UcjBqemppYlBVemxyNFBteDI0Q2JQb3J6bG4ySWIzOUcydzRhUU02MzBTTlRmSTdXT3JnOFBydUNqR3FVd1FaZzBDZ2JDRlJYZ2dYem9BRm9VQzRHUkQrWWJra21xTmVmbjh1Vm9tcnNkcmdQazhBV2xnZlQxOUtndXRGbENGTk1LNGxsUDRVaWZmY2pnU1AvN3N6UENrWDY5bHo5Wi9MTHN5Y0xadVJNNi9pYktIMVJCczQ3RG9QeXZGWE95Y0diZUJMNXNzWEVpeW9MMFpxMmR0SmpVYjNGbHpERDFXK0Nqa2NoOTNrMzQwTHowVmV6VzZoZGg3LzBmRjJGZjNzTndMajR1djdud2Z3SzcrWFpmS0lQdU4ycFVwd0hQVnJoUWFUU3dBOTJ1TEdpaU04eHlCcFRyeGtaSHo3RVJ3ejB5T0szUGs1aFBLWVlGaXNEcDNkTGFBY2NpRG1NdXA1L3l1US9TKzFOdEJIMUMwR1I2ZFlvRmxLRjN4eEs5V3I1TU1jN29GSDJpZW00SFNoR0JjUmxRaUtYUUxvYmJSaHVSeFdlclNIcWhVanZPUVVodEs1U05xS0RMZW9MR0NGbEd0Tk9VUHM3d0t0VTFXSkhIOUJibzBJMytPdUlpN2J5dkIweGUrVnlkSUlCaSt1LzJ6Zy9NRXpkWTBVc3hpWE9wM3ZCNEJnNWFrY2JrNlNkaUM4cmdRZ3g3QkM0YUF0TTgydUVEOC9NY3RkSklDdEwvb2pUYTRQeDgzV0ptZEtqTlpuQ3dWVnhuQjRia3RoaS8ybUw4YW90NVF3OTJrem81S2xWQ20zM1hIeVJ1Zm0rYmxmaGJtOTFUSmNGVTEySG5zaDIwTXRud2FYY0NHTDNBakNUZ1FXOHNFVUhBRlVLU1laaWxDLzdVeG1sVjJ5WnhxVmg5WnBRZ241dHJ0dTl5Y1dqdXFNRzdaOVJzQkthUUNLZzljTHFJME5NUXMzcXNsVnhNQjlJeWJFMGl3Y012M0dFLzFoMGFPYkRDQTdWVmNqWkxtU0dGai9CWCtZVm4vRXJxRXN3aUtnNVV2QmhxREFrWXFKbHR1NmZnaTFPL0lkSVgxQVFNb0FWMUFaQzVWSGFnOFZEUTIzWGtFdXVuaEJpSXMwL0wwcUNsZDZXTGJWVXBtSnBTQmtPSXI2dUFJRlp0U1p4OUw2SHpnaDBHTmJadkMzanB0anZOS0VNU0F2bVJVR08vNWJBUW1iSEozWjI5aWl4aDFvY1lpMGhSRU1ueGRPRWFpWnBGaEVYc1Z6SWRaSjJaYVhRRTZERkFkRDF6S0dxNzJCLzF0c1lGekpBbEhGL05mUkxMemMrSmJPYmpHS0V4Y3UvNnNBMmdCbFpWcVpkV2ozVW9rbzZkZ0gybFRpZ3lzQ0lEODJHdVUvbFZmWmNvcGgyUjVKeis2UXNmVVJ1SUxsaWt4WHYvNllHYUM0a1RPMlBNdGhxTWpzaVF2eGlaOVJ6VzNLSmdkRm1RVngyWTZaREtrTTJoc2E0RFVvRlpOZUpCekR4T2NmcEtyakt1bkZMcmlSMytzMkdWc1Z2NUdsMGh2ZEluVThwMlZySjRwelFjVmJaMHNZRzFLaGlNcnFuSUdac2UrWkpybzZ6eXR5bXlBaTJCUnRYOFpqSHlnUHUrcDVGMU5kQUNRak5CaEEvMmZJN3UzRnE5a1RtKzdFdWdZZ3FTWWN4WXZjRHJLdEFmRi93QXkxb003S29oRlN4OUpYUTg3cjArOVRTMG9DZGx5VHFxZFcrcGRiUXhTZjRpYmoyQkFqUW9OM20yMWp1aXFYVGhLeUhLSkhjWnJxQTA0eDF5MW1oSnZFeW1YdmMrZXpCMGlTd3VWL2Vkdk1pVlNvNVVyRDB6eUhWQ29BU3QvYnU2OFJaYWhTTmdWRms1R0R0VFhRWWJPUmFkY3JQYVgrVmFkZTFHaFI5RVorOFAyeFlKS3dUQ21xZEQyTUpwa1gwWFFod2JPbVJEQXlwUjVUM25uVXV2VWRqUGNSbEVsVFU1bzdrNmdKT3g3QnRoTDRRV3QyNThyeXdRSWlZWjBrbjFoZHZnRlJUUWRRMHFucDVoODdQRm9BazhsbnVtOVBGdHRJSks3NE80RDMxNHBoVU5GN0k5Ymt1anhlT1g0NlNRU1lXbjJ4clM2T1NWRmluN2VsK0dOU1hJNld1bnhjT29qbk5FRkE2Vno2SGZRcWpXY2FpWUdUbnorR0FHaGRBNDJwNHlTQ3JBdUJEWlhVbjZRbGNVRU0xT2J5WHRQcVdTVy8vOUUxLy82N2F2RWFJWVArcUI3bzZ2MUczQXdrZ2xoc3pTYWpNc1VOMDh1VnV5akwrU3lQelVPQVdPREVRR3V1MVJacVNveEIvN1dWeCs1bWR4ZGpEUkl2d3FQZzY5SzdMSHErYzhXMzBiTlpsVUphVGJiS0xaTnh2ZllyOTFENG9Cb1NlSkxzREIxZ3J4SFkvRzROSThwVTdsZ2Q4Zzl2Y0Rqc1ZqN1RsN2pLMHg0bDN4T1BDK2swd2M0WGkyRy92dHVPWUtuTnYvR3VvYUM3S0hlNDBEd0xDMlhMZ3J5ZjJPeElLbWhRcU1aZk8zUFB3dW5QT2pUdllQTVRGcnlSUkozK3FXTEE5RHVqL2hOSXNKUzR1aVFBZnFBRmFZZDdielB3a1UydkE3TGhpZVBza2VRVXlpbDFOcWgybnFzZGM4NlRXS2UzUlBUZjlETi95eFArQWVPelRWbG5iWE16Wk50ek1FNDR4UXptNFlsWkpKaXo0cVpNNnozVFZEbkdQRnJnbTVVS0dNOXJOYllqYVlEdzdjQ0VPNlhiWjlrd0pSWEtJVXlLdEFLQ09iRmZ6b0p3OUU1VThma05kamtKN0VmVVNCQ1I2eFhBMHZLTnNkejFkdkF5YllYdS9NQm1PYS9rVUZqejFMekVuTUx0cmpJb3o3MUV2MThrQllMaWovMGM5MjFLMU5zOGFhTk42V2szWWlmV2VnY3hGT1JNY05SR2hTR1BuVHhYcHNMWlROQWJHYml6RDdMbGJEcEJucDRRWHMyeGxxenRuK0Izb3ZkNC9FY0RLTE5NbzJIaTVsTDJmbFAzNVR1Wnh5YmZtNWh4OS8vbkladGJVcngzUWswWE5xK1A3c3Q3MWxQRGR3bCtUTzZXVy9pWFQzVjVNajdKR2VUZE9RRkpzc0Z2MU5aajZmQittM0l6K3RsdVdNcG5FT1ZLc1MzaXdNVGxGMFZRcGxzbTlpYlRnRUxnWHhPY1Y5bzBZOGpsYWFHQ2Q3SXRTRHM1M1VXd0d0N1hWeGZqRWtmOVlsVWkwVHJPNzExdXVpTFIvY1hWUDhQanRrbC9mZlUyc251cEhTa0J6UnpEellvU0ZBKytaT1FmOU1SZ29FNEtEQjF5SXUvUmtrRFUxSlhEUktYeFo5K2VRSEl3MXY3Y0dyODlHQVdWeFdaU0VubTZhYUE2aWN0OEU4SkhGemtRYzRTS1J2Vk9tYlBla2pTeC8xbEJscm1SKzVJWFpsQ3FOOVFQUFlYT1dCYXNPRHNNNUlmQ3dST3hwekNJR0N6V3NlY2k2MDR2R2hubHArSENrNVV6ajFNc3RkZERoTXZPOTh3c0xkZUNkNTkwVmxmYjNGODVDSmZQRUtSdnFVSVY3cklnMnRkWGlGYWczbXpqVXpSNnNPMHo4MnBpQlhnTEtna3NCUUxVUXhRblhuVHZOSytoNTFuUE1DWVVyVThjWnpvS1d3T0Q4VVZjQnVLbGRhNEdha1k2OFg2RXd4VHB2MDhGUmwxYnRuMjFGTnVuaUZTeUNWK3JKTlRNZVlMZEF2dTF5WFpRU1dTbE9jRHVKd2hGUmNsdHhUVmNJUWdLOWR6bTNBZFZtWWZuazRHRllEM2YwKzF0eU1ZRTN1d09Ec0NvL1lQckdnY3NteFlTcTY4amt3cHBFTzg1RVlCeit2M0pJZ0tKTlh2bHJ0Zkw3a2RZalVyeGxXNUswQno5YW05a2lEWFprM0tjS1huOGNyUE9ISU5VWFlUTzM3aUphM2VocHUwYWpkTWtuaDA1bkQrVk1tRmt6R01ITlRYZXdQK3F4dFVEN29kOVNPNlB3NVVRVmoyU3JrMjB2VWNkUkhpSjlzV1hnWllSUzR3MmtpWW5qdzdTbkFsa2kxUE1RejFNNjZnSy9sM0hldnZ5eTR3QUFTVGgrd285QUZTNFBUN2RscTkrekNwY0ZxOHFkckdjbEhIMTRpVTU0ejQwRy9uZmIxZXIzQ1p3ZjBVMkJyMjVxSGhaeXU0RDVLV2Q3RitITlo5a09FLzdId3JTWTNUMVdzY213cXJWMXZYUTRHcUF5ZUx3b1AreHFqRVUwa3BPaGhGelBrWU9EU0EzVDBvTVlJT2VTN2g0QW5QY1NKcU5iSk1Od3VNU3o3Zk5MZEFiTGI4SDhhMGlYT1MvVEFQcjlzb3NZTmZITmhQaUNrWjEzUkFqNkdYRVpJQTZqOEtZaEdoNVlHVzN6YTZSKzVHWTZZVTRyR05IQ1MxMmkzOEZOdkQ3cGVIWmpXZ3dNckNKdzRnT0N0SGllUVZHQkFTeVdZM1pxSklwUHpVQVlKTWtxM0xrKzFNVXZrcGNLVVV0WHI4dEMrV1ZNTTVObVozV0dTWExOOFlBSVFjRXNRL2NpQjZHei9lOVRhUUhRVVcydDVNU2VmZzJKenlXSkN1NWNEbEcycHpYZlRZa3RpOUFud2RpVDFKd2RMMmlPYTlYMitudkwzb29lQ1JmS0xhQURPZWZmQ0hCRXhFYmhBUVlHdlR3aUhnMWxSekRzR0xtSmVQckpadnJiSmNNbXNLUzZ4RkpmTm11SXlnaWZ2RHdxNVBaY1RWaTR1WHlaUGxJcU1scis0eTRVK1EvZktVTERkYXhBYWllM1MwRWc3NzAvVXFiVUtqYlNHNlNjQUNOeEFkeS9wSGZFaEk5SnJBSjUzeG96RExxbmszU29iZjdldzdCVHRnbnYyOURVcmM2OTE4aDdyNUQwK1lRS3RrNlV2a09mRTdUa2o5NW1XNC9xa3Q3a2Yvb1Jycm12bnlUcWpGUWZtN3Z1cjBIR3VtVU5zbzdVdGRRMXdjMW00bWtiWnpKNk90WlpBM1dMSEFMU1dOME5Bc2VYVjRLdTh1bDYxWHVVMVhLODVvamdFREZwMXNWRHlaaFFrQXNWZGdJMW15TGdrWXRPakxTL2VZWHQ3QTMxeWdXMVhENUlZWk0vRVBXVElhQm80b2lxSEpnUFp1empVWmk2NU1IZ3hyaTVmaDFXUHJIZmJxcjhWdjdIQm9uQUFidldoUVE0QXhBZXBiVWM5cTErQWlXdnduNEk3L2ZIOGFsemM3VzlaRnF5eE5Yd0tPaXBWOWxMM0hhNytpNHFVbXEyTDhyU2N4eTFIMkpkL3VNOEVaT1Nhb1lsaVcxZW4rczNhUEFMWFVwbmZzYkZvV0NHbkovTElUV1Ztc0EzbDBRUjB0VTF1WWZ4d2xQU3hZRllMM090cENvWG1OSVZDWTlyNy92dDZOUWkyQW83SUJRUDFFdTh4TlF0NXQ4OUN5NFhtdU4yMkZWZDRJdHZEd29YaHFKY2pLeDNiWnR0Z1FLTStTaUxvSGg0QnpNQ3hDTHFkUjV3RWlBY1FsTHZVN2lrb1AvNXRZU0hmaDZzZlBpWlgyLzBlZi9ydGZ1VlFINVQvRktreWxSOUFtWHB3WnpLVE1oWGZRZG5oa29MTS9RaFpaejA1VjlFeFZKbm9BeGsyK3lScnR0L3ZGSFBCSHMwMTltZ3UyS081Rkp2djl3Ti8wdThHcHBqbXVrR1ZZMzk0SGZiQnN2RFd4TkE5YmswMFdBOGVVVTRjN3FBOTJSdHZGOW9vbC8xZjZ6Yzc5UnZKWnFkOXN4M2YrUHhtZXlKVXpFU0RBVklveThjVHRTVmxJZWVOOVJzdWpVRTZONVllZ1ZVWWpicjNlck1ISTFBbWtNTW5MRzQwSTIvc2ZDcFB4MW50aUlXTmliSmZWZkVibmpJN1FkL0Y5dFg1dUNYVXlHaFRvWXVycE5OdGExalFOM3Nib0dKcGJIL3BPYXI2c0xzekJuU25QRjFEOThDQ2dMZUlra25iSGQ2dVBrUGxKeWZybmNJOUwrbTR5Q3dSTExJSTk3eFF3Wjk3b0x4SHkvcy9YU0V6QUJzcGhPYldZZmlvWE0wQ1JoMUpWamlHNTFRaFp0bVIySEd3blBLKzZlRU9CWVVxM29VbkNsVGhmNUozcWhKdmtEMXFmYkRKTHczV3VUMmVmRjlvMGZWT0I4Y1FXa3MycXFVbjJTMklwSFJ6Z2s2QnlxWExOQ0c0dU0yS05YVllwdENVQ2hVclc0aDFMRzlWRmRQS3F6aE5tVmMxSGRKTFdMVGh6VzFrNmFzQTAxTEw0dzBhdUtwS2VsbFIxd3JSb1V0clpCOXUxdG9ZdnFid2JhelJhN3NacGJucHZTVHh4VFE2Qm9nOU9KSzJIdnRVamhFQXF0dkF1VDNpcW56OVlWMytPa0dQM3ZXVkovOGJWalYzMjlrTU5OSTlFTWU0Smg5T0tnMVhDNDBJVFVSdm1pNjE4dTdWYzRFbE9NbUxERklDT0ZwVWQ4TUZjQlhVK3JuZkJWc0p5c21WaG5uVE5wQjI5RUlySW9STlY4bFVXaEMvb21iNEdWVVdaTXJWNlI3OUR3V0JoaTk1Tm9HWFY5MHFFWWJMRWNTTTFmRTFsRFNUb2Z4QXRXV3R2SmI5S2tJVGd0NEtGWVI5Y1VabHhPWmc4OGdpcTFBeXBsWUZSK1dmRFRxYXNYTjJiMC9YczQ4bXprSWIxZ3YvSHJkTlhIc1I0WjF4ZGJGc042MHVVdWdDcWlZR0tvVW1nOWU0K0M3R2tKQVBmbnROVWQwUEJqQ2JSZlN6dUNjOFNSVXlLdE1KM2hVRzJmVEd1eEdiMkF3ZU1xb1RXOTI3SXpCYUNzNk1UVDJ4VXRmZzluWGMrOEx5Z1BNMG02SlhHT09WeUVQcEZldzAyUjJ4Z2xid05MS0w0SmdNQlhpRHIyMnE5WjYzK3lxSEZRenFjckgrWEZpdC9RdXF0WDgranY2SU1jbDZBTTE1UVNmN1NhVGhJT3UwYlpUakJFK1VlVDJiU3BUMGhtYkdoRlRTYVY2ZVRLeUg0WlVRd3dzcVIxa1pkYnA3TVFOcXpXSXFoV3B3azF5QXk3Zmt5WVoyMG1mcm5neHcvaWJhWEMxWFNqbWZpaVFjYks2MEtxaGlKU2xETFdPS1NMWTBLSE9XeE9yWmY1QWh6YWpWemVzdUlSSk1VUFB0SEhQN0UwWjlDVkdCS1JwbVZqNzEwakxpUFdsNktmVFVqalhVTk1FZ3c1YW5XK3MwK2k5L3AxUGU2R2YzeEpXeXZ0K3FTZ1pBc2twMGp2QWM3V1h2cU5tR0p5WFdzREY0K0o0MExJSkFZNjNhTWQzZ2cvVkFlQTk4SitOVEEyVmJpLzRHbjEvTGFWSlFjNGNnZFNaNHA0Vi9ORzRvTEgvWkgrbmFoWC9VNzlaV09ad09ocWhtazJoVWd4MUNBdnBKNTJjSk0zUllPVXlxTlpyTVI5L1RJSDBMU0JzalJPZGVBOWdVV0FhZnVoUktiajBobFEwQ0ZaWlJkbHZDVlo1QUppbTF1aUZRRVRTSVlzelg2SVFkSm5GWXpuVTZRSmt4VGtkVThlMEl1R1NJZnMwSWVKTHdoc0NDanlBYUJ2NnRIdE01VE5PdWhwbk9SdlRBZGdPdTM1MDlRTGdwTC90TXJDUmpSK0NtZ0RwTjZpTWRjZG1ERWgzSTVZaWdDN3FuUTlZejJMNWJGMEtxRVlqSE1xL21ScVRCT0NKOWdLekFqU1RUc2pFZ295OUVQRVRSUFRkUzEwdzkrdDN4QkFaMmlVUFdEY3ZiV2doelk0Tit1bHpzeEtBdjd3NjZoYnB4RUZRMllvcHhzMVkyaTI2OEFrL3BXYVEveG9xMVZxZ3JVRlkrODVDS2JERU4xUHF5eTV0a1A2OU1Ncjc4VlkxVXFrWVJkSVh3blEyVHcwSDBLd3hFditLZGRGRExLaENLVXB4RWU3WFd3UlR6MU9GTTFrNUg4ZXJyc3NCTUo2U2Qza0NQazQycm05ZmZzU05sMmRkcDNLVDZiY3daUlZiTUxaRHNNZUd0R0NhdGFJMEg3MWhyM2FSYlVXdDhyeWVQZkxWU2lqUmVqbTFHeWZ5WnhqUFE4Y3c1bnYvMGJmU1dlbi9TQlZ0T3hJNEk3SndOSTBBNGxTNEVRREJMZU5VZzU1cXRJdkpwZnhvTGtPMkorOXpNWEZ3K0N0Sm5WRU9sTDhSQlRYZjRmRmFicUo3OU9xK010WWpXdHl3VWhqRnZZUC9pSXdwTTlYSUpKQjg1elJvV0xBMmVESHFtUU1ORkxsWS9ZMWdZLzdDaE1WeXh0MzNSb3ZHQWhOem5Yc0FVN3VtWURtOWNwM2xTaGJTdXFMT2ZzcE9WYkE2NHpGVFE3aU91WS9hbDBJQVlidzNLdjE2djRKalIrZzFMNVQ1VmdlZSthRmw0ME93TDd3ektvQktSM2l2TTlaMk9DNys3OTgxZWVYTzNlN09uOTgxOThtYVBlN083a3A3dWs4ZTczZU43cThjUEJnZ0Rsem9ybDM1aGNGZG1MRTBSWmtCeEhGVmFFenRodEtlbkpEWFBBdUV2TEdKamJLaDZDYzBhNnAzc3FrUXRiUU5ZMGx5ZzF1Nmo1WkdQSjhaZG0ydDNjRUhMcnc0ZTArUzhsUlQ1ek9sU1pDZEhYcXRzOXFPQmhZZERteUJTTGhwNDA4ZytKK09wQ1ZhYXlPV0ZUMVYyVnc2ZzcxRWNwSzZFV2tzUGIwcU90bnl4T3R1WGEzVEllK1hWT1czS0RsSXBNS3ZOVlFUYnhMaFNDYzhTemhqeWdpTEFydW1YSTNSMlVNdEFxbzNNa0s4Y0tXL3lHVlJIT0VIU1cxMTRHa0RaVTdZa05OQ2JXYUE5MHYvMlc2NzlvTmZ5a1RZdk1KeTA0Y2lxeHkxOS9OdlFnUHNTNSs2ZGc4bWZVVEJRK3NvbDdJKzZaL2MrSnR2ZFhnQWN2c3ZXVSsyQkVUa2tNNjJFU2VtV3BKSUhYbUpLWkl6a2poY1ROK1FBZ2tjNWJ1YzYzV0tyeWtSV1YzaVNYVTQxOHJRbE03dUlJdk5iNDZMMjFva0NVN3dPNGIyZE9DN3NwcnQ0SWtjS3hQV29JY1hxOVBqN1kyRDc0dzk3Nm9kbko1dDRmazJSN0w0Q0xkeGFLMUxDWGVHMHlxaHNicFkrOHF2ZVRUTng0cEdmaGtYU2ErQ2o3cWJRa25IaFlqVWwwTGFwNmFHdCt5a05XYTUrSjl2RE9aNm5tZmg5SXBhMTJTOFM4ODgxUnNDaXBRYVZJYVpRR0RpSUM1MWFQMFpvZnJqWmc1cmdFTTNqWmFBaDJTTWNzOGpwOTBEMEtIS1BJdGRUdEFDclVBVHlycDgxeGpOdERHeUUwRGhBYnNKT25pNGRzdldMVGo5c1czT3Y0V1dpSnNtS2lJT1dkamc0SU9iWERrN2pnZi81c1JsNVlLS0krTm5UMXNGVmdGaVBCdW9iN05nUEZhQkdsM0VLTzVzc0ZPNG1QWlB6cTFlYmxKczdPTGYwV2FRTVNibzdVYU9QSElaZnN4aElvZjlqem9IRGlxV0lnbUZJOUV5SUJvSndSTm16TkJOdVZjeTJPZ29CWFdDaC9tQnk3ZjlSUTdoWTRUNldCaWYyV2x3bFpjeHdtZVgvc2tyTjVNc3crMFZZaHV0Tlg0Q2IwOWJiN0laM292elNBR1MvdHl6SXJFS2pXcUVGVmxOamRzc1RWdW5zWkIyWHF2V2p4ZUdsR2RjQy9SbEp0YUdFRFN0UDFOMlF0QW1yUVRocFJJUUl6eGlEZFVHZFZSeEZyZjVseDFVRXVmSnBpemJhbjh3Wll5UkcyaWJrSkNlSFhLbmVjM0lPL01oZDc0cFdxUUJXN29GYnlHQkJJQm9XYVVyUk1yYnNNTFFNQ29KMVBJcGtncFdUQXpLNFQva3FYeTNyb3J3UWZ6c2NGZlhDSjM4ckRhZWlRTkcwT1d0RzBPTytxcjFiekhJQ1FIbnE2SldpWmZkUXVvQ2JaOFA1UFgwNndnN2lTeng4bmc4elJaUG9HUWc4WFpEVFdxNit5azJGTE8wdHI4VytZQUhsdnFicml1ZWw1eGFTVTVkTGhXdUF0VGJOMXFVM3ZnSVFUNk5PMXJ1VjhadE9wNHlsZWNoRmhaOExWV2RNdTcxZ2xla0ZUaXlETXdiY0hGaElrZVJFTzlINGtyTkltUlBhcUhIcmpESGYvZkozdFdVSldnQmpXN2dPL0NGTVBMaEFrRVlod1lWS0RXblNVWGs0bEpiYlpTRTRITVAwUDhzZXFvWllORDBPeW5BVDRRSkRKYU1aREdIcDB3YWg4UmxqU2xSR1lXNDE5Vks0dnF4djNBRFFnMDI4dzV0Tkd6Wkk1clgxRzJWaStCT2IwdFBONkdSYS9vV0hUTHh1Smw2VmlYZHNKaU9raFdob3R0R3VOcVRMekNiRmN2YVJzNnp1dG9VSlplMVhkelJVb2MvTWFrQzVUZitpY3FJQitRZ3dxUkUwSWlpUHZuRDBhTzJNOVVVNGhwN1Q2U3Q3MUZqaEsrRUJHN2pVVm55ZzJMbXdHSk4xb29pdTRWaDZqYThXY3ptOHlHYzNxUXpVekVpbmtPNHpRSS93UzBSbUREZWlMa0FBTzJzcys2WHo3Y2s5VFNNSGdPem5JV1NOTVNiTExCNFo2WGZEbDdQdFZCY3dxZnlPV3Jhckx1TXhkYWpoSU9SOXQyYnFwbkN2cTVKRmV5VXl3aXVMaVVCK0phRTVjWDRzOS82aTJUR1hRY3FxcysvRDJHVnIwaW0xRHgzKzBaRzR1ZzdXU0lwYmZFWlU4c29QeThWOU1KVDVDSlR6dU5qbFExcGZwYjVYQnBaZThFUEx3cWxFYTNuSk5GZlZmWkUrUHhpb0wwU1BqZEVwUlZTNWtvelNoUmllaytxOU1zcVFibXVWaWZEcEhLY2k5OGdzY0VmVnBRVG5CYk9FanMwT1drOE5laGhXZHhzL1Y4UU5MN3Mvc2VoeFFYbWRyMnE2clErYm11NzVsMmIwZVR5ZURXdWMvcjQ2RXN1NDNaUlVya0hDTGg0SnkwbDR1ZnF3N0lZcGJPbWxaeGpSNkhFRlJrQnBINEZYVkpwME1MYUxJNzVkdk9ndTdnNTVvVWJiQysxUTZ6UUJSZGM5eVFPamVmV1BZdlZ4T0tsbkR0RWEyZGpyeGM1bnRmQ1ZNU1hGMnRiMWgvUm5zUlgxblVraVNxUS9sanFBY3p1Qlc0UTZmS2NtNUtwZUd4ZW4wUjhYVTRlUjJvbGlsdE9Db1VYWVNWSUhPV216OXVlanp0YkNYL3QrdytDL1NlSVZ6TzFFZUlHKzB2ZUsrTTFGOHVaeTh0SWNJakJJS3M4Q1FxZ1B3SmRHcndxanJnRkRObmJ3VWZPY0FmTUdxblc1VDc5Nkx3UWhYSzgrZHdqSzNweklrM1ZGWXdJaUh2Z2ZOdk1BVHlEZ204Z0QwcThUMVFPcGxDVVJuY1hEWWoyYmlvQ0FvRHRRZlNOVDZlMWlrcmJGektrdXI0UVNDeTFjdjZFODZsL0tNa3lPK3o5OXUvaVYrVjVsc3g2clNNMkJKU1FFQnoxRDdwRGRMeWMyOUNSd0JzOFNLbG9ldkFib09EVXBUdjVNQldjUTM2bXpTVTQ4RVhwVWhsVkllMTc3ZjNsN0Z5ZzVydXBjdU92WjFWM2QwelV6TFdrMFBaWk9sWVExZnN0Z0pOOGJFbE1LbG1YSkdNZkp1aXYzLzRIRldqL3IvN082Unl4R0h1azZRZFlNdGdOeVlvSVlqUk1lRGhtTUEwNGlCOFUyNEVROHhzUTNzWWtCaFpqRUlVNVFicmpFNVBLRFNFaml5MHYvL3I1OXFycDdKQm55K3UybDZYcWNPbzk5OXRsbjczMzJvemNqWEF2dk9KbGRnQVZzSXl6OEVaSkJDblR4TXRJeXdpM0xBM0JNbTYxblRiV0FzYVh0Nnc2SS9IM0dVU1lGZWhETnJQR3h1bVVKSG1VVWloV1pzM3pqZ2F6YVJhaWp5dUFMd1IxNXc0N0lJK1QxUzFXaFVpL0RhVHMwdWFDZkJRc0pVTXBxcEwxNWR2QmpkYTIxOE1DaElOUitGWGtkOUhCMkczb0IyTUVZVWNhdUNGWUZibFFWTjl3K01saTRES0JMY2Nwd1BrOXZ1dHRjb2pqd0Y0VWM4bGRmOWM4bGh4ekZ6aW1pckxXQkhGeFRCekpIRFd3OUJOVHkxTy9hNldsa2dWajNKY1YyWnpXMit3UFk3cHdEMjlHaFZkanVsZGp1eG0vMWZ5QTJWb3B1Q3BlMUovZm5FQ2N6ai9aQlhOVHI1QUNvdVREbExuQXdDenZFUzloV0MxNkdCVTRpa0t0TW11SlloaXdpc3BpQmxlRlpXT2t6aGh0NEZ2aEJCOEJPS1ZUVnNpSUtBRHVEUG5ZR1oyT244OE5qWi9DRHNETmdlQ3VMbllGdDhXenNERmRoWi9EQzJPa01ZMmN3Z0owQjVqTDQveGs3UCtDUTdvbDB3WVBlSWhKSnM3VCtxRENWdDNWOE5LcjRtWUtUR3QzVVZlalJZYmNSQmt5cGxzZU9UbkVnOHdRb1BLa0RJeHlndjAra3hjSTVESGl2NWJBYUtFWnluSWFoQldDdFpKdzVtWmJaK0lUN2cyS2tGWis2dWdMZ05DRlNoMUd6Sk9GYTZkc3Z0QklVdkp0dm5NMEtRd0ptZ1RFQjJqSE9yUEhuR0lOd1g1RnJnUllDb1FJRWlZT0Y1dnQ5bXUrWE5OOG56ZDlXVVhrdE9DQjFTb3ZDcFhJQU9qWlhCZU1KeEl0ejFTMjlqS2ZReHZHK3l3US9SRW1YVVRmeUR6ay8zRVMrUUtpeCtBRlh0blZqdDNSWHMvMGc5d3F5TDJGbHd3Y3cyZ2UyRm92YVF5Nk02NUZHQ2NzNjZNQ3I0cnA5WE53c2VNQUV1cmd6SHZWQjlrQjIwUkJxbjR5aXRHTDhaaGlGdkVHWUJzYmI2NkVWNCt3QnVaaS9wV3VDbWF6ZXkzekY3UUN4RzNzNFB0aERvZVE4UksvWUVNOUg5R0FsdElybytRWFJvM3hkVTNKYlRlN0VibDZkMjVmUm14dXFCVFZ5ZU9lL2lDNEN0UmtXc0FDa2tralNRRkpIQldSZzZTTkVNZ3RJRml5cHBOUnlLK01RRzFmR1h6Mmc1a0xSR3pJZVNScDU0RnE2Q1JiSWtnaU1JQUp2QkdMcURoTFQ4OVBIOE4rYlB2by9rRDc2L3pMNkdQNjcwVWZnWVRYNWVmL2ZpVkF1dUU2ZEhIUmVyaVBpZ2NlNENZZzVQeU16Q0N1dk4yUlZNc213c0JDOERtVktoZHVDZFZxVWUyOVFzelhHMVovcnBaR202dzdKZkprSTU1MVNqMVFHOHdkblQxYnJ5Q294MVprczdvRmVLVWVNNHdjc0llUW9OMUxDUVFtb25IdGsvUDROeXlkY3ZYekNrbWVJNG5lQkJLc0VsRHY3R1V6ZHVETUtod0d1eGkyV2ZNaUJnZUpDblFhY09BQWdJRXRLN3V4TGZnSGhVT1Fabzk5QkZUOGpOd29kalVVQkVVT0F4RkRwK2M5MjVZTWVpNk15Y0FQQ0plTVRDMFNQV2MramJnK1V4ZTFsamtKTDJBOElEeUpFUkM4a1BBeUM1bHpDQTBDK0NqUk9DWm93UGxZRXRzaS83NmlHOXRSMzZvalJnaU5oR2FXLzMrWW1FbkZuSXdKUHltdFRoQW5OM1FQMCtkV0hLSUw0T0FXZkQxMGxRbE5KaDZQck8veUFVSVBVZFlERVBPcnlLVEJ4enJnUDVpZi9vYTVId0M5MUs0ZDJtTU1mVkJVYS9wOHhsVDI5K085Y0lYSjZiRXd6QWtUcDVoejZPb2RCM2hJd3Y2SEhDVmhZY0luQXpxdXN4WnZEek9qeVhNaDhMejhsMzRyWWtGWnptOEtIVEh6ckFOTTc2T2M0cm90Z0x6MkhpWk9sZUQwT3lOWGNySm9mRXBvMmc0U1VoVHQxQkY1WW5zOGFoaU9SaW1WTGtySXhWRlk5Qk16R1BpSFljWDFXNzhBOFZlWllMcW9hZVZQYWcvQXBEQ1F2K1Zjd3NFYXhzbDZpaFJTaFdFbUJzOXF4UXMrZ3lGTmdSbTBBTTZybndJemFDMkdHRjMvTEdWVEtuYVVHNC82eFNrdm5kalN5dVdycDNGSkw1dzFvNmJ4Q1JhZWFOcWZnVTJDQXdFN21WWFJlMW1aZVUzYm9qRlJWREIrVTFiVWg1ekRjVjJwRUdESjVPbXJ2QjZ3SDc0Vkc3Y1FYVkZSNGFaTVAyMUhaVGs1clFqUGl4Zy9GVHJOMGkyK0JNTGNzWVc2Qk1MZjZ1c1JkMW9UUTZXcEFsQXA4ZUhDdzRSM0FaTFM1WVhpekVPUWpYcnRRaEtwT3hWV2p3U2hIcEhtR2xtQ08wNEVEeTJnRVdidjhpbFZYSjNvS011RmFOM2k0dWN1Mi8zWWJNUUxrckVhWCt5em83VzZDWkx1SUl5enltZ3MzQUdIMW92dzd0ZDFOMEpLSWdkWkpOM3JxYmlqOVNPczRiQ2piY3MvZkZyekhaYmtNTlJpY3M4Ri9Ib2VGUFVQK1F5U1VpLzNaWU9PWnhvWExUem5XK0xsQ3F4clR6ejJKTVJmZEdlaEhSTXRCTmMxbzJxQUROR2xlMVZXeUlkM0JqdnBnNTdxRGZSMkdoM2FwQmhWRVYvaHlnZGtlcHNsRUY0T3lpMEl6dWhwWlMwRG5wbldObkE2cU40QUtUaGJuMVFPNktPTDhtdG1zamtIVTgxZDE4NXV1Wjg1MmhrcVdkM1RwTlFHejFmTmtzZ1orSThyZkRBemUzZFRJdm1rRG5RS0dCY3hvYVFwdFJ3UmVKeklLQWZTamdTNFFSUGEwTzE1UjR3ZnlPRTFadDAyZWtjS3REVzd3YXBJVW1CRllOL1FoMk5ESnJ1anhhUDZzUUtEUlB3cEZEcTV1R3BjbVNqOW9JbUlGKytxNWlQa3dHa1FkQmIxVXYwdFZKbFlNRTRZUS8vWjBxRUNma2k0STB2STR5M2hJU3hRd1ZGUldRejVUZFJ0bW54bEN4ZEE0cDZ2TysyVzJMZTMyTUliSFJXL3JZQjc2dU5OZ2Z4dmFXWFlWbzBSbkc4QVQwT3E5Q0FnLzA1Tk94MXhxMU1iSEZyY2FaNDFpUkVlQjlLN1BZcnNwUnpPQzBkUjBORUdYVnQ0eW1nWkhVak9OY2lRZURQamlWV015bU54eXVvVHJZbHlOU2hFYUQxdzUzZTNKdmVTbnZsZW5HbFRlM3V0Qm5UbVRMMXkyUnlQVjVsK3E3Q2x5eVlBcUxDc0hIQWhHMzY4eFZxZzFDbGZzUVFtV0tzcmt3aUJLdVcvSUJtSkw2dnJsOTlYOGpkajkzQU5nM3U0SG9mYlZiMXlqRE4vdjJUUGEvQUdQQVNYdFdZMk41cEdBSENlV0hDY2d4d24xeC84SFloWGFvcTVWdTFNSm9EdVRtdTFqVUI2WFQvNWR2Z29ZZGIwczVTcFFFZVhkblVPSWJzcGNINjI1aVpxY25LSXp5am03TUd4bjhnb2NjT2psczdLaDRzaHBRK3JueDc5ZnQ0WVN3alRkKzZtQnVFMXF5N3BMT091eEcyQm9US054TFBWSU5wTUVVbUhwV1BEMnp3bWRUZDRSNXNlL2Q5OFgzaVRmRXNtQ0t5cDFBUFNudGRVcGhDT3ZxTTB1ZmVkd3dJTEFBdG9qbUZIUVFrUmFxR2tNUE9uUmU5NXZlNlJ3MU13Vk9JTzVTUTJlM2xzdGZSdkxJbXEvZEVVbHlid2ZvVVZwWVhQM1dKRXM4SkdYdi84VnMrLy8yZHFyanRaZmZsL3lTUFNScTkxTFM0dkd5eXBqUEF1U1hmSjYyNHN2L1g0NDNBdlBwaVhvTXZTK3A3Z0pjOXMxM1ZjMXJiZU1HZWloR2VxZ3owRzJMYUdWeTNFTjBDOGMzeDc5UWU0UWRjZkJOZ0EzeDVyYXVpYjV3dHZMQktvREZlYkhuTFM2bzVLT2xWT08yRWJXSVlaQ3ZJN2sxMWVQeEdiQmhneXBoZytydVhBTlpTNVBMNnUwc0VLUUU4V2JnUXFuY2wyUDRaVm9GaWNpbU1jS2lMTTdyY0hLMy83bFdjMUpFMTkyaXU0c3J1NU9FS3ZzY3Z3N2NWY0VmQ2I1emg5MG1PcFlnS3Y1YUJrdENZTEJoNEIzTk9VZHdEMzY0OVIyK0RzOGE1d3pwdG1TSThJb1h4YUVyOGRVdnJSaFlJM010QzZ0ZG5uYXg3eWRXMlVMQVY4d3g5MnQxbVh5U3B2YkZhQkZpTkdLSnRudzh2Wk1OeDF4a1JnWWNLaU9PcFh1WlRiREFQYkJFVElMNkhiVCtEZlFzVUQyTkdWdVIzQTRXQ1Q2RFF3QldLZGtXMVNEZkUrT2FlbUo2UWoyK2dZZzNqQmdRSkV1TzRjTzBGN05JaFNRSUpmY2tLQld0QjJhQWc2RmFFTm0rT2R4TkI0eWlJWURKRE1RRVpUdjR2b2RNb1FGUHJjVjdtcWE5ZkhsMG9EUXhBZ2paQ2N3VmlmcGN5ZEZOMEhzeTBKa0dsMU04dWx2eXo3cllKNWxwUEZTN0V5QnhWM1pEb28yaFFxbWJBVlRxR0NLNW9Tbi9wQkNrRndnWEFLbHIrZnVnb0NBY0diNXd2cEMvM3pZMVdPTWo5M2xhbDVEOEpJVzBueXhjdGkxOFRnM3kvWmFhS01hcGdGdFZDeWJaWExBeEZZYjFhQTJxcW5hZWhZNVlKcFdEOFhvWGszNW9wSFBkZytralp4SFlzZnZjck9SdWJTVnIzd3NobWlWQUNWR3FjTTU3R1pqYytrNFRKbjVEbS9hWm13dVc0T3RkVzAzWGNjRDBwVEplNDdKT05hWHpGQ3N6aURTZ3hscHQzVkEydHg0SUp1VVZzMmtiTERPM0Q3MEJCMVNEc2hNUUhKcTl0S0pZdFFDbHl6ZVdhaXp2bmFYYXlZRVVlU1hCTnRNZ09kcFFGTUN6L3ZUQXRoSzJsSHkvYmg4T1dtcU45Qmd0dEhqcm9rZC9mUXYwdENzcUc0U1FZc2JzdGZLdjEyZHZWS2I0SDFqRjJBbzdBWVlQTGtTT2M3dzc2NU8ydEU4SXZLdkl6SXBKa0R1Mm1hMFIvREVDcDRiTzFJZ1pnNlhuZlJnd08xMXBMUnJoVlV6YTh5b1NUUlViQStnakh1QXBYQlBNWDVqQmg5ZHI1YkZJYjRJRGQ2cDlYTkxob3VRQzZiR0pQUjFZVm1iNmk4b1Ezb2F1R1dYOGU3KyszTDBqOS90cXR2WmJ2aXBvTWMxTHR2UlhvYTBsdkp2TjVMdzFGTGhvSFZBWUhZNUttRzRaUFBZQTJPQXVobnRwcVBDSDg2RG42NHBRSFozY051MHh3c05BWDRUSFdtbWt5QW1vNnh0RWlCcG9MWTlQTTllajA5YUNDRUIxM3hnakptVW5obDBPSlpWQ1NtaGxTL2M2Y3gwOC9zOWZOZkhHQUg4YVA2NGZkZ29MT0JYdG5lekM3QVdMN0JyOFFLc3hRdW9DQlNJN2t6WEZ3ekdFM2U1YWdjUks2bzlmcGRMZ3plUUlIbG5pT05JbHluL2RqTy91VnkxZHRJd21kTTAyVVVraDR0aEsyY211L0s3K09PeVYxK3pkTFZiR1VScVdjZ3kwbldDVHVzNzZhU1FPbGt5aVAvZ0Noakg1bEJScXd1WlltY203K3NxYWVoUnhES1FYNVdjakJneGJqcFFDN1VORWh5TkVaZnlpclM1Y0ExSXlZdkpxVTY3ZHlham94aVVyYUJoSzVoa0JXMjcySGxBTE8ydTc5ZzFUandicmszV1FWRmJ3K3FQaDNva2EwZDZkTjdPeU9mN3l2NWtjZHJnOFN3a0o1azBFME5uM01UOEt0VW9Kdm5Nb1M1aUZuREJyMXF4RTEyN2FMdWtBSVdYWThlTUM5WFliZk1nM0wvUm1RUlZQdVZCdmQ4QkpuUXNKblNBQ1IxMWVnYTlwVStaaCtCYVR6TzRWbUZHZTZrUzJhQWtzckNhRlNKckQwU0RWU3IvY3lqN1FaQVFJVkNKL1o1KzdHbW5XS1BmT2hFbmI5WWpOOW0vY1hkRzlpcDVvNXk3eSt1NGdBMU9LU2xsbnY1VVhORGthbjd4RENWWUt1WFhhS0lpbFRHL2RSZmtLM0IzTXlKdTIzQlhYWkoyM3MyWWNBNVpjZHo5cTIxeSs3dFRyWUJTUFE4dE5hK1gyNUREdXVxa0NtVVg1MnpQNE9EaEFXaEJ2aFgvZHVNNExrUWVwaFM0V0xmK1ZTRzdLYXVaa3dCemt4RWNUN2FrMjg4ZTVvU25pWW5UVVRWUytzSFRFWEk2cWpvZExITEFWTXRETEdJS2xOL1k4MExkc01iS1lMT0I3bE1oRklnaDlxa1ErMVNFa2hGRnZIMU1WbHJDU2FaelRFZ2dOcXRxRDJvR1pESnBTcGR2dE02b2RySVRZU1h1OEVucGxWVkxHQXgzTkxuZFR4TzVZMkFYMlp3RTJpMmg4RUlKSFNHclFacFFCVEdDT0JnZ0pSQ0ZQWkpYVUtCT0dqUEZWai94QjQ5eWN3VDdPcXpHWC84UjBFcitMZEJLRkZSd3o2K3RYZzdQWVBGL2pNdEJEZVo1aCtYd0h6b2NpK3ZjZmY1MTQ5S3RRaGcyMmFKa2VCZ2p6MnlxZHJYYWJlYXczV2FDL3NwMWl6eVptbEJlK0ZJZVd1WVJxOHR2cGNjOERwY3d6T3B1TEtmeG5wSjBXWDlZUnJvMm8ySXZreFVJUDF2bWhNbVBQSW05TWVvcEs3SUx3YW5UTmRoVlRGdDIrVHk2a2ZGeDFrb0gxakM2bFBDektmUVFhOVhmbnkva1h4dDZlc2dURFNpNUFKMDVnUnFQQk1kTUJPdEJDZ0VqMTJtNG5ieHVNL1kwVFIydVJ2SWpjdGwrWmdBY1plU25SZ0ZuRTkxQXhWM292anhmZUF4eFZraW9lSFNvMUtwUHFjYjZaS1VLTFFja21HVzNXL3JzWTQvWTN4MXdGdzNqZ3FLb3l5SEtoUDJFRnFOVzVsdHhNRkh5a200REliY21VaVJvUGVnMEl2UUtFVGhHTlhpVlJtd0tUYktMVFdEelRGdUtCazJtcDVNVkhPL09nZzRpVEdHbDF1RzNya3VVZzJ4aWVPc3dVdUdVbTNtOGkzeHlmVFVrVnlvVTNzYjRiQ3dQMWVVVml5LzBDbEc1QVFBeURUTHFiUFRIV1ovSncvM1d5NWxQb0dGTTRFSTNPT0liQ2Z3a0wybTNvQmRzeFNJWldoSCtHbWhXdFpFOHE5dkFUSU9INVF4cFN0L1lqSVBCSWQ4Wnc1Zys2b3NIdkZJVUpRNEtjMW5ibTQwTlRxdHVWY0lLY25mUEVrQzloVTFyRkxyQ3NSbFd3YkxkSGcyTElrd3VUbHQxSU5UZnFZQ2lJOGlwL0JTZWRIZG4xekFSSm5OMzhyQjdBMHdYaFJ5cnlPeUFCaU5BUlJNdUtCSEVzQWdMSVRJSnR5Rk9jYy82MXJRNUNlMEdNYVhkNHdvTDdBanRNdXNDSzRaaENvc0gyZlV5S3J3REUxcFI3M0hkMEt0OTVTazcycjYyTUxZUlJqU3JGaUpNZ09QTlhUeTlrdWNjVHRteVlGM3lWcVdhT0gvQis3YTFVd1YxQ0ZUdGEyc3lBY3UvQmVZb1VySjA0TUpYK3NGdVR1c2FUS3RVdVhZVm1SYVd1QVJmeFFLUWpIS3M4MTh0WmgyOURsZWhnYTVyK0d0VlRiUTNTMlo2RnJzRUxEY09jQzVFQnBtQ1BxcGs0UXlkc0x1R2k5S0U4QTJuamxHdWV5VkJ0ZzBYd1FNS0NJRHVETFZEVWlKN2JLWHdWaXFhUkJ1eXBnRm5ZaysvQjJaMExrdHlSdmREOThPU1NvekozWmgwcDZhOUdlc0pYYlMwdUdHU0dacjRWYm41dVR0dE5MeXFMRm4zT251cFFGV0hUczdETGlDa2NDVzdOVVNJTEF2UVhMWHRTS0JvRm82NUkxZXdtaHZsNFhHNVNLUTlvUGQraUNTMUxvTFR5V1lKZmNHb0VraVNNUVNjeXlkbWlzY2VIck5CNHlJYmU1Zy84UXN1TEUxWUJRUlVwT0YxWkxxRW9ubjdTVzMyeXpLTzVCTzQ2T1BETVVySVkwSWFCUkxBZjNtZXFQdlF2UUpZZWU3TW1ORWI2Y3ZOR0hsOWRsRUcwTE1IVkpFdVVydHVSaUZjN09yMGE2RTJDU1NyN0tKQ2ZCUll4eXlxY0ZVYk5FQnVjYW15Y0w5cUhLWkgwdnVrSjAxRWFBS28xaDNvYmRRdkNrNmpLaFRneGhMVld2RjVjQTFzbXNnakZzOUtIbmsxanNIaUxDMWFrTEZVQzI5MTlqSWlsN2cvdzdRTTlLZ3FrRjdOcEF0OTk3cm5Wamkxc0lFblZ0Q3FzbDBvNXdZMnRnQWIyMnFTUkY1Q0s2K2I1bG5idHJYYjViYk41SjJ3ME8ySEQ2a043RHFCN2pybjJtMkRvZDAyNk8rMmhYUVFuSHUzSlMvVTMyMlJycjNZYW5IZE5OeHp4d0Nnc2NIUUlUWnpoTXoxaEZuRlZtU3RBY1lpbTV6TGFySkd5cVZ2MWxQZkZKWTkxQUNXdW9tWElwWFJPaVloUnFVdHplRkwvbVRVY2lpaHNpZmRQbzZ5QlVYVEZ0RzBwZ0dOKzZXRkFBay9LdndrQTEvQXQwcW1xR1VaR2hhaGYrTzZhM1VKZzBWa25RSVIrQWRxQWk3Ym1rNnhMektwelFyVng1K0NnY0tXaXpqRUVGZUhLTzVZbjFjVlZCdFYyVTdZY2ZEd2IrcHl2aE9xRUVTS2RIWjJxTHZWV1c0aFpvc25hMzR1OS9mTEd1SXMyczcwKy9EM1Y3Z1h6ZGR2UTBCeWc1VFRsd0daTDdQSWZCbVErYkl5VVltWHU5WkZaemVkVUg5MGwzVkVnMTczMUNQbENaQU5sV1lkR2VXcm5XcVFDWTEzUHQzTlZCZU1jZWZ3VlczdjdzamY2ZDBDd2IxNXNMYzRjUlpPYVVaZDlTQ3AzMno4RzhtWlAzSlJGNkY1TlUxZkx0MitTRE9GMGFIbzZadHhDbTM2MmFocTNzdFZBUStpcCs1cmQ4ZGRKcmUrL3lxb3JpcjVVZ3pWR1N1R2VpN2YzQlVlTzh3ZnFIY3BBaDlmMDBWR2pNUmVKbEMzNldXMFQ3WVpYNkNlanVlbmo4VDVuNG9RM2ViVmQrVUtqUHZhZ2xHVTl0ZWFxcDV5ck1WMHIyT2xpUHE5WG9OR1JhbG4xaU1wdDJ1OEpod3cxOHYrMERYcmlHbElHTzJyVUlFVk1ZRm5jQ0YyOHRPM1EwRExQTUlOcyszazk5K0JSMEpNVDY1aGtXTjNxQXkzbFhmNmxvZXd3VXhQdnBDQ1R3OFh2R29neUFVREJBalpiSGRwNVNSMEpqKzlESUorY28ybEkzU2lpSVJPWCs3SXppSi9zcWlYdi9zbE0zbXlYNHB0N1pmS25YMHphbVl3ZEVJUVRydW4yelNCa2F0dnRiT2dPR296MTl6M2thdmRremNibmd6M2hoOC9kYk9kMWc0ZFBCOWwxOHZVY2hGRTl2V0NHc0xpVHhINmsxemxGeUFEb0JiZG9Nem40M2RZK0FtaHZRRDltazAzeFBuSk8ySnpnWm5zWmh2ek1hbWlZNllRckh1eUR4Zk1XT1BHSXBnRytiTzFRTWdwT0U3ekZMRWoxVUlXZGZJamQ2S0pmYkpiVFJGdElRTk1BaVJ2N0Nxemp5elgycHZqTEFxRDFMbmlMVXBxTERMd3NORGdGQzdoY25XTlhGMmpoSGxTclRrSWNTK2ZvaFQzelVlL1ZjRTg1TCtKekJINW1jb3NWR1UwOXM4L2Y0Z3pKUFBwQ0x0ZDNROWRVWFgvakR4NENLckQ3ZFNkRHN5VHJIQnFuVXptZFZLRFlmMDg2QmRVaGVhQy9GT1ZtYTcwZkNWTk5VU2FtcTkzZU9KbHdHVjk1U2xaYU05V1RLZVRac1pvVWhhRGtjSlRPRDk1UERhcHNFbmQvTWh2NDZvdWxhTGtBTUFORURHRGJWcFFBRjNlcHVyMFNQVjltc2JXSmo1Zm9FQ3VKK1dUeGtBcmxNbDA0bVVVNityRnk3a010SnlvN0FGOTg1RzVmQUZXcEVGdkx5NENrL2IyQ3JYSmt6bUtPM0NlUWh6eDZ6SjBOdHRrTnFraE54S1h5M01vUHFLT2RCK3FENDhPU2lheXFnOFBFM0JyZHo4bUFWWnkrVnUrU3JPODJVNXVqQ3dZWi8rQnpKdkp2K0RNMENpOHV4ZnFoam0wVFNxM0cvWERjcEIvZDNWK1JOYmFaREV6cHg4UmpIMGtGb2hKbHd5R0pTVHNSYmphSjZpN1djZmJ6UTkxMHdzRlpCa3BZbEJZSkJLWVdkNVczVUZxejdsU3dMdGlJWlZpaVF0NDBrbVRGak9ubnFjVlp0b29BUXFaMUpZVmVFM2VRSUd1Z0xVd1Z1aDFVSzU3c3dtV0drTHFMbmVPcjZIRmlRZCs2RWZrVHMwYisvTStNR01SWm5TVDBKRXJVTmxqWFNxa3NJc1FMbExOcExiT2RZWGFockFZYW80RjE3eElQdTVKMHhlaWJJQjk1VUxqc1NpV2tnR29QSkkvMk01QUkvQ1lOaDZZVFYxMUYyUEFDL1lxa0E2VjFVenFJQ01HaU5RVVFUYkNRaDhNa3lpUm9rOXBQMzZTWnpvNysrU2t3R3hQTFhMdDlHRUtVaHdzV3V3ZW5DT3ZtS01JUEh3cUVQS3N5eCtrZHFNQ3NHQW5jNzVMTDNIK01VaUZOVFVEeUtTZEdFd0Q1bmFTTTBBdlg1eGJUSEpYalVwTm5TRC9UbEswZ1FiVDRWaEltM0RXTkpkdG9aZGRxdDBIQ2JEZlQ5NUFpOVgrOTcwME9nZnN0bUF0SE9wbTB4aGU3aHpBZk05bVczUndXMEFlUFd4QTAvSkhDc2w2TXZKbkZ1VURNMDNGTjFVQVJyNVFwTURxN3NvVlR2MzlGSWZyRnltcjBjaWhWc0V6VU9TN1NaRW5FZTJwWWdrNEFXV2pRYTdDMHJiRjBxQnJwa0JiSTdzV0NsVGhIdGt6a3pPNWU2QzdDamZ0OTdyWm11U1hoYk5JTCtJcXB3U0ZwMVBDUFNIamlPWjloNFhWUlVVeVZkdUUxb0d2cFhEVXRVODM4eGdUWHhjRlpDL0hzeCt2WEhYTE5la1ZNcUFMaXZDeXhUNTI5MFVhdUdMbGJicERxZyt6dkRoOFVUZi9iOTEwRXkxenRIZFNpbkFxRXN4TndZbjc1UGZweEkxOThOR1BhcXkwekM1aFlJa3MyWWMrR3V0Q2xqMTJrMGhOWnRNMnFiMTBuQ1hEWXhmRTR4OUZLMTlqWDRBbmFZWjVXM2dVVDVkL2FlQ3BVOWdIbmVRWEMvck90ZS95Wlg2eE12QTB6bTBTMDhaQVV0alV6bXVxODFyc3FlVkF5bUdRR0dGYnVoUlVQc2cvVVF5cDBPTmhDNGNFN1E5TnRaTy81ZTIyQ3dLVDV3UlNhU29GbnNYRnByNGF2R0F6VEVxSmxUMTF6Q2FGS3JoQ0VxbWc3R1RBalo4RHcrUUxEUlltcjZ1OXc3WmVlZG5xYlgxSUhGa0xzSjFBNys0N1VvQlVodkl3R0lLcmw5SXJBS3BOMkRBM2Rwa0tod3dIb3MwOXMxRi9UMjZVYjMrVDM2WmI4ajg5VVFLcmF5ZDBQL2ZnREV3eXBrSCtYZ0FyR0xSMW9TREJOQWdmUjVXYXpIS2VHMlVEQWl2a21HbnlSdis1QXB5ZzMyayt5bU41OUFkbEpsRjNZUlpmRm5DTVVyck13MW1teDhkMXNObW9zbDFVV2NoamZNdjRHbmk5Umw3THkzaVFYSFAva3psSDA1bXdBWnd2c0QwNkhZSVAybkZ3RlpORXNjQjJjZEs2SU9oRURwTlBqY1lPZHZIVWU4a3VybWFUY1Y2ZlR2WjdJQ1FlVk9yWkV3QWhBTHhCd1ZkZ3prQXZLRjhDUG1RbW9YaVpNOU00cTJmKzVzSThtN214OHJZdWt4bmgwaUxHM3Bza2RyTWtWdGFXL01PSFAvdVh3bFgrcnovNG44ZmxlYWFHdUpOMEY5QlNJZ0duZ25QRXQ2dUliMVpaRTVtc20yNHBEcUlxQ0tDMWZpZko2RVpkZnlXemsyNFdZcld3c1p0ZUxMK25aVTFjWXZtU2pXYXo3bm1uMndVcDI1Z0wyK1YxN04xRjJPRmFxQzdKTGpRYlp5Q1p6R1V2d3ZLNnhNalBKcEE2N1BjNS8wbFQwdzIzTU9EemJHUUJiQUJRZmdpcFRyZVlLOUt0b0hFWDVxN1oySnRKdC9Ca1BkMGFDeXdPNmJMYktNc3V1MVFBakpDRkdiYWtMZVRxTjNBdUlyTUJjN0hKc0N2VE1FOUlyMXk5ZDF6Smd3SEJGaGd4YkdJMFZxZ0M5TUhTMGZUS0lXUklqVkR5cmVqSUovV2MvMHB6SlM5ZTI5R0xUNzZtczJRbTVkTjdBUDhJbjBZRjRMZUFrbS9KK1E5N3VibVVvK2ptcjJmai9DcTlVcnEyUlpFemxZSlFubm5TaW9mZW9Nb3RxSEpMRVdKenl5QTgrZVUwVnRnV3hDcUl5Z28yckJxNUVxN0prbDZoOVJSWUlnalhLNFp1cmx4Y05mZ041c3BWUFpDZDQ0SnRzbUVKc2p6ZnByTWxmZHlzdkhxNG5ueUF1OTl6RlgwMytBejZUQnkwWEF6a21PeFBwMVFOVFlKRnV3ampZZWRRWjhhZWJrSHZaRGlPc29yZzMxd09CZlVmVkZCaUhsOWdKQnR4dlJITnl5cnI2ckNFc25SZmVHSlh6V2dGMWpSeXQ3NFJxOXZsU2JMc1JWenFURlA1NXFmZmkvYWVscTNXYklDOVFrRmFMVTJTdFFmdFlIaDlKdzlKajZuZ3FhZ3g0QkQ5c3kxc3lzTzVRaGJUcWpacFBUYW40VGFYYkh3S1dxNTVna0FtNldRamN2N3hOV1lzK1JYRS9aNEV6VlExZzVNWG5QNmt4UWdvNGthMW5KcFhSRVhKUXJLSVdESmh5VVJMRHFrdUhOcHVLNGVNa2hOcVB5OGxDNmNvNXY2eUcrQUFXQWNKTHJmSmZrNzZUWGl6U1V0ZEtQenNJWlVuaEoyTFpVZHd3R2tNQUlxSHFkeEtNM0FLQ2l2YVNnbHRxczhKYS9tVnlqNXA3ZDN6WFRMbUpvSUJldWN4aU9lWmlrekdGTllNSGJDZHB6OFk1OGQvRTVQU21yRlYyU3ZwcjlDdGsvTCt5QU40WHl2ZjEreDdzT05GdjFSaU1OZzJaeWlya2gyMlhkZGVab2p4c3Z4V3FmUDlwWVQrdnI2RWJpdlhIVHlqV1gvRS9Wbk5VckdiOHF4RzZpQi8yRk5GUjhSdGx2YXB4UnZvVjFTTHdmMTJZSlZVYlBMZjZvdzh3SkV5dDZXbTFRQTIreHBBMitxNEVuRm12OVRrWElYQ3hyK3hpUlJzWG5GZWpXcEZMbGc3dzlPVnV1NlRRUS81SDZNaDZZank4cW1DbTdFeHRQdlNrRlIrc1h2eTV1ekYrSDNpNXV3bFI5T3JjUG5VemRsTDhmdjR6ZG0ybytsMm93TVI0VVNha1oybFE5TUFKTFBEVGppdC9jZ010aXFtWjVVcll5WWZTcmZhUTJrWUV5cFJlUEhSOUFyellsNHZwbGVibDk2ZHZzVHVKZE5nRmsyaHFodWdJeStGK0lQNW1SUTBGR3FVQ1dGWnBHZUtiT0czMG1UT1pOWndidUhIbHJLdFMrWnFjK1dTNlVBTGhpMWhjVEU3RHkxS3pWQkxMekh5N1JWbUUwa2V2ang2M2k4SGFXRUZvVlNmdW5tN1FBc0UwZWhzVEE3V3ZNMXNOOEZEMlJWTFp1czlpMlJ1WlR5YlpBQUQ0NUhlYmluR3M2VS9ucVhzYXVuWVZVYS96YTVRMk9rQU55bEVYbWlBZzkzUXZseHhsT0JhNGppUG1xdVBudS9qczZ4VUlyTVdqOWIyWlg5N0JBN0p2S3BtTHhGMXYwUlVWZXNOUWtxSkZDVjJxM3oveDA4aFFOVFJ3cENkR3BranBwdGREbDMrNVZhWGZ6bDArWmN6NE9tZnh1N0l2QThma0FYYTVwM1RLekJIeUU4M1oyZ3phQ2p6eFErTCtQUmhXSGJXNFhDaElZVk5vREhtY2VBUUdvM0tERHA3L01QcUlXcTFRZFU4Mm44dVJiRkJsSjNaR1FZTGdwMmVQWEliakFPdWRYdElWRU92NXF5V3ZNZlhwN20vejU0dzRSbHNPSEliNjlndGdwVGpCa2U4ZU1HamdUcVlmMmU0ODhidUl3eENKYk8wY1g5V3VjVlVlaG5PRytYZm5xeUNVMWtmcDVJZEhpOE1CTE9XSVp3K2M0MmFFZm41Sjg3Z1ZFNkVvK0NBRFByN1orQ1ZLMyt2NzhnZHRJc0xiMTQ0aElOUVRDS1VBRytRUnV5cDNtQjNOSXAyWktLcmNIRDE0S0VkcmNNN25JTTduTU0vVmtJSFhadUJOa1cydndQV2hxR3dSb1BOR2dmS1RoVjErNHdrQmxtaDN3YlBidEJiYkRTcjRxWVgzM25uK0k1bnFQeFNOaW51Z2Z5N3V3TTk4eG1vbEZVZnh3ME13dzNtenA1WVcxbFc3Wkx4UDFLWXhkaHJuM0VaVUtEQ3MweEdzY1JzVjJ5aDByaW1KMVhZa3kvV09YK0xjY2s4ODd5WVI5N0Z1SncwTHIweDRueFVRVlROeXhqWnhTUUlYSFdreGVDSnNIbGpZQmowZ0M4Z0w0aThjWGVUVVFBVy9MU2hOWUM0TTFoWFJFc2tIRzRxbGlHMGgyQlo5UlljNDczM1MyZXFlNXF1ZnNxVHErcGM3eGdzbXVsUW5zbncvR09tY2V6UWpnMkhQNWdmbkZXVGM4MDZ5bit5UEp2OEdpSDNOeko1ajVyb01XelZQZ1lTU1E3UVg5c25KdG9JR1JWdDBrYkpzREd1aWlnWjFkN2NNVHBPSTExb05aL3Q3dDhyM1RpMEl6bjh3Wjd4Wi9MbWZ0UTYxejJXanZFYytrRTZKZ0JzTmVIM3lCMk9LQlp4TWRJQ2ZVU1lLMC9qTWNpczF1MkNnem1DWDRnN1FQaFJqRlR4L1lPTVFDQ3dZbGR2dllWbUg1WGRRUDVkdDNTT21iRkRadnl0V1p1QlZKT0RqT2kzOGI4SXBvK1lldGUwVjY4WlRoWDhMYjcrQitFdUc5YTRqK1hPV1JQT281RC9SSUZuMWRySTUwMk01ZXgzLzJYcjk0TWFUYjlZVU5IcXhYZk9WVDNvbDhFRDZITjc3Y1c3cmJXVk9wam5Odm9iM0IyWGw1Z3UySjBCRFVWZ0U1bXdtZnpRTFBrMjlWUDE0RkpwY3lNZ2Jidkc2OHZMd0grYjFlTjljM2VRNDdMbnNZN2x4cHpCODFnYVF0MGN2N3NmbWM4N2R4aHM2MzkrV3plL2JRK1ZqT3JibVNmNTcveXFoZ1RKWDU5cWhzMzhtYzlyUWhqNlhMbnFwc3grKzBiekRDVHZRcUJxRFNyQ1ljSFA4bnc1a3Y4S1ljZ1p0a0N6SHVXSXlPbUFwVlB6c1VvdjlUV1lHTFpwMUFvSGJFOEQvN3Q1a1ZLRk55NWp5UjNVakNaUTVmaFhxWWRxN29GY1hvWHdFQ1VXOUtoNDhUQnNKbG90SzJBRUpjR0ZXNVZNeUtaNnpKempXMDVnS3N1OU1IMWhPUEtxOXRnRU50WkxmSGtSNjlVVEdwcmYvNTJXVEpVc2JrN2tzdHhKK2RHWUptVGd1dU0vUXlCbDVWSmUzbytpc0ZKUnR5bWhkVFpBZVA2R2J2NUdEZTdqbExFKzg4VGFCaGhuRGhFbDFiQ2w2V2hTQUgvb3FjMkJFZlVmTnNqUENQeWRPU2E0bGJhdk5oV2Qya3IrMnpiTXdvZVk1d0V5blVNemJNUS96UDNVc2ZPakVsOXlyei9zRkkyWnZGcm1oT1plMUU5WDVyTFNsTDlhaUFoZ2QxSlkxU0NYaWRZbzA1dGllZ0xHQUVGeVFVWklnQVh1VE83dlpjUVpmM2VITU5mQUlvVzg0cXR4VWtSZG41N3IrQWhPWENHL2w2aitFYWF5MGlEY2tJSmsyZS9Oa2lZNFZKNmZxZXNteDFPQ2dlRVUzenNEM3pOYTRrQU5mdjc4R1c4V1h4M0l2ZGw5V3FNL3UyOVZWVndiNWNHWUtWSUtWdFN5Mk5WaDJQN0RJYkpJdWhXZzk4b2JRblVaRFhiZFFVZ0lCUDg4b3cwN2M3bDdWc05GTGM1NWFsbFYzR1hXczByR2c3RldiR01oRGZVTDgxalVxdXlLMW9vaGFNWHVxdTR4bEViWndWVk81NFBWdWVldmJyV3J1bzh3cHg1am5XcnMvM3llaHEzeE9tdTVDZDQ0UDd3UWMrRjVsZmc0YUNQb2xFWExUTlpwMzNhbFRFWVJGWm5uWHM1SXNRSjhkQXNxVTBTcEtOZzR6eElpK1VYU0NhVm5YVXNLaXMrYy9tYzJJdWdMZnFiZGJzaEs5WGhlRkw5R0tZcWpKa0JJS2txREswQVdRWWxtYlFSdHVQdEtwUUlyaEpiWG9QVHkwbWhtdXR6WjE5THowWllOSm9TQ3psemNvZW05Um9zdEVoVlpVTXFPbFB2SisvMzR3NDdyenpzSEFiRzV6TUVxZEJIOExaOVhldUM5WXVLeVYvelVkOUwxMHVSSDN3OWJnRE13OWxFWUVXc3E1RWdxbEtjSFNUNTZ2UmRUa1Zhc3ViVm5VVlJFQVU2NHJ4V0p4SGMxTnlocFR2VWxkTHl2cUxobUtoKzlMM2t2SE1PSGlsUVJjRnU2WDBXb2JmMnQydC9JL3Ric2I5Myt4dmEzWVgrYjluZkUvcmJzYjJKL1J5MTQ2cmQ1akQ4SHNkakJUNVM1aXhtMUZCT0lPblN4bTJUQlloWWV2WnBtV0o0SkY5bFp2UEZSVGlDZXhmZzZYSVQ1Yzk3dVpnM2NSaHJvcjRucjJtSldsODhRV1VLSTM5RU1uRU40TlBOWUZaakorbEZjTmJGNmptcjFBdW1qR2FNVEhjMWNlVGFoeitTTEtMN1BjeHZzZHZJNy9sRGZEVUplWFl5UVY0dmE5NjFJWFhJeENMcDBiakdMcENMWWxzbGVvcU5BYjV2STZJVStzYXRWKytJcTdYb0tqNGhxMlN1d05Eb2tUT0dsM1d4RXYrR1JVeVYvV1RkckZlTTlDbzg3UUsreHFLQnJtRmhxMmNybTYvaUNFRlM0TkUzZFJMWU5vU0V5NUIvL0IvK2wxeXlCbXo2cWx6cW1RT0JtNzNGOFdpdHVuS01XL3BqQUNGQmlPMVdwYzlwT0JFVHVjcGc2aXkwK3M4Mmlwazh1R1dtRzRVUVdVV2VCQjRzNkFUSnZVdnBxblhSR3hWMVV3RmN5bHhXTzRCa3FSS0trU3ZLUWI1Y201b2xaclhteGNudVN1OGtqZnZ3YlZiY3hYN3VOakU4NGs4RUdTdGlZTEJEQXBDMCtEV0NJeXhaTWlHWVNFK0JuZERFYlk3OURGQjJYb21Nc3hFNEUvTklISXlWdjRiSjdORXVPQXN4Vmt4ZzhJOHdEWE1LNXNxV3ZLOFZycllXdCtuaTltTFg0TmVCVktiNnVrSmFLa09mc1E2OXJYY1cwU1B1WEdBZVQyMXJDclMvU21TV2FXVjIxL2RuNGtvekFLSG5EOTdFTUU4L2JScjRaNTdDeU5VdEhzN1dMMmJxajVZS0x6RHBPTFpNbjQxaTVZVDl2MnJHdU5XTkhDUm1NZGF3LzFsREgyaktqU3pMR2NhazRNVzM1bFNkcmxqQytiTnhDWUx3UGdVRG5tVjhtZlRCVTVhT3lERGtqMm5DQmRYWVJKRy9PZ2lJWkFFVTBBSW82SWlxTzlJRWdXODBQTmZpRWc0ZGhxZ3V2NzduL3FDRzNmOUNRVFRIWkV3TWpiQXlOY0s0N09MNGZibkluT0w0Smp1OC9iRDZGRUZSV0RjNml0WmF4Y2VUZEZQSjNYYzIwUFBoOGN6MC83RE9NV2RjdTdPTGlsS3huSCt1WmhUN01RbTdYbHZic3hmSWRpV3hlUmFHUDhKM2Z0YVZEZTdGOFp5STdWRkhvbzN3blc3eVdidGlMNWJja3VVR2hGNkhRbzN5WGRHM3BDWHV4L0FzSnptQ0tVci9MbDZacmkyKzFGOHVMaVl3SHBiYWcxTy94SlFpV2xqOVZYQzNmSitYY3N0d0p2Z1VnN0JmRjFmS25wSnhmbHZ1WWxoTlkyQzg4ZTdWOCs2Z01yQ3ozY1gwcjRMQmZoUFpxK2ZZeEdWdFo3aFA2VmlCaXYyallxK1hiMnpJNmxKdEd1VS9xV3dHSy9XTENYaTNmUG9IeGxRVlg5TFhBeFg2eTFWNHQzMjR3UUJSOCtWbmgvSkh3NUgwK285cHIwUDUyRWRlL0NQRC9iR1VnaXY5M1EyOTAzajNvM0ZZRWxqdG5ObThFQTZKb3Y2K2J6MTFQNlhBNWdQZ2VhaWF2UURPdWhQbG5oWlcrRzJZU241T0x3N1NYa0lzRnVDTXdXVVNZdHhBSHV3cHBNTXovV0o3ZHFSNmI3dDV0cEoydURWVmVvVVF3QWIyZmsveXFUUTJQcjBNbURBQng5NU1IUWhTVmZVR1BLdTJqR3VLVVFLdVdiNUMyMGpwbFVZMFkyQk1wYW83NWtlZTcrVGYrOHNRL0g1cGxtSVRxZ0g2OGFUMHptcHFHdURXVHdwV21NWk9ONEpvZFNPZzg2RnE1bi9FTEVzWnpJK01JdVRrYnpWdDdUVlVZOHYzNU55R2l6Q0ErbHpPSE1nNDFqelhRbmhraFFhMnVHVVBoRVJhZW5aRlNXcytvZkw5dEZSZXYvdm1GM1dWZDFxTU0yRVd1VzQyM3pKektzcFRsYWJUTmZaM2htWEhJZENnMDQvaXh4UlBXK25ybEd1UFp5MHJsLytyUXl0M2xxYTVETUFpbC9HaTYxbmp2K2pXYTFEbWFTc0dNV2xXODlHcDhaeGtqZDJRUEc5ZHQxTW52aEliL295WC9mcDl0NS9LWHZ4L0g5dTlHaHhxZGoyVHJrbmZVbEs0aERlMjY1TDdvYXZWZDZ0ZUVGeUI3RjNsSWhSa1B3U0tFejhXT2ozLzBZOSsrNC8zdi9jVnJrSUV2UkM3VUhmLzc2ODkvNitndi9kWHY0aEhRaUxuSStQTHYvL3o1TjIxejc4ZVo4emRQZitZN2IwSzZWUWd1b1dxWkF0VnBPcnFCQ2NPN1JrU1A1ZjQ0ek5yM2E2OVB3SElkWk45anQzbTdTb0tFc1BNcDM0WUhhMk5SdGUyaWFtTlJ0UmtLNXpjOGQyemV3OXBiY0xENHpsbU9oNVlVM3lheWNHN0FQU3RTZ3M5QWJSTndoVkJKSDU2eUhvOUMxYjA1Z3BxWnBrUnFvZ1EwYnVMRjZ4RHBEZGdNZisyRVpSTEZacCtlMS9EemdSRlFBdjhscSs4ZTA2cXo4UjQyemJYQ1ZJNUJGTDUxdHB1TjhSaHRMUGU1djY2VDNvenphbUtKMjkyb2JKanJsc3lFWVRudWxBa0FscFNxbGxmVDJGelBzd3VCMW1jb0ZIbStFSXpXaGc3aFZ2ZTVybFVJRHpMSEwrWHVaYVBWeWxBalR0bk02L1FzdWdIN1VybTZNeGdOR0FmVjZXWnJNQWxyN0NTc3dTU3MyVnlKZnlWMHgrZjkvbFNkczlRUFAxVlVCc1I1TUpNMkVJbGd4cEtkd1RrYTBUbFNHeWhTbkZHV0dTMG96cWpRakhKZUVNRm1YR0ErSmh5TmxXM1RkVEo1NWZTMDhXVEN0SFYrYk13V0tYMGpRK2lNMlRtK21FeFVVNmJPM2kzZW5VNkNWUFdmbUhWSDAzV3FqNWJQZStmODZxaDhCQXhvREZXMERpTG1LREZyVEY2dkJ6Wk1McEczd2YzRWtsa3Y5MlI4UmpGcm8vOTYxQmdsdlJwbHBpdmNRdlcrUDJ2TGhMUTVJYm9rUmszRGFsTGEwcU8ybEVmWW83aFFNalFGWVdLRU5SdUJHdGhUc296ZVpDMEVxekRDalk0UEtHMjRBamhwd3ZHTjg0a3JUT0dTY2ZGOERKZGNDWTR3ZmxJcFMzQTFzTUFTU3hoK3NXaUxEVFRiTXMxK0d3bHc1dnpWai95QW1nZUJxemkvRnRpODFtTHpXbUR6V29iM3NZdHFkUFdpR3FqaGwzdzNzbjVuWEJqblR1N244NHdQa3RZN29XeFBuc0JSMWxZbDdrWnZ5YlB3V2pXQ1ZKQUdHb1RGQWRueEtHLzZwTTlNSnczcTBtRFlhd2lVRVc2YlN5WUNDejlDZmx6NC9xTzI2YUo4b3UzS2JZM0NLaFN1bEdwbERWa2hZZHpVOE5OZU9ycG9wYzJHR1ZrUzlHNHRMUW9vaEpNWFhKRkx0dEJjdENLbmc3eDhRYitmVGNPNlMyRW9reXJhWlBpbG9jVkZST3hFZ3U4NUZha3p5Z2ZzaGdnSlZvNW9pTUFBSVZjR2dkVXUvUnN4WmEvUVl2MjhMUVpsaThGQWkxRithZGRDcVNVMzA0VWtWTFkzcnNNOFYzdkR1OXVSODZWZ2p2L09FWHh3YndNcEhIRGZDd3VYY1o2c3dZbFMvVjI3MW9PWEhwTjRXTVBreXJoQXJEMVRHMXhlbkpVbWdqeUpyRzdIVndlUzEyaGFxVUJCOEE5a3hVYk1zVHFSZjBUZmM0d040MWd4dUt5c2V0N0s0bk5XTVVCbjRuZDR6dGh0QXBrdlYwaFRvWGw4U2krQnBWZnhDdEZmcDNnRnpZQklvNjlEUE8rTDNWM1FTMEVMVnNQUFJGYkhUMlZ4c1poZHoxQ2pSR1dGUHZYMWUxM1VDT2xxcW90Wll3bXhYaGN4RklqeUl5SnV0cmpVTTBqajN0Rk1wTkFBeWlVUmRvVW5LVVRmOXFMcW9aaG03bUpxLzBLb2x6d01Wc292WmtKTkJMa1N0SEkwQzRHSDBzN1JyTG9FVlozdG8wQm9pWXZqYUFaSGRFR1lVUXE4OWFNNkdDclhSQUtCYm5GSlJvU0NIaFE1UzlJYUN2cUxPajZ0cm1icWk4V0hFeFNJcVhRY0xOSXk3Ykp1UTVVZjlzeCtMZkZMTlJuYWNvTHpLQnlnM3RRQzIvaDVpQ0hDcE9kLzR1UlBpMERRRWNrajBYTXAyUjlBeEtyejRXMDBsZWtiTHdkZ21ZdkFlL1pVV0sxaGRFdERwTHE3VFlPbFh0ZFpUT1BCdzJYalBtUmltazR2M3BQR1doTmpTT2FJTzNJYkdGTVRsTnowdFhUTkVmYWVLbkN5REdxZWJHTUJQNlNHVGxuakYxSFRxMTREaHJieFFCRlRmbUhoVnJnMk0xeGwzVVFQcFNQYVhtdTFPWVQyUGZPSWp3MmVPVEU5bitYam1lMVQ3ZkxnZURrMFBLRU1peGp3RWxDdUpXZ0J4N2lOKzdQd0ZxUVlNclh1UTFteTlGckdMRVpNQnVGYkVnUnBHNFNJdytoajBDSjZ6SjRWSVlTZ3NvdmF5bXM3VUQvei9NUUdFdlpuc0FmV2NIRFpNUDVENkVUYVpMRGdRZ3p3SG1wcEtFL1dyUE9qVlM0bFg0a1lYM2Y0VXhwczFNQSszTkxyOXJQbHlnNDB3NGo1VW0zc0F5bnVtZllUWWZtY1E4NUJTSmR2QUwvWlA2aWl5M09IRHYxak11UnhnbG00QW5XeWdyZXpNODN3aWRFdVBaNUk3dlRUdG5HS3g3ZDJHVjFSR0NzMVJHcy9sQmxqRmtsNTFQUGVCT2w0WWVzeWJ1SnJpWDIrSGxya1RndHN6aHExendReWtNOFpNemFQZlJHVlVMaU15bTdHSDJwYld4TjdPYTZUSFRHbUlaamsyV3Z4N0RyWWVkWnNYSmE4Q0FDMGp0eFUyNnhUMjQ4MmpvSmxhd0RJR1Z4bXREaEthYVBqYlowWXFjMnM3U0R1SkFFelFYRlJvNm0wQlo1ait3V0FZM1BKWi93NFAvNGtZakQ2KzYzVm1iMXZ6V29nd3RaUUpJTEVUQ0JvVW1RbURqRGN6eG9yQkRpelRYQk15RHpjYnlZeDY5RUFPS211d0hBTmZ0YWc4SDZwb21YV3o1a1c2bCtQaGJOZTYyZlFtUFU4elpmYXg0VWxuWmpMRUdwd0hVRXhpUTdzejlaaWNDb281eWVmUkN6Q1E5MThBOEM1c3dNL1krckc0TElzZlJzM2sxaDdIWVQzUVF5SXNRRlVNVk1pRnRVMExKTXllbTN3d2pOOXZybVBEd1ZZTVJUYlYzNitic1k2Z1dtZ2h3bk1uNG5TOVhHKy9Eak1RZXFJc0lEejBlTi9LTExCeGJDSHNkN1VwZDhvTUtpdVNwWXBPTFlnWHE2SEtPZFQwaTFNaW13VDFSdmx2b1ZqMXhZQ2R4bUNiV2RId0lmbzdVSjNZTDJPWkNTVERJUHNITWpXVWdpbHJCRFFYVm9ra2pCZGE5YkRmRGxBK2dZcHNYTTI3VERxQ2syUVV4bXE5ZlFPYko1SVJOUHhiZ0JOcWtwTDNwejBLQnZyNWE4VDVodUEyWisvTVQ5b09wMXVma2hvWjZjRHEwend5VE5RdjR6dGxYMXZuQ0ZseHZJVkFIS2x3bXNmTWJ3V1BvMVFMZFhaUXFxQU1Pc2Q2Q0VMUi83OU05WFpkSXFwSWpkTCtjSVFhMXpnSCsyVEtScURJZGFZTmNRYXB5SFdxTVpLWTVFRFp0U2FYM0craEptU3A0aVZOczdraytrRmZUelFFR255RlVTQzFnRXB0L0ZBVmtQSkd2anN1WDM0ZWdBQkxrQUVHd1o1aHR2RFRtdFFUbWl0eGFSQkZKTVhCNUxEUXBWc09tSk9zQ0oxcks4UnRvaXZjWnZjSmRkQXJaRTVNN1UzUlFEZ0M5UUJUMU9mbzdkVGlsMTRKN1JPS1Bub0xyNGJMd2phcU5JNUZ5YXc0N3I4NWMwamg5MU9la0VNZHJLWGJ2aVBBdWZHZnowNE53S2xSbnR3dTZwQnJRcG5Id3RjdWFPemFCUGhsK2NSbDJUK2xsbHA2OHdaaDVFT3BaOEw4K2tHVU1QeXZmeWQxZTZ3R0NFODlWanlXVDhkWS9LWHFSNXVwR3Z4Z1R5WmhXMGdBRENPNFdPa3dNNVJEbjlEaC9SWVRmcFk3SURaWUlHd1FVWXc5TDJDRDZHRHl1ODNkbkE3L1AxRysvMW9MNC9ub0hhVWdVTlgrUmU5R2FyTTg5YisvTHMvMmpXajVXMVBPdEV5RzM1QXFhNWdYblV1WDRBdG1uMGtjOTFLTnpLd2IwOGdQazcxNDlWTHFURmp4V1hxcWgrRU1NaTNDckpNQ2NBT3pXYmpuV3d0c3BZcVZ1a21LUVJsSGVaanBiSTdHK3VrTmJuenpSakNlbzhpOU90VTRTOVFSTHR4N0g3TFpGR2pJczhMMGVFUnRWQkRBVW91S0c4bWhYcldFYk5adVB3UjlUVFR3S3hBRkFqTU9VTDRQa1Nid1pvSzA2TzRnNlNhY2h0V2MwSzk4ZmxtbmV6ZzYvQW15L0RPM3ZyMkszd2plM3gyZE9DZG51enduWjlwNmFNRE5mRkVxZUhIZ3l0WUlVVUxEV0xwbTFkSXR6ZVlEYmx2NnIzOVBRMkpzUUhVWUM1SHFwNzlRZzZGNlRGamlJbFJjaUFDWk9qS2NRVVhPZUZsRUNjSHNheHhqZVhiWm9nVDJQUzJPM2pXVVNEQlRCTEFFYlNRZXQyOWdvNXlqZUJQQXR4NWtGZXU5bXhVMDFRcjJBSE90WUtpQ3ZaV3dmV2trQ0FDUkx6ZGFLb0MvYkw4T3BZdmUwcWluLzhNK2pMVnlVSElKM1ozRU5sdVV2WlYyYmxrOFJpcFNpNDJtc245NVdUbWdKbXpYMXFRZFQrdU9Ra0c2eDg5ei9mb0NvWTcxUGwrWjBZUlIxazdBM3kvRGowYVpZL0d1aTgwd3FKYnByT3FZMEpCZE4rTk5iMHJHTFpScGJUVStGRnM1azdXNVNZTEJuYXRJREVqVGUvTzFtRXAxT1MxWEl3UEttZktoVEd2MGNxbWhLOUFPNk94VmYrTkF3aTlZcHMzYTN1N1pma3BYZGZ5YTduOWcrV0lDd0NNOXl5dGxTNHAvb3lSN1lMSHVVUHRGaWFMYjlRUkhXYzY1NjEwalBXVnZYWFZjWjJmUmRkelQ1TU5Xa2ljWVBNQnhEaEwxN0lqVDkvbHBpTTdLdWxtV2VyTDM0N3BpeUdJSjN5bGdlK2I5UXl5RC9ZVUQxZzBsREhMdjM0cCs2QXN4YjFSS0VzcUFoTk9mQ3dmTjhWc0VHb2thYWJRdHlrdzNKZ2tTSnhTTTN5S01tWjB5ZFpwWmhjR21XYmVqblZ3aTVqbVNmT29hVitmdVoxZTFuNGxMUEg0NlJpQU5GYjBxR1pqTWJiM05PSFZTTE92Y1NoNXdjV3VNMFU1VzBMRXJNMllqQjY0ZlFFbnNsL1ZURzNtd1lNQ0hzUlJ4NWFueWRMUWxFTUwxWEh0anZhNVRURndEQ3BUTTQ2bmJSVWVOUGpXMkt2NEkvTUVuR1NFTFF5THkvejZyTmJwZ1FsQWZFM1pMTTRlaTFZMWVqMjhYR3czcVlmdElRbGYyYzN4c3B1TXZMV05QWlBoVGtFd0tDS1ZVY0pwNFJpS1VHVW9vZ0tlNHdKUFlMNVVEdCtTbnZMc3NuOEpQN0dONS9FMWZ0Yk9EODNpaUVTa2wrc3hCVDMyNVphc3ZZMjJQcHZKT2p4NFVPRFdscDhQditNZTJiTDZrbEFoNW8zck1jbVlBcy9BY0luajFQMWlnTCt3S3dEaFB3REZFUTNXdHY0TjZWck5WQ1BZK2JBWnlkODBBelhKV3FTZWZ2aWVFOW1MN0tGVDdlWDNtUmNWNTJjbnI3bnZJMW1XdktNbVBjcVMreUtHMVlFc3R4NHNUTGhITjRnRE1rbUNrMFNZdGxrL1E1a3NHNThCc1F5dko3Sm8reHpIZWhnZ2prbkRaT29vTmZtR1NtMVpFMjJEaGo2SFU2emlXWTdZUFVhZW5UVkdjRURyd1FGbE5kbkVyN1hpYUI5eW95NkRmbW9RVnA0amlwd3lqbHdWM0pCT0NnZjV0cWYrWjJVbS85SlhUdnlOMThWOG5PVE9QNlppVWQ3ZS85QXEyQlpTRkFQTDY5S0RYc09jcDhaMVJZMDFtVEFRNXgvQm54T3lGU3dzdUxPZHhWVzE1emhBOGRsL0VhOCtpQmdiMEtta0VHRXNUNHdkNWNkdnUrREloYWxaTGRmWmZtUEx6MHkySkpJOVdKOEJ2ck5wREhBTHJlUmxjRnJDeGJhRDNjcldrbUVtMmdYTE1WQ0xMVW9jY0Y5RkJtZ2NOU3F2dnM0TWlxbUNLK2l5QjBGK1Bicll4clNmSlpCaVhkZUtjeVhJYU8wNU15NTcxRkRuQitWOEM0NTRTQWlCN0R5bXZjdXM3c3Myc25abzVmQTh5ZkEzTTFaRlk3VWY4dCtTeVJhdEUyNXVFOXZJZnByaXNVQVZPeXQxSnBrNW1tMzY4WnV2ditBL3YwYmFOM2hyOUJhcXJLSlZ6eEpPckZkZm16d2JtckpoWTFxYWVybEpMamZwN0dnZGJyL25RbnMzU1JkR3llNFpEb0puYkZsMmxMUFV4Z3hMVjFaUG1XbFFRYUdzSENabHRZYkIrV0UwREswaERVUGJPSUJxUy9wd0xnMERGUXJ0cmpWOUhkWTNuRVBETURpNS9yQ0dnZE9BVGx1RjBKcENnYW42SFFqK1p1eEFvZGl4dGVZclQ4YVc3N0I2QzR5WUJDSG13ZnpENzlEMXczcEMxYkwyS2F1ZHE3UGdPQzRFWjFSRnNuRmRLd2pvbWlWZ3JBNWswUHZZa1FoRlgzK0FPR3dGNklJNERZQzRENjUxNVpMRGJONTlWcXZ4dzQ0YjZBRUhrOWp1ei9wR0UwTitsdFpqa2NjZGhhZWlZMDIzdVhraDFldU1QZCtEaDVlMXpJWHVaTi9BbTFDdFZrKzg0ak0vTXY5L3YzZjVLOWVvdFVGSSs5dlZUNGU5QWtwZjAzZ1BEZGx3VW1SOWt2Wm5sZnlYM3RRWDZMNndBbis4L3YydlBuN21USFhneVFIWVRzdW50endXZjFZQkFONjR4L2hqSWUwdEVYN1hldmVIcW0yT2NMaFN3ekVPaGxEbjBSd09MdXd4WklUa3UwdkNLOXVEUzZ1SWpiRGZSNFV6TVV3cG1XSWNRVitoVHJJdFFGbUZGdFRkNWwvU3lMdzJjckJvcEhTUmVuS0xOekVmM01hY2FsdDdXZlhjU1U5c0FNM0N5UW1tVnlraVNuc2FqelBKdi8yck1wZkR5Y2lzRnozbHRNQ0V1Mm1Oc3JZTXVwbmFsR2h0UktJdTBpdjkvbnVxZEVCZGxkYXNBbythcCs2eXFlOVdpb3NuRHR1TFIrK3lTWjFXOEFUVmZZd1gwcjFqdkhBMGRBSWpsRzlEdUg0ZUNqeGYyZnR2eWM0Qno1OUhEN3QybkVpR0pqV2FZSTdvSHZlQnhKeG9BTkpmdlJlak05M1ZjRUxSNDRlWmZZR2hKdzZUU1NwaTRYaEZTZzVtTmhHRVFBWW9rZWNYTm1CL2hrV1poN1NwRllEM0tjOW1VQTJSSEVVdmh6SW8vSEM1U1FTMWhqTWkxSWN5SXRUNzJVbmt1NmpNTjRocGlOSlExZWpPZFhiTnQ1TGJmWUlLZ2I4RkM2a1Z0YTBuQnpSQkNCSW9oRXhmVjNZb2dsczFPbFJiTlJmUjBGellFSVdJc291VWhaY0NXYjUyaDJQak8xWHlMOHQxa1ZUMnkyOTF5K3V2dmRYR2YxYndmNHpnRDNFWXI5M1pUWEZNbmRzMWRybVRoeUlpU1NmOExyUXNpY3gwVjNOOU9ybEh2VXNYc2FaV2ZuU0pxakRRaVBvUXNNTnliQ0lBWUd3QVo0TDBFSU9ncmcyQnVqYVFDTVlkU0FTRGNHSk05b0tjYmxHT2crMFdUVzQyNXFlL0NmZnB4Z3lKYUFUbDAwWmErQzRKRjhlcmluUVFtS1V4UmdZeEM0QXpSaW5HYzdoTzlScEFOQnYxK3RRZFJYcll3ZUFBLzI3cGJ0S3dqQ2ovNkdHMTcwT0c4M0pTaUZLZVJTa2hBRGFoMEJPSTBoNzNsY0xXVlE2aGgyTm1nait1YTk0RWU3ZTVqNUNBSEVmYW1BWXQ0QndiZ0ZkZk9MYTBMVkhXZ3hBZlJZQjVYMjFsU0JVZGpjeTdmS2Vqb1htTjhpT0JWeWJVcVpWQnBDT2wxRVpvYzBqK1Q2YkhwSzg5SzloQ0ZRSEpwdlBqbjREL0xPTGVwQ1A1TW04WUd3TWMvOGI4eUNjUWFoblgyUSt6cW4vb2pFUGVNS0o1dWdUWUdZVUZlNVJmM0MyT1hJWGJmZmQvdlNiZENMSVYycTJLQTBjb1loeE0wQWU0bFErRmhqdldqMjZ1T1pzTTl6azliclJya2dhd05oVDZMbzFyRnFwMlRpTytGNmdDaW83eDl6Z2tBcUVPUzFHaFZYYk1YSEt5bnV3YVU2SlJMd0dGMGdJb2VRSEJzWjYzZG5ITngxRFpWT2RNQzcvaFhQS0wva09wVVpwZFY3V2trNytUV1dia0cyZC9qZ01sWjdaM2k1WmlJQTJaNExxaWlCS1RoKzlPVFRrT3dRY0laY2xqaWhiQzV2UHVOUjFJVDFWRVBOVFE3L3AyMFc3dVdNZUdPLzF3QkR6bEpmNjlGNlFNTlBmdEdzdmlEdDFPbVZsd2FKVUNuKzFNN01LeC9Ea3lKNVFSN1FFOXlLUGg0THAyVEloRGxQaWNCTk5PenprSjVubjNwaFNhN3VnV2dUSE9PL3RyRjZmRXBHQzVud2VEQTF0bFRoY1doOGNMSHk4UkgvWmdzZHFteWY0UDdhSFVpUlozbGhPTWphd1lQZEhmY20vbkNPblBybUFZd3cxb2w5Z0tnbUJDT1hkcHBYSldqaTN3MzhtU1h6Um1VeVVPZ2JtaW5SWGtSSEtBckViM2JwdEdhTlU2QlB6dmxNNHpsRkN4SUMyOU1pR1BMNjVaekoxOHhHZ3R2Ym1IbGpTMElsNTlVbkZ6c0grRGZ2L1MxK1NvYjdmYXU5ekN6eExIRmVUbjR2TXM0dFhwbVhTT1E0dXh1b2o3K0UzazNRZmtaWkFaR2VTSURhY3lVbVRMS0JKSFpLUFVYa05tR1JPU2ZlOWJlTDdzbGpPbk9Oc2FtTElpNDBLRzJBc0ViVXU1Y0NaWWdNNXZoT29kaFRSeXBPYlYzUU9RWnQ0UUhiSUF1VFlJNUxvYVlTbVFQd2tnTjVsa3RRL2lBZUFXQ2NhMU44VnliNUhBNnZVSXJrZktZSXZTMThTTWFlN0xoSTFDa0Y4RGNydldqaTh0VXNHazYzU09WcGhQWkoxMGV4M0NkcWNUQU0zQXJWbVQzeXQ3NDNyNVpUN1NTYk11N2Nnd081Q0lzZEYyY3B1ZERTTDRhVmRWVkV6azBpbXl2ZW5lREJsS3JYNllPWUJ2aFZqTHBqMzEwRHZ1U1RNUm0zV0xTMDFZWlBERGFjM1VYa0xyRXdUUUp4ZVRqMGZwUm1oeWxkU21Jdjd5c3d6cWlrMnY3YVRZWjZVQ21XZDlhdmdVZVNJUkJxVnVzb0h3U0d2MVcrek04cjk1YmVkb1pvNlNVRmNxcitsSVU1a3BSTkIvRWhGVXlpRkJhU2NEcDdVUjVaY3ljemVqYXNJd1dvYlNWd2kyekJvWkk1aHp4aGZwaCtocllZSkdBSnJvQU0wNkZIRmM1cC9YOE5ZMnZYVGxIRnErVUxWOHNuU2x1Y0luQTkwUFZjMTM5V281UUFNV1FENlo0b0VPelJXdFZtL1FhbEhqaWxsT0piVWF2WUdhK3RvajA4ZjBnUSt4d1pHRUxLMG1EL1IzN2dDdmhzSUJGanY2Y2VZc0dyMHhXMGZtQ2xobU5BdXVOdW5uclc3K3hsbWFNVSs3L21pYlRoVHl4UTFhWGdvV24vbUZIc2R1V0VXK3pxR2dmTEFLS3RtUXNNK3BLQjhUV25xOXNMRHc5b09yQ2ZGZzNMM0tLdWxNZTFMZXh3ak03c044UE8wVTVNbU0yUEhxeGpCaXVmR1dyaXdzN1ZPYkxFZHBaNmJCeUlnbzNqUVVuOEMzQmpPNVRSSURCc2JFMm1QQnJPYTBlemVOeFVONno2Q3Q3N1h5bDFuSXRlRURNRGlhRmdBQXdRV0FGNjZKaE4vNHRuaERBTTN1SXIxd2JOdm1wbEZMUHUvTHg5Kzl3OUhRalNMWUJYSVBrY0o2NXJmeWIvR2wzS2FiK2ZMTGd5L3Z2QlBtdFdhejN0ME5meHFlaUxUeTAvaXNCa0RJaFZTdFVsdWsrZlgrTnhVTVRPNEtzbGlYeTVVdFhla01rRndRajlhSXIxVkI0cHZPOVN5N2ZFbVh1eGlRTlQ5eWlEdnUvWWRkQVJJNHM1bzJJWXNhWnRvYXlKSDNKdERPY2s0OFp0V3o3T2pwTlBtQVNMN3kvTWlkSk5LQmNiSHBGRWR0blM3N29tQjhRRnE2a2dySUFVcTlXcEtnSElHRW9zelZxMlFhYWQrTS9OdmRTZnNKc2ZJaTZuT3JrSU9JV1phd2pBQzdLd05vVlNmaEJpS1liaEVKbldrbzZpRFRNaHh0a3A1bGVpbEx0RmdJcmwwSXNGV3V3V3RjVmRpcWhiSzA4cXl3Y2R6SlNaOG9hL21sYm9PMERiNEtzbmtvNVloM01ubUliYUsvMnRCU2ZoWUQ5RU1YSEFCenNXSFZ1SlRXVVlGTE9vM05aOTNnMWhUTzlmUEZwWWlBdFZ5V0NPZW9sS3NEdFhaQVU2ekMzY1U0YWhWT2psZUxVTkt6d0d1eFk1UlVOUm9ramlFMnBYTVJ4M1c0WG1kdC93WjhlYXI1MW02MkFScTZEVlpEdHdFYXVnMTBySHFINTlWdTgrZjlnL0NlbGFXbFFWQk95Z1d4UlJZUFBFQkFCQzkybjc3RHlUeHVhSytHQVJPdi9rK05hL1BzSFk2MTVxN2t6OWpyd0dwVjVQb0UxZkRQRlRjSnBDUVpURStOdlozOFVOODlKcTN5NWZ3dHhYM0VLS245OXpYam51QWhUUVdFR0dhcGRCcDZ2cUl4aW1BV0NVL3lFWHNXZUZwNGhIK0tUWk5ZRjU1NEh4d0o3ME01MDJDVldWT0RKNXFteHVOZFBIRWZGTnozTWNJQXJ4TzV0dUZ0bStvVEpHV1dsNmt3RFplV1RpekRtWG9SeTVvM3Z2d3lpQjY3akpUdHJEZXJMK0l0WE1aUExBK0V5akExYUlWbDFQVzBwbHJXcnlGRWsyNDdUOTFsSTF0Wkp3KzMwSW5ydW5TNUxyMis3Ykp1UEs3YUxnZGtvdnA0empEQTVkMlFBVGJJUnBHSkdFbnBtWmg0WWFXNC8yNnBHM05Kam5mWW9DbGZIcmorMmtBWlVPWGkrZDNsOWFER3ZiTEQyWTdSeGZGUE9PNlFZKzZBdjZoZlJKMVM1VW55S1g4NFVFdStmTmp0SmlmOTBuZFhQWFUvNFFyOENpL2RLdkMrYXZHK0NyeXZuaFYreXg4T3YrVVBwSFR5OCtXM3VmRGZSY0FtVjYzOGJ0SlhBZFN1anlDM0lUNC96b3VLRGNLbEdvbitJRVJFZzJFMmxmK2hIUVFRaGdFZ25iNS82U2VUMy9jUkUveEdhOHdnNnh0akZKSHRTVDVYdFRoOGl6Q1IvbXh5S29CVGE5dTRRcEZ1UWhoTXVsTSs3V3VTbVBzQm4yZDlFeVIvd2hoTzJqdlArbHBHQUUxa1FSTUJOQkZqWlg0bWNPdnp6aUhEbExDbm9OTmErR2RwNUJsWDNmVWdRR3F6bTEyTnZBYkhBUWRKcER5S09FNXl4RWVFR3BySVkxcmNsajI2bnNwWFB1TWt2eEhDZ01BK2lIamJLRzU5M2liRHQrM0JXOWlwVHhRYWFkOWF2dXB4dkwxcDJOK2s0RlpkVFYrS2VDQlN5eTRiVThsQnZoNVh3NGdGNk5nTXpwWTB1NS9hckJzWDRSelIyU3BPV21wOTFGU0tYQzFqb0oxNkVvRWNrWHQ4QTdmTFUyOXp1cnJJVnVSS3RzbVZQNjdZQi9mL01YVkk5Njg1MjJXWkJ2M2IzT1UxZ3FpL1hNVkF2L3Vrc0pFSWVuYXRiS05nTVVUbzhQTUg3aFV5ZTVWTWpjekVGOEpKNloyVUUyb0FLZWN0cTk3eDRZZmU3dS93ZDhDKzJSR0pJeDU4OWZOdjk4M1FneSsrSjBBRnp3eFY4RnYzQkRzUyt3RGdlZWNhNVlXU2QyT21CUzFkem53MXY5ZStBRmlqNUFzK3BCajRUY29nSUlqUUMvR1VEZ1doQTQ0RUdPWENwNEc4ZHBRREJZeThoMzhRL0UvdHJzMHdkNFZRVytjcmNFdkZjbkZBZ2FaUW1aQ1k1TTk4Nlg3OC96b09vdXdvNnZvSW45WVBSQTk4QUV2c2FuUk5SWUlLaHBlOEUxdVpERWNXazF4OFN3Q3NvWm1rZ2VlZnBKNVl1cDI4SFpzY29KOThwem9Vc3RZdFlncG9LQ2hGVWJ0cFZjcDJQUVpsdGl5ZlZsYUdUOUsxd3pBRi9HM1kzeUpjQVVZcVAxdnQ3V1pHMzZyRVgwemRxK1o1TW5lY1hvYmJzTXEzMlZXK0RhdDhHMVk1RXBrRStKblFMSXdUakFwblZYVFlXQkZhYnlxcm81ZFZMSkhJUXFjT0pmTnpUMEtiVVRQMWFmZndwMW1ncllIaUdlY3JPUnAwZDVNN2xKZWFpQkFGeW5mV0E2Y2ZvTDlRNEJKQ0RkQXVOQ21zMU4yZlpwRGRBSmk3Ty9rbFh6WnJQYzNNSC9nTWE0WVRUMzYvdHBMcVovbktqK1duL2xMUTYzdGd4SmIxSFZKQTdPcmd4QlNaU2U3OE5OaXBlQ1p0Z0RBMUVBcEZsdmtOa0EvWWhTWk9walZNZnE1T2R5QjZYL2VLNWduOEc5QmFJK2ZncG5KdlRrVzNhZmRaTjZ0VHAydVQ4YmxGSWo2YzdmQzJyckNOU0lrdThsWnVqOU9yR1hlMFN2bStaZm5jbHRFUzVWYzhOQnZKcTkzODFsbmhvWVJEM2NYYzJWWW0xY2FMRkczU3hGWVpieHRUSm12UjBzU1hnd1V2YmVjd2Y0M2lEdlRRK2tiZ2VWSjhVWmJQYlJrYkI3TjZoVE9OTXZIcWNsQk40WXorVXZpdkNSdXZBdUN3eU91WUVVQVE4azdsT2pJblFNaG1veDVyMXllZ0tpOHNCSVVacC9FK0FaNGw5RzNRU2JWTjB6V1NubGc5bVRzZmVscEREVmFkd2U3bWNuK2ZWalJRSGg1WCtBTE5JQS9yWmdZN3hwVlJkRldyUkIreFRadkpZcUJ6cjFPSHhtemNZYVhjd05aUkNzQXRac2NVdEF6Vk5uTVVvcVV1bkQ0MnQ2aVB1MDRSZWw3RHlpWDV3eC9XZEpLTkdvRFFrQllza21PN1VEU2UyVWwycFZVY2ZUKytVdVZlM2o4Y2JzclgyRy82YTZCKy9qV0FmdU1zVUg0VGFpYXpNZXRtV3JmZHpzYWhGd0RjbVdkZXRjSGJYRm4vSU5HK01PTjFRUHUwM05menIyRVhhcXNBWGlkVlpMQ01wcUtvWGVTQ1d2SW11VDFTK0RBY3locGcxOSs5QjJJcDRKMThNWnpNa1F2ZVlmVHFZd29GTUwreVIxemtHVk8vQ3QyL1daREpqUzBORWpUU1JIZnl1eGFVeENaekVRa1YvVmluYmVmUG9Zc1ROblpySGRUQ3haRnplMXFUR05aSjZPWG5lZnlzQTcxNkpOUk95NHVzUnU2dnFXa25Kcmp2bUFtT045WXFZTXpFV3hreVhLNmFxcWl6alVrMzAwbGNZT2M0R3NqZ01IQzQ5Z3UzWFVudWlCVEhJRnczNFFuRmo1amMwelFwcU1xTUw3OVhHVlExZGJkQWpQcWxwY2huZjhmaVVZQUJMWHk2d0NHeUlwUEpVakFKbkZpREJKOTFiSWl4NmhTbEZ1aVBiNlNvR1ZrMU5lQkZVc0d2cDEwYmpuK1NpY3BWaFRhMHJwWGtNdzJpOU9hUnp6RFVUajJYQzJRYVpYTlRBeFJyNm53Tlpsak5OZkpWYUI2NUR4aEtXcFlxcFJPSWRITDV2UFNzbC95NVA5U0hKbWwzTEhERkZER3pScVpKT051Y0padVJjeDNuVjlOOWNDS1M3MWROUjZNWmRGU1NXV3RSaU4xZkt4ZVBDeERTQ3l6NE5sandXU0NuR3kyTWVYZ25uRU9heXUrbDNUU1RuNnVRUFV4WFlycFpMdDZKaXhkaFlRczdtRjRvRjhmUnhoYTV1Qk92cGxGR3Fyakk0bjk2TVE2enV1a2xCWVF2dGVRQkNFWHFrRjVtbXVubDNDbldtOHVtWGNvS2x3dXl5aEs1ZEpyWlU1RUxTVjB6cGRBbFVPekJ1STRoNmg5UUxPbG1Wd2dvbi9zam5ZT3R5ZDEyeDFXSjZXS3EwZmNRNVFpdzJ5T1NvNnUzeTVvczFyQ1p2Z3BiQlZoRmZzU0NaNnFvQjltVzN2OUlWZVpKb01yeUZidml6WlpwalJSNjhuYmxFcmdXWUNxZi8vM0RWWkpiNGpZMEs4QnNEOGgvRWFidkVuTWhQMGJVZENEUjlSM3pJcXZ0M3p5dFNWaFB2VG1HMDFweVQwbHQ3VUo1MzRucVFIWEZXc1RQaFVMeWl5NlV4Yi82cWJLNHVWVExOWHVFTGZHcG1TWVlGM3FWdk11UG1iUE1aTnExVlRZY01GTkpEakIrUEU2b29rRWJEcHF3RE5sd0NGZm1wRmNPZVNGaUprWmNweEpnVjMxUjEyd1YybnhEMDJGVW5ueFU3M2MzYWVkd1NkN2dVVHd2ZWRSWUc1aE1LTkl1UVZDd3QvaklYUFJpelZVQ0RtT3YyU3IzQU14VzgrSmV0blVJRkIvNFBadjV1TmgwQ01FYVR4eGVJdXY3U2hKbWM0WFVZVjZjZk5GaWtjdWtiaUtMNXBvVTZTV0kybDkySnJzS3NhWWNGY2dudU0zUXBKRlhtMDBDQzA2elVWbklyS2FFcno4SXZEREcxRURlQmdoTVFkSDhJdU1CVkVPZ090bExEYk9ORDVHMW10blFKMnRUNXFVYVZVRkpiNSsrSkhEVW1ySnNVaVdmeUQ5d1RLR2huYWdsOTBnWFB2R0YvL0dQdHdrbGtXNnoyR1dWeC8wOG1tM0tERjJpY05tYXZNMG5RT1FCdTJmTVZiTEg5ZkdYR1hOeDVLaWozTm5KdjN4N1RHUUhhaVIvWEVLMWdJS2pLeHdja0VHOVV3WGxld0QycGhjVXBPK1k4NElBVXI0SForM0R3SmthQk00Z1BEWXFuL1NBZExscHBucktLMkh0QWduc2pGczIxYXlkdHVra1gzaS95Wm80cFNqSi85cVMvRS8xeWYvVWVjai9XaVgvMHRpVnhZbU5lUW56TVZXSzNwd0ROVkZYcDZlYjAwRGYzSFBzaFFuUFNPZ0NreThmN0E3M3RkODk2WmRyM2ZiV21pbnVTQVBkZklIeFo5anQ5REIwcW10ckp0OGxkVlBOenZjS0NXbmN2aEhnbzEwWngycUFKRGtiU2RLbVNqTjJEZDl1cWQ4UWVqWUhaaWFyRGZTdEdMMmc0NlRTYXNvN1ErbWp1TDFnWGVCckVmTFkya0RDQmx0M2MrZXFha0VXUzhDdVhtMTJtOFk3N3RTYStVc1c0ZVhkOVBMQ0RKdTc5WVQrck5NZlRtc3RWbUZpcktzYzFBaGRHSnU3T3VtSVBmM0c2WjhabDVFSmM0NFVSUWdrRXVHc1EvbDhVS2hpTFJlYlVQN1lJMzBHQzZ4eEdxbkVVRmNHUlVtVUxNTklKWlVzZ25oUXU1WTV6YU5DRG9tNDVJZ1dTQllyKzNoOExVbGNiZUFsbWJ4Sk03VlBFeitaVndwRzI5N1l4dHRHTTRFSldJWDBLVEl6eVJnOGtGMXJOeDV4citMNXd4UU9xNmIwTUt4bTMvbjIzU1RlVFc3VHNQcUpWRXg1ank5N3l0T1hJcy9aQW1hem9tSkNYWGRkTXRkNnBEd2tISzVlQjBPU0R4U1R4d1VmdGtObnNkM3FMTFpEWjdGOXN3d2cvbjljZDk1NXdZQTVhaU9EOEJhT0JyYzRVUjREd0R1Uml2anFpZmZkeDNpdDBPaFhsNncyZmpCYXpSMVFHZVZGdEk5S2ZyS09nUE9JN24wM2JEbkpXdkcrSzQvZXh2TzVlOWN3SGpZVmdSV3lkMHJGODlQSUVBSENYU0dMTjBDOUF4SkptOUFveVorMWV5cnlSY2ZHaTMrbDFGc3hzVVhGUnVndVZFZlVXMWFzYk9tU0taU0dqbmxZbHRETFVzb29jdGg2Z3BEWWx1aWxEL0ZMV0YycTFjb3c0ZDVBS1JSNjV4cWtsWEF4TUJETUFiMVVQQVp4OWM4ZHpWUHdSZWJPZUtYakFsNURJV0VZdWNWbjVCWnFnTXVJS2pnNWV2ZC92V2JKSUtnS1Q3M2NvWFFqOGVjYzE1bXZyWTR4NHhuMUQrd1ZaMHNPd2xUYVF5RkdEQm80TkVJTTcwTUQ3eU1HL2NIWkVVSXQxeGtZS0FVUnJqSzFqTS9RNkdVbkVRT1lzY0p3WHVsck5hWlNIT1EwRjVkd3JBdFQrWVlKRjVkc0lDS2J6U1NRdGtQcFgxUDYxTEJJL2x2OUV3a244NEhjdmtWdUg4anRNeDZlcTJvbGRBZGJKTTk3R3Qza0t6NG1FZW8yVlJaQzBQTTQ5L1lxS3E4YTVWVmlLa2dGeC9RaFBMNmc5WlNMRXd1bTg1Q3B4OVBDbFBsYWpic0Nob3MvdTdTMUNVVWZLVCtxNHJHYnoyOXpUN3BHRS9mY3VzMTlYdGJBRGx3ZnhwLzU3ZDVwUElDQzBOSENwOGdFUUJtS3Y3OE9Hd2szcGhMejNJbFJqQnMvNkxyK0lROW5Ra3hPdWtOcVhYYmxkNkg0VHg1c1hYVS96ZHdyM3FOSXpId3NIUXlMNW1zd2xjcEZYbUw4ZzRoNGJLTldSdmxKRVhkcUYzbVZMUHhKTXBOU0pzcGs4bjRTcEd4SDVXYVFrNHU4Q1Y2QlpxM0FSa0xLMzhSb01FY2N4Tm9FOVVGUGFTb3cwS1dmNE1JMklic3FwVTlYTkRMbk5POFdYTDNEdU5pR1FUOXU0d0RjbDJ1RTBob3orL0EvamVnWkdEVCtrMDNDcnp4Smk3L3J1ZjY4QzMzdnlVb3ZxNTA3MXBnZXNCMTNNcEZZWjNtMEgyMzNKdlFId1ozazhiNXQ4cjRmQXFQR2RNYzJBU1R2VWg0cUFaRENkQVRIRG1Zamh1ZmVOMlRjNVFBZTZkOVBzSGJzRkxrM205V2g1S3ZZYmJET3RHWWpDRDlhQi9CTlV5K1JRQ25TUytiRDBzdlRzTS9Id0xYdnU5UkFXekIybDhKc2VydDN0VjV0M1U3Q0tGZkw3bmJ2QWJwM1VLRnlpdHRuNlpwdXMxa0kvUnh0VkdEQkt2OGR1a0ZOOW5VRGcyV0tteFhuU0UrN3RERDF0OG1WRFM2bE9oN0FRSVZZMm4zYkRrMXM5eUs5U3BBSis5aEJnVEJ3SURLbHVVVVdQSGdRQUs4Ujl4cVlxWWFkcVFabXFvRWorUllVSHc4NGlQSmJ5Ly84Q3dHV2JDMS81L2YwOUU3Ky85dTNWVVhJZUh1WUNIQXVzMkdOVlJ6UzRSa05jQ3g5UjhJTkhvcktuMThQNC9qemdWdWRMN3gyaENWQkIycTJBelYwb0xhNW9qdE9ZY2prN09LbVdvRytPcUN6eEpTQ1VWWU4vZFFDZmV0blZiNWxVTzh1VTFycWl3bDRPRXZYSjlSQTl2V3FDZFRRVllGeE5QQ0JWaUFqeGxRQVdCMmMrT1gzenUrRXZlNjk4OWRaQlVTRkZKQWhkbGhEbDJINUh3NlpMTVMzQkpKOHh3cGxjdldva0wzMVM0djJXUGNtTzIrYVkxQVJvbXVQZjhDMy9icnE4TFV1NFFmeWVWb3NvYml2SnR5aFZkaFNrR0ZNWENFWkhPSVVUdGlMNUVBY2tub1ZsSjBPMFMyaE1JSDIrVnJsVjRvUXpubDV1RnYwcUZwMHAwSXZBaUEvMDk2UWh3cHBoQlBtL3czMm9yY1c4ekJod2g0RFprMG85OTAzSXF5U1NhcXFwYVdVVEpBVHUySWhocXlZM1N4RUVDbW9sc01yRWN5dG1FRE1LMmdGRjcvWkViM2xUdWg3QmkxUGZEM1k4NlZnMG9lMzZxVzEzMU8yKzVpQW1JRWx6eFArTWtKaWtYelIzZVpPeXkvUmY3TmN2UHZQNEJCVm9yK3ZEbEZZQVhXRk1IYVlweU8zTWU4QnZVMHZDOCtkTVF6NjkyMk1UKyt6VndCdXRhQjZ4UW1ZUFlFNkRFNEJyTENlTExYVkVzYWw0eFltcTE3S2wvNFZsVXArNWpGdk5qK3o0bEZIVDhWYjdxQUMwSWpEaFFRTXhTaEQwalhKcXVMZjdrNStTSjFLeXVNM01PZW1vV2RHT0hadXNFSS90am44Wk9aOGpXaXhMNHZ6VTJlazNWTm5xQVlKRUt0a0pKKy9vZW54SElzSkJWdG1SUFk3TWpyeW50M0w2YVRpWDFaeFJLN1pVVW5IZHRnUUd0UW1OM3E1ZzFOYllaaXdmU1BTQ1MzM0c0SVhXWHZIR2VkbWVUa3V2d2NSQTRZbmRpS0ZJU1pIVGFTRnpoeENxRVRvU1NOSGxnUDMrczRzaEx4bVB0Vi9KZUk4MUN0NEpXelptQmsvU01mNnBteFExOXJsam5Mc0NLQWduZUhKWUEyZGFkQXpGK2VJRFhZM2k4aXExYTd2OEhBUmdXbGEwc1N4ZzJiazJFL1RXQXRXUkVuK2hROFA2YTFxamNoV1dPTVFXamdKRktBaFJlMzRCd1h5anJUcDRsVGhMdExqTUwvNzdrQWpzbi8vKzBQME9MVFl5Sjc2bEJVMTJWNWRHRUtlNThpRzhvcHJWVWk2MDlkTmg4NGF5UkZmS1FyNjkwZWZXdFUvRitaYnoyZ2NlaUxTblg2Qm1Zb01OUk9vMTVsaUZVZ1NaRFBFcnFlaFp6Vi92S0tpQ001UCt5MGRzWkJBMk9WdGJydHNrTmJDMWZ4NVQ4OXQ4Mi94NnhsaER0eUJob0g2R0JpeGc5eUtDTTJaOWtWNEp6QXRMZG5vdUk1TXpNanpwb0ZtN3Awbk5MVHIydWhPQmNwaFgvY3cyZHNFdkZOZEJyVlAvcVlJYU05TkNUOVR3b2VBcFZRcDM5TWZ2bVp2YktXYTZHaXdTS0RMR243cGtRMlpHQlM1dmtNWTFJK0NYSXhhY2pFS2NqRXE1S0lXWHk2eWpUVlBnb2I2Mlc5VFF3MUxFUEJoT3d1dkJCWGwzZmdLdXlPcmxZbGdrS083d1UyNkZmeVUvcndPNTFUZ1Z1UHA4NVQvYVMzNE0yWEIxN0VmT1JQV0lJRDVSZDV6c2hmbGNNbTlNNlJ4VU9aM1lKYnpNeXdsakVzbkU0UjV2YkpEeHUzUmpEVEkzUDA5Qkx6WHAwN1A4UDdWSW5EZUh6akNTZHJONjQzSjMydk9RWWY1QUFNTkZpVUVJNXlqZ2JwY0JYT3BIL2VWMG5aVzhlM0lKNTFLSlF3cUZkZXBWS3MrNUcvSGw0dXEvWThTT2ErOHdTZVZvZmMvK0w5cStWK0YzNXp2YzZjNitGLzU1V0FGWnhXSWN5UGpUQVRaUWx6NnVHMEVNVUxqQmJwOXJ0MlpoVWdTdkFMV1E2NFFmU3FQY3N0bUpzSzRYTHd6cTNZRXViYllrbmdweTdlanBiM1NiQjFscjl4SlkrTkxtTUhibC9aOHVpYktveVZIWDIyNXJ1bEpBL0lxa3E3STVsSzBsTy9wNW5SdGtTYjhvaS9Pd1B0TGRnNi90TlpZMkFhZ2FJcDJkOVRHR1AwNERBc2hIejZxVUxEMFptbWtCRk1vc2x0OEd2Um1HU3pVeHZqczdGUk1mU0JnTno4d0R3dWFaRThUVnB1VnVmeXRDeURvdXZKeWx5dFBXODhFcHRqSWQzZnNnV2xodytocjVHTUs0bm0weWxZeC9rbFZOWVFER3FDcWRhV3ZxZ2FJQnNjelhXRi9IVlpxckJJazFMQU9kc1dYWG05NWhUYUlBL1VGK1ZuQllGMU5pRGZxcTRlWHJWR1RwNGFzY1NoYmFueDM2cmFzVkZaRkZ0Qno4aUtGZ21PYisxUlZNV0ZLUWRrQWIxZjRYWVBTTmozcXlUNzdHYXQ0TE9ORWFqZ0xtczc3YXM4a3RkM1BmSURiM0dYOTZ2YlB3RFJwMlFQSEJBNmM5Rk9XTks4cFcrV2ZoSlNwQjNzVVByMzhxYW95b1RBOWhON0lFOHlBeWtBb3loUEtMeFZDQnMyUWtxOEgyQ0QxOTZmdDd5dms5M2U5YmU3TDdHK2J2L0E3TVdvYVZaV2ZsNmt6OU9Pd3I1WmYyZXZTdW5DSmtPSHR0bGtjbjFOTlViTy9rZjJ0MnQ5UXcrTkpiMTZuTEJvU1lQcVFYNnhnTk1IZStreWxDZ1pRdGhzZnBTNmxieHRXaGlaVC9jc3c1bU9OTXh3clUwMTRKSDhUSWxYaGpYcXdRWDZXWExZS21XV1IwQjZZMG40M3BEVEppZ0pkY1pjbTkwRVd4S3dXczhhQzI5d2xPMjFIZE5xZS95eW03UWluemM3YTJhVDI5U3F0WXFQSTRsSUlmTFY5OWpyN213Z2oxa0UyN0lid0JmcjdjVUVjbi9vdUV5ZGY5ZFVCSDU5bURKK0xqN09HU2lpeXhiTUV4NnJ4SkVoWVhnOUtvaWVMYUQrTk5aYU9iM3VqbWJqN0hjTFhXaUsyZmFNODVhdGNNYkNYNlk1ZjZlZWZHSDVybGFiNVJQNVAvejFVSGtiRi9hLzZoYmZPcSszTTZ6Qml2UmFvWHVSK3pObnVIZmJZcUdDMHdQYm5yVHhYdmwzd1dQZnpId28xOFREcnAyWW4yUzRGNkFhVlBLZFF6MDhGVE5SWXpNYXpyalQ4WnY5NkpRNkZUZkV6TnFWdkdiYmhHUlN6cmZxRktjK3YvRnFWMlVrSEMzNXR1S0Jod2YvKzNpb3pMbHM2UUFteVVmUWd3Z2RxSkNUb0ZWblNuQkR5aWdreDEwSEFvc3gyaSt0R0JpYk5paGQ4Y0IybEJGOUQxV2hWeGR5QlQvMURoVHp4MHJPTDRUbElsbkh5SlZucGQ0ZmFuVVkrcXBHS1p5MG1QaXJkbzV5Yi9LMmYrcm9FQU9oRDI5em5vYVNSWmZBdCtjMS83UmsvLzYxbmZQQXd3amVlZHRucTF4N0V5RSs3bkJOMDB1WUxSV1ZjdzhtSFBVVmtQL21vQjRSOVp2bkQ5OTJtdEVRUXQrZ0w4NldHSkpWZlJxTU5hK2FjNUgvM09GbzR4UmIwVEJzdzVRbXpYdCtnODM2U1hIR3owQURkb0k5MGJ1MXVwaWo2eUY4b29DdzRDc1JKL3RwVE9rRnVQYkE5VzNDb20yTXNnY0EyL2dDWFdpTVRmbXM2YTd5U3FOQ2dFaGJWUC9zTzlQZWtRcVRTTDdsTnZpdlliTjlDcHlJMEdjQThGb0M4Z20wUENxeTV3YTRXT3k2UXA0SEovdUp2Vi91VEhkcCtOWEJLYVVBaUt1VnUyVkFOLzRnYThBQVBIVFhuRlFrMDN0bDArOHRFeit4YnlVSlZpVUVENTB6OERvOUcrZzBnNlF1cy81eHlnNFdjVnJGTmRUT2ZzeWl6aDR0OEh0eVRFdFJUTWc4cndLUVZyeXVBelovOFhJQWJnZFRSMm1SUkpQbGVpRERxS0NPWVJoa0hBMzdrellEcWNjVUM2aENiVUliM3gxcWE5OXR1REl6WG5nS0FDemJ4ZFUyNk5OTkV2UDFLN2hzbHo1Zi9iSGZFcXpnVlhaZVBVczd4YmVmZktIdjNXWDFmSHV6N0c1TnZESGY5aUhiOWV3dmNOTFRyVmJMc1lNRldLck1NVlovZjdWeW5XQ3ZnZWNMMnBnbmxYc011MEdkY3pXRi8xdkN1N1E5dWhDT1Q5UUVqWlJoeUxtampUNTRoemRUR2c5aFdSMk81dUNCalFtY1duTUhTemhDVU41ZTcyRVhlODI0MnRnTUs1YkkvUUFJazdmVXEyZmhOL2Y2TW1mR2J5LzRvMEpDdGZpeFpDUmg3ZndVeDhrOXJxNThoZ0U0N1pSOWxGZjNWVzRyalJ5S256U1NnUFJpL2lUYXVxdndlVHo0UmNFdUxsV1ZnY1hLci9WYjVtYmJNMTBJWEhTWGZYM2I2dlRtbHZYa3IxKytwZm05UTdsa1NoVUhDZjBSTC93b2hkbVFBWWtyeGRlWWdzUlhJU2QvRUlMTlFoN1lNaEpiNmt6aXZYVy90UFRDdkRXSC9kZEVJYVhqYTBSazY2UkF1LzN3UHFZdGpxWXY5UlBqTG9FVGpWL2YzMlZWVTQwT2ZHTmdpcWphL2xxOGpvNUVQZFBqWitJNzVnenUrVXYwdkhPbjRkdThKUjM5WHRBY1AveTFHdk1JZTJQR2U5RlJsZkpWN3pOdmhIZHJoei8rWVBMTXZmNnBraDI3SWRJN1VydHJFZTIvUVRWNEU4VzN1bzNhY2o5aVpPYTd3UFg0WXJSMW5hK1JXRkllZlZTYk9aYjV3SHlSbk0rRzkwekoyNUxFL0dRN1NTSlNjVGkzVlh3aVZPSUNUQ3E5cnVvSk5vYzJsdG9BTG5Gd2RDVmVkYUQydytzRXkySngzaGwyVTVnTEpmNVNiaGltMjFydGxSeU1xQ055Ty9yMTJoMkRKZjU5SHpubGlVMVZMMlNQVjNOa25lRlV0K1ZmdUhBQ2J0VnV1WEZaNU5MQldNNDZ5dzNadVRUaEs0YTFnQXh0VUVGaERMbDkzT0YwKzB6ZzZZNHZKMS8zdDN2VHd1b0lLRWVzcDdQTk9MQnhpQlZEcnBpSGdYbkJ0M2FvOHcxeC9aYjJSQVBqdGoyQXFUMWNzK3lZd2U5NHRscmNLUWZCeTkvYzA2Znl3ekROOTI1SGpZUWtEN1AxVTUyS0tuN004VHlPeUFMc2I0b0FHL1ZjNGVaajJTSlVyRS9uL3VJTnIyM1lCaDZHUGhBUFJaeDRKUjl5SzQxb080aEhwMVAvNlJtREM1RTh0Q3lkYld2SkY2OGI3ZkZCczBOOE5WSmxuRjkxUFVZREU5MVoyT0k3ZlN2NThRQmRwYnhmZ2NwRTh4UkdabHo4cW00V1hQMUhCWDV5Y2ZBZkwybnVwKzZpM3c3d0ZGeC96N3R6dTNxQmNQQ1FvTkVUVi9rUW1VbFpWNVNYblduMG1pQ0hZTEdzNytZVm9RSlE1THZOeEV5SDI4NThuL2Fqb2VvSmFGVG9TWVJHL0VZTHA0eUtSYXlFb2prN2pzcTdEYi80QkJWYW5ZSEc5L0J2VmJlN1Y4dnNIT0ErNFNpNis5NkFNZG11cGZ2WGdCbU0xc0s5WGZvOEJ4VksvUk83UUpuaDhOYmM2MEhEY1gxWjVJNWxUTXRJTlFleEpuSzdDbTErVHlNWXFTbDU2cmNwclY5dTFOcEg4TlZhdS9KVU9IeE1oNEhSZ0JjQW5ZSmt3WVgyRlZEeVFBY3ZyT3Y3VThDZEtmazlHaXo5Vi9FSFNvK1RUbnA3MlA0eDZucWoyZlkwYTl2d0VrdE5ORUxqMEpCL3Q4QnovcVNxMUR3TG02dmxVbUg2OHkzVU9PZk03ZUNwZVNnb2pnVEFmanFQTElrbE8rMm9rUU44djR6NTRDRmZQdW9kYUZNK21WUWVwaHkxVGVlVzZlSmZqek9kdVVhTTFsUG4ybDk3VUhXbjRMdi96WGIvaVNiYzlWSkV2bkhvVDFGUThNa3Yrd1dkOXJUajM0M2Q1ampkOGhqbkZBOHhpNG5UQW1EZ2JBc2JGTkxGY1NsWm1xbHZZVGt3WGZsRGF5NGp6d2t1bzBJdnJ4d2V1WDliRkZQRFM5Qy9iL1V2T2lkMTVmSnM1ZHRxOXFuL0VTcFNocHVRcXRzeExuVkUxZTZqa1Q0ZnFkZWJZeUpiZ2k4TFM3Y3hCMkRYMTRlcjd4N29sQWp5RDMyZERva1lsUDExY1RIUUxSZkdFaFF0Z3BYb3BpNjl1SDBrZHFhNFFRYXcwUURCOHNJKy9Wb2g3TkxCNEJ5M1dleDNITCsxV1BDQ1haNUhMQTNKNTFwTVd1dXQzM2gray9lQmFJZ1RhZWNNaW9oMnlZNTFqaFRMKzdXOGhWeTJvb29ocEdVTVlpdVRHSEZTLytpZGFEVUdUVnF5cHlEbE5aa3dsL29aRDUrR3pkZEQ1d3NMQjdzaEdRVy9xZmozNWp5Z1pPcUhuK1g0WWhsWFhjOVMySUY4NExVZ2IrTDduVldtUDlwM1AvVnczRnlFK3pBVkw1ZjZyZ3RTWm00ZDdtckxSR1hjdS8ydWtGQUJUa3llQ3dSUHl6N1NnR1U0ZEt6UG1aejdIVDJLRWQrUW5qeVV3L2VXN2IyR05lSUwwWmZNL0ovZXU0N0x4VDMvcDUzU1p5UFdkeTdJQndnVk5hc2U1cUJQL0p4WG5sYlBXN1V6MUJQamIxcTJNeXhXWHI4QWZFWENkNUIvOStONlkxbVJZZVhWczF5NURSK3ppMFkyM0Z5blljY3lISUJHYTlKZW5oVFV0MGNpL2Y0WXNHOCtZYWcvdThONWk2c2FkZVhEaGc2MnpEZ0NHcHVFNUdjMUlWSXVpS0l3Y3Z4andpZ0RBclpYZ1B5VmwvRENLcXZiQm4rS2p3SldQYUw2UUx4MFBkamJwV3B6ZnRlempVTlMwdE9TN0FDRGc4cHRQeVFWU2hpNHVCM3J4UVZ3QWwrODRicDhzNE50SXBrbWd1UURTcytMaXlzTWZ2d1hHdUQ2SGE4enBRZzEvR216R3NVcEV0dmcyMUlZV2YzazV1STZlZ05GYy9vL09YbnBBLzFIbERiWmp4NWZWN0kyZjVxZEEzTzg3NXJ4aHpyaDdTUXpmelBmNWlpOHR5YnZIVGpqWGQxcXh6Z2hkYWZNVHk3YWgzMEJSN0lad0wxUGJpWHl2d00rcGt1eGZvQ3pTaTY1ckJ0S085UG9JaHJic3NyWUxlWnF3N1BEbXhXanh0TU1lMWdiSHRBRGdLVXY1dnFMVmU5QXFEbWlEQS9MTkRHMVNCSTBYRHMzeXN2MEdxWFdtcGNxTFFzZWEzM25jVHNjdkF0UThxL1htVElBaE4vTHZuVGx6elI1dDg0WCtSMzlPQ243VW5CRjNaQ1IwUjRwbDhoMHNHOThmOFFvMFdWakFPcXBGZFh2L2RSUnd3OERlL2pPd3lFVW9NU0RLZ3ZRTVcrbDd1S1JZNFArajdsM2c3Q3JMYy9GMTMydlAyak96QWhGamh1cmFXMXFEZ00zNUhRVkVsS3dSY2dFcTBhTHQvMXhwb1QyZW5jRXlTUXpXRXpLREJJeUtHZ1VSRlRFR01JckU1bmdwb0FpcHQ2S2lZTlhXdGw1UVViRktUYjJpQXZtL3ovTyszMXByVDJaUEF0cmY3eFRON0xXKzlhMXZmZmZ2dlQ3djIxeGJQNHkyam1rTGRZRGFNbkx0cVplVTBVYTdpVGErcER4U2U4SGZ5SmpMNnl3bkhFeGUxbS9jWEdBM3JkTkdZY0F6TnNYcytyaTFTWGk5cWVvYjY4cVhWMjlXWlJESHR5bzlkTG5McEg2dmpLVnUva2JPcEV0bU9kTWNnMUtHeEJNcmdwZFVsVDEvZkhDeHY4U1pNVlFkdmg4OWwvaEJtS0QzdUdhaWxWUTV2R3FQRENSSUVtbllPZjJpbzNWUXRiWlV2dHdzdTJTaHVBYnJvQ1NhT2grNHlmNTZ5YW5UR2ErVjRmbmFzM1ZxMVlYd2N6Z3dWWk9DOGk4SjdjeEdBTWlVcVhFMWRYV0gyWTlaNEllNmUxNHhLL1VOckg2eWhTTXVacWcvRnhFV2NSUHJpTDZyTTJHYTI4L21QajN5eXkzVGdFWkt6OWNPQjNxcnZQcVNSbmVtQ3VTWVNobHRwK2ozSFpIK1MremgzREJEelpaTStqQXF0TzNVM3kxNzZCWnNvc25NTHJoZmptUlA1NzVPZ2NJVXhlY3FRUEpvM1FuWkdJMEVQWnA0TGdPb0NMYjAvNkZHeXFxSWRqTHpseWtOUUZvaWFnQVdHQXhGc0xIclFBZEFyYXZ2UEU4WWFJK2NNVEQwNjluRnZpcWNZZWs1alFqanN3QzFMc2lZYnlyZk1kTXZsNjVCK0xiOVBwNFdlT0s3NVBXU25tNnlSeWxpeXMvdTlUWXdBRzBqUjY0NTVHS2psdTlyOFM1TDlnUU5VYW1hSjArRm1MK0MxaUw3SS9Senh3aVlsR2dsdmpwZ1Q3NUNDaXBPZ0V5Vy9MTmNucXJzbDV5UHpqTEJxMFQ2TUNLY2ZMdWtmbU1ET05RSjA4WXZNelFTNmVsZlJZWXI4dC9sR1NzQXVnK1Z1aUh0Z2JXa3lhN0RuVkRrQ1hKWE56TGdQQjVXMFRXWmpUbDZ2aHAzUVgrV2c5WjZUOWdzSG5JZEJTVmg3dU1EUzEyc0ludWY5bzlMTkcxSFROVUFMcStudVJRdjc0cEJEL1B5SHJrOHRscnZ3VmpreVhvSkRXWHBBbllNcnY2YmNGUjZkUTZZTExPQlBCN2RnY3M3QTJqMGVIbGJvRmFQY3JrM1VCTlBoSjhMeVBqeDQzSjVOdXRKbmNxSm1ucTV0UFdQcVR2RDNiMkJmUmxNL1FuaE9acjZWVFZnd0NWRTZWTjYrY09BakQwdTd3dkE3dlB5cHpFRUFKb3EzT05tcXh6a0tyNnFSZzVvVmRNU2g0bXJGeHFxVTVuamdLSDZheDBxMVdJSE5pS3lmS25LNGRoVkxWdWlKci93b3ppZXRKa0JXMTF2bDh1T2w0SFN5Mk9QbDRFYU5rcUxxL1l2aDdHR01pR1VOTkM5QWlhcWVua3E1THJXdE9ObG9QVHlUQXJEZWJuMmVCa292VHhiUGg1b1BVK0Via3RULy9oNEdhaHFsQmFyYmdSNXpvRVFSVk5mZkR3cFQxeE9LVEtNVGFVZjJ1VkdxbFo0K1RKMDBSOFhqQ0Q3VTJ2clpubWM2T1dzOU9wdFNUVmNnODNMbWl1cjRsam1MckZURDc3RVZtUGNVazhJSTNrbm0rRGdtMVV3eEdHa242OE1GbzE3MlRhaFBNRHo3RXRnSWp1L0RhRlhmczB2dnk1MDE4VHg4cFpDa3dFajc1cFhMNmZGak1ITmxMVEpLeXQ0WTdYWVZGUzVXZlZtcDlwSS9rWUF0b1VrYWIrL1FlMXFNOExxeW9rRGg1WU5ERmE5Z1dHd04vUmFjQkJ0YmNEbXVhSDh0cmVoRjVjN1hyMWNTb0RWYlZMdXVIeTVXZUEyc1gyanlkZktocmZIUDBGV2JqVDVPcm5lTHRjcnloMnZXdzZZbXFvYXJCTEt5N2ZHa3ZGaXliajhoT0JFdVh5RjZrQ1hsenRlc1Z4amd3KzhjVG5ld0x6UlJpR011TmJJTlUvcjFKSnFWMVZGc0o4TnZhUjhteHdzd0duZER3NWtBRkpYRjBPcDhRVURkcHNISzJLNTNtdTZEQkJFTCswSmhkU0h2ZmwyOW1vQ0J5QjZER1p1RWhTNGd1VmcyUUxvVjdSUndUYmdrYnVxNjlsTGJaaTR3QmRLc25kVEMweUJBQkpqWjFsZ2lzU1Vvc3llRU04UDhHNCtPMXVhRWs2dnh6aGlFT1IzQTl0WmpRSE1wdTRCNHQrRHY4N3M4VDN5WG5WS3QxZU9WaUlhblRtR0lHVk1HVEJhRWxjSjExQUYvYTJyb3FrdFM2MHFVYytGK1ZvQk5ydFZ0QlNjdU5NL29BbU5tZFRFTE9vQWJGaEwwWTVPaXd3R0hRMW8yY0RNWllUdEpJd0xvaExDTnJpckdnWERuZkcxWGVpQkFNYUNxQ0dpczlOUEFyUEdZQlY3Z2FWQWxJQTVkeWw4d1dRU2w4QWN2d3hTc2Vqb2tPNEVNYTZZZDhEYVIybzNpbUFrdFdtMDczcFZyV2tpZmdZQUhEQ21aaTJRMHJiQ29zSlZxbDFWRTlYcmVaWWNGeTFYeDhMVnRqVmZYZVJMKzVKaFVyczB1OHZYWXdhTHZtOFcrYUVaalV0aFVyYm5YWHBDT0J0b1FvcUVWQkkwd0FXV01Qb2xmeVYybmNoRS8wZkRReWZTRjZFUm8wamRtcHhvOG9OQUxvWGNSbTRSSUNMaWgrUUtSUG9NWU14OHZHV0ZYWG9DSno5OFo3UXNTYUN0TFpaUWdCK2RLZGtqZmhCc09YaDdlc2tCTGVxMTBDWlZMMmd6MElBaWNXMW41Vk1rdFZ6ckEwd043RlBTK3NIcVN2bW9NS1pUbzg3eUNRK2VHaTF0TVBLb2U4ZndndVpyZDkxREI3Yi9IYjRhcmpuUEN1eGtrT0RKZENKOGNhSk5Vd0RXVU0reGlNaVJnYTdpWHRMbnNrdzN1c2VlQWtzeWViMUxUQnVKUWxoWDZaMW0rcEtONjQrZkF3U2Z2U0hRNlJaQTk1TWptenB4OEg2eDNrZDZYeTRoT0FHVFVwZmxTTDN2WUs5ZDE4Tlh3K084eDJ0aVdOajloTjYzM1AyVDlENXo5NGZyL2JncmRLbmVCKzcrTUwwZmNmZFAxUHZFM1IraDkzQk5rdDNZRW45SEUzMlg2UWw2UCtydUg2ZjNiWGUvU085anlEOERFbnJzRW5BczhBTlYwTGZnT0kvSmlPSE1RT0k5cVg2WWI0dU5hbWV2eVpQTmZWaGs4UGFKOHVwbUlzQnJ2a2p6YVcraTljeDFXQkc0REtrcjZFanM3THc2QWtlSVB1MWtGL3J4akdQMVpOS3RvMXZrUHNZR0lsVmpscEV0aGpNdUVwbzhSOWdrVVVPRXo1U05DOXRYMnBqV3VxYlN4cnlXSmVXd1UyVkt5NGFibmNSNTRXQ2gwZ3RSVGJ2YlVIamFIWFJxdlhCRDRWVTJCT1dTQ3pka0xhOWNCaExzeWV3a2Jpd1JXVG11U2R0eUtJRStLanRGT2FMOUVWbWhRU0lQZGhGZWZuRzhsQzliZ0JiOFJQYTIwSHVMS1paU3RySHlnWHFtY3JXdGZpMk9YME9ZU1orS1BCbllrN2hCek9nQ0ZocXJBQXg4bG1VZkFDNG5QMGVZMDZqUDdsNk0zcGE1MjdmT2x0UHJyRkVUelIvVkM1VXJwOXRKNmROTWJSWmo4RnJxSDQ3cWtyNFBZWnpkUWlIcmlNdUlqZWlNaVo2d3RlUFQ0T2NTbEI0cTd1QlpyR3ZJZmNFZHpxbzRNUGk1NXZFc3RmNkR1UTVpM21sTlJGR0tIWjZuZGpvMmlQay94WU5RbmFyRllPYzk2UHVKS1FUQythRTF6ZVl2NUloeXIvRHpTMW9VVDVSSEVraVRxalFvQXhiRGZCVThVNnpPcThINXNNdmt4K1Z6cjJoTjlBZ1VDYmhrQWovNnp1YlliMExwSlFCcHdDcFN0MitVbFArRExrTEZWMVVyczU1dnNnN1o5UExYMDhKWFFUekI5eFV4Tkd2aGNGRE1LSHUzWDdud0J2TzdycEpPN2ZSVlFNOE9YY3kyRzI1bnc2Ylk5VGtXUmpkMFZpeFVPRkVpQStWSEovL25lQUFKbEd4TVIrRTdjYTcwRWxRaXNVb2txRVJDK001ZFB2VnBPdG9kTlJFSjF4WEI4MGc0cTBHRTdNZVNvcjU5TW1NZ1k4dmZFS3RTM3plYjEyQ0todEFPS3RGVkdvdGJ0YzZZYkZGZGFUamNMNk1qdlpkL1BZYmh0R2ZRQ2VQbVNpYm5lUitiV2tERFVVWVRrOFRzRGJXM1BYdzJXTS94MnJxRkxodEE0blRlZERKSHBnWmtXNjVxZ2ZabkxkNnFxeFlhbUp1WGZ6WG1KdzZvV3J3T1ZUUGYrNWZyV1cyaXRUazFBZ0VrLzZSR1lWV2pjR3F1aG0vT3F1S3c1bCticzdUMDB5RStYWnJZN1V3dVdKU0NNOSs1Zm1QcjkxWWFjcWxON0VaSnRqZjYzQnZwN29LM1Q4dW1xc0tPYlJRR1lSM3NKU29aSGgvT1NYMzBIM3VHYmpXOEdkWEZpVDM2emZFb1R5NTR1RnRoQVdXT1VPOTUyU1pzcW9CYmxYK3k2WkdBd3VER05vbmpna29GVWlxSmRrb0xKdSt3NE9oU3BTWWpUbnVpRWdSTFZ2ajVPNFhCNkhOa1d5UmhtaTBBRnc2TWdSTlpXUXlwWk85aE5oZkJHc3I3M3RsV0RhU3NETjNDd25YNVcySldWbEtrUzZNS1hIaitKWWdTZ1ZBQmIzdFFRM0dmN2pqeHVoN1B2RE1tVUdiK3hUYVhQdGl1K2ZaUm9qV0RBRW1xWFdmK3J3WFlGMUpkUG5UcFFSdSsyTzZaNDFTZ0xvQnh2cE4yN3gwbG9mV2xJdXFhV3pSZlVXT3h3TVNxMklPcXZXWklGYk0zQlg3THlVdWwxZklsZk1mcG93MVZvdnpKdTVMOGhqYjJ1QURMMDBqZ3lLaGVHQmo3OHR6Wjg3V01BVTVvcTI2ZUx3SElHTHhBak5pb2ZBcllSS2s4eHRlMm9oWmZOa0JHWkFVQW9PUkpWUVlSOUczWDZvVjBuMUZpYUVLRDdaWGVLdk52RDFVMDRjbzBqdzdkQXpuQlNPTExIaEN2NFdhb2JlTzU0cGx2U1pDOTJEQ3QxWERCNnpubnJncFJoRDB1WGRMRHV0RER6TnpKVWN1SVBmSjJlV3hyQ2V1b091Z3hKaHBEMGN2K0p6L2sxbmVBSlF4MGhqdDBDWU40QVd6R3NHY1lLTit0QzdjMEVUb1FyY0c4ejE2cURRbTAvbzJkeEcwV3pTOUZjemFTd1ZwQWZxRWZWSjV2WUZHR1hPUVp1ajlhbDEyRHM5YTJYMjIrMG5DeXJFSzNNVVpxajNyY1NnclYvUExZL09wMkQ3Q1BQcGR3SFJJT0t3K2lrUVFMa0J0M0VaNCtrZTlnTEpPcnZ4ZVQ0QURIaHRTZGJiVTBQbTVWMTB6UTRCTmRIcnV5TnN6SVBxWHc3QXJId2c3czZ2Wjhta21JUW5VZGlVaWwwYzNiSEd0bGdpZ2pSOUhnTkxlMXZhamEzbDVyYWhSZVZuQzZXYVZHNGZRYjhlSHpDSE9yUkVuUmxhTXQ5aEdtY2FSeVFzTUtsc05GT2lDeXFSeFdRVUdicVo2VGdFQzRtSDB2MEdOWHliVkhRQldZeXFwZmhpK0J0dGRmWC9qMGRlOUdySDlZUnVxTUM3ckExeVJ1emNsR0RJd2VscWNidWxlRU1Lamh0QTdUczNVTjFvanprVTVvejZ3bE1TeWJ5bE9teSswUFpZN3o5TXVYWTJvMDM2SkpsdStZN0Jpc01Jamc5Y0Q0YmdpbGdGdmp3VjB6SHl3VG01MHZ2Rzh2THBkdWFuNEt5Yk9QaE5OUVZkSHdhMU01T3h0T3J5L0hCZ3NJdUZzbTY4dkZnK21vWmFUN3kwVktnb2QxWmJLejdXektDM1BoOThoSktvbTZyOFZWQ2ErN1FJK0xnR255WncyVDRGNHUyL1ZacXJDUWx1YzN4RXV6N0JhdWtYTjFqU2hWb2phY09MZlZtVmNKSTVsZjRWa1lrMUwzWkVEYjhQdkFWa0I3eWkxWUdlcFU2cS9SV0hZa3VkWk1rTFgxTitxTTI0VFRHUk5ONmhYbTF5VTk0OFlDQWpjckdhWnFUQndER29FRSt4UUZCSWFMai9YenU1NG1kUFFuclh2Rkp5Mmh4L2g3ZkRsWkhLY3hMMUZ1d3RsSTI1WDJGRHFobDZ5REhMT0l6NkJmSUlickR5b2VyRTh5WHo4T3pBS3dzM0pVS3N3Rk03ZldxQlJHT2hsR2dYU3Z5ZDhkRzNNd0wyQkd0a1k1eXBmcjk0TjFqa0NVL2d2NjRGb2lOMGJWd1lndll6OGtlNDgrWjV1ekR4MlV2YkxhejIyN0crcDFpSFltNUJCUnNlQzNXYlU5dHJhSE5Lbmo0Vy84dkhSQTREb2dZT0I3N2h0MUJ3UjFCOHc3RU5tZmtlRUlWN2phS0xQUWk5WXgyRTBvOHlZR2llWlg1WHFaMG0xUlZUMlBxQmNJNWNyRE5kQjVScWhwVjROL3Y2L2MwUGpLKzJEeTVtYXg5bXVxV2RkTWRIWGhxSHVITzh0OWgxYWdaNWpTbzFnZVlVVUVjY3ZWYWE0bWNwSmhKek9VYTVYSDZqaTNGZFk5WGFwN3RNOWpYbjNtWWl2ZnNlTzZkT0pzUjJDbkVWWXEvcDB4b2RGN2hPS1pKazZhUHcwWDhnVEhGQTZubW9qYWE4QVhZZUZyckRCQ28wQU1kVm8zelVEWkNFMFY1OTlQRlRFME1OL1FRQ2JqMVRSNitOazNaY0dVSVhMSWdoc0Zub0czQ2pKOCtlbTFwdGZMQ2t1bjE1OW1FV0lnQ2JneFpnVzY2bm00MTFJYXNQbGUrUlFtV2lRaTVZRkE3YkZqVlVRYTZudnFoS25aMVFmdDRwMncwTjRWRHdJa2Zham0zT01oN0gyc29vbEVHV3hzRzZxbFEvL25XQ1lLYktOUUE2RHlGa09NVDBRSVdjZmZrRlUwd1VWWmRxaVJIRlVkaWd5VUlnNHdKMWtsTUxQME13MjZMVWhmaCswcFJRdmNzUStaeTRhRG1XQmlDeUhWN2R3QWJaUThxUmdGVHUrTGhRRDFYUVFCWTd3V3RLc3NUR2lVNzRrcmsxZnVOYm9nZlVybVhITTFBOXduTGNvTFJPdDFBQ3llT2Jwa0NaS1E0djBuMUpJNTg5OUZSVDhZRDR6V0VEbUxuVFE5UWdoRnFyWDMxZnllQ25sWGtYQk9SZnl1QTBPS2FLZmY4MlFYMFBQVk1HVEI4dlNjZlNXcjFsblVxamlpaGNRdTJlL0JHdHB6SnJrZTZQckZwYnJ6c2VFcjFYNzZhOEhCK0RrbnVQRzRmd1RnSExtWllHckNiYThTQ1BpTjRmVnJ2bzIrM1h5ZENHNTA4MWhpWjZzSnZaUTJoZURCWDFsWlVvVUVBVjNpUEJueUQ4Vm1Ta3dDWWhtQVh6MXpBWTBVV1NPbGtraXE5OWVLR0pncW9sRnM2RW42aVZwWVltcFl2Q01EaldyRzJqUlB4NDZydzJDaEZMZEQxdzFsaEZGdC9qNmNIWTJ5cCttMExCcUlkelNoRDBwYmduNTVyeXdFV2F5TFFZbWNXTXRHR3hZL3VrOFh2aHJoMkNSeFU4VFBiNVZKdXVPZ2R0RllFSFpPRzFsQVRzRUlIblFYYlhxQ1pmcUhLU2ttRzVZUGh0RUVMYlNHZDJSRFhnUkU5R3JHQXBsL0RXZmZEU3J5eVI4KzBZSzZjcGdjb1ZZRjg3NzhKaWdVVGk2TnlsSlhHZDJUUTNSZ0xzVkw5Q0IwcFMzbS9oZHl3N21WemZYTHJYOVBiWWRmdnZYbkE2ZzV2dmxzY0ZabmxXbHpwd2dCM2VBKzBLSEZQL2hlSG9pNnllRXNLQmZyZHVzNzN3bHkyRVNIMFprVTJkS25leWhySHhGY29ab1hCWlVza2JSV1NjSUFGajdGbk4xcUlRSElpYW96VTBjRk13R3FkdnBnL2wyR1UranpZVENpQUJFY29pRlFiR1I2aFpXWUJGamxscUtXSHdSbkdac1Y0dEszWTcwOFJ2WFhEM2xxRlZ5ZnE3SysxcEhVU0dvUFZvSnRIR2xhU0tDVHQ4cDdIOG8wVWdSa2FEUXNwWU40L2krRWR5M3ZsOGNBUGV4MHdnSEFDek9NT01xc0Z4QjlmV081WTdiRHNzdzEyeFVZV1lFY2NWT0dDNTA1NlJmSjdzdWs1QWp1UkpCZW1SNU5SclljeVc5dms2S05GSUFQNmt6QzBSRzJrMVlQNWJjOVhDYjVSMlAxY3h3c3djdHZhd1B3aWw3YmFpSVV3bjY3TStuaDN3c25FQXFtc3hid1NaT01EY0pSbngraUxGTnpWWWd2T2tXMmxlR0tzMVB0QUFpM2tBMCtVaW96NlpuOWVMU3h2RTg3dHZBMHByZWtXRitPTjRpVjdHMnE4WjhzdHUyU3Y5MXR1OG92My9qbEcrUHBkWUFlMmxSKzRMdDN2U1djbHZ4NjBVYzhvMDBJTVBmNmEyOTcwS09wSlc3SitDTDVsT25DMjlXamhHZlRiMXBTUC90NkVNUVZlR0E0LzZaaTRnUVZBOGhNdnozdXFrdEljNjc1T3R0aTF5a2NRdGNmUmZBQzlhUkRIOWwwVk9TREgzdzJVdHlEWGZHYzZhZEhCZGpyRzIrT0ZFUmhsNnh4SWk2VjMzcW5Fb1dUQ3ErbU9waDBjcS8zZk9ONDBtMlQvaVZyTlk3RzVKUGhpWnJ1YXM3ZjJKbFdtM1h2ajEvdHFFeUYrM05WWTVMV1NxaktTWDl6alhEODkrK3NYZ0h5M2J5YlNiWlcrSnNuSXlvV0pNdnpVejVra3ZOM1FiWU1FZklkSU85bjAyRTB5WDhGV3ZJV1I1WElXSEQva1g0Z0gxRDFnUFMyOVVBUjdoSlc4TWxuakFhMHhIWTkwS1UxWUlnVzJXN2laMmY1d1JZVG45OHVKL1NaTEJkQzJzQ1ZLd3M2dUF4TUdrdVdrelUwcGFyc3ppaEt4U09UbmlwY0Zua3FMMVdWZzN3MGUwWGdwKzUwdG1ubGpuVFpaOWVWNFV1dHF5TW4xb2pJK0pLZm1DYW9SREI5R21FUEhZb1BEdHZJSVhJcnNKN3VwNG5xSzlwRlNQbGNRSVVScmtiZ0JHR3k0QkhUeEZuR1k2blFxREtlVm0yNFJTVnFkZnFWa2IyOURHbndNYW0xSzVtYkxRUlRhNm1BVHppbmFZQUdwSkFXWjlmRTFTbStBRnFueXVNUzNmRTYrcU5DUGJqOWV4UndncVQ3UkF5L1k1LzhUYWc0c0g3K3ZnU2NTRlFvK2lhZnBOUHEzUjd3RkNOWEtPa3RCVHZrMWlvciszMEpJK001a0ltWVN5TzFTSWtlNzlPdTd4ekNTRmkxR21tRmtSeStodWtaY0Vndzc5dlFISlpid2dVSnEwYnM0QkRSamVEblRDbGdNVzNhQTJrMlkwSmprc2tYbEFhTmx5a0FkNXEvTittMVRodUZsS0FGVWhJVU1qZ3JRb0NnOEZqenpsQllRMVg5TWxJcmdCcFFYa0pQcTZyWW5rSUl0OHpmbCtaZFBQeTEyOVVsTzZvZDhxaVJBcUZGMFRRRkMraXBGdXBMVTVqOHJVSkRSMGJXcVZ3S0tYVTc1SE9zUEFXTnlFVGtGQ3F3Y1h5dzRucnFwYzNISk9wOGlKYnROYzlZaEZnUDBtWXluZGJSeit3ZEYwMXk2Q2tZWnY5Yk42emxDKzFYQVMzbWdDVjhSUG10ajhIeUFSQVdWQlpMb3ZUVmhkUDVKMk5xd3BZUFYybS9JVGc0QzErb29NMU50cWpjTUUyalBsV2grTFNtQmJCcS92YTRSMm92SmhNRGxiaDd4MmxiWXNMUlFoTFRWbU1GaDIxclpZUW9vMFhTMXQ1bzhZL2RvSFZBaFB3a3JRcE1Fa0RqUlRLZkdyT0QzNmcrV0EyaUF4RFRONGVLQjZMc1hHTDFOUjBWR052UTlNL0tBV0pHRTRXSUdoZS8ydjdJTzNDSzI5VFNXVkI3bnByUng4bXFCWGVpL1I5OUJZN1dnZXdqRkYwcFhEb3hkOG51QmRKZ2d5dUMxUHRMZ2ZKSTI5UGhtbEk1TlUveVhnZFJaSENTOS9wVXRRS1ozbzdvMDdZTVVPejJmbVh6MWE5VWxZT3lkdmlqdDNvaU9YWU9TNWExeG1hbEV1aHliUkZNRU15UXEwMDJ5SEltdng3YloxQ1pPbmhzYUtBTkRZemQxaW5WZ2EzcjYxSlp3Zmw3NDZ5eWdVQjZvUFlGV04xeTFPK09YZTdYVys0cVY5VE01WlFoTUpiSmI0cTdwQ0MycDhQNGpUajdrQjlFU29UdDgwQ0Z6Yi91UWh6RFc1ODlBOHZKRjl1dWZqKzkvay91NXcra1NwS0RUaXFMOG8zM1lWVW15b1FIUlFzdmJybm9PVUdWNFZmZmxDTTFmMXVzeTVhSkh1YzJlUEtQM1AyK2h5OVM0NWw5M3JBRkhHWHY5UDE0TXdmbFpoZVA0VGs3ZXp5U080MlUvRXRwTjdEYkIyZTZLdUZ0dnFFd2hYUGU0UFJ3RVhTOVA4RjZHcmlUZFhzZHR0VHI4amVsK21EMnoxZnNQSFhKY2FlZS9ldHVlKzkxU29GMFFjRGpBRk55cVZZN0VvSVFOTTlMemRtNFBBcWJ0N3BaSVgvazZFOGlNQWhYeVVKVVVyOUVueTNtNGZpZVJNMVNRTS95S1FKMFJQV1h3R2dIY0pBUDg3dGpjOHJLbnRJVWxYV3dQWVBKdHQ4aitVdlRySmRYbmt0RnhVZ3Z5VDhmVi9JNUp3WmpwMm9FWG8vSFYycWhJT3pQRWtwcWZMTWQ0cC9jSlJFd21YOEtSTHk4UWFXQnI0d2ErbG80WG9UbC80TG44Lzhxd25VNlpFdDY4Um9kQ1NIY052SDlIbUhTZk5vNTZMWlVMdW4zcU5jT0ljNDBDYXpTZHVVU09BZWFpbTQ5aEVpYmVDZFhTemF0WDMrOFoxbWpROGdhYWRiMEVMS21talUvaEt3ZHpicEUyaTVad3pwcldHVU5MV3V1V2FVSGtEV3FzMFpWMXNpeUx1YWFCQkt1Q1VLa3kvczZVZ2dGcExHL0ErN1BRditTQVZiRnRhSVhrSXp2OTR4a2tZLzU5Y2Y4Nm1OKzFZZWhIVXNIemVvQ2NWUElXb1c4emI3cEc0S3NpdUFNZHV6R2hOWXdGSXBFTlVLNlJqYW5pTnluZ1YrWG11Q0EwcVhDQkRJSnBtZUlJbHBxVUxORWFkWEY5VllmRzVCZ2FBZHhIVUtCTXo5UjhOSFQ2QmJxcVZVU25Gc1ROUmxFT0JJcHZtRXZxQ2d1dmFTeUY0enlMOFoySkVmWk9iWE1jTkRlcTNPV3NoaHBaZTlGVXFwcDdZWDEra1ZGejdmMW13NnNaNjdqcjRkQk9oTnRHVEIvS0xsV3ZHVlVoaXc4dlhiVEVYVnpaYUlLdml6VFNTTDh4OGp6VGRxVFc0R2RndzUyTDk2dFh6NW94bVEzdG5ndlBYaE9uMFZHQjIxTUw5emQ2MnpaTFBXOVFDaVozUzlTblF3VWVQbmZ4VDBsdXVDbFUyVGdNZHVZR0VlQ1l5RmN1MnJaZTVBSllmZVN1YlNPTVdRUzdaUlJEdDFvMFhuK0tBT2hwc1hvTG1lb1I5VUxBbTJCVVIwdGFGck44RE5WYkdaR1hxS2VXTEpseUVaeHdMb3V4VnVZUmkxQ2xnZkVxd3RrMkozNis1RXc4TGRFTTVPUmtoeUZpZU5DbmdTK2F2cG9wY1RUb0lpZUVVU2I4WGZKNXNsOGN5OVFEOVlYMFljOXFuQnQ1TG5zS3J1M0ZFRWpTMGlLL3NqS2VLSUlkaGx1cjB6cG5ReWFnTTlaTFB1RGJsdktMVkI0NEtsbGxlcGZEN3FKR2U1VzV4Q3ltaFZzZmdoWlU4MjY1QkN5ZGtpMTFDcGdHVFJWQlhQN2JGamxjZzNUS2plcHJYSjFvZmJ0NWR4ZXp0MjJwMmZlRXFPcGRHOTJYMWhDYXkyc2V6ZHY0dXpEdFlKclFTSGFYUGxzWjZyYys0cU9Wa1AxdXhVY29xK1A3N1RIUWY0V3hrQlVYUS9VZHV2SVVlNW85emhCNHdvUDlYaXpSUGpzblNEeGhETXpOZjh3L1VySG82cFIvbndsenRhcXhOUHRVckxwTDNIYVQ0L2NlbTBmR3NBdzN3VGpEVTBvRmhRSkpsMFo4NXJyRDJvSzgzOTBldlFzdThHdi9kOGRvWUtXbm1YS0VpVWZGeXQ3bC84RHRXU3dWeWxwaUdvQTJLQlFRbG9GTDZYcXBVY1ZBUXc5S3gzUVl0NHNycmR0ekNXSWgwMDJBQlZqRWJrYnVEeXJIcFFpaGlEN3IwSTFoblVOeldDQmtOcXJKeFRuV1k4dUFxMFc0YUxFVTdpY2lMc0xOaE5GZVlYeGNFQlRIVXBYSVI4NlJkMVRLTmlDVUVFRkVJR3V0dEFzT1hUZWgrc1lUcTR3UlJJNlBrY1h4alIyNktoTlE5cU50YytTd3ZtT2dHVHJwZERrRnkycGI5cXNieXlKNFNKWVdpSktBNk9Qd2trcVZXb1JZZlFVTGhleEFSeU02UnBuRllIUXBkaUxJZThRRnJHbGpUSThXMmdkRW5TNk1DVHJzdWU3c0c4aEZhSUJuZmFpNTRLU2QyNWtpbStncmllOWdKSGRaR0xqOThvaWZtTjMwTWdnenRhcG92RFlXbjlkZnN0WC9LaHZteFhTZmFSQS9QSTd2cXF1dnV2REZjTXZ2K2NyZlBYOUNueGRmdDhIVWVLWC8wSXkzeTkvUUZiQUwzL29tNjU3elR5eDBRYkJ4VUg5OW1oc0hQYVBDV21EaWQrZHp3d0hvYzhQcGFTZ0t1bXBnWmFFUGhpSXJ5WWxQZmZSbDNSQUdXZVkrZUJCeTRCSlhWVktrU0RpMjl5eS9rc1F6Z1FIalBDOFF3dHJIMFJoby9HU3pIbEc5R09Cd0gxdlhYRmk0RFVITzN2UlBFMWxXWEI3Mk94RUpndjE0THI1ZXZBRjVzMVhIR29nUWhkeDhNckM0aEMrY1c3VXdiZUR0NDh1SWxKZXI0b1pCY3NkclZVTGpyVmgwZXFURnBFZmI1NFB0dnBZcVl4VDE2WWFCVElnUFBDWk5uSWxTM2dxSTJ3SGhTWjJybVN2WVRzV0lpcTdFcTZ2Vng1UXZVT1pNM1BtOFFFeitGRG1UTmlZTTFwS2tjanZqcmxsdmRrY0trTkg3c3UyY2owQXMySEtxZ2lqeXdDamk5WkR3SFdkWTBnSWpSK284amlxUk4xNW9lcDRVOHNMNmFaY2lEMU9DL2VCZ01MQTZ3TXJQcWlpQ2tBbkRvNzlUMVV1eWdOK2Znc2JTSHozeEE1eWdsdFYvb05ZRmVlbXlkYURlRmlNdkNkU1Q2aHNYVTVFT0dyQUFUNUk4WjF1YjFlSE5XNEtEazFvYTM0RW9MZnNldC9UVTNPRkVoTWUwUlFVcmM3RGU3dW91RllRQjBUZ3UzTnVCTDY5Y3hNdW1IUC80am4zTDVPaTcvWDZKYnRVZ1ZpZWRFSzRWaTZERThKYmdncTRKZHpEQUZWUzI4b01hZEErdzgvL3pab0pJOUdnenBIL3VMWkxsck44RmR0MWRYQUE5dDQxUVFON0R3NXZIeGoweWpIc3ZhOEVodWI0MDhBdzl4NTBGdys1QzZEejQwSzYxUkF6R0xUaVFYOXVvZGxLTlJMZElkWHhCMTJYcmc4c25LZTVWT1lQREZvemMraXVENGpobCsxTC9HU21QSzliWVdtdk5mY3lkMzlxaFEyNjJzaTgvTWNKTFRnTUVHNDFqWVl1U1VCR3JDYk1YTkYzTVAwRnNOVUtLb3poYndWMUhkQUpuQXRZZkRyVkxmaXFVcnFuV2tTUWNOMTBQbXNsS2xwVU4xUTZLb0UyaTJvSTdHZnJxSTRMeThhTzNrZm9uY0QwckQ3cElvQVhUQjgvdUkzcjZsdXJEWGhTdnp4bm1qdGtsRjljTjRUMlBUaWFpOU1STmc1ZEtZc3NSSlRLZ0picTBHbDBvcXFzV09YV0xJT2RHSlptSTFrNmtERHo3RldnRnlWNmlGSS8xVGZVelVZRkRVYWQwa080MGhyNExZQnVDT3NHc2Q0cldxNnI3dzE2Qm1TTXZQbnRyT2k5UVZZTkJBZEd1L2xNclMrZENRT0hHaCtveFdlRWNXcHJHTDJZWWhRRjdJbkxsMUdyRDhkSktmbnFhc0tzT0UzTmM3SnEwZXNxa1F2NjF0SlU3SnBBUGFDNERIa3N4eVhpR0tZeUxhQk05UFZrQ3AzS0xnU3dzZWN5blQ0aEg2ZWxTVkNhdGhsbmxFcTlaRXlVMkx3NjBDUGR0OTFUazN4bk14TG9ZbDJCQ1dMYXRia3p3bEVFRVJhY0sxeDFlRDRiS0RzRjIwUk5SNlJQdU9rRmZkM2E1OHl3NDJFbFQyWmtYTitXM2Z5ZWlBYkJCcDFqK0VhblZsQklxeXNrSk9BWk9haWNmYjdCS3lqMnpwbTY0cDFEaXF5L244WE5kU3U1SHNUZXBqNUFYdjRUZThvUzhwL2pEaEhkcURuRnRsR216cElpVUNJREhlQnNGWERBTVVFT2pQZkhxZ0JDc0pNQjRBNzk2TlY2YnBic24yc0N6SlVBY3dVTEJXZHFxQzI0SnNDTU1DRlNvQ20yWjEwZHVDcUFPM3AvckF6RTFhQjExRGpDNUlRMjRuMWFlMGFOS2p3WVZMQ3VxRzNBT0JEQmFXNktNM2EwbWlscUg5UHI0RHdaTXdLV1F1djBianEyVVh3UzZraXZZSjNBaFRSbXNRNk1RWWNzQVFlM3BGL2RPNDdPM2FmbWp1NWdQT1ROQWtFUHZYSVpuaXlyY3k3SC9mTDYva1RjbjJqM3BWbzNqR2VxVGJVWjllWGtvRmIrbnNFem5hMVhmNndBU3NKYS9yY1RIRHpTckt6cVdSdWdyWEs5MWE2M3lmVTJ1NzRjb1RoQ3JmK0xlU1FURHN4WGhIZmllL2xFZmVmMVYrVDZLM2I5VmJuK3FsMkQwN25mcmdIaGRibXZKVjdBUXg5WEwrUHhqcXM3QTZVVkhGTFhmYllnN3BIMGUrejZYbGtjOTFwNTJ4QWIwY3JiR3loWjRWQ2haaTNQVm9TOXMrdDNTNW52dGp5QUNuTW9WSHNDamQ2QTZ3L0s5UWZ0K2hhNXZzV3ViNUxybSt3YUNHWUF4OElwcjFoakd1Z0laN3FQSVpTL0NINnJ0dmlWd1p5dFljNHluTnMyTFkzSzFDV0lQNGthcWZIQVBYWFZLQzJUVi9Qd1dxVXdzRGJucWFoUDh4L0dFT014dkYxVUtmM0pScHVqSXVST3Nqb1NjeWpseVFxS01hSFZDU2xHSG13Z0ZSQXNoU0dZQTZWZGVwRWlHQU13TGRBZEl0S3RRUzAxREhlRU8rejkxajNBVzNOUVh2c0NsSmtwMmNQQ2xQRHBlVlc1RDgxZmJteHJmSHRZd1NYanNXN1FlQXk2REFzNWdRSVVBVjFjdEttbWNSZm9PaXdnZjBFUGZULzdZZWlQVkxiVjg5b3NZTjl3VkZOVVJYR1h1eXE4eTZtOXVLYWZoSVlnZk90NU9QNDRuSXFpZ2JGY2JaYU8zTUUwLzRPQndZaGpmLzkxVEVOVTVSRHpuekJ3MUlKc0lqZkcwQml1d256cFhWQ0xvTnE2Z25wZklrZUN3NUZrVDk5b0JBZGFsNzh5S1dzVDJqT3JWaWt4QXNvSnRBaWY5UmdML3N4VkxrTXYxYTJXQ1FRTTRva0dhaVl0K1U4T2VGQWVDak95Z29aVVRvcktWcldWWVkyMVZZR1RwWEpyanExaGdkbzVoSklaNlJSVVFzcUVadVJiVzB2TjFIdmVjTmF5aWY0K3B4TllsUnZTcmxlZEZLdVVwbEx1d2JFeVlIcmVIeDM2N0RpMUVUNXF0YzJJOGpiVFIyOExlMnoyNWJKM2EzQ0pEU1p4M0JyMldQM1pzTmVXNlh6V3FJWUdMcUt6cUp4STY5eUtQYURsclVXZ1JUTjVTbzd6MHJMakFqcHNEZWtJSCtxeTNocnFWN3UrM25OZkoxSHZyMU5xQkxVdElybFpyVzRuMkNOK3FkNnh6aE5CS3Q5Nk1lMGdmYTJOalpzeUxtN0FTSWJyWnZaaWk1OFJ3N3NLOHNsbzlRUkdzc0V1V2J1S2xwQ0c4cGdTOUlodW8rVU1Kdks2TXU1dkpFVy9MYXhxUlVUNFVJbEVNN3RRY2k0eWFqdFdlM25pZWFFcS9Ya1pnbE8xVDdScC9XWS9zUDkwTkpDK1d2YVl0RCtwQ0Z5VDlkbTg0Qno3Z3Urbk0xVUYvYXFDc2ZhU1dWT3JPZDJNSWI0R3gzblFWY3BQN0Z5UVE3UDdQanBNSnovbVhXTHg1Q1ZIcEFGL2FWQ1lLc1ExSVpjWkt6Mm5MSi9SSnhvUmFrSGI2U2xmSkp1S2tYSXhvN01xUFZDME5zbit3Umd0VTgzdTRuczBDc3l5dncwT3BuMm92UUpvc1JZYitxSVBHdndvRU1BeS8yeVRmeENFb2lwZ2hiZjVWNloxQ25WNEpza09tVGMwQzcrS2U1NERRVkhCc1Q3Tjg0Zk1QaUUwVVV1WmwzZi9qWVpMVTRjZG5tNzdZalVhak9tSGNyS1VjNmFCelZQRHhUM2FwT2FzbTRlNm9SbmsrVnhPYlVPa1pTenlQVWc0TkJ5dU12WmFnSzlNZ0xlZ0tzVExka1FIODAvVnM4RkNsT0Y4OE5Vb01JTDhFYjJWcVBnbllTWHI4SDRENXhPOXpkWnFBMWllR3hpMllrV3Z4YjZJRkhiUmZKNWFpK2dMSUJ3RE1aK0VrcURweDFvK3BaQ0haTWV4V0MyOFdxN3JnM3hIOVYzSXBIN2R2RGV1SjJsd1BVbitpN2c1UkhvTTRvUnpoTkpwcnMxZ2UyMlg0N3dLYkY1aHhIOTlxVVZXSVdtVTBJdFhaNC9MOGJhQkhJcWJGYkFMVm10amVYb1JHclJJWE8rY3VrZzlEV21URm9ITzBCZXI3ck4zdmVlTlVpeVF3TDNKT3BPVm1KUDlWTXUrMnR5Z0ZuSUtMcUxzbXNEaDhDaWI0Mkl6Uk82WWtiU280VHpLTDY1U3duRXRNaTZ6RTVrM1J4RUVNdFJ1YVhoYUVXamRzWkIwQkpOS2xUOXhjYTdQRzZjN0dBTVpVRzVHUVZQKzAzaWNoUjNseUI4cldhZWVhVElwN0lnV1JUQTZPTk0rNHcwMnBSZGFNS1RCTXM0Y1hvWjBNSVdrYjFRLzI4bEtoY1lyTklTN3pXVGxTOGlyck5xRlZYakVuVExrVGhucEhnZ0ZrNXFyd3FxM2lnMTNwbEtsUm5IYTlQQVVZMit1Q0NlN3pOeTZpcUdXZFdZdDZ1SE1WcUVqVHV4MDJzenAwT0w4NGJoUU03a0daMHlaUDFXMytYN0RtaXFHVzh2MVRkSnVwbytlQ3lnYVZLZE1pT05GWTl1QUV0c0lPVndSdlpSMXN1UFlPNy93Vnh0Qk90VUQ0RmtadnJUZ3Eya1pUVThvQ01UbnpNMitXR0FiWTF5eGVveHMwS3h5dXNMbjlrSWt2VkJXT0JFd1lLa0hqYnkyZEV4aUhhTy9rWFFNbElEUG8wMkhTVk1UR2oxN0ErUUdlMjcrTlJkbjI4T2dyZWFSTkJYdUlGdkhzbldRcllOc2s2U2VZNlVHMkx4a3Z1YlZmc0J5Y3ZmR0p0TkxYRHdyV3FsRktuN2Yvd3YwZG5EKzZTb2RuRElWNlJpTytyVm1KV1FpNlVoalFzejBhUnFDTUJ4VjUwUzBBUVpjcllsSVNvYytSV3lqQkZRRnV5UkQ5NlptS0JjVjVxNWxZeTZFUW9HcEhieTBod3JGeFlnUTFNR1VlNzRCU1lhNGtoWWovZTZJNlVPeHFXTXhLZEZCcWF3L3Q5ODlmaGZha1JRK0o5MFc5dnVSeW8xNUZGMDlhbDA5aXE0ZXBSdnpOWUZpRlA2RkJ1bEpWOUxtUWlQKytPVnNzTXBCeXd5NEFBUmppUitIWGd5TnRWK0cwK1dYdlNtU25mR204cWlwTHZ0cVU5bWF4ZzBENS9sMmd5ZkpwaXA3V0dmU2tvQTRUMXd6RXNYckRMZUdEbEwyRlp3eGRjNW9JR2M4SjZmR1VaWi9JRllpU2xXNTQ1b2VBRDJ6RVlRbkZFUjlBdW4zQjdvMVcwb3Voc29RL2dlU0daNDlXNVBzclFGMG91WnVsUXloUXhKc2JjY3FsYkJNdnJUOTBnNjAxR1FaOGtmaVJoaHBpeG5tWWhUczdyVVJnQ0MraWRZZ0U3MlJ5VWN3ajE4b3owWW1aOVBOR0J1L3Yzc0xxOVk2bTc1NmcyN3c1VkV5WGNwUFBKVEl6c1V3WGVSMWcwWmJZRmlGV0FkYml1Q1BTSW9FZ0t4UDFCNld4ZVN1bU5kOUJPalB1WXRRVFpIQThtR3NmcHo5YjJ5UXlxNHBRYVN0Q3RSVzFPMldOZWhTd2ZnSFVHMmQ1NDZrTmIxd1lqZWg1ZHl2L0R0allqY0F5eEk2QlBLWWVyQStFcEpoTUNTMUthTEd6cFl0NmtrdjdiVTJGSzExeWc5Qm9kSk1nUmhWTVVjS3FvWEp3aEtVZ3E2cHdJNUJOU3RqczJUb2xqZU9oeCttZWpJcDMvNWxldGttNWQydkd2Q3lUWnlYYlZKK2hDYkpsaFVnQnE5RTFyek9xbU9BM0ZlWm5aSzB2RFdFWWZhNnFYclRxVUtuaGEwOXhTYldKdnEyYzd5WGZRbWJWblVQejlyS04wN2ZBdVN6SWowKzRPZmJnRHRSREdITHN1OEZRVXUyZUJ3OU9JVVpIQnhvcGIxeHQwRnpQTVlkcXlWUHdXbEJSakZTZWxVZ1pNODBidWErNEhFVGJDMGFWMnNhamJXRE4xT0xYWXg1cGkrUDBEQVAweTZEbUZyMjJFdzJSQWpyRENGcmhERGVCZXhiUmhxN3F0L3ZJWmh0QnpHV0FJUmRiYjh5UmZGUDBrZmxLbGxIWFBJUkZqUmFZUVJMcno4Uzk5cEdqVE02MDRnakIrU3RNZFExZWVrNnVMRUNhdHVkSkRJTytodlliMmkvd0s1bWM2MG1QclIwaUwxM3FjVkN0Vmh2K0gvMnljaHZZeTdzOVRBWnhqQXVZell1WXhpWE1UY1phbDB0akRCbDh5ejkvSHJucGRodTNNS3RxSEc3UkVZYk1UeG1JMG1vanQzSjdZdzVBdnJQbUQ4T3RxT1pVemliVzlBTmRkWGtUUWRYbzd4Q1JOa0l2dU9qZ0JSSFVJdFdNWXA0RUZGNTNmV1laY3ZwS1VvUXVrUUloTmNrcEFrWlhaN3Z3ZkNKU0tXdElzVjIxYmIzOHVaN0h0K0xWTmZnM2t6MHphTWdBb0xCa0h1VC9xdnFGdnlYRElTOXpCQlpqL00rZU8xeW5XeHdRRkdaVnZrN0cwa0V5M0cwdmljSENXa0IyRFBjOGtwMXpZUXBxbTdJSStYYjhRRjZtZElCUG4rUEdwZUJUaUhLWE5HdXJrYXFxMHl2TEx3bjJiTnk2eEwycGxuZ1IrVTIzdlBiekE5cUUrNlBKQjI4Y21TbC9CbGRxWWpTTFNnVmUrT1lJdU0yUmNZeFJjWmw2ZjUzV0gva05VaUdpK3pYRWVaZzl1ZDNxYnE2Zk1pZkx1L3oxdWlqUWg0ZGQ0YnU1OERUYllRQWxFRVlWeFpNc1RVK0V1bUd0WGNaSEk3bVBTL1pwVUQweFk0OGMzb3ZocDVZcW5MZncrT25tenllcUlMbFh1bnlleDhlbDZzVCsvbXJEVEZrYjRxQjFNc2NRNnVYUzNEMDZtV0J3NWpCRkdUQ2x6cytDMStmZ2xHYklWTllGdXk1ZGpuMVZ6THh5NWt5eVA4NUpjU1hKR094N0MzNjZvK0tyUEwxeHJSUVZBNHRlYzlWeS9PM3RwWHFYb0hXVkkvb1pvZ0xEQkI4NGtmMTBJT2h5bFhMemNOTXJxQ1VXK1U4SjNNOHZ1VmI0K1hkNzBySVFPV2ZVTDJaYnhGOG9MaWZ3S0JaT1QwblFUWlVMMzM3b1UvSjIzaTFwS2hKOG1Xb3FWWHNtdlpTN2NIOHRRa3VUaXc5dTM5ZG92MXBEMDYyQjdsN3NBUVBFbUZkWktSd1ByVldUOVRJL2JRUzBseVd2V0IyU3kwa0ZUUEV5MjlTcGNMZVpjTWdyRlk0b0ZRc0JvaWtUTHhmcHZSU0tkZjMyUldMemxERitTbEVHbFdIQWVVZFB4enE3QnZ1RzQ4cHJQNSsycFUvZkhqYzNPWEtQZCtOOHkra1pKZUV2U3p2dVErM2hHU0t5bys2Rzhaa3haekF2QUdrVTRTRFF3Zy9LVWhlK283bFUzRmNYTjd6K1NoL1YxdlhOV3lpTi9ZMGEwWWtPSG9IcklUdEFHV1RvWm80aGZTSktQZGVxdHRwUVB6cGlBRytvazI4cWNiN3JiK0d5N3RPRmNlMVIwclB6L0Y4c2tJL2Rpa1I2QnNUN3NaZm03TytsbUxKM0I3aVprbkxEcXlYemt3bGRRT0xJNlZtbWZ0L1pTZ0JOb3RoTi9QSmRPbUNudmZQcXd5MmhqdXlHcFlyN1QveTdZbUpHdWIxdTU4eVB6SDFaMThXM1Avd3VObGkyN1h1ZnJHNW1uYktWMXg3cHhIbnFSMEp1ZFBreDNxSW15VnQ1TnhMdVVzdGFzdThlOTZoR0pzQlBNalhGL00zSmd1WWxrR3Q0cGRMWENQbHNyejhkaVVJM09HT3REZmM2WWlFUS82OGQwaWZUNzN5SzNBWXlvNDgwQnV2ZHNUN2hVOWtBenhRM0FhZlFkcUpwVEVwbjdtbzhDK1pmR0RmbCs2NzdhWmZ2RG5ZTW5uU3RsM2x2YS9xcUcvLzdzbjkvaVd2QkNyRzVDbnljNmxreDRqSWU5NUZoVGYwdlhDKzk1eFJXVVJXUnlYTUw1eHdWMzg0MGZNdTRndW8wN3dsL3lmUGV5Vys3cGhzQ0k0QXpCb3FHa0RQRU9wMlg2WkgzUDFoRUNHUWIyMVhwOWJ0a3g3Q3l3VWFaVTVLdUdObVduaisrQXhxN0J3cUhVS3dUYXNFMW1OWUh5MWg4MlR3WDZ6ekpNdUt2bUlxUzMvOGY4QjBRTGMwTWcvY3ZIRGlJcDJLNElubFVBMDNDT3QwMGJoVGVtZ0V6RWwvbTdxWUJJajBUcDBFWlU4VUJ2bGJsYjk4a2RYSzNkQ00zTnV5dVFobUZhQmJMbVN2RDdiSUI3Y1VNZEpWT3JLV1pLTHhxRHkrRy95bkROSHNpMGFKQmlSVGVjdG1UbzlpRzlSMzZpSnp5UmJqdmNjdkllaEtyN1ZsY3krU0M3QUM4blhVQVRxdHllS3lzM2R2UnFVMjk2UnVjdDMxeTFNcWdhUVo2b1M3QWFNaEpmcVhiWlczZ2tsTytQL1NTeWRrb2tnaC9tVkZ1bnNyYlY5bm5NaXhNWklnSVdRY0o5VE56SzN6TXBZK3paN0VMbmc2N05DZkhuaGI4RGZDdlZ5R0N6L1g5My9IWS9jWG5JZDEzV1JzWGpSeFVmYkdNSWhWMG5DUHR3RHBoRUdkcEJZNFVDVUdRL1FtNmt2dFF6VWdUWHNPdVpXQXdjZFBSSk9PRGxhY0VJSU11Sk1ScGs3czA5TWZrY2NacUdkMUx5UldHeUJ2b0JmWlZlSDJvZ25KVFZzSU9TbzMwdTl5MDU3cENYZTE1U0psN0VZR0J4dVRmMFRHaUJBVFlEai9rRlFLOGVEQ1pWVzFDcXhOMlBHUU5udHJRZ3hzZmJTa3lrNW5YcGdKa1NLU1RHMnA0OENpd1h4ck44YnYrVW9TOGUyMEtnZjkzTDZJNENuRVpwQjk4YTNKNXE1dlViS0dHak5VRytGeFdJQS9mL2VuTC83bU8yNysydFV6Q09udVRacXRrUlF3K2FwLytPdEhycjMzenAzZlExcjJmVC93dDRUMENUazZCQVpjY05ObVNkZkIyMVdlTW0wbTBDVTlNcUJLRlBJTTV1WUpGd2xROXRWYkxvSEFhcS9PYkE2ZEVBcjVEaEJXQ2VOaWdFMmxUWWc4bzRWNlVLNlk3cHV5eXlmdXIzNm1HNnZ3czFCM1h6a0lRK3FmK0dYNWxCVUxLdEZ0Z2xyY1h1OThlUUlOcmRUYWVXTDNGU3RjenZQc0RhRS9Ock9ReHdEMjBnU0JodFRoaDc1eVhRYXVUM3VwakNkMW5DTmRsUWIwT3M0aHNEdFdaTUl2dHJzWksyRmhNemVWRHdFZ0dmNit3QVhlOFdxZUN0MjJ5dmpIeXoydlZ0K3JsdUdYUy9xVGpHMHB4N0VQanhXakc0cHN1aGpiMEVYQWkvSCtNbmw5SEJMRU1TU1BGbVBseklicDlkMXhxTHpMZUFySUplUFROQ3FTakxtQnBwUy9YNWVsQlVsOXBzcTRtWGNjc3o5amVlc2xvK1ZxVFRXek9GdEFZUjdIaTd6Zkw5b1hJbTVYdXhoekNPcHF1NkJFVDBiQkwreE5Sb3VSdm1MMWpnbkxQVWNsbjcyL2hzVUxobEFEQVNmbVpIaVpMQkt3KytwT2lGTHlkeVRrZTBQTmNjb2xreWUrWUZReHJNRUFwM2crcUFReWpUeEFIaEhQZ21Mck94bndnVDZIRFZ1QllEakZjY2xCb2Z3NGZSaGV2cU9FK3o1aERNR2YxaFJScDEvbWhaZC90OTJGTEVaZDV5Zm8reW50MmtuSi9RSjRtNEZEand6cThuMTEzdkpQRTlvdi8zWmJIZVRXK0hMNkJic0xmL2NXaDdubk1KSDg5ZWhOdk1TdFZOZ0RWZjJFdXhTcG1kYXczMm83SjFTRTNwRGI3Qm02TlVCdDZDbGNLWGx6ejFOb1JwZGVHUVo3ZER0N3ZIb2ZlSjdab2pDN2xQWnMxTS9UK2dXMVZGUXl1ZHBSL3g4MGFoanNRdjh3RU1SamUvdEdlL3QzSEdUcHpzcWp5eHZBSzkwQ1dYVGdlazRabGthL1FTa3hYOThwNGJYTXdmeDVTc1ZlRDZOcXp5T2dTRGlCTWNlZllPSTNiTVR4cWhlcHd3WDRDdHV0b1JWNkNpdnNOS3ZBQXREYXJhM0NEZGhyZ2I2R2V1WGZKMUl5UEVCRDJHNzcvWUZDTklndElONE1qNTNUNHlsMStCT3RQdUdLbSs5b3ZzMk1LWStKRURwRnQwZTArWm4rdElJYmd6VFlTR094bmthZThjK2c2ekRzdzZ3aXl0bFlaQ2ZGY09XcXR2QzNJYWVYSnNQeEJoMUkxZVhMNlZFeDdPT0g5T0hDMU5RSC9TWlIraFJQRUFZVS84djBWeFNzcmxIcVdYMGN5TC9yR29hWDV4clNzZ0g1WjNvNkdPajBHUk05ZW9BU1V6b2djOFRCalNZcW1FdXZTUVY2K1llUzdMUCt3VUtQVlAyZ1h5Ym1LSHFJTmxsZGhicTgvdkpZY2FUdWU5T0FsaUJ5V2dJNjN6YXFiTTZxWjB6WWhGYjhIY3haV2hjQ3l0ckNXR212b1RrSWpPb1pmTlQ4UFBmREFZQnNOaTk0V3VqNmdTQnIrU3JWdFFQMGRsb29Jelh6QzdqeDVoOXQzOUsxQUxJRXdiMjE3WWhJbFMwcTZLSWFRMWI2TUFKbWV1VjlmQWJNNi9KaldJNDRVZUJmbHhpQ3pOTlhYSGZxOUhWLzJUN3JpcEVWTy9NUHBxcjA4OHFQektoQTZCbG5BREh5d3c5ODlKRy91K3FqTFgzUTgzYkw0b2JKblg3SEw3K3ZYN0dpWVg4K1ZlNjV2RU1uVDYyNm5sYnUyUzNWczB6eHNpbHN3dmMrWmlYNXpVb1dLM2F5eGM3RVFTMGJoaDk2UlpMOVpjVzMrNzBBZVFMTEV5QlAwQUN3clVUNlMvS2JVYjBqYWVuUHk2SytQTW9BYVEwcG1hZmR2S2RwOXQ3UVQ1MHVvVDIvb0xob0MrVmRJbEFjSW5xM2lkT2xVN3VPTVRQQy9ZVUtHUi82bEs1aTdXWVkxbEhNK3d4OWhFNFozVnRlMk8rTmxZK0hwc1F2eGphV2I1T2RlQnJMZjdUTVZxcWVBSnRmQjI5MExLNnA3b2R0aVAxUFZHU0pweU1TUEFTOGJVajBsd0VFRUFLb05rUndoZndBejBkK1JpRHphc3ZFVW4zQjNxczYybzF0VUs5dHpzOEV5bzQ2aUgwYmVvek1vTURhcW1WdEZ4bTJnRFpuZUhuWDNhMmlyVnBXNUU1N1dmNWhXaXVkcHoyUUNTc0FWNzlScVJCYVhQZU54M0tnOTdKKzFBSXdhQ04wVUc5VFhqOS9tT01zMjNmUStFTnV5d0dZaC84ODg4M3dWWkl4MDFmQVlLSmJmY1NjckR5TExLU0VuRm9GcDRpZDZKWFBXbVZFblcrSXVZRUNUUE5WbXVwRlVuRmhJTW9qMUZrejdjWDViUVRTei9oSVp2ak5SSzR6VXo1RjhWZUNOZEorT0ZoRW94dURCc0NMMy9VSHpCTEFLWXc5TFk0OUwrTENpd2IvQ3pRVjZVSGdSMUVZUnFFWDhSelhCZlRoNUxUUnlLMmgwOGJuUElIN21lK2U5bWdPN3NrRElSTVVFOVBsOHVwY1RBbnN2Y0s5Rjh6M1huREFlOVU3QjJiMkQ4anN1Y3lua2VZZ1BPVWRoekE3M1BEdkhUTDhPbnRTRFA4TCsyUENxbnBCVm8vODNnTkcvbkdITVBLSFBOZ25xWi9zc2dyUGl5THJKVUlIR2xmLzRDbGc1ZzBwSTVUdUlJVUF3NEFMM2ZHMWR5RWNOa0lQbDh1NWozbUk5eGlwUEhSNTlTVlU5V1JtQkpRcUdOU1FLM0orMjdCV2RzOUUySnBwYlhiSTBjRndhYzFqK3gvSmg3R25lWDRRUm5IU1N0dExCLzViOG9TSmthd3pPcDQvZnVuU1JZY2RzWFRwNHNPWFBtNE1OUFl4b1REVm5RbTlVcmdMaG1rUE4rcFIxdTRzcFNuaVlpQlNNZ3Z1bGtpYmkzRFJLRE04WVU0RzJoWTJjajJEdVpZc21BdUV2ODVhdnZJLytjcmpNNGNZZDBxZDFaSnlPZGYvS3EyZTc3aE84aCtSMWRsNjdhSzkweDdmZXdmenhrLzUrWk91R0kxV0lPdmpYTk5Sa2VVVlByZDdlZVF0N3RYeVhFeXdrUnRwamd4Ym9ObVg0Vmh2VTduUnhyL1ZFN0NTQnRsKytrU2oyeGJyRjZvYVZ0aDI5V2MrMmhDRVhWTE4zZjNlaXlaUXdPR1B2WURuczRERHNqa2pkZzFTRjgxTmZSdFM4N21wYjBmcStOelUvSFZ0cEkvTlRhL3FkdDQ4YWVldXV4a3ZqYzU5NlIxSTdSeThsVFVxSUp1VjJkQ05WT2thNkdTK0Y1UVNyMllXcmZIcGRsTzVwWU12d2dNWWhMQnRJNGRlL0o4K2h1TGJqVG5helFaZmQ1OThjQWJ6MGhXRUo1MWlaT2hrR1UyTHprSVBzNFVlamhTZDgrU0hBeVBYZyt0SG5rMkFORHFYL1o0MmF6NmluZFFaNktSaVpLQTlmeTRkTU0rNGpndzA3YzhtMERrZDdaelc0QUllMkJUYTd4eDRiK2NPeVo4MHE5UTJJYWFldzBBTktoeHFzWTdDZkt2YXIxYzF0WTd0WjZyamFIbnRBOEpOZ1hhTHN6bDdRM3RPS2UwYmVYeFpLUW9jSlFlRmJBN2hnWnREejVQdG9kY2VPaVMyRTdWZHZ6MzMzT3JhOC82YzR0bjIvNlZjY2RMckl1YUJQSno5cTc4ODRmTmxrVSsrOXE3dmVGc212L0hkajN3NzNQeGh5QTNZR281dFZlQ3pkcUtqbzZ3eDFjTDVsMDZrcVVmcXhEYnBZbU8yanRhc2N6WG5ZMmZrQStDaitmc3FydnNLOGdEcHBwamRWQ09uUk5xRmtIUURWU1RCanRvZHEyWlNjOUtOMUs3czVmMHQ4RmdqdWdnSlJ4RGVqUFlQVHV0c1p6R3lvOWYrVTdBYWpjYjZlZzZnUm9wcVdZekp1N0ErRlM2RHBHMHZ2UG02bmQyTzVTdmF6Z3lzbm9DZDRhdjVVUnppNWFiK1dNL2pNWjYyMmppMXh4WlgvNDM3OG1mUllZc1g1NHRSTTlrV3JydW1HTm41VGc1eTQ5Q3d4VkJQK09mcWhOK2pVNmVoaU14MWVuZm01T3pzNlM2YWszTVJUcjFGd21aY2xkeHF4MHVIblRzaXU0VDcvcUlxOGR3Nk1jL20yUVlreTUvVVdjYUhaR2tVUFRZa3k1L1hXVWFIWkduVXBUTWt5NS9WV2V5QVFXcis2OVRPQkxuWldlWGdqalZ5WFhXZjhuNUhkZC9DZHU5dWtyazlyRXVoTTNmYmFOQWp3M2FQWWtRbk5EZkx1RkhOTDZXNnF1dVVOekZGaWwzZ2JBZ1dPbFdDWWJVZUlJVG1UTE5xWHoyd2FTQ1lwa2tJQkF0V3lsK29VdjYvUTZYV3MxSnFYcm9jVzgzNHFmcnRIODEwTTNlNXZ6dnE1czBkM1pGeVJuRWw2OFUrVmovdG1LNWpOblZ4VmNMeUVRM0lpYUVkSzdlL1lVenRCYUNMdXNXSTFIdi9Zc1YxMkhHa0htT25mdTR1L1BmRFV5VGJ4VnY2TjJNVzl0cHZCZEZKTmJ3UnJUR0xWanRYK0F5MGQxZ0JNYzVUM0dTREIxYzE0ZjlNUlJhajU1bU1pTTJXQXJxaldlUHdrUU5IODJYbk52TjFvR1NyUkY4amc1azdBN2Vad3hHUnpkbENPU3pIN3JERERjMHBPL1dNa205akQrN3daNkZLVjVXZHA2SlZCYXZLelRsbkw2NW0wdGxnUU50c2NzY083SEYzVm1URjZGdlBJMVVTRFBkYmJ5T1NwNVBGWlVNOFZqTFRQa2xWTTdMVGhVVWloVzIxck5GYmhDUlJOcm5DWEhwb1B4VENKZ0tDR0hRRS9odjVSeFBXRHN6eWVhVnFpWWZ5RHRJMzhybWh2aDBqMmJjZkJmLy9ONFA4djdtTGR3MUFJTzFGR3Vudjl4WE4vYWtJZ2x0bzhGZUtyUmswc0pZTC9FMGxGNGhOTG5CNHVWaHlRMFQ2MUpVVFJhd3lnaEF5Z2doRGhHeEZPQ0FqaUE5TlJ2Q2VRd2paQm1FNVJ3WGl2WTgxV3hwWlMyc2gxOWU5QTZSY2ZETzFOelVJZDBFY01oTjZCQ3ZLdzFUczRablFReU5BYXdaTnQ1YkJhWUVtSmtmV2VEQnhFV09IQ2hqVFNqYXBaMks3Y3VnSytxWEFPWElWa1dYdHVLeVBRcHp5MllOQ205YmtpWTE0WEI2blFhRkNsZHd2eFZaRUQwZkx4Q0RKNkRlVjFNY3FxVitKNmNGSkVhTUpES2NzWlIyelVpNlBXN2xPRVNnSW9TbjdITHFabWdvRkRpVVIvM0VpdEE5dmpKKzlibEZ0OHg0TWNUZ0xUSFFFRVU1Z0ZUNCtPRkgzYWxXQXFTa0twS0FuOXZPL2x0V1hxbDdpeEI0ZGFkT1ZDc0lMTXlLdGM2S2Fkb3Y4T1VjVTFTVHdjZ0lnNDJXWlh5M2lTS2d6bVBwZkkyYktKeEx6ZVN3UTBLdXZKcDR4b2VycDRFWEV6aHJpcjNSd21ySHoxMFBZaW1oanVlK3Fqb1VGbTc5RTVIbndLdW9zcElITjlsaERrb0h2NEgzcHVhdmJHQ2YwUit5bVBJN0N2TngvVDRzc0U5YUY5QlNHajFxeHVGb3lqTXE5VE4zcFR0Wnc5ZktMNkh3SjZQL1ZvMDZ1Mk9QY09YcWwrMERPRC93TFBxQ3VMdmpDeWR3T3BYSng0eXNGMSsvSnFEMGxraUZCZy9RRFhLUFlUVHBSMXZ4UUx5bVBwUWR2VlFobGhuaHI2Y0s1aWdOeXFVWW40WlpXMTM4NTYvL0kzYWovOHI1NlJBOFVGQ2pBTTJkWVhMN3JOYkVOV1ZqK0NOYTQ1a2RmL3Z6VjlZTjl6UWZ2YmJ6eGI4MEhIL2hKVkQzNGNmUEIzM3lnZnZDVDVvT2YvS3grOE5QbWd4ODNIdnlzK2VEOWpXLzh2UGxnYitNYnYyZysrT2xYNndjUE5oL2NkWG5kamw4Mkg3em5NL1VidjJvK2VPQ0crbzFmTngvOHV0RlhjUlhDTnk2L2QxTmRVdEpJLzhYdGRmNlJSdm8zdDlYNXMwYjZaeHF0N2pUUy83SFJ0dEZHK2gxdnE4c2ZiNlMvOGRvNi8xZ2ovVFdOL0htei9HdnEvSXNhNmYvNnNUcC9xOW11eHJDbGpmVExyNmp6dHh2cDc3eWl6di80UnZvSDNsdm5YOUpJLy9UbjYveFBhTGIzeWpwOWFTUDk0NDM4RTQzMFZ6OWNweC9aU1ArLzk5VGYvWjFHK2hmdnFOT2YyRWkvcVZIL0p6WFNQOVdvVDlITS82bzYvYkJHK3AxWDErbS8xMGgvL3kvcTlHNGovWDJOOG52TmRuMnVydWVURytsLzFlai9veHJwbjJpVTg3dk5mdmliT3Y5VEd1azMzRlhuWDlaSXYvbW5kZnJSamZRZjNsdW5QN1dSL3EyZjFlVWYwMGovM05mcS9NYzIwbi9LK2Urd3RKYTRZeTNoc1piTU9kYmkrbGhiUmc5R2ZjejQySW1lYkJwREJPZmNZc0k2YUl6SkduS3VlQlJmT0hMZUwwUkR2NkM3ZE1GZCtucWVNb1hicGNQeU9DTS9xSjh2RFhvL3RNTkh6UTJIUmR1S3MzTXJ0SE9LMlFKNllDRVdRa0Q3OU1oUVY1UWhYR254bVlJR2ptaFlydXlYbTliSTc2VXovZkxQMXdEWi80YnE2aHZlcXVrczkvTFh0bTQ5OWJVUGZHakhMejYxNXprN0d4anZ3UXBEZVZkak1kTTBlbXBPR1poTHBEZktVSUcraFp0YXpsODVwd3hTc2ZTeUQ3WENaQ2JjWEVVd2l1Wm5pOHB0OTk3K3RaY3IrZ0Z4bklpZ1VQN1E2K2QzbXFvdVdoWk1PZHdreFFTTWxYSnNsWWVkTWVxWGZ0SGFXTzdZOThUcDAxUlJ6cWZMNU9tc1dXYkkxYXdMZFJjUy9leHM5WWhhQ3lPTThuT2ZTOVJHRjBRQ1B0WWxjQXJnVlBxRGF1RjVKWENveXRqaElmN3p3MkEwektLa0ZhZnRFVUNjUzNlTk9mTzk4bXZmanVqT1ZjN1FFcVNFTTNsUVB2TGpLSDluckxOVWJyOGtTeHkzQllQN25ZTlpSakJkRFl3S2F4MVFZNmptT2JRcEM0K0JwL1hOdlpIenNOcU9DWXRpNU54Um95Njl6cmpGV1lGQUtDOXYvVnBDNDUvT3VIckxmRHFSaVRtbTE1L0I5U2loR0JpSnhzOC9peFE2bWVMdUx0eGxlc2NhNVo4ekFnekNlWm1kdGQ1TjZuWmVFVDA5T0NmL1BGNGFVVVFCV0ZaK3dpOGY4c3ZQWEIvbGQrTkp1MzdTS1IvMnkzMDMySU1Vb3VwUldNbWZFSjRUbU9ranY0cDVuajlnWDA1Z1YzNU9kNVM5VUpnbkx6cWtKM3pycmIwT3VrVFk4M05QTTBBVkJmRmUxamNKeE96V3A1WFhQZE5GcmN2N0p0MnRrN0hzWVNqZWFhYm43TXF0NzJxcHdmanJFK0NGb2NyUzU2Tmd4QlBYWmZlZ0tVbUZBUmlVVjE4Zll3SUVkRjQ1Z1JaWVV0U25QcXd1TnAzSXlISVo0dHZpM3FoYXZuUDRWakRqM1I5S3pNbnU5YmFQMkJkREhjSXZKSXFtRWFuZUdhOWMrcytKV3VGWGZ2c3cxVUw4cm1HNEdnL1VzRkhKL0prTUNLdkdhbFkzWFhEdzArNHFtTllZa3VFSzh5em1YZzlmOTdSb0FaQXB4VjFLOFVaSU1NRTdHU1RSVVBBU1NrRkNPdjRlaVhTd0lRa1V6YTFGQUlHSHNiS21PaGtKOWd5dktzUVE1MW8wU0VkY3lVOGxQWTFxMlVJSE1XU01yNjZWY3Iyc1FPeVRWWHJUTVZRUFFQMmw1WWl3bjlpNjVXcVZCbzg1bG9jSHdEYndQZ0MzNG1hajRTWnIvRnhzVEdneVBMSmlDN0FRUHUycENnK3g2endYdTg2YnlHNWx5QVk4cmUyU282cmpaUmZnN2dpRWFNcjR6UFVuT0w5WGhYeUJtV1hzemhGS1hZamZ0VGYvTzdoQ2VNZDZQcTRTRXppcXZ6azRIbFFlY1QzT0cxZVBHamtHTjY2SGtaU1prbnN3Yi9NY2cyY1J4a3pJUW12Unk5cmh5SXl2ZS8vZUZQZ3M4d3FXM000SUdVUzZ2aHhicFNLTWNrL1F4OG1LeTcyd1REK0tsOHY3ZEJBc0wvMUtUUEN6L0UzdE1qRHp3Q0txdDU5NFdiQlh1Tm1uQjNzQzJZQzBQZUIwSi8wVHdqMUo5VVVqRERnbnVEUU00UzB3aThGVXJWUjhyN2JaUzdzdEZ3Qjd2MTlKYW91a1grZVhJOEJqZUZKRTNrVHRvVlJLMFhkTjBzRTlvZW1ad2Q5YW9oUTMwV3VqaHNlVzVFdVhsWWZCNXlyL29rTkFRRytOYUZlbFI0ZjVyYzhNYjdIRlBXS3UrWGdaa0FVZVhkWlN6SDZkdE5XcktYS29EMzJSY1NFRVFCa1FzdUdPbVROWWRLWmhsdlB5dXM4a3hIM0JwclBuNFoxZi9qL2RWSm44NVgyaUQvU0wxTkFlT0hDU0JxMkQxY3diZ0QrbzN5ay9jMDFVUlFmRFVTNExUSTMyMG8zbEt4VVhNVUFSNnVNUUhCUG1jR1ZvZm9IQ1Z5dlI3L2RTRml1TUY2R0ljUnlNVjkvcjl6cjYwWjlFZFQzVFppbEk2REJCWGwzU0tEbDBKY3ZlUGVkZDljMnhmSkhMTi92dzNHOVVZcDA3WmhvdnhPNEZiMGl4dHlRSTBjRGNmRnA2OWY5aytkOGhZMnB5VWJVaDVsSHlkeTFadVE0OERSMnIwZ1MrSTZVay9meEx5VkwyZXN1TXNIeURYNDZQa1duVUc1K2oweHVmVC91SDFYaTBMS1VpMytvbTMyTXZZbkxtMGt0WWlwRVdXa3JwVC9xZ0h0S0NpUFlwSU80SXg5Nm5hTldRNWxPdXBMUS9QMDVGa1dhdjhRL210T3FFYk9wSFlBYzBmUmdKRGVYUnRVTnRwQ0czK1M0dzZGVW1wRENHNlBXUFBaQVF4dkFna1J6T1BYaGRlSXgvYjc1di9OdVBEdWtibHlWaDVJaHVpRE1YUkxJNVVKUGM0ZkhKdThoWUFGbEp2WkVpdWhsYThQaldJdHpaNjVDK0JOa3BTWjN6aURjdXU4aDFsTGE3YlhpbTBtUURmZXNGRS9WdFdOdkNUS2hsVndIMUEvVFlNQkdWY3JzNE01ZVo1akp4dEJsdmNOZ0FXQ2hzMG1GSlRZZjVRbE5pSnFLaVV1bnJlcFZHL1E3VUduZjdvSnNyejdNNy9IZkJpcDM1MTFNNC9hN0Z0azFwTGNOWEpWb0ZmT2V2UHFub1IvcVJGR3lHYit0b3BqOTJXQkFtY2J2VmJrZnR0dWUzd25ZWXRJbk1JZDBpUlJmeGx1Y0lUZEE2TUNuUkpLbHBuUWIrc0tHcDRSdTlVSi8zUnF2K3UvZTVmekpSak9KWWUvN0VDV3AzRUhJVUFwNTFvQjFkMW4zUGhkbFJnT2dlbnNveDYwS296d3ZxaEkvdlFGL1VpL1ZTK2FvVkQxZHgxcUtpT1RIc2YzMGk1YVoycCtwRWZPSHRSZmlubFg1am1BNTJyaTJOQzI2ZHdIMFU1ZUZobWo5RXA4V2p3eE1OSUpBNTlnNmxZdjNzWFhSMDNhd29EY05BaldZY3FYY2FlYkswb3RDMVMrSkZ4RnVib2V4Wnh2bFlSTU1WSmd3bkxBaEJSVlZKNGU3b1p3citBZ3lZQUtRTHBzeXZQbTBvTUtUV1U3ZExNazVQZkhPdm8ydHJGSUVKejV2b3pkTTVRZDA1RGlNZnZJM1RsKzY3bzZndjV5OGhxa3ZnK0FIWU4xamZhenNIRDNpSnpCVHRpVjYwbWswSnptUWtaU3hGQTNrS0ZOYUowVzVicXJGb3FkMDZjWEowY2Z5TExNS1dMWTVVMVNDcFVvT0l6d2cwaHZseGQ5TnM0NkhzejVCRDFEdXhMelgyOHZ2bjNTUy9jRWliNU9VSGRWNTB6cVpPRmF1UVg3VGNMZC83cjNINVlmbm41WDhiTzF6WndJWGtNWHQwWEZPajBUbVlmMFlJVno5YW9aZHJFY1VET29EMkg2akhZZmtPY3oyaGU3OVh2bWNHTURoZXVhYVBMaEJLVFo4bWF5YlVPV3lSK1JCVnpCRE10djBaaFcrY2Q4djNLTHJ3d2lpSlIxb2pJMUU2NGdjajBVZ1VqakNTeGpQbzF3eldWdDNOY2ROcTNpVE5HNkt1R25xNWJoZitVd1B2STgrc0dGVHFqRHpsVU8wbDljaUtiTlVMWnlHRUhvd1FuT2ZYRWphcG91MUx0aTcvK3lUYlhvL2hrRFBPQkV1dGhtQXBKcjhJTHBIYVVqQ1VOTGtFQWlUMGpjdFVZbFFvS2dHQStmdmFteUJGV3NiSnpiL2x0TElyRCtxek5VVFUxUm1RZEZVMWlzR0d1QnI1S28yU1krRE9XSlZ1ZEJVekJQMmh1czA0KzFaYlVUKzNJejd6RUg3K3dHcUJaTHc4WkwwU3F4ZEEwSlVrU09oV3pTQis3RUt5eHFyQmVpcXhpQUlUdFNVYzJaOGEraENDcEZUQ3RuMCtoVzBvU3ZaZEZvOE9abFQ0V2ZncVEvSTJmT0xPTTVVVG5jcCtFRWRwMHM3RDFraldTVWJIeGhjdHRxQXc5TklCYm8zUTZINTUzYmRpbGQ5YzBSYW1iRkdkcDZqemZQcnUyS0U2U1o2OG50N0w2enpmK2xpc0FoYm1HYS96cktqenZPL3l5T1EyekRUR1RMbzAxdGE1dm5ObGJGSkk1aHBsTGk2WmMrWm11dGRsNnVqM3NKUXVxRFA5MCtkakZmSm9Kc1ExUmx3MVdWaXovdHlpWm4zTE5XSWljMGEwb0hzMnBKSFI5Q2pzZG1RS3Z5OEJpclVLSjVJSnlnSXAxSXltVFg0dWU2U1NjVEw3YjVwVXd4UzFOUEZlTUFxVGxJUnVtdXNoblBCVWRlbVo0cHhGSmFZZTk4Z1VkekpGbWF3QW9McjZrVzVnMHZ3RTRjeE1xdWNUMHpGUjBLSHRNTG5BdC9wbFdON0VZZDdPUmk0ZFlNRmR2KzFvZE1tbjJYRTdYSmUwM0t6SWZ5U05CMjBnTFQ4KzJOTjQ0d2NFL3RyajNraXFOeDV1dnJIM2dEZjJ1amNvajlOSG5EajVQeWFha0wremJWQ20xQkRqeDBjZkhPY0ZHcS91T0M5azRCWksrNzdpYTlqdEwva2FTZnVleGhkL3ZnMWZ2TWQ5TWF6bjZMMk5YRCs2RExudWRia0NJd09TeGlEREpZbUM4ZkxaNVVuNVoySVpPUlFHdVhiNTlyZkU1ZnV1alcwR1RXRE1Wazhvem51ejRTd2NHK2wrenpucG9xMEhUQzdER0ExTmhCWXhDc2t3ZmNuZmdkaXJXSjRGTUxrYXNCNW44MFE5VG1iYXBHeDNGMUcrTnRPbkp4U1F2aHhBZXpBSDlxTkptTDlBZ3phVmIva1dpQUdaWHk0dTNEOSt4eVVvbE1Qa3hYZCsvb09qWjZ0V0ZpZEtNTGwzNjdObmV5bCt0bHowSEdxWTVFdklOYXVIWWpwNThpdWVJeVFYMDEvMytTTm5lVTlIaUhMcjV5MkVMNC9NWFdvc05YbXg1T0luTUx1MlB2c0NCZE9TN3BYMGwyQmJzd2N2S1UrKzRIajFveW12UmtrR1cyZldLOHdDWTQzbEtwZkYvZFE2dUVUaWhSdjRBbmU3cFVUcmdTNmlEcmozQnhXV21wQzRtTGZsQy9wamtJZ1JaNWZMbWtHTVZleGw3ay96T3cxLzBnOURKMEVzRmtEcmdsQnZpZncwVEdkeUJhbHg4UmF4eS9PVVZaU1hJUC9ucEVLT0JUbCtERjQ0T2x4eTYwNGV2OEl6dHVaSU1GcDdTTlUySlJncGFWeUs4S1BoK041QjlycGFBREVFMkZmcHNJTVFLQWZRSTE5S1ZLVVlxYlJJMTRud01MRVJLY1BnZEYvL1dJaVVvQ0pTZ2dPSkZCWGVybksyVFVyMk1vYjJJZEVuR1UyVkpldlhrK3l5OEdEUnNrcXZpbUlTUWFvSlZTanFzd3hHWk5ORm9KSHBIQkVYVVlFM0x3bGhBZFdGWVBBODZaS2dsWG9qc2VjbFh1aDUxRXJKMUc5U25USkJjaUVDbDNiY1E4NGJrMUl0QllYTWVBeE14T2JRQXNzNldBcjFoRVg0OUNEbEsvUmJRV0FNbWN6M3lIMlN1YnRQeTEzY2VIcVgzRWVOKzgvSmZWamwva3pDZmNmdXZwQzRoVXhpSmxKRk52cDRlWG5MUjVVN2NqcmlZZE1rdXpPb0FsNGtRemkzUkRVL3FvZ1JGdThuNzByeUc5cFNvTVdTYmgzcmViMjJzRFJReWhYdHNsaFBabVlwc0FyYUJOaHVGeVBsaU43K29aelVldlVOajlhZ0xlekJMZFBqcTVTbDhZMFJscTNHYWUzOGFsNVpZR2wxR0crckNiSndxb2lxM1RMQWk0UnlZcW13SGk1dEV2MGhkVlpHdlhhd083dzlocVpJQ3I0QlpwWXROU0JObEpPVDhXeFRXa3VzZXFnTGJMbk5iOHZieW41c0h2RGJmZWhBNXUvS3VHQ2dOYXAvcVRMYTVqdUJKTXdkdC9sU3F3bVNQYXJPOGxYdTBPSWhyWExYOG5LL3I2YUhYSGFySkdVcmdnS1N1dnVHRXhSTGd4a0Q1SEsvQzRucWVWQm94YlZ5K1AxM04yWEh6TWM5M0xZZnd4UzkzTWw2RWF5TlBZMUFnZktGQ0lvaGFBTFVURnFaZGFTbWloNEdmWWpxSldPOFBPdjNSbmlxeU1TODhRc3R5cmtOZWxDYVBRTHVHaFFVNnMyeDRhNmtTbzlLd1BLUFAwdFVFUVNPSHo3dUhEV3NqZXJHcGxLUnNrSVVGM3VRcE84bFhreVJXb0xjL24yOFZNdk9WZS9rYVNSNCtjd1g3cTRVSUZJT1ZSL2IvV0Zqbm1TbnF5R0Y3Nkl0WVorcVVVYXhXLzZmL2xqa0JjS3FtQ2NRUTdYb1JOTzdPeTBPODcwSHRiSXRMY0t5SG5jK0diVFFuSUtFaG9kU012OUU3RXhHTkpJQjQ0L0lUUDliYU5HcmZxVmZjdlZZK3YrVHNUcGJZUWk0b3hqS0dhV2hIN0RBUGFFSlBtS0ttcHpnSTlUbFV0YVJVK2JmL2lOdS96aGw4bThsMlkrQ0t1Q3R5ZU94eFRnc0dybldReVl5QjRHSU1Tb1JqdWhUNUo0RFk1SjdNV0RLZ0tmWmJaVlJOOVpBSG5Pc05laXg3NFYrRU1haGV1OUhWTlMzYUVyTnlDRXd4R3hCTlpzczB4ajJXQjVDcUZxc3k3VkZQQUdtUXg1T2RCbHlKaUZXbmlza21xZVFLRlB3ODN5UDBydTA1WlU1TTBIZ1hVVlFBQUdNaFk5Q0l3dVNROFcwbFhVbmFsSWEybnBTSGJQNkpqaVBqOGZNTGI4cko0akJWcVphZTNqT0k4NGdwaGFFVXRtWGpSaFlqczFweUFHdC92RGd5cUkrNmh4eGRmeCszM0E2U094ZEFZVXN0YkVyell3bHBwVnJVMk9sc2c1b3JYeEZVWXhCak1Xd1Z3bjBySXlGQmp0QlJjazhYd0FFU0dqQTRLYjhWd2xpTXlZS0FXTEt4eUUwVHBMdFA2UlZvN1VubS80TWcxNHZPMVBsbmpjcnVsdGd3TXVTMW92S1d6U1Y1aU1mdE90QW1aODZlbUdnSUFBMDFBbHNwdEgwL1RRankyWFRnQncxTXh0NHpjbjV5YnpZMTJtL2hHbEFsRmdYb1ZBMzZVckZmckJGZFpsZjJYS0ZLK29Rc2dIYmQ0MjJ6NndmUEUzOW9LUmllUWNIMkpJWkdmanV5NTh0VzZKTXRlL1V4RFBYcENHQndPSUxFUmU0ZFFpelRpdUFQUW40TWlJbitBdWpUWkpYZVBJcTRuREUxVWlYNzNrVjlxK2RiVmo3ck1LME9nM3hwaFZSMUFKNmdVMW1SQ3hFWjVVMWo2V3pqZ2hhNEtqeFo4MUUvaFpaSHhIellLZFhZL1RiZEVPT2E5RXlYUWo2UU9tK0RkTlRlUlRLZHVRYk1WRjVUdkxDbW9KRWNURHNmSWNHeE1UdC9zL0djcXNRYkE5aWUxMnlFYWZ3SStGMG1XNWNMNWZwSnQ1aDltOWF2LzU0ejNOYWdhUXE0MDFYeWpKdEZ6R3R1OWl1Q0tvSGdCKzVjRnZZb2szOUVKY3ZGeFpMRGhPS05DSWFTY0J1TVMrLytvWGFRZ2tXN3lRaEUya0J3cFJzNmlaMnl6QjlrbkNTNS9NcTMzU1M1OEtvb1RyYjM5NFI4cUpNeTBmOC9PcTBSOHMwKzA3Qjc3ejE3cFpLeWV3N1hML3g3M3ZSc3p5UGxpSlNSNHBtVHZJOGl4emlkSXhCTmNLbXByN05keWhQN1ZxWGVNR0s2c0pseW05dE95K3ZlLzlpeGM3YVZma1VlSi9YS0FKd3lYSWRkcHNQNkV0c29vbGg1RmNGbkZmZjRTM0ZDMU10aDFuUG9hRzMzNlBRV1d5bERWdjE0WEllcCt2M3FucUw2aXFacWlkNTNERDIrc1BaczQ1QkdIZ3lpN0k3RGg0OE9EVGtwc3FsMlZlc3E5OUZNejIxeWZRYk5veUZSNFNreUNFa1JRMkVKSy9NVnBtZFhLZnJPWXNoaE9mV0h1U2JzWHN6YnJ3WjRjMXdBQ1M5dWYxQlVNZHRDenhPYUk1ZUhkVlhvdm9haFNmb08xRDB1V3JwWXoxZm1uVExUSDhzOFRNaDRqUkdoRmZ1bHBSV21HVHlYMlJKMXlLcGxRbGJtYlZvWFNjZGtjb1AzSWlBWGZXQTBCQWp1dm5DNURESWY1QkFoYk5TRW1IVk5NUEZFMU9MYkpRVlVWMGU3d0p0bFhkNkszdmVSQ21FYmVGTlZHKzM4VFpVWTdIcWhodXZQcXZ4a1ZTelJjeldHcHF0cGRrOFprc0dzcjMrODNJT1Z4a1RWdnJLYVZLcXNjYlh0Ylk5cVZGZXJPVjFtSVc5anFFcDMzYWZQTWovaGNKWVBpczhCc2ZUNzJFU2dDZmhSQ2c3SzlYTlJzSFp0NzlMZllTU01zeDN4RFFhQzRVNHdEWUpodFBIblFsZ0xGd1B6UGNpelFzSlFkVG5NUmhvWUNDclZtUDI2T2NqallqTWVhVGdmRlpOSEJhWTRkbUNZWUlqNklnU1JsY3pGSFlReXZpSGFBSWdEaEgwSXhaYVVpSGNHZEJXbml2bkNnUHFzeUNoRkI2dlZPeHRJZFpXVWt2cW03SlVBMGt3YkZsS0xPZHhSeEJVQm1QbHlGVFI3b01QUmhTYzdHV0tvaWk5LzRPeDhvZGp1TXlGSUFwVzk0SUozQ3p1OThMeWdXQ3FENU83OC9IM21obitiQS9QNzVlalVIOU5BTUh4TGY1VWVmUG1maGxMNmhXdk9idC8wK1RzZGZFV1BYNVBucUtsZHJuOVNDa0dEZS9mdERtN2ZTUm96NFFRcHMzNjJFNkdSZmxCemU4aWgzU3NJaGsxaEY2R0xqeXdPR0VsR2VhdmJmVTZrR1hPSURpNFg5NzJLajBVQTkyWXdJU1lmRWlEVndZYnU0bnJLSWpxOTkyZ05Bay9qUm1KQXpVelBoT251b3dYWXpWQWpQQlQwc0ZKTndwdGUrQysxSEw3VXF1eEw2azJWZmVtQ09KemY0QmVvellnZ3YybUJtZkZScTBjTnV0cjI5SkdUcFRFQlZPTGhQaCtjRzU5b1JpalRJRmN1VHFLS1UxejNNcGVHMnJkVjkwWDE5blZNV0paY0xhUzV6UjdLYTl0NU9nbXl0T2RYU1FFODByelY2ZTlsbk1iaE1SV2FNZmIydDBPU2luZ1hpaXJITXIzaUtSLytRbHNkeGxvaWtpUDQ4NEpxbmVWN0dzeFFTS2RIWEo3WnYrbWJvZUtlalBydFo1K0dxTnNsaTNwb1hMSGF4UHVCU3JhOGMzcEVMUlNJb3NGZXV1WU9tdU1Tb2Q4dmo5RmVHUnAxc2hMRE9zWmxIWlB1N3pBYS9JTldXTXZQY09OZEdXSndRR0FrMmRVL294akhYSGJEbEF6di95Slh1SzRBSE4vZit2OGJtdnkvbFozbE40WkxvZHZPU1o5UW82MEZJbWFrSkpTMTMrU1RUenExN0ZMNVlzcHpiOWtlbUhHL01vemw4Z0JxREpiSFVXOU9QQzhHMmhQeEhySWtwOElWeEtGRTlPYzRHbzIxU0hjblgyWG16cEZOUlZvcmF5UjVhaENnL09DYnNGSDBYTlZobjJxVkVuMnlWTnllSytqanlrcWVzektDVW5xK3JVZzZKODhKYUpSMHdlOXZuN25nZFFSSWdQSlAxUk0yZklva1A0eWx3Qk5jRFFqS1BsSHkvWTdabHZCWW5CeWk0MDlzTFFqKzhWb2ZYZFVYeVlZbFJoakp3Ui9yRkIzVXUxeXBvaUVxWjJDS1JsdGFERzVmNWgwVFFEblc4b1BVdmpUeStkdjJzeEhIQ2kwN2lmZVNobWtEQnRMZDFUNUlsSnVBV2Q2MDBKcWRMYm8vS0ZNaTlaTnZiRUJvUGpSb3JPbHgwZFE4M1NLc2MyOXprV0FESURGRkR1a294d1hJeUw0dyt4VW91eG1FNG5PK2tQVjZLcEFnZ2ljenQrbnJNUUJFSFVUTzE1Q2l6YURmTCsza2ovUDVrNkdzTm1QVUJ1V2dFYXNESVZwNDJSUXZTMHJvSHoyS2dyY2hCUlpaeEhaUXQyWEFEN2EweWhWS0Y2Mkh4dy9SZnk4VVVacUttQS9qL21DOGt3bTVsdkFhQi9lM2kxK3lnNUNaWDVMellBMjZNZFJydnFHVTI4OFJCOFhqamRDcldhL1cwbkQ1SUQvdUsrR0xGZkw4YlZYVjRKYXJ0eFNTeUtHUUhNcjlWcHUvMFdzZGZ2cTEyT05BKzJWdDMwVHpObXIrV1NpcTVSZy9tKzBEMUxmVzkwM3k0ZmZUemhjQUphV1Jmbit6d0pmSGxwaEpOVDV5NW55YVZMY3JsZHFjY1R6WGo0Y3ovdC9xSytXYjBjZFhGeFlpQzFLS05uOEtTbmFtbHVKczJobEZwRC92bWNYSDhIcmgxK3JBM0g2MlJHSzVlSTZUUHR3SW50bkE4cGNRNXlxUTRsSno1Z0w0QUVxTG1zV0VFNzBQQVRKQzBJYjZscW9GbkR6aWxhT2trUXpYN2dpZ0Z5M2VXeUNUWXptQ3lFNklBdkpudHdjK0NOMDNJVjIzUEg2c1hyWUIvSWNWdVdaM1Q0c3oxaVY1NTVtbnI4eUxWdHhrTmcwUjVZdTFLckdSMUhxOHNnZTVOU0FkSFdDYW1iT1RmUXhPMXVzSjUyWi96S1ZRMnRHWVNzc2FDcXNrVDZtTm9KQWZ5dy9zOVBDNVhDTEhhSzA5TE8zUjBHcWNUajJ5SWJpTFJTZUhmVDhqbDlFK1M4VGhuZlJoTjExZ29KUXo3NXBURFoyQmdnOE9yemwydVdrYUxCWVFUNkVKZ2Z5TjNhai9OMHBDT0YxRHVFWndSK2dLbGl0QVl6azFYSi9PTTBRVE5jdVZ4RHJvUHpiYS9aL05ZVHIxYTNmbnIxdTg1b0pXbDJVZ0E2YjZwZkVEdXVyQlZmcHZqL3BiKzYxVDhCVjBkNDFwMFRHWUp5djJMNktHdjExNVJ0L1NocTdYYVFYOWRxVGU0azdsRTU2THlqYWs5R0xwaFV3UkRKT3lNWVhPK1IvRDlLS0hYNStXV3VwWHN2bnl0azhmMVdMdDVCYjkvTlhNeXBFSVNPK1pDT2tRMDR5RTFTU21ZQ1NHYVhNRDVZTFFqSmlSSCtPM0o4c3UzL2dGaVByN2FvQnhHMnZRdHdHWThOWDl2akRCSGhCOWpUTStSbWJxcEM2L1NKeE13OHNXSlMvcGcyRGhmd3RnTHdQc3U4SFFYdExNaU84aW5CMGFyRlJCQWhkMUxxMGFGM1VBMjVEV04rMjg2dUVZbDNMN20zTnlDc3BmaUJVblVUdlJ5L0VrZlRDOWIyeENWSys0NUJON3lya0xwY0RZWkdRMkFudkRoTk9KdThlWGh6V0hWTU5YUzllMjh1bDFNTnZFclpxMFUwRTkwdUtlS2JYS3NadTZvMXNLY1p2Nm1WeS9rcmhxckRiVXJRMzkwYUw2STlHdVZPT3FkRllkbEV4TWtNL20rSncxZXhGQ0t1U3p2UmdjaHFkUFFHbDIrRkZhMWZ2c0tsaVVWOHVwZjViRUhLbnZia1FIaWlSZ2wvVVd6UWhWUnNySk10NFgzN2xkZ3lkN2hWajYrUldadldsQ01DajlQVGgrTWtSWHhVczNwYUw1R2djM2RYTmk4NnU3bUhGV0hlOE9MeTdTS1laOUtiWmY4WUxQbndCRUhQSFl2QzRjRHlSeGRDRnVCcGJoNUpNMmJlQ01KTEY3aERRaHlESUtqT3pBUGlRUmF0VzBad1BFNFVWa0Y2VkNzaEU1ekNJTUdTQS9JWUF6Q3dyUVd4Ri9meFRxVHAvK0pOKytSd042eDZWSkZCUG4xaTMrN0plNjlZSy8vU1VIZGMwb1BqVUVLSTl2eUVFTk4vNFUwYnJaWkJnSUt3aWV4WFQ5c3VIMFNuWXVldUsvWWx5UU9scFpPOVBXMjlRQXdqNkl1L1gzVWdIMGFQRDlJVEFxYXpuRDhTMldNL0p4VlBsOWl2R3NOWXpPU1ZQYm1qaXVKUTY5ZEVNbXRabDVsbnN6emw1bjZGclVNK2RqQUZleW5mSUd0OWtFUm85bXVKS0dUdXVhSnhFVDEvZ3JhRXYvVjd6aU12MGlKTThWMnVlTW56cFBDZGhuZTJhWmxIMytCclBnVUowN08rYU1aU012YkJaSXBoTjl5WURNWWZzSVEydWJOb0g4MnRreXIwNmhoQ3BQNmxmbmpNdEI0dVBzSVFxR0l2T1Y2R0lSaXlCN0hUSzRwQVg4ZmszdlpBTE95NXBtRGN4VlFSVGlGcUowSVRycHZsZDlXZzBNSHNJa0poUHd6TC8wbGNLU3ozekVtMVBNcWQvV3Vqa3hEbzVsc1BQVnhzeVgvbGEyUk5LZUhOQ001RkNlei9WYXhjaFFvaTNFY2E5NVZTekNLT2s0VXJYUVp2RFAyc0FaeHJKQzg4ajVTMUZyUnhWbVhtd3NSZGFKQ0NzTDE3R2ZlRUgzcFVPbUJxNnQveUYzN3BoOEsyU0lmSWVaR1NvbllFR0pVRlFkS1BTVGZVMkc2dzBqdmxlZjZVNWcvcHlDcTRDRk9ma3haKzY4c05YL2R1L2ZQY3ZUZ2poNlE0MzhuMGYvK3kxbTFYbC94V3ZQL25JclQvNDVQZGY5NmEzNUNBZTkvc3kvU0hIbmZ6S1I2L2E5dENPRDkxK3ZMNTR2K1RjOVk3djd2clVUNjk0K1BZWlZRSkxZWlAvOTZyWlI5Nng4OUtiN2pmRk1FcDg4NGMvZnNrVnU2NTY1WVVPazJ6eWUzZnR1dWZ2Ny9uQkJ6NHlVNWYyM2crOC9xRTNYUGVCZmYvczFhWHR2LzdXYlo5OHd6Kzk0bTB6ZFdrL0Z1TGl1bDBQNzdwaGhnemJiRUJadXBLOEhpVDBGemlYMDM4SS9YR0NPQVd3NnA4MzJBQ3Qram0raUduR29GQnp3MFIxWEppb2ZONHdVUzNKRmROczVCNnZSdXBqMUNlTFVMU01TRmNMcTMwTURVS3lDM1V0dWMvUlNWQ1M0SllWVTY1MkZ5dDRVZm9YS3ZpVnhrQ2lBbnBNT0xiNHdqNjAzTEZWNHltb3hpaWlSWTN4L25BTklOV2VMa1kzbEcvNXlhdStKSG5ITkF4VmUwUDV6bi80M3M4VEpLaTNUdmtzNUJaR2RuMHhPbzNmNmZYbFYzLzVydysrVExPd1hMejI5NWU4NW91Yit6aE5UY1RaTHA5NElYcWxHS3N3bjF6SXFMeHdZYVFHUTB1MUdXNEtXTEV0aW9LeHYrd05ob1FteUY0WitVZVE5ZWJBSG9FOFIxaWVJNURuaU1jd3NKUzE5bkMyMHpVOWx3UGVBeU53V1Bkd2p2bWk3dUppWEJKSEpVZTcrN2pHdU8vOUxZNzdlVGJ1SEdXb3lVNGxpemhhUHVIQ1lyUWN1M0NEL0EwM2JjQ1RseW5HV3psK29keU1Yb2k1TVNKUDZtblJHN1dKOFRnTVlXc2F2OU55SWFNamZ3NlhOMXJseUlVYlFDK05sMHN2bEQrUGs3VHhzb1cweGNVaXVaNHVGdU5iZmZucTlqZHhhKzFMcWRLaG93Z1lOdW9HL0hIU2o0dTdoN3VoRmdxUXZKTW5wZVI5ZU9kNXhTS1pETFNlS2NhcmlaQlZFK0Z4QzA2RVdlbWF4Mk9RSDIrRC9IZ004dU5sSXZ5ZndOOFNXY0E3UkRvS2RtL21OZ0NiZWNqNEVSNDYxdGgzenBlYm9wTEF0bDY2RWZxeTc2b3VzcEpoeXBncU1CMm56Z1dMV3JSaEdMQkN5MjRKbklreG5ZYUdlQlpwelZxVHo3cE1hSmhqTGpNNmFhK1FjbHNsWWNJUzdqM2xFcm5MOUc3Zmt5N1ppb2Z4TnR3K09JNUhqOFAxUXkyKzlMdHkvVWlJMVBDeXlSTzNiZDI2VmRzOE95dEVtL0EyYW1Va24yVVl0ZWN6MHNPUHZ0TGlNemRFRmxYdFZhMktGd3lwUkRtckNxeldFNExXQXl0NEQ0T3FDVkVvTXptcVozSlV6ZVRJS2E1ckdZOXpjSnFmTXV1Q2FqbHFJTHlyaGZnNzZuaU44U3I5M2NFcDl6K0NjTVlGTy9CNlBrcnpyVFFmcGZsSGtjN05iNFJlNHVpUWEvN3BRV3BEUHlTMlRTU3NENnlzTjJmbklveERWZnk4dVlYdThQTDN1T0twTmtwcEVqNHN4RTBSc1hBNWN1OXZuWC9UNXV5aWcwV1lJLzlHRSt0Z3Q0YU01T1lIRzJzcFlvcFdOYlJxOHZPZjAyclB6MThObzdweVF2VmR3MlBMQ2Izd1J4YU5tUFRBRTBIcjNuNjVIT2xsb1BZTmZubnlxbEcvZk9ocU9VVExpRndvenREelpTbjVVMExycktPNC9ud1oyUGFVOERkVGhkZlhXR1cvTlBEUFlyZ2kyak5SRWZzc1Z5RVV0bUdBTWlwNkVLU0syMXZPZGtWNjRhVDFxbGhmM0tkQndaTmUycE1qejVPeFFaZWNEMTA5N000OURZQlduangxZm5ueVh5andIZWIzZmE4bVlPSDBhZkJnUEgwOU1HNDFjOEpzSFh0dCs1RlQ1NE9OL3d2YVVnYlRFeW9CZkh5NTJ4blJxNkJtV0hET0U1U2NkbnFoTmhtSWNWTU1CVTRwSk45NU16ZE14cDhDNmZhSERBNEhNVkpraEsweGhMMzRoQ0ExM2o1R2FEaVZDTWE3VkRZTS9JNEN4cHpuNi9qUUhsR0t5SzlzWlRmWGRrMURkaUJIeCthQUphVjJzc3pMSzI1VWtSVEUzTVk4TWxqT3RNR2dxVHpyNUpXVy9iSjNEMlJYcFVIK3hwWkRLNVZHcEVxZkxTbi8rWFdLM3JqUUJsQkUyWDIrV3NHeTR2UDc2aFhkVUJXMUJrc1pHU3hscFF4S3lyVjl0UmRPYWt2aWhENlF1Q3kvK1UyY3o0eG44N2x2UXRNUzU5OVBpUWQxOVZmaUxqMnZFeFV2aFRnU1pPUVJXMzQxQk5xWU5PdDZMVWtPejRCSHV0Tk13a3JHSnlxOEkyeUM0ZjUvSHRrejRmWWVmRlVNb0ZDTFkvM0JONDl4N1BPdndkNG1TN3p5K3Z2aTdGUEcwOURJUHQrZnlHcmZuNVFkWVl1Q2plV2U5NCtwZGgwVzlnWEtNcis3UUFPNCsvbHNDNXNTZmlEYngreGFyTDY1SFhVL3RubFFVbDN0MHpsNWN2YmlWMnpkdG4zSDN0bVpFNElscFBqSWNsbUpGN2Zvc1ZHQ1N5OWY0MnVmTzA2M3hkbGU3dnRyMWtzbUpPaGdlbWNlWmd0ZjQ5QXhXT3ZqQnBKS2YrTjhxY0c4cWFHbU1tRGxyaVQ3WXV5UFZxNEs4OUx6dXNudy9hMnlJbGFweWVqMndCQnR1QUU1MUI5bEJnT0NZbXhYT0NhOHBmeGh1OEVmR29ZS3NJZUtFVkFPTU81SVRScStubGw5MWVZenBFdHJHcE1ySnNmS0dHUWtPZzFjcGcwNFoveWJ2MXgvZ1hJNzAwVnJQWXFXRm0wTHFNV0VTTGZqV3BiVDlob3BwR1h0c21VZ1FCZE05enBrNGltRFk1TlhIVkNqTWFsTHV4Z0RPeHNJR1M5VXdBalZRa0tvZGRGYkk3cFZiQTlHcll1SkVpM1RZYVRvME1ZZ1g1VEFhRitxM1hhcUFZQUF0Q1VaQ2oyb1FSa0xvZVFxbXBqcWpVMEpLejZtbkxmc0gzM2E4VEt1ai9jOHdOTVlnaGVKODh4MVlTaDF5cXFlNm8xdzFhSitiVGVhMVdBQ2N3SGRWYlNuRUs5WG9XWWc0V2lwU3I0dUJCTmdCTkE4UU5XV2hZZU9rSVNZRmhPZFJURXdmQnJqUVJlV2Vka1Qya3RHNWFkOERibjQ1UzlaeU1VM1hSVTFCY0F1NU9KYllacEorOCtMcHZxMjE4bW1kSmE2a2lsaGlnT2ozNk1udDNwUlBkcTBycWFaTE12NXl4ejRqY0Y4MmNjSDYyYllXZkVhc3lrZktFS29RaUZCZ3czUDh1Y3JTa1BJenBPdFdkdmYxclBCVDMvdTBUUml5VVlGUjloZytNVkRtM0ZBeG9FSy9WYWZEbGJoN3g1TmMyWm4rdTkvcnVkNUoxOTU0a0hhYzJET2dVcjl0aDhQVnVPN2o3Sk5ONXZVZVBhVW5ScHBaOEYyelpON2J1MyszYkk4eG5iK0o4K2JQUEd5SnViS0NRdTBjM2p1cW9iLzNsa0dxL1ZYaHo2ZWZqbnJiNWgvKzNHRE9KQ2wwZWUvVWZyZ3B4YmVoSC9mOXc3WWRoNUQyb0tiOE5CODJZMkgycGxTUkpsdlhHampHc3pSck9OalRoNzh6TzJIV3RlbitSNTNoQk1YM0pnT3pGWFY0cmYxNkRGdXJsS1FXKzNld3B2US9EbWJOZnF0UHg2c3hpSFBuLy9zZTVQTEwxdG9veG5NVWRYaU4wbCt6QnRIZVBDTkl4eXlFZnhHNlk5dTR3am0yUkFlZGRwQk5vNGgrUTVTTjBOb0hQam1ZMGhic0c1RDh4MzZSaUZGY01VdVgzQ2pPREJYczY2L2xVZVBjYU9RZ3FvVitwd0ZONHI1Y3pacjlGdC8vQmczaW1jRTNtU3g0RVl4bUtPcXhXK1NQUGlaendTd216K0V1ajQxOERDT3o3MHkvMjdhUzJpazJDcG40R0paN3Q5eStnU0F3SU0xRXd2dEk0K3VoS3IyL3krL050ak1Md1YrOEdqNmNwWDd5T3lXZ24vaFBWSHUzdzlEVS9tN2VtSWhGdkRSbGpHM2hmOFB2empZM0VlQ3dKL3h0enlLZmozcnl2d2I4aUdTMXk4cjdQZUY4akUxZmluczl3OG5uclBBVHZoWXk1cmI2ditBQlR5YWsxbStjY0NlL3hqU0ZqejlodWJMM25Hd3VuM2tnQTM4c1NVZXJINURNbVozSHVwUllHUDFQekZXQ3gwSTgrV2JPK0MvcFllRG4vLzZvUjRVeDRRdXpQQTVLM2JtMzNtTWg4V2pMNlZxeTMrVVZ3ZWJmZitoSGg3MWgrNnRQdlJZRHBESFVzNDhyZjJQOFBKZzg5OFlIdktCMHZoWUNTRGozL1JRK1UzSysvKzVleGNBdTZycWJ2eWNmYzY5OTl3NTkzRW1tU1FERTJIZjgwLy9YeFN3ODMxRkhyNlNNK2JGUXd3S3FmYnozMktsL2NjN29TVWhJdjkya2hrZ1lyQWdLYUtGbE1LZEd6V29BUUlJUVFOa0FCK3hhcHQrYWtYRkdnVnA4Sm0yVkZHQmZPdTMxdDdubkh2blRnTFVXcisvbUxubjdMTWZhKys5OXRwcnJiM1cycjFHNFAvZ1NqcUg1L0NFbk5xNVo5cnU4ZUlTRDB2SVo4NTRoRjFRd3E5T2EvV0ZwaDBKdUJrMm1VZWY3eWFUbTYvWFliNE90OUhNbExmWDVQK0tNN3hvVlVicHlLcU0wZ3lxaWY5UStndGhtSDdITGI2bW02YTlpTFREb3NxTStZNEEyeXVVUDIyTnY0aTB3OEkyWTc3bnI4cDRxZWQ4QXR5S1Bxd3FZM3F1Rk5aZjFhY1hxY3FnaWo1cGRRaXZQcXdxbzNmT1BFUy84czh2QkpjbElQVzBXbDlvMm1IeFpjWjg0ZWZtZUtWeFg1dy9wdWJpM3VlZXg4ZzZURnA4eFVkckFLN0ZhakgrRzVFYllZdjJWL2RwSi9wMEthN3NpR2RKeXVVcmgzQnJQQktyTzNTVmp4S0x5NGJpMmRubldicVNKcytLUGdON2lNbUpFbnZhMHRUUGxwU25EaFhoQU13ZWxTTk93K0RDeUt5ejJROTY5Z2gxOG9yTDlhekw0VFhFa0dwbmUxeEp0cmhyekxVcCtmaWJzQmtiY2NmU1NDRDJQd0psTm03N2lKMFJuMnVhUGVKZFB1SWhqR3FZVEhuTkpWOTYxZmdmMzlSNllwRldlaFo5V2prVXo4V0VoNXArZHJLUGtJTmtMb2thRkpYYjZ6ZEh2dlN6Wis1NjR2MjMvQnZhMW1IK2RjcW5tbndEOWo1NDdaaEdmc3I2YzZseVFpRUQ5ek15V1hjRzNiVW1yVkpua2htL2tRbGIvVVJ0V3BtRGxSNWxaRUJOazJVNFFvaFg3TWdXMHlmdHBTTkJRQjcwOGlsN0tHVS9SNTdxeUJZcmsxSHhaeVdncFpBVm1wMTFjaXlBTVBtcWU1SzZoSDQvQnFPRjlmVHcwME1GdHFnM1Jnc2h4NUEybm1zaDd0d1FZTGFpRVJtN0tCMDZHVVhNU0RodEhLYkNtY2JCak40c2VYQTdaKzlBdGZOOVg4WDJ6QXdmVjRJaHJFazB2VEI1eEd0Mmp3dFBQZHdNQlpkeVE0bXZlNVdNMnBSQ0FBRmJ3Y3NiNVlIM1hmOXZjc2dpeFRzSHNIdE85c3E4bVhKSW1aSlprZ3BOQ1U3dG1wd0RmaytJOS9zQ3Njd1Vic2hkYldmcWZEdFQ1K1ZtYW45dXB2S0xrY2N3OTc2dllwRGV0ME9Zb3Ywcy91MmFnNm1nOC8yV2t1MUFPdUVIcDAvNGdlNEpQOUs4VGZRZWhhZG5uTGVEWnQ0T21IbVRDcnJtN2Vranp0dkJhZk4yd013YlY1ak8yNEZwODdhbDBCUGl6WVg4dkcxVko2azMyM2s3eDg3Ynl0eTg3WnRoM25qY2MrKzNsR1RlcHB6Y3ZMa0NTOGY4cWpRVVZnTXVXaHhSUWFEMk1WZGQ1REx0QUdWV2lNTWcxTjJRZHVySUtkSnNnSmFRdzR5QjNFMG9FQlJvaVB6Y1NQaW5ldmR5MDEyMVVmcGdpRTNnOHNaQTZnaklkcCsxRWNjR2thWU84cVpEVzQ1N0JlM0RzN21MTlIzQW9tdEFPNWMzNW1oM083eFNHNVdzRXBYYnRFd0YxSkN6Mll4UUNWWnBUZXhUOE9sUmFLWi9GZE5jL2hFbzZ3S2xzeDM1anZNY0U5RlNPMmZyT2RUZHRmZkNkcm1LWGpqVUk3ZEpHNmJTL2cwdE50VE45anUrejVMK25ROVQwaHJ5MVhEZEkzMDNyb1hGclRBNHpWdzA0OHBRdzl5UEkxNEk1NXY0WTRWdDdKWmZwMTdWeGU5RTEza2N4QTZRa2lzbU9lc2ZycE01RGxkWGJzdkFsR2JyZUs3YjRGeForK2VMbmQyTGFxWFlQa3dybUZmZGx3d25kMy9VV0JTYlZvanBlS0J3VnJXbzRjZGJqeDRxUkE4V2lKbDQ3dzhMdWpLRXFISW85TlNINkx0RWxac0dqNTdGRmJqZ2JhUjRvOHFHaVJZK2xrSUhLYW5LdFZhSFlFV05XaWU0VmdubG1nY2IzMzd3aUlDWjd3Tmx2b05JNy9XdVhjUFh1WFlSYjNGenEzaUxtNjNpNUZNdVl2amFFcHZTRWhQNUVoUDVFaDhtTXJIQ0ZsaGk4eS9PWlovS2tZbmtkc3AraXMxK29zMCtuTXMrbk12ZGNqbjhQaTdObWNKUzVSUWMxUFlsRWQvK3g3YmVOWHlZbXR1TSs4R2U5aHYydEIvc2FUK3hwN1h3UFNiR0FrSVpxOFBFNkhCSC9welhuUHZuSSs0cWRoMk5UUHN1MmxlY0lBNklDNU52ZkszSUJ1U0pMOEU4YUdXem1UWGk2L2FPNCtDRVorWGNZRWRLM0JiWVFtcnViSDZjcUdUUHc5bmpsSnMrRS9iUWdLNFFqOWtyaHZ6NnVMdEJqVm5mRUhlRzIrUWN1RmdmdkJLV3F3ZSs0MGdJVUZpTHJteHdURWc4VHZ5dUljM095OVNTT0lJYzV2dytURTJqM1kzKzNPVm9pOFRmYkFCVzM5NktxcE9tMDhQVW9VT0h2cDJ3ZWExOEhtcjBpeFUramYyVEhKcHJZa0tSa0FBYjJwY1NsdE1malFaUDJZMi9KL0xmVisvVy9maGR2SnRER2FPMkZkVHZoMHZHNkoycjU2anRXRkdKQkRZMXJtM2VZaTRqVGxOK0VzRGprSU44YkhsU3NaZFFVdVlrajVPY3B0VkhJWGltTlpUdkNMTlZkWE5DZ05uOG5XVHZ0M2dNRWI2U0EvSDZjditmdHlieG8xdUx0TDZlOURqVUFlemZhZDA5NlNVckd4eDFuRDdnTnNzU0xvQXRzWVd3U29CbWJHU2RoWGhyaERtQ3dRYlhGUmdlWjRTdjBXLzhwTVhOazVZR01nVnM4TTkrbHFCczA3cWFxWFYxZnl1ZWRROU9DL25DeDM2aVJ2NnV5UlpOclhGblVSZkJwNllLMTduODJKUnBFNkYvQkdHNWd3YmhrbW94M2lmV2lCN0ZmK05qbEhTQWtlN2o5TFQvU3A1MERhbEozRDZCQWlUdUxUcWJ0K005RlhpQXpSNjVwdkxHS2dMTUp5MkJHazgvNHFjLzVEaUl0NlRKdCtTVHIrL29vMk5TNysyVmVweTM1WUt1ZkR0L05DMWZza05SdDJlQ3BOQWJra0pQU0FvOUlTbE1nNlRRRXhLazd1MVo1OVQwdk1tdGlpOXVwcSszcGNOL2U5ZncrMGNZL3VKdlFLZVRuV2xIZWtEaTk0YkU3d21KM3hNU2Z4b2tmazlJL0o3RDcvY2Nmais1QTFBWFpxWUh3VFI2VUZsS0dFaEVvY2lFTXFNSFlZNGV5REwzWlpuN29BVXFzZTVHeENNSWhhQU55aTcrRjBybkFxaFpuakZYc2Q2WjRzMWRYWGpqSFFGdkNyOEJzNVY4d3M1QUwwaTgzcEI0UFNIeGVrTGlUWVBFNndtSjF4TnZ2SjU0NHlWM0t4dm1tUEVteU9GTk1DUGVGSUEzaFY4SjNuZ3o0WTNjSnp3RDJuU296Z2pVZTFMVTJkV0ZPdW9JcU9QL0JreFljcStkaEY2UXFONlFxSjZRcUo2UXFHbVFxSjZRcUo2b28zcWlqa28rcWVReUswTmhDaG1tRkpaaWxXU1VLQTRGcDhLbFZZaXUxUnpXRkhOWUk3SFhxNGdwNjlJUFlVMU9YTzNQSVJCN3B5Tm1ac1VTbnVxTDR6cnlDRmJGYzlYNGZ5L2t2Z2h6UVIzOFZJcGZ1N3Z3eXowQ2ZubS9BYk9hM0pmT1ZBOUkzTjZRdUQwaGNYdEM0azZEeE8wSmlkc1R2OXllK09VbTl5c0pmdXNtajNqd0ZITkZlSU9YS1F0dlRpcTh1VVp5Uy9qT0NRZEJIVWpvU09SNmVsK1lkY1k3WWRqVllSajIxcFBlREFRcDdzOHdDc2drYkdkL0N2TGIyRG5VVHg1MDFqUVptZUlxcXZPcEdvNktuOGMxbTArK1YzSGNtS2R2VGtMWWh3dE9qUE42VDA5T1hRelhpcWQxS1hmakh3S1hGYXdMWDRGRGg1c1h6NFIyTUZGMVNvbTdQaTQyT2JaMHNmbHkxMW1EaFdVZVNmb2tZVHVwWHd4RGkzeE1oemViVUVtNGRWTDdaZ1diSUN0Wkl3Vlp3a3pBT1U2Q0JMQkd6Zm1LY3lNU1RobjNYajlIRDR4Yk0wSkl1K0sxNnFNKzZEZHhMWlRMZDBNSjZMZy9peStDTVFuU2daajlPQjF4bGpVZmtCS3h3M2VhVmFDQjZ5c2xpZS9uZkhiNHpwYzVIaWtEWFdWeWt3YVA3ZitxSGlCbEVDbURoK3ZUZ21sOU9yR2pUMGg1TlZMbUg2YVhWN3YvMlRqM3ppTVovdVR4Y2YydkNCL2ZHZnZjcUc4YTlibFJQMnMwajZ0UEk1TG9meFd1dmpNdU1hUWxBMm1KSVMzbDdLSmVHQjYvTS9hNFBzL1U1M0Y5WGxaZmZ2WnZWUDlsUGUrRjR5OXNMRjRNL3IrZzBSbFZhbHh0bUdseHZFeXhaN1lzRHJ6MGRTOE94WXVqanhjSFpiaU8zZWpsOFZwSVVYbkVmeU8xNVc2WUNmVlJmYWtiOVNWa1RZbFJIM1YyQ1diaEx0ZldlYVRwNVhoc2RuYW9LcTFlcHFMcjdBU2FCT2M2TzlVbUliak9Jb05KcUZ4M2JWeThscnRtSjhyTWg4bHcvSFYyeWt6Qy9PdTBLWkFmOTIrK2NNQUhzem9Ici91VjlhUzdLL096SEsrK3JxdHZKM2IzYlFIM2JWcm5HS25HZWlLVk9YTVJwREl2MDVES3l5RVZaV2dicE1KakN6TFdOS1FhNjRsVXB2cHBTT1hsa0FwMWRvbHRCcW5HbnNmY2VIbWtBak9xanZOMDIwNkZTWERhZGlwTVF0UzJVMkVTQnR1dHVOamlyblVobGNudzVyWWRlSk53U2x1YkF0T1I2Z1VCUHBqVk9keitsZldrdXl2enN4eVh0THY2dHJxN2J5dTRiOU02ZHhHUWF1Tk1sT3JFUEtVNmNXWktCWlJDUk5lK2pZeFNlQ3h2SENQWjNCMGJxVzkrYlJmRitqMk01OGFaS05hSk0xTXNvQmJxTG0zTVY1MUhzb2RjVy9mekl3RHF4R3hqc3RGbzA0MEpDZElKYkV3blpoc1RmMEJLdWpGSlZvRW50OVdjbUcyN2FabDAyODJYeVUvSkUvK1ZmVUJLdXJuTzJLc0YwM3AxWWtldmtKSnVvRFAxODJVT0g4cXdlSk1KT3ZSMFkvcDB2UkYrM2gvNkVRMkp1NEV0d1RSdTNKc05TV2kya1lSbVF4S2FiWU4rTDRUTUovZUV1Rm9aYlJXT2pmdkxxZkVNSmY3d1N0eW9RdytQWHluM21QR2RObnlReG1GUU9CQk1hVTBqc05lb1F0S1A1NnkwQVYzMG5PZ0J2bWZNaXYzOFNlVStxYndtRE91b05NcVJiQkRVTkpSS3pxcDZuVWM3T21SNU1LNndSQmhYVDNDY211ZTRDdmNHUUptQ0ExRmhhUk5IenJrdUxXbHZEZXplNU80VTFBQ1J0WkpNVWdWVUhEY05UVk9HSEZ6ME5qWTlLaTFOeDREajd1VHExM3hUaUR4U0Rwb1YwN2x3amNSK2tVZ3YxS3RsSFhCcHZtZTVtSHN6TTVBdjNZZkUvVmNXcUFyb3UzeTVnYkpYMDJZeTF2RHRpelFLbGFRdC9Xb1VzejZhMEQ2Mk56UzFjVzFhYnlwSDdsaU1rSXU2THYycjlVY20vUE9SSzhuM0wwWUFUMTJUU3VqYkFlcG1aRWRLVFJ1cHl2TWR0MXk5ZlZtOTV2b1N3ZWtvdWNTYUJabG1HbEZxT1ZER1BBR2hHdjE4dU5xWUszR09QWVE1NmdkZFFRQWlDZXNvQ2drRTZ5QWlJOUhaNm9hZlpBeURucVFtcDVyTUZzMjl0akZYVkJaUm1sZlBQWVVmTTRPQW5qQjVCcVpNd3pmdmVjQVYxK3hBMVExTGttSitMWS92YlQydjFaalhBUm8wemZPd0VmWUNiUmExM1U4dDl3TTBKYUJGUm9GVU16QkZzaTNKS1BRY3Nicm9qd1JQNnZ6YlQ3S1FDRDgxUklYbFJtZWxId2pvbkQ2a0g0RDFkd0NXUXcyTy9CZ2lTeWhaQ3NtRWo5aWhCZEdMRGRERDdWY1hUeUpzc0hveGN3TXZHelVVa2t0OXZtN05hdEVLeVpYdksrYTFhSVVzcTI3R0E2QzBBNGJTRG9EU0RuREF4SlVjc28wUDhaTS9RL3d6VDZKcUgzQ2FIUE9NVW5idU1sSFBrUDQ0cDdkeVNmUzZ4YjZlRjRabmltMUNJYWNVVm5rOXIwanRIUGdac2Yvd2JFS0JDQXNBUm1YTUJOVU03L0RjS3Q4V05peEJiUmZJdVlVV0tvOXJaUkN2L2l3TzM1ZVM2TVJ5T0gyWWZWZkNrZEZJWTdSUEgwcWVnMy9MV2drYXhyRWFLN3EwQm1Cd2hER2VRYmF0OHV6ZE11dmlTSWRuaVE3YlREL2JOd1ZOdk1YOWpBNTF3a0hLRU5rTS9Zbks4QVE4a1EwVUNpTW5WSWU0d0pXc3VvcXBMcTBNT05QSEkxWGZvV3M3c1BkdVA1TDBpa2krQ0txTlFMNUVZQ1NVOThLNGZoWXRmdUlOY1k5QmJhaFJOK3hmWVFWYk5CVkdjVGwwTHRJWDdnaUhHWUd1ajVwQTNBU3p2OVRlOUticGh4QnRRYWlEZWppdGZQZ2V6NjM4UjZmTUJqUEd0TmxRYmJuNWlxdDJ4bVMyUXBrekU5YTFnam5IQlFmVjV2VFpvcmM0TXJOVnk2YVRrc0ptSTNkcGo1TU5mMGdFTGh6ZG9ZczdOc3B3ZWp2R3Q3TXVJZVRaQ00xc2hEd2I0Y3l6UWRXZlJUU0ZZeWdUMlJwSzFXbEhtSWdRZDVXODhJbDRQZ3RSNVJaaVNwWjZMY1FIUGRWSElzYXZaU21DZ09OY3FUQkMrd3NmRGFwR1pIVDh0Qmlyc2hnejRRWnhUVEc5OUJiWG1IZU94aG9SRU1CbXFDVytNTlgxTVpyM0FsKzAyYlVZUGRuQnBicUtxUzZ0VExBQm94VlJIU1BIdkNlT2pBZGRsSHJRUmNhREx1cndvT3U5SWd0bklheTBYSDFkSFpKZzNNTkdPbmdlQzdQNll2RGhSazhGNDk1L2RBb1pvM2dhc3p4aGJtbG1NMmhtcm1wK2Eza1RJeTg5N091Y1AzcUw2eHQxYlF3ME01dGdTcXFPZGRrUTJRbXA2ZW9HQkVGZU9NNHJ0TXF6VXpXelUwMW5wMnBtcC9yOFppZTBzeE9hN3IyQTJRbC9UYXZWdU52M1dLMGY4RlE0cmpiODJsWXJOazVQdUZHeCtHdjBaNXRuVGRhcm9jRllwSFh3bjlWVXRYbWRqcTZsOVZwUFdJOUpIMnJwaC81ckcvMjlOODlza1VxWlNrZGxHWHIwMC9zcE0wOTExV3lOVmRrYXEvK3BLL0JTeitzYmQ4ZTgzaE1qQUFXN21Qa285NTZpdmxUdzAvVnRuRkhjc0VJMjc4dTJ6VW9DeXowMjNjaXR6WnFkcjBxdnVSSTdEa3hUMlk1clBBc1dneEFST2lhRVV6c25yM1BqRkY2M2pzRi8vKzYyTHU1cTYyaDM2NTdlOHhDY0ZWZWFQRTRFODVDeFYreWNnbnlBVldHWlFhK1BNQVhsYkFyUzhzOXJtWG01WldZdHFYc3VzNy9oWlRiMmExbG1ubDFtbVlBVjVhd3BabHB1c0ZTdlE2eXFwa3BmbW9zV0w3ZWdLUjlxNllmKzFoR1dtNUhScXVMeGxsWW15ODJUNVdZVm5QL2x5MjBUZUJhLzkvUzg4TVVXdlpqRmhsbkxHYjNVcDgxWXg2S1RJYzBXWGNlMHlLS3pTZlVXTVRMZGk4NWovcVJmMXlkbHpkVm5tSXBmNjRwYklESEJxZldubnEzak5tNjVKNUFZVFhxblFlVHcrdDh2cVFLdEpGRUxWbWZ3RDYzaUZzdjVyQ1R4ZG1WelUxelM5N1Z0Rjc2bTd5ZUxjaTRkZnppa1hSb0J0V3RiWEV5VER5NDZmeWd1Ym90bi9YVThPNzNXSytGcnZXWi9qQy82bEVDMGZPdFNBc25LUFQydURWRlg3S0tzSjdndzNsaTdzNmF0bWd6Q1BBUTN4TzdRYWtmdTlyTXFybFh4dFhjNmM1ZEVOLzUwVkM0VDllQkZnNXBxUTZMeHl2U0dSdk0xclAzbDhuU2k1cGplem5IZUNsMzhRMGtMZE1WOFhhbEw1dWtVSFpoOGkzWDViWENlcVNiem05RVBzZFFPT2h5Tm5XOG9XUXFqTmN3YUZZMHVMV0VwNHRJWFRqb24xUUlRdnl4ZXZUVys2L3hUUnJwL000RTRDK00yZGVqUUh5VGlOWk5FeVJlZktvclhDS3BxOEtYUmhCR25Fc1JzdW5NaS9mZ25VWjhJMmVUT2swcFNhaVpQODRqR0ZZUnNSOUIyS0pYWFJMY1dNNUM4azlSYktYZjVWQS82MEFBT0h3eW5EdzBoN3A4cTZhS01CeE5KM09KR0QyOWVyd05kam41VW91VXBBR212eXZwalg2aFFKYWJHU0h6a0ZYRk9qSk5pVHlQNHUzWllQV21hNzhyZkl6T3VUYlA1R1kyQjFNZkRxUU4zT3doRytFQUt1UlBQSTZ6SXdiUlVLUC9DQnY4TXBPcUdRNGNXblY3bDhQUHlBUDJLdXg2WHlTL1VEa3VzTWFMZFc4TWpqNitXUWNzTDhJYTdMSlRjUUFNbkxCZjNSK0JpR2d3VC9HdzNYa0I5NFRVYmZhdVVUUmpQNDhONzdEd21mNjh3VTlYa2czS1pZN1hiUXF1YVh1YUlLL1cyeTlSSEh5NkdzcUNyMERqMTlxSnh3bU5TalZONkdiRFV3U0h2dzRtYVZ4MFB4UldGaUVHNXQrWktGemcyTzkrdEVWYVpPYjZBTnd1c1hPcW51cUJSU1ZhYUczdVNJTHFseUo1WS9GQlg1cWJGK3RMVUU1T3ltVXROK2RyMHdxN0dYTFU0b3pGS3F6d05tWmZYdjFPMS9JL29mMVRoTzdMNzgwa0ovSDRxdUp4akYxOHYydy9Gb3dKekpCdm1yaVdESnl3NTU1ZU44dUsybnJzdDJsTFdpazlkODlyRGNuS1RpMGt0eTRRTTBNTjltSkJNTlZqT1ZJTnNHWmZieGZROElwZnRlREJycDNFVWJRK05vNkVQelRha29Vd3BXdHhGa0RUbVE0TnVENHBma3RndHE1OTN2OHlONXhnYXZYbVVXaG5kcGVkUHhzZG16YlJqbGJlbVE3NjBHRWpaUzdUYTFqZ0dGRkZ4dCttbHcwdEdsK3laeVR4OWJEcys1b1k0bTRTM2c1QWhhTDlxRVpWdnA5TVRUT0UxemRacTZXUDBNWktEL2t4YW9yK24zV3F3MXl3cTBJUGJvcHVDbUIrenNudGFTeWIvKy90dm1UZjI0Q0pVLzZxajV2L1c3V2Q5ZTFGN2lmL0pQL04vdE9ScnFEdHRkWEVHUVRRbHpiVmJTd1p2K3RmWE9WOTROelZHTURUZ1ZKc04yN0ZkNk5YU1IyMkxHY2JjcU9uczhmeWhtM1V3ZlVUVkRUVGlrdkR5eFg4RWlyeC9WeTJwYzI5akZUMVZTdmJmVzB2Z1lmWlVhVnZqV0d4eFd6NVpTMHBaMjhkdVc5TFAvN3RqVDR0TE5IU3lqN0lFWEthaDlMSFI3WUUrOXVadFd0TVV0UnUwL282aDZaQnJYOHZKUXh6MXYyd3BSYm1iVXBRdHBVam53VFE5TU5YeHFoZTMwd0ZzdFZyWlJEWDR0alpaTE94Z1BHU0hZQUxhOUtGV1k4aXNGZjJTclkyWGRBZGNNRnRhelFjbStiamcxRjhqeHdNNWJOWXVySWlib3NLWHRzRG1IdDNXUTl2WTBIZzJhL3BtRzAzZmJOYjB6YzQwZmZtMUdsYWgzQ2lPWXMvd21vM1o2VWxFbnh5d3phYmM0eGMxalE3Y05tdFU0UG1LR05MWnZTQ2QzVFNhajA1SUVkaXBZUlFmalZUeDBUQ0tqMFplOGRFSnNNb0RQQ3NQTUF6clpobUFsUUZZV2plcXd2OFF3Q3dRZG9MaXpnaUttaEVVb3dkNTNxQjRQVURwcHJpOHA4d0FpWnVEeE1zZ3lVVEZEa2lTOURwTFhhTWRVdGZ4cDR3TmNnNDJ0amxtWTV1RGpXME91Tnp3ZlFYbGpaYzJSdC9ITGM0TDFmRVFXazRrUnFHTW4yRStlMmJkRkkxL2VsWHVJdDAzcnN2amNaazRqcGprU3QzM0pwQisyR1BRdnhWRHZGVGdySGtpU1Q5R29aVmVFUlBnQnR6bGZKbVFLM2VrbEpCeFFWd1owVmR3MjNGMW5QWlBlaHFJNjBpalY3NWM1Tk82dWxGWFJzYmZQYWJyOVAveDdURzN1R0lvVnJoN0JZRVVLSGR0akVCSkJlNjRkQ3M3Sm1JelZQYjhITE9yeEE2RkxSdTAvT0tpRmI2NzhMeitlWHlYVGpNMlJaYnpCRUdZTXdJTzJERllhb1FiR2ZZeDBRbHVOMzYyanNncDAzTmMrbHExUUdhSHUrUHYyRERpanJFbU1SUzFJaXRNRjlBSWpWKzBZMHlHb0R4R1E5M1ZWZW1jdVVjVmpIdDJjeXdFTC9abjUxTTFRZ1orZkJ5UElROUxhUWlHTzdCdkRUckhKUzZleFN2Q3NhUGptOUh4emVpWUVTa3UwMEYvd0FzU0Y1MFpFUTI0SXh3V3lwZEd3Wnk2Um1MZ1kyWXdsUVA4a2FWaGRRRTR5MEZPOE9UcXNma2swQ0ZjYmlXOTBpMEUwb1lHYVVNZ2JaaGUwLzdNZHh4QVE1VjllalgrN2wwTnl4Wm1vamU5ZzlFTW9LOWdnWW9hS3pTalMxbU52SUpQSEs5Nm5MMWhsN0pvWFdUbGE0RTVtSkk1c0tWcUpzNFgzUVlmb3ZKbzJjdjhTdXk1Q3A2eUxFMExHRTFhREI1eitwdk9qMzIrNUFZT3NyUjBOZDU4WnVEemNuUit2VHFtcGdJaDBkN1ZhTXdZOEZjd0NCVXpDQlVNUW9WV3JzZVhvbjNNRitjR3N5RzZ5V1dQK3IyY0c3N3N1K1gwUnJrK1ZOaG5LdXhEaFgweXFqU3VQSVBLU0ladmpWbTlNTHhNWGhlSVpETy9xbVNZV1dsMFRpcEx3WWxuUHRoa1d0UXJxVmZLbU0zb2draVV2WVFuRmlZaFI1SUlKYTdTWnFHSkhCUUhxZVJVcEFFc2lEQlVYQk9YZUNoeGxicEpwMVF6dW9PNEczdUExK2RDTGZCZnNJT1hVaVlaMGF5ZmovWGdRV3pkWHVRNzVYRXg5aUJjbnhmSzgwQmNKSVFWYkxEaVVTbVRrOWdjM2VRdXNtbDZUazRxc3B3RXNoZGs4bWhSbHk2SXk0THpURXA4SFZ5d3hxZzBjTE9WRVorc2dBSngxamQzMGgzUFMwaXVtc2ZrRklsb2tNUzNrZVM5OGUyajZBbzNPc0JWOGZvcXBhSVpLSWZVblRqU2Fkb09lcTRzWGF6ajg1V2VYUHRua01wTC91bUJEaTdMTTBoMWhuTE5LZDJtZDhRcWsva1lqNXM3WU5FMUhIdHNYS1kzNE8vQzJPZTNCUnMwZS9adEZKb1hYVjhNdit1NWhYR3g0UkJpb3VYK3V3TGZKaVZFSXdBNnJFL2NkVmpKRmxsa0VaWVFSS3pJNmppU280dmFJMHJKR3hOTUU0M0xQY1k0c0I3M1JUR1JPWXYzVjc0a3VtVHRjb2pCTkRqbndhNWJ5NGN5TnpXcWtlWjEzeDNkb2NIcU15ZFdaeEtXOGFWWmFldmU2VE8xenBkazJRdDBkWGswYTcra0daN0ROY3ZGTEVrcFNKd0UzOXlCQ1AyanNZdmgyeTNoS3c5RHNISFpxdEk5YmJnSkJOYW1EZ0dreUpVaE9GdFJ4ajBHVmhaUEgrSXErSzVJMm1sSDQ4d0tsTEFMS0ZUUWZmZ285M2tDYzVnWkRNZGRtbkdYMStMZTFXTWpvc3NtMUhHQko0UklMdU9KQTN0SFhyeHFZK0pGZjFXTVBjcks5emZTTm5VOHlGTTlIRGtmSVZ5ME44SlgzWi9MT21PRkNxS05JK05qZUJnWXA2MDE1dGd3NXc1QkIrYUhweUhDSzMxTU51SmFYWmQ0S08wMGswc2s5b3hSaUhDd0JoK3lncE1xUUZ0c1ZUbWVVbTAvL0tlQ1YrSVlGa1JTaDJGYTJKT2tZcHR4Mlp4ZVRNMW9VOFh0dDFBTDhEVjVLOFYwc0xKYmJwdkxXZE9XT1V3Z1Rid3dTRUdIejZOUEVnYlFpaUVPMk9BMWpZZmgwZzduaVc1aHIzTVdpUURRdXhxcG1xK1ZOdStValJYeWNVM1hXdHFqcDBtTmEwTHhZSUl6ZVl1M0lVaEpUVmZiT0U3TlNUbGx5RGMrUkdYYzhBYkxDRkZSMXJyVW5MV1A4VDJvUnMycE9GSVB5UjJRaE0zVmNDK2dJS0ZSeGJUSUxMVUorVlJJUHVlSVpkS1B2bW9zazdwa3d0UXl5YlNwYTVBRU9xK2JvKzJreUphY0htbzhSUXlqdUVJWVJuM3lCNFdaREtPODVPb3ZmczlaazN6N2lkMlBlYVk3NlZRSWc2dTllNmwzK3dsUGY1SnNTeVhObGt4SGthZko3Y2pUVldtYy96YUpLU25seHNCMnd3MEIrY3V3SHhuSUYxaklkUTV5blRQcEdwNXBGd2lBM3o0dEZYY0RiWk9lN1U4eTFreGVjeHBmWDNtb2FDSW9LWG9rbG5TRHhOU3pzdklpKy9EYVRMbmdKMnBaN0E1aDcxOW1oZXFKUmRvZjR0TXJWbFVqUzRONXoyWDVreWN3bnN5QisveVRLaE95dXAyazlZOE8yOUVkdXhiMXVRMVEza3dCc2xnMHZzdUdzRStRU0dEU0wweW8rYTZreFpLa09MZVRiT2IxdTdzTnR0QmVvNHkyUUs3NUhsbHFMTkhhRzEyL3F5MlhIcFpTc0ZpQkRsa0FjWWpxN0poSnpFenBuampnbzBuUUJvMUhPZHRKYmlRKzFaaTlYZTgyTTVWSlNTUlhKem5vY2l5YWZRNE1kMFZXS3hpcVZiYzBvQUFHYUExaFhrdlU2REdSWjZoM2ozMW43RjZrM2RGYlJ3YkFNNXpMNHRjblBsV3plOTRFWXlxQ0RUV2xCcFhjWW1wdzVacnduZlRLRm8xR1lsakdTbkVsZnE5VXFtanZGRTNqTmtCY01QS0JaWHFCcFQ1T0FxaHMxa00wbU95UTVuWXRtWHZ1M2J2dkdGV0wyMHYrZk9DMjVkLzVzL1dMMnRIdEFhNkxiU1V1dDdCKzE3WkpCTnU1M3QzZHBwYXU1K0cxSjJRMDJBK0NNekNqT3BqODVWZU1vdGxKUE13RkFSUGU3M3ZSdU5yZzlYQlhZVWtvU3lsaHdySENaSENZMjhEKzBTZlRCT0krUjJZV2VOS1lKeE9KYktFNTZpcUl0T0JabHdRejRwdGNNV2JnUStDV3U2YUorU1d4MXhWeHF3R3RtanhGck9TMTFmV0xoOE1jbkwyQjdad0ZrN0k3cjl2ZEdFenNMdWJyUHRDVVFSMkl3Zi9zcExLT0RSZHE5RWtNWWVLQnBDSUg2b0dlblFUeWVZRDJCSnNtQ1drTzMrWVE3NjlycjcxMjkyUmpFTGNHVzl0OGlKKzZqRE5OMjI1WGt5aUhRdGhTS3JnRWRBaFg0TElsQlJXcHdvYVJNKzF1M1JRZnBRY243NG5aRnJnbVFjYXNiVEN3bkRGbjZ0QzNGK3VqOUx4MlBLZ0gwNVR6aCtKQlMyT25kUGFJOUs1Tlp2QmpjdCt5YkRJNEpOT3pTRWJyVm94MWVsNVhUbEkzdXVGdHZsZnJqVDZDTEtVTVdRSWdTemxEbHRrcGdqQUtXYnlaWTgwQ0xGczRBN3FFbmVoU1NkR2xtcUpMRGRsdmRGbHpJMWFLZFVHWjJUU1dNTEtPSStRRHlzek5vVXdacmM1bFFrbForaTNLVklCTmdqS3pMTXFVYUlBTXlzeXlLRU5wa3BEbThHMk9QTXJNbllZeUFWREd0dHZWcEVHWnVialV0Zy9YK0RMS2lLbk5YQjNxeU9MTFBEMlg4R1hnRkM3ZFoweDE5RUNHTHliSTF6dzlweDNQMVhQVEZNS0x1Ull0SHRUWkk5Szc4R1Z1Tjc1VXFYM05RU0h5UnVHZCtOTEgrUEtZOS84UGNxTkFibmhTL28rbk5yT09UR3FFSUlERVRGTWQ5eUlLMzhNaysyTzkvR3Bmd0NTbkJDR2RjRnFtdjY1WmpsaFBUWE1NVGZYY05qdFZkRXp5dlAvc1NaN1hlNUxuSFhhUzUvV2E1SGxkVzhxZ25rZnpmRlRYUEIrVnp2TWdrWVp1ZFhxdmFYNkZxN29PbEtOblN1eHg5STVZeVFIenBpY2Q5Z2YzKy9uUUdnZk5kN3VHRi96aWF1Mk1PQ2V6empMWjlEVUpMNmlFbzBzZS8zYm4rNDFmZDVyUnMwQ1hUM3pUUG4zeFcvWUpDbEI1dXU1eCs3VGpDZnQwOEIvczArYXYyS2VuRDlEVDMzRFo5R25pU2ZNVWZiTWtJTzRURUwyRHE4TzV3aHdxbkNKQWlMaWVJWk1iNDU4cGhZOE4rTUc0c2o1MkIvdWhzaTFCcENnWmthSUVrYUswUUxKM25wTlZpTVdzckJCL08rRjZvK1F2bnkyeXhwS2tEaVhodm1HczBKRXg0b3lQUFZOazNXaDMzb1V4aEdTYlYzUGU3Nk5TRVh3NjhoN2ZrWGVZOHo3QWVZZHplYlVFbjJSdHFJQzUrZXZ5K3VaVWdYSWVERndjT1BTdGpzc25lNFB5Zk9ISm5wYnZsekRZZUJvREF3b0pHaEV4bVUybDF1RUllTEszMzJWdTlTdjNFeklsK3psWXFVekRvSEVXMUYxbDlNbmVQaW56MTF4bVg2Nk1Edk5EZlE2ejlsTzdhaWNSa25hY1ZjYktxdWMzdndYcXdwWFFMcUxUOEUwc3IyVHROMkJsQlRDMTlKRmRscGRteUNwcFZvUW5kbzBPZTJWMGY0SEh3UUllOTBuMFl2NTY0RzM0M01lRFEwVWJaZHdzRCtWT255NXpwcGVweGErRGFQaFdVVHBQL0c3aUxPZVF2NWltWjFZSjVCRk4zdmh5Ry95VHNJbUVpZ1FSSEpPaUJBa2RRSUszb21wbk84MkFsMmRXeVM5clZSY3V0NlZPY0lZVGQrM1NYSm1KVW1KdG5nYnlMOU1xc0lXcHFwSUFjQTZFZjJJWGdxU2N0bDlZTVpUMmhNMFlWZlJzOFNRMWhXa2NUcjcwRUpCdmlxY3hkYzZqZm9Za1dVUHlXWjlNeldON0VWdHVNZVBzank3RDdFdThXa1phRGlNSDBtSXNpcUtKd05BV1VlZFRUd0xybkhwd0ZjM2RoUDNmK05sOGpFUlQ4TU5WY2NqMnVtK1ZLWGwwMWV1SVg5cDRua2pBSnU3ZUQxZnhSRFZDZEluUEM0L2ZpSW5mdnhydkozdVByR1lFeWRVdjMxQTlGV0lZY3EzQVBNa3V6KzRXZi9LaHE3NUNMVDY2S2pUNWRMZzdyaXhadStNdnZya2FWakp5N2xTQkNSNXQxZ2RXNWZ3Ymo0K0pyYzVOMGRJVVVUZTlneVBJME5PSFZ1SHZMZngzeHlvY1NOekx6NnpFbitLRXZmeDNIeWMvd245Mzh0L043NkNkb1A5a0I4dUhLbFFja1NwS3J2bXlySlJrSmZXSkEwTHlybUFLOE01Z1pqajVzMmJpbjFZMUVFbDNvK1RwZnpUbHorZm9icElYaTFUV0VhMGNXcFpvYy9OYnpFZU95d3ZNV21rU0Ryek41Z1hwT0luZXBRNUdRVjU2VU9CUW52Skt0bkNqVm45d2YwZXJoRmNIYWFNay9BRVptQ3JnM2VWM3JsNnFuaXJZWlY1ZVdUVkxQQ1VhcnJ5ZnBENEJUVGNYUDBudGxDSDY1MnVBdUR2ZFptYzNEZWtSVXRKWjBjcVQxSWRNUFdXcXB5WDFiTitDZWxyVDY5RmNDOVZuYTJPckdFUDRCTEJsY3FRMThidDhKbXpndXk3WHhoWnBZL2Vuc0RhM1pHMXdRTFFvdWZ5cGRNQzRiamU1bFNQUXU4a3YvNUVqMEx2Smc5ZjQrUWowYmo0Q3ZWcGFOWURFQlRHV0JNTGV5VGgrNXdkMlo5WkJRTlFMaUxuWmRmNUo2dWxWWnZQWEhqYmtEd2NzZDRJSHNBbEhHMDZBZUNiN3pndWY4UzM2YVNrdThPR0pvTW1tZDNUU3RETU4zWFZaaDZKeVJTdUNQK2hLZEgySnRySjN5TUdaWFNnVm1UTFVZWEk4dlRyZnN2VFVGQWZ1UHJPYWxnY2ZOank5T2p0M1pMWW43VnZCOER5Mkw0Q0kyYUUwaDFGUW5pbUY3LzJXTExPVkVxK1BPRzNrOWMxaGlGMWdFNCtiUkxOV25sN1ZVWmptWStZU2Nqd1NnYXg2NlpPeVQzWlE1WlRPSkFKWkh2azJxdzA1QkNpWU02Mnl5UUtMbHI2bittTzczUlB0b085SklQMTUrc3YwYlBwMkZWYWpDWUlhSmlZKzlqT3JkR0VkRzN4R244VlU0OWduWkE1TUZ4b2NFdTlnZnpNT3dLY0ZoazhMd0tjRkMvaG9oYjUvVHVIMkM0UEQ1OVBEMXo3ZzUyKy9jUE8zWDdqSlhvVnJUVXoyOWZUdzFBZjkvTFVtYnY1YUV6ZjVoZUp3N1NiL0pqeTEvOHJ2Q05mdTVzSzFIdzhpNXRLcUJDcTZ0STJlQk9kKzdJaHVkQmtmbVcxaWJTMnRWVVdTdGh2Z25IdEtJV2g2eno2S1Nsc091M2taOE9rVXorUm1rdEl1a0JyandnWGFUZFdJQzlWVlJCL1lOVUhzYmMzTStSam1ndGdIKzJJNlcxeVRITnRNemxzYjQrVGhvMFdvVHlmNDdJb1BmTmpzMjdGM0w1aW1QSWhXSll2SFd3Z0lXWUtiVllPdG05a3p1dEFVVmh4V3QydWFzSjNBK3ZYTlNmMVZWR2dwbTM0emdBVXJFTkpJK1d4bmpJRjNzOHVVVEJuWEZOK2k1SmRqVVN3a3dMdzFVdHFVVmNrdHloeEtFOTl4bFdMdE9xVk9xV1pjeGlDWHpTQ1hNY2hsWTU2Z2twdjVKRm5KVENQZTYyMTNkWmducUpRUUppMjJCakZaQitqaGZ3R0pzbE1YbFoyNjFPMTY1SWdXeThQSFMyTGNzRlBoS0s2bnVVUWFCWDNDMm4wNGhpZGk0Z2x1cVdIbHA0WnNiNnZsNkJabnJDdU1kajNnUU9HdS9EMXRDTWZRWlRtR0R1UlVhQk00TGRrRFNSUVlwVDEzTll2aVVUTmZjc1VRTEZPaXl3T1crRzEyZnhTUlRxa0FUSG5aTEtXTTZTVnVya3p5TUllbURIWGZLQ3dJRHF6bVNDK0VVa2dpM29hMlBMRkQxRjVHMXBmYXgzMnJVeTZmZUk5S3YzS090bXhaZERKSnBFekZjV2JQcmZyWStISEkvKzRBcG0wdS9lWnBtckVuSVBpdllFdXVGVlZQT2lEYkZ4dGQzTG9SMis0anE4ZVlCK1F6TlJxQlVrcmZMR3UyZDNYY0Iwc28ySXpGWlY1c1piQ01uTjNzY1E0TWE2TDNNQXhzSmlHamlkWnA3TEVreTQyK2RCL2F1MXBqMlBlYWZZZWtiR3ppOUZORVdhb0duTXlvMEVtMHptMzJpZHo3NmRVeWhMNnAweFVGaEd5SURBeGNjZ2hhM0JRMEt0WEhBWFBaeVdaQksyVDE4Ykd2cVFNMlh3Q3dSSGJRc3VsWFg3UTVzQTJpc3lFTk5TRlNIeERKbU15b1BBVG90USs5RFk5U0g2elUwUGxRT2g5U05nL3pWZEtoTkZLR0lzblg0U2dvd3ZUQlRHMlZrRnZtaGVZU0lKbXZQdHNmY1U5bGRKaUo1eGwyN0F6M2Rjd3c0U0JoalJLTzZOSG5VbzdJbDduRUdTU2FNa1Nna0R4K3RkL3pnQmJoMDV0eEZldTNhdFp2RmV1M1N2VEVEOS9xd25ISzBzaWxsanNSQ3BvYW9QdDhPdVV2eTJ6OFlKQ2xQV3RDbWorVVl2ckxvVEhDajdpMmRsZE83WXdTeHZSOWsySVJOZGV5bHp1Uzk5a216SmNUTWJncXhncDJtc3EybWJQNDZpcXB1S1R4QmZURTBqU2ozTjZhWmxmeGNHZVZQZU9KMkUwVVFPeDZEbGIzNVErNVErbDNTSXdqWWZ0Y0xHOG1SVGVWanE0d2t3TFdDNVpYcVlWTllMZ2k2QXhUcWZUcFZTbDNzM0k1QjZabWhreVpVclNkVmZwQU85S0xPM0tac3FyTG9XSHQ0aUF0aWdZTDRKQk5kcnZSRnBJRE5LWkJCNGNVeFF5QnVDY2wxMzA5SmV3bDRjdk9IT0lUMlF6b3VMeVVseVNxRjhiaEhUQmI1YnJGVFBVWjZwZ3JaZ1ZwcG1kV2RXWEN5QUhsdzFDR1lHQTU4M1JQZmNjQUFNT1VvbEVWNUE2bWlaSkQzdFZlRjd3K3o0R1NOVTRydkVpTHNVSmo0OUxPNU5KZTVEWXF1R3RuV1JXVDFjZitnRVB5Q1p0Q0lmbVNqN3RzelBKYVFnK1BmcXpqTHB0Qy9pNmJRdktJRDljbWsvMUVlbmdRdk4xd0x2dHdMamVzQ1JmYTNMQW8rQ2ZzeWpOWkZQek1oSlF4ZTNnaHVlcFJmeWJMaVQ3cVE5Z2dwQ3MxS3VMNjZSa3pReElhS2hZclplSWFaYUdMWmRuU0t0QlcyNTJvUWhtdkRNRFhGbTJJdVlBLzBNZ3RpeDR0SFMxVU5GY0c1MHRGODlHVWNyZ1VySmR0WlNodEpKTE1vZ01iZmFQRVBpUzBqL3Z5bDZPRkJHd2dFTmpKQlQ5UHk2aVNZaldMaStENll6K1hLdkhsaTlMdHA5N0V4cm9qTnN3Uko4WEZIVytoUHRXMzAyalZSejQrOWNtYnR2K3oyZ2lIV2x4d1ZXZTJNeDlUNnBrMzZXamtrVy92Y2NkR0h0Ly93UzE5bDIxbmpEMG4rdmVTckV4aEZkQnJzV3RtcGpQWjVFcmNJZDRvdnB4dVpieExiY3JDbnhHSHZ1aDB5MVg4MElSQTg1aUdGYytpSlY0UzZpZlcxSUd4cXZiTkwrQmdpdnYwbTlid1RvUWc2V0IvUkFMbXdGU0cxZ2x3MXNndFlFNFlrNmdRWHEyeXRMTlo5d1UyZTcxcHRtSTZNVk96U21LN0VQdTRCamVQSmZXMWJFaWV0cXM2MjYwMDA2YnBzWGZybFk1K2g0ZnZkNTV1UjNtbkVvZHRBZ243b3ArVnhQM1J2ajlkRWtiSXZ2K2NjVFY3LzBYSmFyNndPL0hVTXRLUXJBZWJGeXc0NmplcytBcTR3M0tHZTVuWXdpOXBkKy9xQno3UWMxZS9EanVyMlVQRjJzdk5kdEdPYUlXZWlWWEl3cFNOdGlvN3Q5a1FsV3lJK1dqbk1CMlhEVmhjQUJ5MjFJdW43NlhFMTNCcDJVZjNLN2M0THNaN1h1OGppMnp3SVpBSjBNdXRYQllYSk1iYzhxcVY0WXJXVVVEV3RHLzZ4MzFpWkRGOUVyUndNL1RnYm9rd3lkMHlRMldOd3RQWXhnWEtwb3RHSHZOZ3ZOVlR1bVVEM2pzOVVHM1BVbTB2T2ZETkRxcnQ1YWkybDl6RmtwZG5xYmFYYkwycmcycDdIZlp1bnpER3dXYmVLZUdEZmkvajRKOFczVDZNOEw3aWpId0t6aWpCS1dXYmZORHhkcStmYWJSRWFKYnQxM0N6c0UvbFBOaDlQMzJBS2E2VDdEM0FESVVSZGdiN0t6aGNaZnZUWmVZQ1dDTTB1RGF1WTFsbTlZdXJPY25VS1g4aE1hRGw5T3pPaC9UZ0czR0o0d2IxZVhhZHVseS9KOVJKYWdxYXdpS3dCR082SzMrbEkvS3NKQ2NPYy8xVVJSd0FjZy9GTEdOZWdKTXdzZld1a1c5Q3c4aXpmT09SeUFHL0YwUnZVcXlYQUVTNkRETHVXcldEbCs4Y0xUeDNGUFVIWW5aV2toOGNGZk0xaU9YUVNvOGtZL1BKZGV5dU14YU5kbStnaGcvWEtaNGN0RE0wdldzdW1uWXQxQzZnem84OGQ1YnorUGpvMnhFM1VpNEJHWnYreDI0ekZzM2srV2V5UU95SzRNVmp6elVVemZoQ3lwRmVzdW1sYk1SdU1uNW1WY0pKMGhKbEpBdFM2ejVFcDRqWkhuZ0ljSUEvYTNSTkxCRW9tZHZBZ3U3bXBDa0MwbVZsRGVZdjF6Mkd5eUpWeUgyTS9YWENWNEtJa1hpdy9DUWptcnNRNlJESHc3V24wdnVLTTlGbU55dzZ5ZFJ0dzZGUEFJUVZodUxWMFY4RVVSRFc1SVZQai80NUNLLzJqdVFSSWx6MGZHaENXWFU3d0FGSkZId1VQTTBld3ZBOTlFZkZzUWM3Q2wvSUVnRjlWS1BydVBmVi9DVkJpTlJLTStxTEhpM0xlQmRvS3RnZzNzT1JzTXYzYXhBTllOdC9YdzRoZU9DQkRzRVp0SlJodkZ4Z3czVHRja3lKOHRBb1NlR3lMMVFTV3FCRFlMSjg1Z1hZUnIwSUJDSWNFQ1I2Tld3bmFCWEhwUTVRd016alJOR2VEUjJQWHMwWHpXUHF0VFRjeEZBb3BoTVpXWmd2cDZIbWlKZEdkSjBzSjhVTUpHUHlLTERHbTludndnMGZVSjY3MFIxWFl4aXUrMk9YNDhFY2txZ0ZZRE9uRG5tbmlROHVYaWJHQ0lXMnI4c3NicDNVRVZxN0krUG5EdFhEOUF2QW10eFdONW9GMVBrY29pNmFBajlmeEFMcHBSTVRqMUVEN3BMU1d3ZCs1Ly8reUYrK1duTzVkclFsYUU5UytUUjNDeFZ4RzdrcWNzYWNxUy90b25ic1JOZVZZd1NqY0ZDTnJmcStWbXN5cHJwYjljeEJHUzFrNVR5VW82MEZwYkRVNzJkVjFZV1g3MEV4QW9mbXNiV3RSWCs0R282ZkVWN3RPanI5YjBuNVo4OVd2L01hdGFpOVpQT2Q3anYzLytTMFJhMzJrbGRkcy9ydWhaZDlhQTg5bnJ0a2MrM2NCeitQMUExLytnTnYxajkraFZQNWY1OVpSRlczMDZvdXUvYmxkM3ptM3J1b3FyZTRWdyt0S1Q2Qm5IdmYrNVlidi9jeVp6RTlubkhDZStmL3QxZDZVNjJjSC9pMmNLOU1wL2NDcDFOblkycXJ1L0NVMXBFbms2dFp6R2NCLzRwcHRMTjNMUTFnMTBCSER3YmRZNDBBRVpUVm1uUW5kejF4SDRPWG0xL3R0KzE0Wi9NNHlYZUltbHhQVXE1c29taUZ0aVlCUTR0S1prZ0ZnbEVBUXRIbmJWemI1T1JrV2tHTDQxcHN4V29iY2Q0MEpNRmFmc01tOWdNK1RhdzZ6TVMyNUN3M04zWWZvVUcvTGtpZFp3ODVsNmMza0IxeVZnM1ZyWTRDMC9rVG5zNWtuQmNseitZYlJDR0JlV3M0SnRjWERpR1hlZm1yUXhKRUZWTmpBTjNUU2xja2RXVmJRemdTMU5JakI3cEZPWVJKTUhWZVBlRnpuU2JMMDduc1R5OXFkeFpVWERDdFdEdEk5T1Rrd21tREZMZUJEdkxma3Q5ZTB6eCt5U2ZhZTlwTHRqNzdUMjg4NFo5dXhhaGZzSFg5N2YrNjh5NDhycDM3ZnozMzJiWDM0ZkhUUDdqK2hodHUrRHc5d3VsRlozWDBmeU4rN0pXM2JpRkFmbEM5ZU1FWmYvNVJUUGZacjluWCt1UHFIWGo4RTMzbVo3NjBkQmNlRDEzdVhMdmd0SWZ3V0dVaytDbzl3bXcrTjlwYTFBS0ZWbnVTdVdkdlBjMWs2NHMxRXlDWXYrQ3NRMUpBRFlsK2RXRnBnWExlSDM3V0krUW9qTHRqd2c5R0g1eHgxdEZxOStkTDA4L255RGJrR21KN2Y2eUFaaHlQbFdtRjJnNW1BVlc4UDJDUWo3azRVV3RwbEIxa1hiUjUrenFqcTFONTlDUUpUMmhNUTh3L2lqWGY4eHpYQzlPOW81NCtUbkhMbmkxS1JIaGRCejM0aUNGQkROSWgxbldWN0tQTGdUeVMvVEplSnFQNUtxNUoxRXZkMUNWQzdiQkhuWVdsdVgydEVYQlI1QWRoNDJIWlJtdUJlcDVGV1MvV1BKOERXQWRic3k0UUgyY0l6eVNSS2hxbTNHdmFUUnBoZ1hiaVN3d3RGRktCbWMxclhMY3dqbWhBTVIrZFVjUEhPMDcwcmFBcVI2MkpYS1h1Vys2ZlBzYUY1TnhtelhPVm8wSTVJbk1vRlVmWXhDc2dFQk42RnowYVVBZWhwazc2MW5DeFVaTG1pUDJsUjdmaG1ITTZtdHRIQTJaTFdGczhxdjJoOEg5YUhiWGlDb3gzTGRUYzdzVTArZDRhaUVSK3YrdkVKUkZ5Q21MQ1ZvSnBRUkdSQlZ4bXk4Y3Zha0xGcFZDOXVJUVd3N2w4RU1XY0l1aHlNclJzaUJpajhGcVMzc2R5dXdkV3RNcHZINU94bjMzMko3VTNLWUZTdEZxeVpjNFhqbXE1djNodGU4bTd6bjV3N3BvSFYyRlJuOG1yOE1PTFdoSWpCZXdCUHkzNXlpbWJIM2p5RjdmY1Qrditqay9jZjlPUEc2K2wzTGUrOGNhSk4yeTg5b0ZXdXdYQzdiWW5XNjN3RjdQVUxDTEFPUER6SVZ2MmptekFUa21ERjJUT2lUUW9xOWVBU2NWUkVtVHhwUFVsOFhBcGk4NmdyeWxuZVdXTUZJNVUra1o1bG91ZXBjOFkxRnpJY1ZFRVVrVTdwYUpkc0VRdDRGQlVRdGxJeEhBNWNUQVJ2M1c0bkNjMVNGWTNHeFVFZVlOQWluOGMwQTFLakViTnRGZGJPcTIxRVBJU08rSGtQbkRBS3V0NVk5c25sRW5EdHlHYXVYWGU5NlQ5Z2duZ3hoQ1NNTDRNRmxVU2VRM0lGU2EvVGN4em81NE00eWNpY1A5ZmhEd3BtNWgwcGpUV3l6dytoUW5aTTVrcVdJRWpOUU8vamI5ejRXdmJ2Wnd2YXBreGZRM0R0aC8zVW9qNXNuUi9WK3JLY2VHRDZFUThyNnVTZWQyVlZIV05Jd3FEbFcvR05weVFIc3oxMzR6L1BCTCtyaWszNWdtZ0thaFRpOXJSdzRFTkVqUFY3dG5tckt6TldhaHAxcTVKcWNoUWdncUdZVFpFVWVxTmRLeVpqS0Z4eFI1WmhPN1JPK2tuV2o4S24xdnNNUFYzTmdZb2VWYVRLOWVWcXR0VkdITEZQTW9VNmdIb3VkZzdVbEdaZWVsYS9HUFdPd3lJWkFLMHJTayt3Y04wWldNYjkvRkJEdWg2eVk1emxRMzZBa0svSXRmQmpvbDl1RW9UNGhQUnNWcllPWHBVYUxhWVRYZ05VWGYxMTVRTG1rZEpMa2hMVjgrTHhqdHNMWnZQekFLZXphS09kSGp6NlhrMGl0d25qcGFWQlcvaW1ZS1JkdzZsMkxtT25hcERQcGdMV2RHUjZ5cE52N0pxOGVJNnZpbW1UQ0lsVVRwVVhta0VjSjNGR2d4TWtSQkY3Q1VMUzQyYUhKYXBJTlJ4VWRhd1pDM1R3R1Fab1VnSUNXZTVjU3k5a0YzUmVYVmhSY1ZFU1pwNUlrRXJybXNCSzZPOWRINFZLM2tGUUtvMlF2amFDWFluZzdTSWFRelRRR0lYSm4rODFLQ25VY2tlWWFsMk91UEtLRmh2VjYxMkhYR1ZGclB5aUQrZ0dldk5iUVJHQ2RlalZHZXJGV3pOZHE3NGNnTWdVNFlsZ1ZuUG1FbldBN0dtbm5iRldNbjQ1SmNCNXFFdHhCbHUzZm4rWTRDckhJZlNWRVBrUHpkWG1Ecm9ER21vaTZNeFh5eS9ZaWgyZU9mZ1BSMjh4R1BDTzhyMWhGMlRwNTNsek53elFua3loZXhBV2MybUVmc1ZieG5qVUtrb1dYTXBmZkZydnF1VTQyZFNZZU1vUTMycmpxa3NvODlZSVl5YlNNNkdRdDVZVXc2TlNoRys0SU42RUJNNE9NbVJQSXQ2MEd4Zlp4QVFnMVNUQjVoa2JOUi9UbE9xdTZsY0Y5RkJXZVJIZGJYYzRvL3FkTjdEeG5rUGszRTl6bXU1Vk5rQUd3UHd5RkxTTFVoeTlWR25lcEdrQmxtb05MTWFRenVkWWF5a3dubjVYbkdUODB3alZNVlcrand3SkE3cHZTb3l1T2pGRnR1ZVYyVUN2cEJGc1pBUExaSG9XUUVSNTI3RXlsVW5seFRSZTljb2JEWERRTCs4dm5iNnpYZ3VHS3E1aHFHYUM0WnE3Z0k0OHBYV2hoOElFZmhnbzI4Q0g2akRuWjJJaEZ3Mm9vdVJKUHprRjErNVg2UkxqajY1TnZubHd3dlllNWw0c21mdS9BditoQVZHc3BXWS9kS0lMb2FFc0tjVk8wdisrOXYvOE9pM2ZXTGYvYTI0RHgyaHo3cHZNa3VsVHJBZ1d3anpKUmZsU3I2bVo4blhjRW1TdXNWMmVGcmpKQ2lrVmV6djJmaCthVnh4RmZtU2kzTWxlemErWHhyZlNDVTl0amhLZGwvMUwzWVkvT1MrWDM1TmhndkQ4NFVKWHpTa0hSQU9qNDk5ZlJaRCtMZlh2WC83WDlhZTdJSXdUVVU3WG41NHVPVGlYTW5YOUN3cEVHNlF2dmswWTQ4RERyZlhTQjJWRzZtRFBVZnFvTURoZDQvVVVibVJPdGh6cEE0S0hHTThVZ1RITHg1Ky9Fb2FHbEhaTHJsODcrY3ZHUDZEeDFQMXhDbXZzL3FRVXg2bTJsSTBJcWFPMkp0MDV0dHhaVEt1V2gzVW5yZERPUURPcVdzLzZ1c0syWnRLcWlZeWlFN2pOKzlCWTJudGlLeXQ4NDN6bHFmVEJzVjF3UnovWmpHZ2oxUUhoMkRXQkRsQ3dER2VERnpNOHYvSWlSRDQ2MnRIazM3eEZBcTU1SG1tcnc3MWxSSXV1dEI3K1h1UDJ2YXFOamlHU2Rab1pIVjFWdk0vK1BJWWdScVgwakNNVWhpMW9mb0hUOU8vdGZYeVB6KzFUWi9EanRvRVRHZVNJQlVTeEtDeUp1QTBRUnY2eURueGpNazFSMmRscXhrcHBXcVRuUTg2bS9hSUtvdldlSUUzMjZncFFWb01LK0owVFpyVGcvWFlKWWpGYUdVMi9hUXQraThPOE1yaVZVSDJPUVdZTkJZMWsrK0N6RFEzYXkvUVRPbjkyN2dBUGltZWplVDc3MnF5QTJIaVJuOGRvQmoyU0NGdFVKNmp3MXVsNC9RbDJNcWR4K21kSnlQdFpOK1lOS3NaajN5MUYyNkZtQzdTT2ZUdFhydXR2U1ZqWC8zNzMzdmwxNy8zbXZhU0g5eDQzSHVmK043dmtSaU5qMHMyUEhmSDd6NzJrcytSWVA3VnR6MUlJdnJMSUpoLzVPbW92Ny8vMGtVdGpuWkROWW1XRE5zOGRQRHRKYWVKRW5WUFMxVEttdVAvWnFvQWFPamFrMjN0VHVxQ3pidW8zWm9NTDFNS3NVUnNTRGNQWGZCTUZ6eDB3Yk1oM2U3dlZLYis4dUVQc1dvelhSUWNTUCttQjdjYUZYYzY5TkhXZ00rUnJEcGRrQXVvWlpMdGJxVGQ2RWFpZ0d0dHBGY1hYQnI5Q2FTR2ZBck4ydDhFVzgwZDhybHNXN25Lcm55NE9KNUR0Zm5vbkc4NjU2TnpQbzY1d3plNHJwa2VVY3pITGczaWtuZXMvUEgra2ZmL25PYmh2eDFUUC9DZUtTaElhRWhIWGxuNHpwdk8vZkFpWkxuMDl5dlBIanIwN1QzNUlMT3RlOEl6WEdYcWMxa2pRNGppdGxGMis3SlhYZldlTDMyV3Fsei96My83M1o4N21Gb2NyeTY1ODVkL2NtVkUwOXRlOHE0ZFh6Z25uVWVxNnd1ZUtvbzZKY0tHWGtRWGlxWUxSWFNoYU9mbnZ2dzIvbzJiUC9SajNwY0lndDF4b0lNakVPQXlubGNLL2RMbEpVemJvck1mYUJ0Q3oyVGxQS0hBc3BqTFhZdTUzT1YvRDZsSjd1c0xkRGxIZkdkc1NPNHhIVytLcldyYUlDaXcyMW5Mb2lQV3dnWW9LVG1iZUNZalorL2ZMUUllRzcvQ3FzOVA1aEV4Mk5nazhqRnYvZWdEOUJrVzhZR2NrTHVKQStyZ0MzVW9zeVE0TGs2cDVhMWNrZlpIcFM0WHNja05qWm5CeTlZUFArZDVoWEhqajh2THJTZEcydWxVcVg0WDAva0xMRGJ4NkN1S2t2YUxzdEIyUnpjSFRFZ1p2SC9ZL3FQTERYZmlKWS8vMVRjbi9PeW9xTHc0MWF4Q1hiWmlpQXEzcVBSVkRZbXh0NXZONUpSMHNaUWRLa2F0Z0hOazJ1RFNwS1NaUnIvNjJPYjNwSTN1LythZWQrY2FQY28yZWxSbm95WUVvV2x1eWY5cS9BN3pTZlIxMHJaSHoybDZxNlBCZEZJeHBTWTVJeU0wZmRGa0Z5VUpwRW56c2pWdHdueTZTa0p4OGhzK0dZcFJ3UHdVelB3VU1EOEZtRmlGQzUyVXVFNk5neEw4eGJlT252UEgrb01FNXUxQk8vc1NmdHhWN3BnN1Ruc2ZiQmVFakdLSkhEU25DdUMrVmZMZ285ZDMwVkk1TTV3U1d1cEdlMWp0Mjg2ZkN2SDUzTGJzdlM2RFNWVnRrb1dQc0R3NUJZNnpMWGY0Q3oraTlGTzBMWkJqa3ZmNXJNSkcwM0pNaGgwdW9pKzhueWk3anhQT1hVU0RhMDB2K1ZFNzFqbFVwUzg2alVaMGd1Tzgwa2wxNTZJaG9XSkw1YnFMMDR6V3lrdkdRTHFtbk5QNFpONVBGdE1FbkNHQ08xdFpzWVU0WDFUTDdpcDhJeTU3c1BCbHViZzhnSjhpTmdQZzYydlpWNFV2djJYM0ZiN0FGaVlCL0tUaGc4NVBDMkNIeFU4TFlackZUOGNqckNNL0RjUC9uSjlPaEUwdVA1MENNMTErZXZWSnNOcUFGUzkzYllyRG5oWmVMNGNER25jbmRNQ1BBUGVjMFVjK0RETmhvU1BkcDh5NWdmU2dtL08xODRhWkI1U2YzRmM2cmp5cFZ6cEtucnhYT2w1M1U2ODN3MHdqL2dZN3FMMG14cXF1blBCbnlrUlRZR3RibVhsQ2c5Z2JaUk41ZC8zb0dTbVdmRGpnV3dvWk05SlRGL3IwQmhHVW1OK3pNbFNLTW5McXlmeWJncW0xTngyaWNaYVhPWEFrWTB3YTBkWTM1QWFKamxSUTBJNVJMc0x0QXlZdnBqYVBHK1RUR3UvMXFTSVBTdDhPVHdERkYxNkc0dmhwTW8ybm1leVlWeEhwenNuVjVYVlByb2NmejdTUXE5TmtUb0Z5SmRCaDJ0TlltWUgvVjZVOGt1T1ZDU2RLRmN0c3cya2NJVmJsTmZGT3N4K1YvS0RwRGVhemwyeE1NNWJTakI2amxVMHZueWFtWXRvWnBSR0tmUjYyNUpDN05ybjBzazNCR2drdXh0YnZvN3cyMFIyVUZuTWVMczIyUm9IOHdPVDZFdk5aSmV2VGpFZWxHUWZsWjBCK0l2bUIrZTZGYWJFMTZkUHE5T2w4V3hXR2RtMHl1QzR1RURPVWFON1diK1dqMldnanRrVmRvTEZrMzcwaUlqM3dUeVEvZ2Z3NEhHMkNCL3c4ZE9mWU04eVluK1BpWURoeGp2TWV1VzI0UTVGTjcxSGxWSFlKanlwNDR6Q00vSG54Tll1SmFad20xOVFOSHhSKzExVnFEQk9aT0NjNCsyOGJobG84cXI3UytjNXR3d205SnBpSDNOWlZLeWpIZFIwY0VweUFQRlJiVk9Qbyt0RjdnMlErOVAzajlUQ3FOS3duVWdyRnR0aExvWGdkUStIdFpNWWs1OTdmWUlIZVA5a1R3azJ6T25LZ3RQR1R1YTdrT3FXNk9xVSt4dVlraHI4VDl4eWErTVFKcjNROTlOSGx3OCtvRXI5d29KekRBdFVMbEVJR0NydmVGUVNVaUdaM0t5QWJpbmJRZkxmRE9hNXJvMVd6QU1zYlBMS2w0a2tVZmJ3ejRVSWsvTHZ5Rkt5OU50cVppWFlHRUxoanUydHVlVFdseEdyVXZFNHNwbGV0UnQvQTlweUdnQk9PdlNGbnBzRjdOSi9IcFpXZzFHbjVZMFFQT3JtQ0haNUx6aFk3VVZ2QnVHVHZyQkVxQVJaWkNiTnVEZEJDZEJ2L0hPZHRmcUpHVEFPZXRqeFJpNzBXckxZbTRZMTFuTmQ2b3RiVy9IUTlua2pVaUsxODJnWkZPTTZib25UODN2dEVqUVZUVHR4cEVtL2hSSjlnM1o3NDY1T0RHSm5rNlNlTVVRWUpRWHhTUHZIUHRlWkxvZEFjT2VHS01ZbU9iSnc4Q3RFZDJDK0tlK0NlUjdVYk03R3lZNVFiNGVjZ01xTUFqMFZ3dVlRb2NWTWpqY1ZqYVZFN2V1TnRZL3htOGh4Y1pQS2cyNjBjS3dRa2l1NjA1NGlSMDQ3dUN0SXA2R0N4Q3BxRjdjbThPWTR1VEdaM1VrQ2l5ZUdPOHpZeE9NbXFEdWVuR0poRzJnaEFqQndnWXNYaFQ0eWE0U0hHdVkxcXpHRGMzZE13N3U1T2pMc2JHSGVhMlppbm94b05KVHN0NTdEdDdrNXNLMmd2aDJxcUU5WHU3b2xxSG1zVURZNmx4ZS9hdS9pY0hBSnEzSmpuWG1IcnZ2clM4VlZzbU1zb3RKZFFzUUJyTmNLQ3lVbkJPcGlkeWRlREJzRU9NSUlWSkhHL1NYeUVFemxwSDdDMmVIL3NwZmluTFA0SjlubUVjMkJrQlFYSE9CNHhPdzlpU3FON0FMMFBRemhDb1VJTFJLU1F3NzRIRDQ5OWwyVElaMHdsbnovZTdjcmozYjIvQ1hnSG9ua1ZUUmtSelU4UmdieXVrMmllUXR1eit6SlZZV3RsUklPNU1QcGtrTDVFZUhuRTlWMlNhajNlNkJoMUh6Q29peXl2bzdmVFdISjEyQ1AwUHREdE1kRlBJOFBFdUdTQUtIY3RqNlRrL1gzMjBZaDJZNmFRTXZmaFA1Q1Urd3gxMi91OUduUWJucEN4cWUvVllwOUhqcERLWTNUWjl6MEVUNGE2alpHSHNuc2R0d0VWN28rTEk3OTloUzV1VDQ1ZGk1UEJxY2NFV2ZhMDcyRUxuREJ3QU8vQXhlRmZGdGxnMUIvcmRObWNabUg0aTMxWFh5YWlVelExczNWWmdkSEZlVXNtOE8xQko1Zjg1TlJmUERmeThpc1dzOHJEZnRzUHVrYVkvUENqanp4SERCOHgrTWtkbjNuSW1oaTZvdUZINXYxVTlvazlMZGEvcWlVWHYvci9lOFZQVHYzK2E0enJyLzIrQ04vSHMrLzNHMFVKZXJQa3VjdU8rNlBsYzM2V3FvajJ3K3lybGR2RVpmLzF1ZzkvMWE3WVN4dHN3NUJiZXlsQWJhSHQwRkxTYXAra3YwYjVBdm4yY2NpMzJCUGxrTUEyU3hUQnFFcmx2eVVuUEZ6K2sxM1B2dmVCOXBKVDMvakVGWC83OS90Z2ZyVHJteCs3NmFpL0c0QjY5TjNuUG5kVXkvMDlHQkkrQlVWcC8rU2V2R0ZvWERUUEFXelpDKzNKdUdEVnk0Tmc4eWxsVzZaUmRUaUZ0c3BKbG51QlVtMHhua3BEVTBCU3FoSEw0c3JWQkRtVFhmdTBSNmlDN2RPK1BUSjB1VTYyYkNsbnFpMEtXekc4N3FEaEtqbFVhdDQ2Y3VJVmU1aUNxZVJVV1NwcGsxWVRrR0dMWm5OZ0d0NGdqZVI4RU5CUVRiUmZTRjBGMDR2WmVhVURVUml1dWNXY0hoNTFvWlZyaDBrTTFaMjNxY1RmRzhKdmVWQWlzOSt6QzRlRm5tb1RhNGxIQWt6Tm81SGphQ080OUpUZHhCSTR0bC9DTmpnY0RwNndRNjNqcUIzK3NpRmorK3dtMFJtaWRVaGM3YTVQOWs4VUlVZTZDVWRicE1xVzg5MFhYdkswMDd6MVpHK1lSYzJJM2JHaUVrZlQ0RXJPWnljWjdkL0tVYzZTc2poY2xSb3VuN3hGZStCODVHTWI4eGFxc2RnZEpkcElUNWNraWdCeEs0ek1LSHNoUzc0ZVIwOHBTU2xsdnlFT25uSE5NcCtFSTB5dVlIZFd5U1NpczVmbDRQUzRkTEozSGtOK0JSeTVFTXFGWUUvTzV6QkxXVTc0Tkt6TXN1M0xaVk0yZEFybEQ0NE9rL056OVZQbGkxbmk4OWp2V0pxR2plb0U3Tjk2S1plMXk1TjhZN2pTOWN5MjRNMmdTV2YzazRwUkNQeXZNZ3Z1TXlyUkZGLytSNFJ5a2pJbTQrSnBtckFtSS9wQ3NId292TVpWSWxXSTNhdzU4b0tTdTc3TStuSVp3bVhXa1RFNzRpT2FGSzFmMTZZS1B4czB4RkV2V2R6a20xdk0vUXVzcy9DU3l5NWhEeFZsS2ZaN0pzWXZ6N1p6bkdzQjQzMENMeVMwZlN2RERXK1NGZkJQSXRsMDNVbHFCUURocUpOSnNOWUk3ZUpyQXBGTm9rcjZVbXBtNXhVU1lmNHVEWFdnNEVQdkdVZE1GWDArZ0xZTTE0eXdEc1hEOHdESndheGkwVXBHZmFGYTBPOVlvMTZGNjg1Z0ZHbkh4SVhISTFRbnNYV0RFL0lGMVlQUGZ2Q0lWc0lIYTFJL0tnTVhJejRMSGx2WjRoQ01XeHBncmdudHNrTWcyODhOYUVUb1l2RytLYmM2L0U5WGpmUGxrMllOZXdnL3hRcG00Y1QrTmhCcTQwV2Y0MmhTYWFJNXZvMzJCaEptZzI5QlZleXV4dFRTL1JQeG9pcnpVRWRmRkNrdXVySzhVSjJIS0hxVWNEYTFuVXo4ckNhK2lhemNFaVVNVkRCTFdUSG54bzR4NkQzQmNhdDhpYVhLVkdIR1RJT3pONk8vQzhJUHU2NXYyYXBZQWErVndXc0Z2RmFnY2xRRlBJbWhoSzVYSFFrZ2c2Q251RGptTzJYTS9lTzNEV3MzamY4U2NDcnpOZ3Y1azhrdjhlWnRvaHRGaUJjaXQrVlNBb2Z6YVBZK3J3czNBMHlHNURYUkRXV3djWHhUaFlpZm9wZlREcTFqekhuYXJvbVhDaHoyR1RqR0ZabVFkdGw4Z3ZXY0QweDV6YklxdE9jTGxkL3dyZDdMTjhwTU9ZRmhEb3Bqa1g0NUNHZEJ6eFNzeDUrTDF4Ry81SzBOZjZTOHdyaTMwVFUzL2FvWjZBU3g1RGsrS2k1cHR6TWhnUC8wT1VOeGVROVBjeG1Fd2hJSmRxMm1mNnVHNHRJZU9kMUZzTGtTNS9GVFFrSTlITFhCdkxUYllrSXV0bHpKY3lIcm1Bd3hHUjVvQTFWeWIvWjU1eWhIWXNrVStMaFo2ajVSeEtkWjhvWHhsbFdFdTBvVjdrYmlJMm9uK21wNkNPWGl1WThQb1BBbmF2R1pNLzhkYkVYWGxkdEMyWjBHczFSNlppSytWQTRseGF6Ym5GNkxBa2s1VGl1QnRLS0l5Mm5GeEtZaEU4N0dXdVlYekZBTFoydmhWYTdybWpndjBkY0NYT0VzKzlMWDJGVlRBcEVlZkxyR3hPUVJGeTRCZWMwVnI5UkhBcmt0SnMxM3o4WW1WUlJJSEUxbmZmSWV0WmJ4TCtHVkFRVGxva0I4VUZCbEtiY0NOTFRDcVI0TUxINnhqQjBPM01LNkpEZjZlaUFMbm5ZWmpjUCtadXd5em9mUy9paWxpUFRXbVFHdElyQVhiWktzWW8rZDBhU3dKdUVJREJQdUdVT1NTeTc2UFlTNG9tRXl6dlFuY1JGaExWcS9MbkhYSVd5TlAyNlhIR3IxakdjQVV4U09JK2F4ZGc4RHlrN3lWRmRjb0cwajJUVGVUTTQvQStITGtxWE5aRDJlUUtINDBnU0NzZEJnTjk4dzNlMGFCVGt5b0tKVUI2TGRVTDY2RFNzbW9aS0pwS0lybnRHRUl4L2dXQjdPRnFybHNsSSsrbTZacWczL1ZBaWRQb0pSZ0J5MjlmTXN2WXJ0TlBoVUlZQjdKYys5RmlJbWtlMzBUR2Z3S3V6RDRLMXNKbjJueVRqcVpmVG5YYzJrY05xNjhLVU1YM1JWT2FkcUZYMmlzN09lVnlhR3Z5VTVyNmFjZndFcDhnLytIODUxVzJldUJabmNsVHNmRzRxK2s0bmoyMlpRSFZaWVBHQkdmVnY0WmQvREZWdEZXbGZSNDRIc01tQlZURU5YTGg0VFNuWHpRKzRxY1FoTHhjQkZiOHdwWXVvZHJsOWloR0RlZVdHMklEcGhHYktnZTNNZDBsR3hCWDk2emVxVG9CMlhOZi9IdXI1V3ZRM1gyK084elhoaWRja0VQZUgzNlp2cnJWYkxmRDU0cy8xODRHYjV2RC8vK1pIMDh6N3plYS81N0VBYUt2QXZ2U0hzWEFtNmlaYmhPOXhreThUR1puTHp4RWJqQnRjaENFT1ZrcmpSZnNqMUtpY1duMjJpdU9HeWE1ZnBabklRSnhIMFIveCtvKzhHdVlFYWZsMzdmbHQ2LzlnWTd6YXB3bW54V095Tm5QaWU3YnRpR1FmMHhCczVBUnlrc3pieDF4T3RJbWhaV1VRajV5Ylh5d3VPeGxJZHorVWI5dURMenJxNGxWRUo4OWlPSGVnWnpOajdiUTV3QUVXcEdhV2RORXBtNEc0eFNTME1YQnZPOXNkNTE5OXNwMmNMRHpCaXB2SG9pWHhsdEZERG03ZUhDM3FnL2JRVEJ0MkY4VzhRakw4bHpmQzJJN0x0NHFRRWNvQnJwNklXZks3QnU3L1VJNXcrREFzL01vNkNRK0dqaW1nRjVXdmRQb3pMZXVEYmJRVmxKVW8zcnlxWHdHeUVqZEJTTTlGc0hxS3NhUkJUeE1LVXVRSVNmUkltdXNCT0NaUzZITmhsMlR1UUd4ZnNvb1JsaFp0V2NtaVB0NVk5SWtEMnNLODhzQkhIWmY4RHROTmpoNktwT2dmSzh1U3dqVU82Q24yVUFuQUx1RGd1NFN6S1M0NStweTQxMXlXbE00emp3bmlUOVFORlBoMmJHRWVXNHZwMTlzWktuM20xREdxTytBa1RrbEZFWTdFTnhhYVZLVlNCSTFYY3Q4TWxzVWtleFpza005VlFUbklkeWNid2V5NXowQWl6bmQ1ZkpZZWUyZ1MwSjRnNGxBbTJHSWx6Wmp3czJKYWQ5d3ZIbnJaem01N0VuK0Q4WEp4ZDRTWE1jZTc0VHlybGFEMFg0ZHp4SW14UXovN3lYVTJDbmpKY3NwYkRFdnZOaGoxTXpSMTFZa2daTUUrNFNEUWwwWmQ0SzNlbGtEM3lwUDNtUFM2Zk5SdTloRzhNZHRiaDROYTFZTGdjcTB4WmRuUG10bmszbFIzWGJMWExXVUVnbkg2K2RYdWdETkY3RlB3eGJVVFJ3MldJcFgzaHkrUVJSeGh1MU82akNyNTQyekExaWg4MklCamljOStGeEYwMThsbTNJZXMxanhYNEV3US9yVmx3WkdiNHh3RUVTVWYrS1A3L01jU2FSYlhZdUxORVB3bm9SY0ZVejNrNyt2UTlWeFVrcWh3dFlyKzNjVkV5bjlIVGtldmxHREVVWHhLWUhIci9EeDRWSjNRQ0xoYUxZRU5vWFNPbyt0RkhJY0R4ZCszanArOU5JbXdpbnErUEgxUmUxbjF2WkZHemNDWjRmMkEzMzV2WXQ2RlJEblg1azltUm5TNksxOG5FcHBjbjIxclJVd0VZbFFLUVBackpTckpBWEFoSHFSRng3dCtEMFdoUE9hUmwvcUhiaDZOL0RaSmJiaDhtMHNodi94WkFOK0NKd21sbXVtWTZPZVVRV3pNQ1p5U1hLT0ltdFpiL0xzK3JuU3BhdlVJNXhnTDFaTTlKYmh4bnpvWlZVRjQwaTVVa2g5Tmx1R0ZxQnpFYllMK3Y0QVVrMnFqVWJLOTNuNTNvR1ppZXV2VEQwZ2g0djRmZUJhY1M5MzZFdmJ5L1lWMW92ZVRTQzV2SlpSZWVabTVrcG1uZGVJWkV3dStMbmcyVzVrMkhxanJNMkl5emFibjBqYmhYeEpXVkp2WlJpTGMweDRYd2RhNVk1K1lMVTlmbVJoV0tyalRiUWV6UHVidm9ZZEJJWDgydS9wTkR6aXBxWmZ6Y2k0YW9IRnQxaFFJVjc1SHdaS1BNYkZaYjNRb2o1ZWk1QURHQkc5V1FpNlUxRXh0VzNSWWRDcmdXZERRdHlCMTlMc0RGak13SkNId1E4NGpFWkpDQXc0QnpLTldlekZvdlY3N0pXQjFtZ0JUbysvMGxzWlowdCthL3JrbzFxSXRrU0Znb25JaE9vMHpXSVh6Uk9jdk1pUmpuNEZNdzdvQUU0c256S3owT0JNQzdoQmdHZWw1OCtaNllnR1BSTDVvb3g3WDdiYXJUSnRCZ0N0NW04VS9YK0hESWJiZUlBRnhheGppeTNXSHZZTC9WM01uV0VEM2xqdWFpTWR1TjZKendYS1ZvVGRsUVRxbkNEU3BvNEoxaXRjaGRMS2RSbmhHWG5xRlF2b0o0clhGaWdRMXJweElFVEhRdVg4bEhmdTRNZlBSZGlNQlJoR1djYTJMZDd2enFONjRpdmswSjM4Wm5PazgvU0F5U1N2bTJ3dnE0bk94N1NQZzJDSUk1WHMyY2NnVmphWXdMbjdqaGV5VXo4Y3M1OXByNDFUM0N3TVlGUGhKblhoaE5sWk85cG5hNDFPUHdEbUt2TGdqak52RlFQUzRSczQyYmd0dHhxVVdEejA5RlBxTWdmcnlJekQ0dXpTSUp1eTFISHN3UVBpUmM0QzBQMVMwVDJESkoxeitVTVlaYlROcG1UZ05raUlyclF5QVhzOWJ3dnN3cWdXbUg2RU96ODJHUWtkejU4RE1CN1dseVB1eHB2K3Q4V0dJa0tPalMwaHBRNURTT0x1VVo4eXJDR2w2MmlrOTI2YWUzYVVGQlRuTVJ1TjZZRmhUeXBnVkVUK1NjbDhsR0Qrc0N0NWQxUWZIK3VKU2U3dnJkMWdWK2FsMVEwdXJXTWJZd2dPczRyemxvZmFMTHlvZ3FzSWR0c0FrQ01GTCtmOXlrSUZZZGg3dlJnMEU2cG0vUHlIRGtFQlhMSGZSZVhzNndsU1RReS9mb25pSm9TbURmUGlSam1oNER3MnNhVWdKRzJUbnN3Vy9IMmU0YlUrWmY5WmJpb1NTaERURFpjcWpPKys3ZmxYbVZ6MmdzNzRKdmVSa3hTY21oZTR2UlFISVdIci84RFR5ZUdSYWM2TjFsaExqYVFadjFQR3ptbTI4ZlBrbGR0WE9ZaU9MbThrbnEwNVIrd2ZNOVJqQ1daUTVMSllsWTFVVmxJNXRBNzNpNExUa3hzZ21PTG03aXYxdkNYUzRmNHJwcGNKaU13dDBaMklndHo1YnlvVlVjcDIyRVdnZWhiemg0VTV5UmRJc293dyszb0JTd0MybS92ZkVreFNTaU8rbWhHbHNucE1lRWY3UzBjMTNLSVp0dFMwVEMyMXpITURNVHdZcGM5djNqYlZacUVxZGRaOHVqNU5KTG1uSU0xWkdGUGp3N2ovK3NHQ0ltb2lrcVErUStQVmZiZVo2dDdkNExYOCsxZmI1a3NuWmtnV0MrbXYrY1BwUmNXMmZ4aWVVR2MxRFpEbitXYWNsZmpFZEozdlE1bXdoQ29iK1Jzd0kxM1pIRWVYNk9KT0lPNGxTNm5VdWNEajhTNDF6aWRIaVNzSE9KYzFoSEVpZDh5Rk9GOFJkdjNkOWwxdDlLdTV1WjljTkl2OGdwajhHMjMySXRINmdVY3hiN3NHam5mcWFKZTlqbzNzbk0rTXRUV1N3VzFEQkVlOWpXamtZN3pQcS9EYlArSEFScG84WkNmN0dwbjl2TXJQWUZrTFRSM3Q0QStVWW5Pa3o3dXllMnQybC9LNXZVd1BZeXMvTzNFeWwyL25ZT1p6aHRDUCtHVFRiSDh5WVFFQnB2TUxFVWV0anZlNW5SdllyMmlIWWJyamg3RHFXVHl0ak1NYysxYXJFT1htYzhiMnZiSkJ2a204QXNXWEtMTFQvb2c5dEtiZlF6aXU3UDBBWFdISmhUV0Zwd1h5NWpOMGVQZTU4TWVFd2RiMzZoeDd2Zk9PTHhycEZ5UjV6d2FKSHBiaWpITE41bGFvZWg4SEVyOWt0S3JNeXhXR3JXYmZYbTRLYU1yaUtuMHpBbTdYencybE5EQVdJaXlnekZ4dGRxQmsyR2l6cDhWcGV3VXFGWHBxWFNHc2NjOGdBV2RBMWl4czM3S0tBVDAzbVBqenB3dE4zRVUvZ1dxSEQ0eEtEaktJQUZVQ2traDVLdTNIUG00bXUzdnNMa0ZhMlJlUmtOdjI3UFl6Q0NZbjNQU2lGdXl4b2RwR01weWhERnh0OUx6VGlhbUVheGEyM2srUVJRb2YrcWV6REZKdjRrVWNYNGpWVDlrM29hVEM4a3dSdXBsRmljSDNMenNMaUF4YzJEMGJBNktnbVBTVmp6MStXajZlV25pUFowMklOQ093akgyOEZGL1NMT2VvUjYxdWlJcXNETkFWYmo2Qm5uQWJnSVhKek1YMnVEVTRMZldNK1JJbDA1ZGpIQXllRUpUdVN6V1hSZ2NxN3lsZkJCNmNWR3YrS0tDVmF1bnRoUGExSXpIOWxSRTZQaGI0bEN4RWx1Y004WVN0ejF5ZFMvMUp1LzdUckpmZCt0Y3dUbGdlaExBV3NmUkRVYTNWUU96ODJPNkc2bUpVZFlTQnlyZ2dqM2FWWitpa09kMVlEeDRUMzhHeEo0SlZBVzhlTmd2RGFoZmRrMjk5MFNLZHE2TVFsU0dXd1dhZzFkcHlQbTl4YWh1Q25Pd0FmRGZPQ3VETExNdEdhQk1Seld4WlZnQ2ViQWpxRWFEUzgwTGtycGViWm5WNVE5dENaaVo0KzI0c0p5dVFISStsZmtseFhtdzdlNGx4MWROMFN2WUdvWURYOGIxaDZpeXpUVExFMm5BOWhrWXFCZE5wM3d3bjdSQkdIWU1ZTGJ5cUJ4bnNYZFpMQUp5eDJIZVd6emhKOUFmcHdVTDZVUmVYVXRrdEhvK1FLOXp3cFZFQVBHazNyNFFwRlljMnkwNTRmRlIwSml4dFNyaEpMTEFsU2k2YlhUUS92RjlZU0p4Z0RMZEFoRFNJOXBvcGpldWRIMnNueFI2UmZQZkxuRmZQSFNMNzc1OHRHeU9WeitXRm13OVYwNGttQlNxb3ptM0xqUzRHQWdXSy9WT2tRTk55K0FhRjFzcnRGMGpRZEpuQ3N0YThaWWl2aFVKSmw0emxzcmxSU010eFJzcW9iQ0cxeHVHRVlrVE1yNThwUGwxdmJGUUlBRFlvRmtjUDA2aURjNFNHQW84TUcxSHpBbS9BMlFlV0owaUlYRDU5RmNLNDRiRkJ3T0lDYXVvN3hVRGVBUlZGYXNnRWsySXBhMFB4UiszSURtR2RDOEk0UG1HQWkwdDQ1anF1TmduRDdnRUp6NnoxOWcwQ0dqUVY4dVhyY09RWUpUWUwzcHdIb2NxQW1XSUZ4bERsaGVkeHNNc1BlVTNEcldUQ3NBd2ErRFFOWU5nYXlEUU5ZNWh0ejFRYnFhdGdUNTViVFpyS2VKSU1tZFJja0dZWTdlY2RTU3VPejJ5ZHNSRzhQQUNVMEpBZUVvUnVKNEprNUlFd0hDWlpzRkpqR3phSUg1Wm9GSmVWU011RlJGMUk3U1VOTFNjeW5CaFNBYy9Bc2hVSWd5aUNrVzc5cUVRMDB1WE5LSVBJK252dVhHTUtXTU01T3lEcHBjanRkZzNyMjVwUHNncWhXaGl1ZEtkVkhhd1NQc3FRSms1aWF4VEFNQXp2NldnQWR3TWF2S3g2MWxDY2FBOEdOdUkrd0NzQ1FBOXRGTHdFOFZDeUJpamlIYVVwUExUUU93VDFjZ21RYTZOTnF3VUJVdGdFWFdaTHRTbE9sSUVjSGhHVURBd3plUUdCaGN2amVFeGxIQ05wd1IrME54RlhmQUZBaGRZZzdsMVJkOW4zWE9ZSTlDaEZHazFVbVZZdDlzTnFvMmRKcW5xNk9JbWNhQlFXRDd1V2dkaC9vcmFSTkxrSENoT01vK2tyelBPYm9TUFJuRUpnQTUzMXd4Q2hERjdrSlhhUGZJUXNST2NPVHhzcUJDam96NmhveDZkbHpZcWM3RXVvcDlZeE5LUEQydWU5S2xNNGFFWGVtemhxK2FMNWJDaDFqR3Y3RFVuRXRpb3lyS3BQRFJHTSs0elZUbG0xeDhJRGpWK25xK284WlByZjJnWGNUdk1vbEo1dXRhZzIrb0NIU0lLUG9ZazVEem1Pc09KQmlsb2pYWmpDT3N5TWlzeUFnck1tTEg2RXY1dE5McGJSeko5MHpPRnpKckRPTmdZWGgwMkJtcDJ6TDB4Rlgyc3FSa0Uwb3htY1F0bFlHd3BEQkNHMXFmSFB2TzhCMUhVajdBL3AyNW80K1hUZTExNkplb1JrM1FTQXg5b2hKMXNWbVpVZHhYNFhMcHF5dTJ3QllzUDFhak8wNzJMbUhiUHZIQVdTbTgvdWdPN2Y0dW42QzUyNXNTZ3Bkb3krcndXempOVW54bjF5VlNneXQyb2xSaUxIT21mYWwzWVZ4QVZVUXczaUltRVR2S01jdmhSbnlSWW14TlB6SnVMSlJ4VnlSZmU2WmRxbzNnNGxIMGNVR05ueXRsTHVya05rYWNzNnRzOTc0QmNVdFI3aTE4TmxMSVE4MlZNcFNlclpreDFSUGJEWnA1c1B5dzBucUZJNFBFUjQyd2JNREJHdTJlL0hpSUVIamRyU1BEVjZSbUlvc3UzMFQ4VUhpTkoxelRQbWRHVWRjY2plSE9QajZEMSt5b081STZ2SkNFSGoxVjVnOUpBRjB4VGpOZjZtays0SUNFenFhelhuTHBCQ0xIQ09tS2V0ZmhKYzhlVXZJWE9yU0pqVTBqVmVjcmpveVZOU3JrQ1Btd3NlNnM3bFFCYU1ycEtMallRUFRVeE1iWE0wUlhIM0thWXRubEo4TzlxdkNTQTVkdWtMK25EeVZibjNNRm51R09hb2ZCQVBoU212dnJOREhTS0EvZ09DZjdCUEdoNzhrY09tT2ZNNE04RXA2aEVGcGJ1K2swR1kySW04NGpCeURCL3AvQUtCUkdIeW9Cb1hNMnJSeGlUUVk5aUZYd3MwVkVOYkVPQTRYZUIxZjI3Sk9RaGdoRDlQMnlpTXgrZEFmMkJrYWZ1Q1FOQjZaaFhVenYxR1B0QjJXbXpoWjBnU1lIdkZvNllYTEFFLzJ3ekZkRHlJZ1Y4T09udnBzZFZxWnNJTkNSVWlHQStJWjZ6bzN2RlFPaTJRWUw4QXd3VThjNFZJQmZRdHJVaFVMaS9YVDBURkRvd0ZiQkhkblBWWVRwN0UvdG5qSjFIZUM2NHBETGJ4N25XSmt2OWM2VDBDdTR0RW91U1NPd2VoUitSQXBYMHNKRkZGNkoxVjFKNTllV2NqYnhrV21QWkRSRjIvS1phVkJaMmtjMllHRFB1WFVEVlM2bUJueWpsN2NoOWpmSmlVc2hXNmNHbW9YWnFHaTVUTE15NGw1QlE3Tm84eVlKYlJYbTNwbDRYUUZPQWpzWk5TK1JReTJyMEFVQ0tGZllxSERjMW00NGhydmdPQ1dEWTlnaVFqb2NxM2pEQlF5NENTcmhBVGVBZUF6dkptck9EczA1TEJPVW1OQ3h0alJnVkpIYjNnaU1iSkRwQzJHRkxqSU4zSlJOMWNPTEJLYTlPWlJaTEZpUkwyd0xpZ2VWTDBSV1lWRVgyS1dqNTlVaDRYek9sVWRuSVFNZzB1SHRaVldTdFRrTXl0dHphWTQ0RFh2SmdSS05QYTVWVE81N1NpeXNFQWxxcDNtMjhabGQzaG54czFwdURJZUV3REVEcks2S3hMZmJ5bXpJWjhKNHUzSk5DZVZFM0c3SGhXUDhlSUtTSnl3Yll0NzErVmVhbUxqcXJDRlF4RS9Rd0Y5MXFkODhIbnlUeXpOVU5DNTF6eDlRNGJXU1lIa1d4U01RQ3h4S2hFK1NCNUVuZ0RtVE1rbE1YTERMaGpZMkg5b2pkS0lXUWhIREFqRi9RZ1pyeVR3dG8rQytOWG9pNXU1T2RxVzhMdnB4MlZMMlJvWEpPaTBnWlJuVWdJL3VnMndFZnY3dkhTUGd2dGdSOExJUlFFVzRETTFWNXFSbWVMazFPT0piWW5MVkJxYmFBTlVHYWJXQmpPTWZyQ1V5dFp5M1VTYm5SYjRheG92dVJnOEhzeDVHMUVQRTY2RkI3VFdrbGkxSXk5K0Q4Z3V6OHBySys2Rmc5RXkxV0NOMjZ5djUvRWZJSVBEQzVXeXhHTWdWZ3RiQ1pEOHRQUUxDTnVwMU5Gcnh3aGV4ZEpJOVJKbnNzbUY3NmlxQy94L05NWFdTbS9HUmZyL3RMSk5rQlBrM1FpSkNFbmZDcFpLWG1odC9nTERWSHVPUzZRNkNxb3VPVmJLeDRsZVgrNkI3bGNWM2c4YzJwQXJ0ZE5HdFpYeXA4SVhLUXM0cUlFN2diV2FnWnQrdnE3N3hFZ2pXVG04MEx2YStleWtieUZKdUlFdG1JRXNZeUZJNmtDVW1Gd1JHbEhEWUx5RWJrTGVUWVJtNGwrTlcwWTdxMVBUcTJGeW9zMDFJNHIzYWxYUnUyOXgrYStCd0JRNjB2RHpkWnA5L1AzUTBNajRteFpkWnNSL0tBTHZOSEZyVTZNYzFhZFRHTFBvM20vNE5JTzQ5L2M1aFVsa2lRdEdvS09uOHltWmNaWXppdDVlajdRcHdLaW1jZ1V1NmVGaUFDbkJCRHZTY1JzVGJWZkpSRWdhcTlQWFUwNGNNYXM0WktjR3NoR1RheEYvZnRIY3B6eG1aRDNPMElqYm1VdlNUTWozUjJoM1EvZG0yK0N4dmkwVlFoQ0x0MHB4WHlCM2VkVHpBWlF5UDE4OTU4U0hpSWliakxEMDdPb0JLaEV6T1JnWkhRcnVYV0gvQU1JQjV5amM5Y2NnMGpSMmNTcXlVUE4xMVpwejliQ2cxa0hNeEF0SFBnY0ExaDhmK2hVeGdldGNrN3NHekdxd3VHa1ZNTUs4b1VYU2pybzFDVnBjYXBOekE1QVFzS2R2bEVydERpNHhnQlhQcDc4cE1IYUlmb1FmQ1dEYm1BUFR6ZUZpeUNadlQ2Q2Vjd0tRMSttaHMzTEc0ZnlSNFl6NENOalZIaEhzZkUyNlNHS05kWmNxU1diNjhrYTgwWmRjKzdnYU0vMmlkQVAwTVlNQThvY2Y5YVUvNW1yVk8wdEhQMmlXZXFZTTl1L0YwcmhzWDJtNUVlbzRPaGtiVUZicC9iT1M4c1hnT0IvVzhsWVJ5VUsxUGN4Q25JZ2R2OWdYL3RyZzgyUzFYa21WcVI4WU42N1RIU0lkRjhGckl0OFdWTW9mTFo5Q0RBWnR3MHdFbUFlMm1qYzBkd2pMM2NYaHpEOGFMTGE4SjdNcVd3S0U5NDBDMWZCcHc4d2RsMXFadGtld010RWRQaEJ1bng2VWhxY2dnNjJ4ZEdrSVZjMEFiNWtpaC9HTFk0dEZzOU1HVnFiUXU3dU56ZmhPdG5xRGNzV0ZFajhVUlJDKytsZkQwSWR5WW9OV3RiOElkSHYvQzV2RFVUeThkd3MwZTF4enhqS0xQWG1PQW51ZnlMWC9KZnRWTVQ3eHA1SFFKc2ZCbEJ2ZXB0STZEaW9kM3Y1SVMyWXJmcDNqSjc3TnBjUlRkYmdxWUhzMUZ0b09LRUFhcmsrcnBROWZXTGdWbFcyRkcwV0ZaYnZuYXRYR3BHUjFFK1owS3F6OUMyU2tsQmFVK21jWXRBczlPSlZrTlBQMTZyaENCbHBRZUFWMG9EWTJZRVJjRWtKSXRKZG15bm14UlVxOXBodXM1S0ZnMW9hUmdycG1mSWhnbE91YkdzeVNqNmIvdFRnNmplWmhkUVlzNTI2T2RaWG5QNCtGK3djUDhJdGlYTFlJcEFXT2ZLOGtHdVZPRU5HT3lVM0pOdVZKaTVsejVobmU2SUk0MFRyTFZ6OEZXVDVtOFptK2RmL2pYMnF1T0Y4VnBkTXRubmRHNEZNOUN4bGttNHl4a25MV0EyVnlPem9uclkwWjVmK045TGJlWEs5bkxWVzR2VjdtOXZJdkh5dlp5bGR2THcxN01tS1F6UTViYnk1WGR5d2NNVC96Q21ic0JyTmNCQTNobzFQUnNXMStSbXpPM0ZKbnBrNnREY21jZTFNZGxjWTNONE9mb2FsSitQY3NCZGZvWENVTTZKeEZlQjBrVkExaE56cTlGYkNES1A4RDhLNjRQV2Rxb0lUaTRiR24wdlo0OFUrZVFvY21XWXBQZWNFc003amVKMkExQjEzQlMwcmVteVpCQkRKK3puZnVBbTdscnVpcTNtQ0RlUWlUeEIxVlNYaGFySVZ5amphQ1RkVG00RjhaTGx4YXFpV1VKbE1yMDgrZzFMbDlQL2tKNVpBQ1NEb29XbG9iRXFBSGVIUm9EMENJdzZOaktQdU1zTnpxZUlqYXp1UjJibVlNYlMzeFFzeG5sajdsNmdDWU40NFZ4WTZNbjNvVm55RjZqUGR4eTBEd3oyYlk0WU01OEZ0STh4eTZQUnFGcjJ5dVp0VFdnUzd6RTdPWmR4dVpOM1h1ak1lWTZSb0xZZWhjRGxCTDRyUUtXZW9sbEpWREFFamlzRWppc1VzWmgwYnZtUEJrcExHVXFVRzR6c20wTzZITGlYdHk1czVhWTR6QXRnYitpQXVkSjZnd2Jab201clJLNHJWTEdiZlhPbGdkamNRYUd6OXZxV3pyaHdMWnU0TURPWGVLZHU1VGJ1VHZKVm9sNWpCTDJheWt4YzY0OEZCZGFLQ0paUjFFU2RDMlRtT09kaU1sRTM1cUdLMHNnUWlRVDloOXptWHpYSVovVkNUKzNzNGx6SlNrajZudEZjMjFCMGk5S3lJQkxZU3l5em9FbU03N0luTGFrcjFPdTVNcW1kYWNybWZNVG03STcwcG1XUzcxUklwcmJicWhzRkZWSFF3Zk5vQ3JKbFRVMG9TUnp2aUhlaTNTQVczdVNMYUkxTWlnaXRSeDBwY2FzbHYydUxjYTEvTkJrem9PN1Q4QVZvRVM5VG9CdklDbzBCRzh4c3dDVVdRRDdzNTZBNnpCTEFOeENpYm1PVW83clFPVktNdVo3QVk0aFFCY08vRnV1Q3kycFlrcEpkYmtSVjFLbVk4UlY1NGdyeGg4V3doaGorSWFTdUo2NzNRaGtXMVF1U2ZsUFFSUE1LU2QrRUJDbnlWb1daOFdRU0xGaXUyS2lOMTMzZzBjOUd2ZHlmdHpqOEFLT3NJL1RVc1JscXFXTnU0eXVkVjFIcnJvTy95U3U2Q3FKZzFoUE5jVFJQMVJmUzlUYzFiVmx1cnAwYlZ3ZElnaUM1RjAwS0pxZWNYaGJKNVFOMTR5dUlkb3JCa0phTVpwWGw2YUxncS8vNFMxQkRBajROSklnTERkcG4wdGhxZkVPVXpIN2VKQXNXTUhyWUFFT1FDdlliUDdoeVovN2IyQWZOUUtyeWJzYTBmc0dhZ2pOcVlWZGhCeW5qUHNXdmtJNUl5KzVRbGR2SFlzSFJpN0Y4UHdlRDFjVm04Y0E3YjQ4WkJQeEhIbll1SUdtYWM1MmJHbFltbkZkd2hOekJGNWRIK0toR05KaWVZUm1sZytCTFlEaXVJNXYzUFVvZVh1VDlqbU1RTWhicm1TTmEzS3VMa0NHeVhOMVRtWXdYWW5EWVQrWkF2YmVwSFZNTUFJZXNQeG84WmpLcFZQR09JTmRwL3JUY1I5UFcyaVV2Y1VKRVcrcTVRUVMyT3Rjb3RZSUUyUDd4ZUZWUXdzbi9QenpEUUU5YW93dHlZVEJxU3JzbVdtalA0TmROOWt5ekxmMzdOR2NPWVkzZy81b2prUkh5RlV2VVYvY3JKZlNHQzR1UzRTNUpYcENqWGVDWUtoUUFXejRIRU9tdjdkMTEvc3NvZDVmRU1wU2tGdzUrbFNVK2pJdW5ET25MQ3ZJUVlIbVBkOFAwSUpDU2orbXBGRW1Fd1g1bEYvalUxbGxJMmFkVHhXSWZZaElkS0xseEJkMkk4Z05DMVpRQ0hvcjRtQW9ydEhlY21aVlVaRjU5RytRL2gyRmM1SzZqb0EvaXRaYWlLbHd6THJXOVlzYmxXUmMxOWNuNHhmeGlxWXh6YTFtdnFPTFdxdnkvRkJ1M0lQdWRxM2xFR3ZacGJYczV0YXlpN1ZjMWNXMXVvTDlLclJURTVyRjdJcHZjVCtWN1ZyVlhIMC9zOUlJVmNEbU0rc01WbUlNdHhSeWt1QjNDR09zSkVoMFVxWnJTMEd5bWVtYXErZEEyT1BQWmt5UFl0SmFhQXhpRnZQMS9ZdVRyNjlGOWMyVk9ab29TRll6UjNjeTN2anA1MWFCNUVzdVlPU3JlU1I2QVNjb3k2RG01Zzc2VXFRRFpmeE9sUEViYzlrckVzN0RHSzA2VDFZSElUSnJoeWpTNSsvK3NWSEUxNkdOU2dveUlZb2o3bEJUSkZxbmZOKytSWWJ2dytWcEEzb2VBK1JKcmc2QVVnbWZzL3h2NXQ0OVNyTGpyQk84ZWZOZG1WV1YvVlJMSmNaUmlXVWt1MHRkYXJYYndsaVBXLzFTUzkxU3Vic3RpZkZ5a3F6TXJLcXN5bGZsb3g2YVZuY2J0YlF5d3k3ZXdZY0ZMMmRITnV6S0MyNUdIR1puekl4QVlwWUZBMmFQT2JzTW5tVUJ6OER5T0hnWDhUcDRaMWxyZjcvdmk3aDVzN3FxSlFGL2pGcVZOeUp1Uk54NGZQRzk0b3N2dmhaMzNPUmtjTzFYOEQyZHJLOGtJbFgva2F2NmpVUlk5VmNTbWl0YTlSdUprYXJmU0VqVnFHZjZEdW15YTc1RmFLanNqcUc3UFAzQ3RlRVhQcFhRVE5FdlhCdjl3alg3aFRTdnd3b3JDNXY3OHJDeVZ4T2FLVnJaeTZPVnZaemd0WTBUd1o5Nnl0TjhSY2N4b201NVdJQUNmWS9yNjVEM1V6R2JJN0JER1IyYTBWRi9JODV2cFNuZUNueWhqRzFUWE9ENzFiaSt0UEFOK0ZKZ0N6VTNDazB2eDZjUFVxZHVENUNZc2VES3lqa2RYSzI0OE5NeWFoclpyc0RrR01jMTd6WXU5dG9YZ1I3L0pEczlyb1Z0S3lnd1huMk04cGl1bHpncVJlU2c3VEVIWVZwVmF6NDUxLzhialBLWThLWGtCczZnc1Bkb2Q0MVhyWjJoTlhBdW9wVklpMXFIQTFHZ1VpSWRVZG9JWG53VC9BOTFBL3QxYy9JQVZRUnBTdjByeFgyVStmZFptWDhmWmY1OTcvVnl2NXdRTjRScUxhUHlvR2ZsUVc5VUhsVGpMY3FEOGVqZGZmSGhSdU03cU1RUEsrRlozMkRtTlAyMEJhZFhwcE9DQlUweUdJamZIcWZFTkdJajVIWjNwQXd6aTMrM3VGN2R1SDVXejZyYjNadGlNaGg3VWwyMVdmdGVpTkh1TnFWMzA3YjVGVFdCMVRxemVpemx5ei84MDM4Z3dpaHlmR0U2Slo2azVYdjgxZzJUbWh1N2N0a2FKYnlMajZYbTVpOVBweUtmZ3VBODk1UGYvOEp2L3RLLytaTWZqVjIwSnpiY2g5NXQ3ZUdlbHA3N0NJWG82TkJDYkRhcDUyaTVOaVcyaGxGdjQ2bGR5a1R5MEM5MTdpZlZKSXNXcUxGYkhiV0o4ZmFIaEhyeVExWDBjSjhReTI2STdISzdqTnlCRlN2ODgrRzJiRnEzWlNuSnFaOEdFUGtFamVQdzh4S1ZibmY3SDFsZGtSWGkwVjhqWVQranhqa3Y3K2FrTWZkZDlJZHcrZTJPZXBLdmlCVyttQlZmRDNMTW5HanhyN095WVgrTEM1TFVUTTc0YzFjTC96cWIrKzJFbjcyYUNQMVI1RmdvWnd2bFdDZ1h1V1BRRDk3N21FQndVbTNOVTF3UlltY1kyU2UwOTBDa2hibE12Vkg0N1F6WFQ1ckc1bXJ6V2N4UXVVMytJaU83STZTYjZrc2xhaGxBdFNVdEE1SlNSazcvU3dzSzNhQWcxSWQyemJPNkU1dlZLbUxCNzhiY1BuT2FWdHZwb0RBOUpvS2pWTUZCSXJvYlV5WFVtSVM1S1pnell6ZEVUQ0pQTnNHR0IvT3lidE8wZjg4UVRHbEVURkFOL2dmQ1hVWTJ5cGpHdmRqZ3JDUzlicE51ZjV5MG5YYWN4WXdaZTJLY05yZmpBT01KQU5KZjBiQ1hOUU5zTW1xNkFtYjZDbmlJekkxaVllN3FDOXd6QXlONGVYcENkaEY5V21uYTFxZW13L3N5MUx1Zm9kT283QlNoeTAzUXFhaHFKTWtOa2JuWTg4WHhlWTVqWEcxbUowejgwcmc0OVg0ZTRvN3U1NG9KVGJRb3ZRRG9UQ0w3TTVFM1drUHlDOFh4Rjh6NGM5Tng2d2NrVDdqSlc3akpFMjd5Y2h6dG9BTzI0WklrMU8xMXlhUjZrMGg1WlpqRVRCbEorZ2RrbTd6Z0U5OTlWaHZBWXlucVYwZE96LzN6ZUR4MkpYNDFibjJzLzJ3eExpZjRFc0UzaEpRR24vLzhENzRWUHl2V3RmVG01MjRCSktyNEREdjRzV0pxNnJQMm92cFBmSVNxdTg4WXBPaUI5UGVzVHlkQ2RaeWVpcFYvbnhPM0FTY3JjdXZhYnp6OE9ldVZNQjE2N1RMWms3MkwzLzFidnpyNGk1LzczTW4vL3A5ODZPV1hydXluSytOWTdjLy8vS3NuVHpCNGQveXBYeTQybXd4KzZOK21ydjlsOVFjWmZQYWJkSGI4OHcrL2pPcUdkZjF2ejc3ZTc3ei8vMzNvY3lmLytKVTNqMDUrY1MrekxoZitpenYrK24yekRCNTQvbXZmL05KdlBjM2dEMXh2L2ZIdnZlOTdHUHhtOE5OVC8rcXpQL0d3WE9ZZWs3K1hpK21YWmFFa3hUV2Z6eHRmL2lWdFUvVnpuOE5QN09VZi9TeDlhR1ZmL213eCt4a2tKS2IwSXFLSVM1TFhUZlpIS2JiK2JPaWJnV0NZSFVhenh2c3M3NlpEbFJILzNHeUJPSmJKdmZyM2NKNzQyZzduaWQvSTN1bzhNV0dyOENQMGdCTWVBdVlRckVteHR6a0kvUHV4ZUV6dXhJaGUvR1E5dzQwZUhmMlRWMTU4SzI2ZE5BU2Z1UGFWVHlRaUx2cXZtVmpraGljNTJSMUdYUjR4am4rNThIcm91KzRSVElsek9Cd1AvdGxQL2Z3MzQrcE5TWEp4SWlJNW5jVXFkWmhSVDVmZUc1K1R6Si9abGp1bkYyd0E2VjJjeXAzeDdNVW1YNXdWOC9iZ1MxK2NMYnpKdzNVanFiL3drN1BCbC9EMzVaK2NMUndJUEY1NmduYzV5ZjFubVR0eXVkdkVvUzZsWGxyYWcwelI1YkkvbGZ2UmVDd2xKc0M3MjRqeUZ1ZmovcGRqY3R1NFhMdUxEOXpORTM2MCtyd2JiNDc3WDVJSmtHc0prc0dYNUFBQmxjOTZTUzlOUkg4eHEyNXlyenFqUDQ5T2F0VWZLTjNTQXAvU0lGMHN6bWpZcnJaOEpCaWx0U0VtMVplell0MytGWTkzUm8xWXRhdHBOb2w1OHJoLzJKNEZZV0pCajRpZzIrTGpWK0J1MTRaT0MyVXljc1dTbW9xT210THJOMmZKTXZEK0t0Y0NldXVOdTRiNHdWVVRuN0krMStVVW5rbW9lYjJ3bUdadGltY3pwRzU2MzJVcmRyTWtOSW5jUDl2bjcxZFhURitSN2JqYm1lOTJtKzkyNXJ2OXZVUVltSWh6YVBxSFZESDF3TXAwbG5ZbjNKUGpucE1iUWlxWElJRGtUVTdYY1krMjdYbGU0YzRqQ21FMmtpRFMvNGxUam9rVTdSbE5nYm1qazFld25nanU0dm0vUEJVZmZFOXlmeGM1ekFsMWtwQW5rY3d6M1orZXBPNW9wUmlibm9CSWZKZWVzczJiOGRYaXNDbkZpY2ZHeWJWWkgyOW9aZUdYZ0oveTQyblhQVGxmbDhkazhneEQ3TEFYSy93ZkdYc1UxUmRWRncvajhwTjhSNmE4QUlvOWhoazErZU9FdU9rOTBwRThXWWk5dko4b0Zyem52UFJuVWdGbUQ0TkF4VEc2TVB6a3J5ZnNZZHEwZElVYVNMVEI3T2t5SDc3ZzZqQlBZaFFtMGJCSXdYQkxmMi93Zm1lZ056bHM4V1RZWWlaUzdRYXgrWTByNEwxSjZpZlppNzM2S3Q0M2tCV3ZQU2ZHbnJSNUVWWnBiRHlsMnhaN09XQ3lWN1ZYdThncDMwY2RrSzlIUVBQaWdzc1R4UzNLZXpvZXpHejJ5ZEVHUVBlKzFlbDlaazhBSElXdXFlai9aVytsOEtWc2NSK1hhWlphL25QVGV3V1NNUHI3dFdQazlzUkdhYS9vc3UxZXpGNUNRZGpsdlljOTMzWVpMK0xhWlNadTcvSmVQYlVxcjBhNnZOOTFkNjk0anRidUJqYmQ5bkhTOW5GU0N1UWN1T3dQcnZiSU5SeVFMcUVDU2ozbk1JUUh3ZzVTRW1iZlpCdUFjMzhudHhxTGV3a2grZUFGc0krbno0NlBTZEZwTHBUSjRNT05sZUQ3LzNKU1QybFJyWnVSNDFUNlNidFM4c0dVMkc2ZEdzL0x0cFQ2TUVTQWVycThiSkVCM3hSNGlhNGNESGhFK1BOVDQyNURqaGZ0cFFxL25HVnlnWk9VMDAxb1pBRysySVAxOG8vV2lyZVpQVHBud0NkN1pILzVrNTlNVEI4eVdXb3ZidjNQMlA2VjF2Q3BmREM1RnNSUFQ3RjNVMGo4L05XVmllbkVBZnZmeElISjFNVEV4SUVVSTM0eWZ1QkE5a0Rzd0lHRW5DQTdLSDBGa3oyUm5qaVFPNEI4SGxmOS8rcWRIcy9tOStVaWpaSTl3Nmw4Y2dRWjJjWk1FcTlNWk9odklqR1ZURTNKcGhKRUhiSzJkMFFqdDd2SUZ5Q3U1USs1MkhmRXZQeHRMdkpoejhzZmpCWTZNRklJd0xFZkVnZitIcC9DM084Sk1vRDQ0QnRpRU1rMmdzUEtBME1YZmlVcndrZTArZlBqY2VaZjQ4RitMS3AxdmxxWlBoVDQwd1Z4U3phU0dRVDBWNm5wMFFJK3Qyc0YyZkY4M1g2VGZ3d2YxODArWmk1T3FSZW9OQ1NTcWVlS1V3QUlBS210VGxjVkpycEFaQ1RwMzJ2VGczLzh5UVF6NFMwUWMyRnFHa015aFM5L09hdFN4QUV1dS8yRXZvS0RHc0RNZ1NtaVFmZGhrVFAyai9OODRqaG5WRmJXZU00MjJFek5RNUFJVzV6VHNVUTN2dlFES1pPZlFoSCsyNjhJM0QzUFRoVitJVnZNcndoNDdCZExLM09ib05iOWVReXpEWnFEUEhjK2tSZEZ3Mzdab2tMVmtJZDhDK3VCQVlMeXpKN0NyMlZWWHZUb0hTTXREWC9JRnc0ZkF2WnhVZkZtVmlDY0FURlo4T0tHaXVBRlZaYW5nUjdNWk9GM3NrQVUzcVBGY1pIbjBDZTVYbkdDaUdlQ20yZlNVekN4K0JxSTRmaEVMbmdReUNEUDhiUE53UkpoY3dqMWdvUHlTalVtYmRQZFo4ZEZ1dVpIeC9uUmNUUEpuYjI4S0t0YytpOWxJMTgrYTQ4NDIwOXdVZmZ3SFludGs3SFA1N09qTXpxbXJVTjlIOEJuOTlHVUVwbVRleDdrdWdhM2xja0xudWRnZmNUN0VNQm1QMFI3bVdGT2dKd0JvZmcvWVltMEd0SjQ0NUNPVDRsNXFZNWl3dVREVFNkeHhvRTRrQmJFVFVWUVlvb2p0REV2ZHh2Z28ybzRnOFN4SjhjekkxV0ExRVN6RTBmSXNVZWdYTFlIVFNQWUhlUTYyWXZBM3NlbWl2dUIvaHlmNGt1SDk1bUMyYy9oM0djbWtRSGN4V1BpYU1NUWZjbnNHR3AyQ3h4Z0w1alZWTERmQ1JsUXBxQm15Q2FTYjl6czFYekc1ZE9CNTVZSk9TZXVhM3hVL0d3ZkpDY0tHSk85Rko3aXVvT00yQjJXRWJ1RGpOZ2RZTVJ5dWR0RlJDWnhOR3U2Q1E0KzcxZkloL2RqOGF2Ty9SL0dBemdZcEZFZEVWZ1hyTlBnSGZWSW8yb1A2UXNRWENQZDc4N3I1WkZqamFJd3F6RTNMbE42WkZCVmVqd0JHMlArbU5UTWsvci9JdUc5SFRsd2RxL0J4c3JFWHFEaFpEeVJTbWV5WTduOCtNUmtZYy9la003R0xKMzEzSTJja3p1OU91YnpyTnVPcno2NCs2dDNYaXBJcndTYjNGWE91QXg2dW03SHNrZGp1NzY2Zi9kWHM5NnVyKzd6L3ZhTmViY2RlVmVWLzEwR0VBTDR0OGV0MHcwVDM1TUdPbm9vcG5mRHpLdnpIRnBHQUgyOVFtYmg1VzhJKzJQOExwM09lSE9UVDRud2szakplczJuVzhyanV4UlByd1d6dGxqNktRcGxjM0VXczFlQjVGN2lwVFQyZ2hiZE55bjhRMG9Eb3FXT1ZJU1hZOWNnOEk5ZGVlNlZzRUx4QlI5alkzelhFdW9lWG5GZWFHeGgzbUEwMWlvbXNKWldiZGw0a0gxOE9tbm9vQ2hwVy9MZldLOGkxM3dLeDd2Y0M4L1JPaWRIYUs2OVFaNGZRckc0TW1INmFoRmlQd1crYS83Wm9qOWx2ZUw0MWp0UEVzbkVQWGd0YnJURkozdE83OE9LaTl6REhMdGNkZTZjb1BqQmIvckJWLzNDLzV6Ti9lcnQ4ZjFYZlRYY2ZEWEJZeHFIV1BLUUxYbUlKUSs5MTNtM3hkbzlyR3UrOE92WjRoMTZ2eVhQTHZ3d1dJdXNpWDJteUJmVGQrVGRKZStPK2NnRVA4SWNwSHYvRk16SFp6NUpIVHdQaUU2aFdPYVUwd25mRVhFOEg3MmI3WUlJMU1id3RGWWNNaTlkUVlBclVXeU1DaFFiL3o5L2xRaGUrWU1rVHpLdUZYTlR3WC81QXhpTFAwNmFITTA5WWd0VFFkeGhiZCtNeWRncnVSeVR1Qy9rVW95ZkN4RlRUVU83MmNNcmhWOFVGYzNMNGIyUG5sZW1tU0g5VFJ5bU1mWUs1WHJlRVZHY0NQNDlUMjVSbGdyanAwR0d4Q0dwR1AxTVNpazlocEV5WTBGbHBWaEE4WkVjNGZVa3dlZW1wVkd6VktHODdJdFlNTFZTM0RNZEhrTnl1cWVnTXRRS2VZdnE1T2duUk81VDhRM3lFTmN0ZDd2RlFuYnNpM3FMV08zWGZpMzRYS1JqQytQMmJBUEVZRnEwRmVqS2x3Y0w5REFHSGt5U2l6RytoWDlvTDJsUGpnNi9JZlBJcmNJM3BzRWpUdC9CVXdsbURIakVUTDJJMlJVZDhmT1hpM2R3cHRWcTV3NW50Zk1RTW8zWktwNGtEYnJqbGVLWUNJQk0zQ3R0VnpPWkhMT2NCMXNoMlhQVzVpcG5KME5XRUNkamJGb2MxRDhXWG1NdWg3OG5nOXRYZ215TDNNcytzRkovNEoyZTNoOS9STTRiRkhOQkZyM0lvajhIVk53eGNreHJMeWxzTGpUT01nZld3ZTllTlFmRWlPTTJjY3U2VjQyWVRFNUVaK1NBSkNyU3M3bHR6UnhzY0FCNTNYZE9Lc3paR3ZXRTFwamVlVFhHV1JrTE8zRmdSVHV4QjQzSW5SS3pFREEzVTZoaG4waURHRldUV3czOGdka0h1QjB6NnZBKzUxejdvT1U4UTQvU3pCTmswWUtBNDdGWFJYdTJRdVpQenFkVGxRTCtJUGVrSGFsSmpvYU96ZFFxWTJjUStVUHY5Tm9xTzJEMjJDcEI5cDhRUTRoclgvTEltV1dieFlNVXp3VlVFOEdQT1ZDRlNQN2RLOU1IK0gxeXdPWWd5bEtrU1Q4bWplQzNoK3hkUmkyUURuQTBidE96RFRxa2VkcTI3YU9oV3ZFZ0JRTXpwcWMya1dPZjZETXQrRDV5UXN4ZlpLYW9aVHFnb0hJQW9FTGVLaWE3M1NkallkNWNhUFN3WFlYN2pZZmxLMVBENkVIYTFhd1hiNFBRQzNiNDdOVDBuWlFTS0FTeDZobnFLTzc4elBTZHdJTmNzZ2ZZVjNSVS9kRGMrYktKRVdNY0VMVlpNYWYzRXRpRzZuUWNjTGNWc0xIRkE3SU1MUFJibTZvRE1ob2NxWnl1Wk9kRkhrUDJ0NWhyR1dhWlV3QVRCTnN4WFY5alNOcDd2cGdmajlrMTdWYVlWZWY5b1p4U1RFQkVWUlVKdllYUnFDbWdmUjNXWnZ3eEpQMmp4OWFLQjZiTUdNMzhyZ1pYSUQ3eUV2Q2tGQ3NlQUZIWW1CNVRnVWcrd3JaU1NrSEw2ZlZsREUwYjYwakR4d0JWYVBvWVI0NU56M2ZZRmtBUkZwOGdOUWVQbEQyQWNVdHJ3Uy9xdlZyVEI4UzJjV3dGa0FvVXpUWG1QY1lHVHBveDRsaEZqTXlFY1ZuWlBSL1pkNnB3L2o5eXpzRTNSV2FkTkFlNnhZTlRWSU5Pb2kzZUdkNVJaQ0dXYlNqdTExYWc2dHRDVVVTd3UrQ2tLWGUyYmx4US9uc0d4YkdlR1Z1OUFRbnZ5OW5pMkdvUTA4VkJ3b0ltelpMWkdFZUd3SmRWTHJZbFdBMUp1b1pqNDVndm1BaytvT1JEYys5YlJSZUdIL2UxRzBnaWlzMUU5TGlPSW1aV2lyZVp4RGFpT290WHQ4bTlqeUlLaFdUUjlVOFA4SFhsdkJKQzJTNkFqRWhycjluek9PU3M2YjNveFY0U2dEajFDMk1XcitaUEMrWmprZk55a1VTMG81cit1SE5CTmFZM1ZLVDQ4cEE1d0VrWHJJbmhZQk9wQVFSdTNITmViVFVQcXZMOXk5K2JDbUxDRHdGL2lwNDFpRDA2cnE3VXd1WVVYUXUyRDNYWWdweCtheEtFWVpLRWdSK2NCSmhNajdudm92STQzejNHc1FYZHp0dERzNHBIcWNETFNWWStIcWQ5amh1d1BaRUIyNnZFM09RaUxZdDJlbzhzVFdZd2U5L0Z5QkdTT1FoOHNNa0UydTNENDRheVNFbDJra29ENmFQSnI2SXpsbWdkMUFIVUEyY0NFNVBCM3BVZ2xJZjNDYlNoSEJVdWt6SkJ5RE1XWk5FOXlaT3pNSFpiaE91NlRlSWgxMFduQ25mUVVWQ1FYWk9GQkZET1VZN055MEVoNTlINWtlazcwZWM3dytqbmdHNTFCSFQ2Ynh0aVltNkozZm5abHo5ajNTb1RBOS81MldsWmRjcTBvZUQyaFdmR3cxRUhreFpNQ2tuT0JEN2htMndsV0I5aDNld0tQSWpFeVJVWmViY0FjMjRCQ243TUt6ZXBGczRLL0xGdGx3YkZmdHp5RnRkNGJTL1hOdXB3b3RKZUVUT0FoLy9sWnlOZHBpWmdUS2lBVkw4cXZwRXNNbFdPeDBUWlZDckNnM3ZwMFhPTXVuQ0tLU084SHZHQ0lqZGFsWkZtN1FWeVdUWHhSME8yZXgvcTlRbkQ4ajBadWlzcnlEQkY2SmtxeHRrVWl6bHVNd2VHbUNNM3hCeEdjWVVaYzI4SmRkd2swM2NIaHpvVlc4ekNTVTdpQWlmOC9LdUF5SjMzc3ZLNWU4VW5wRjRvcXJJcXpXZFVWdDFtV3NOTDgvU3EzRWtuRTdFcGtJaitROHhkbXFzbVJydDZBZVVSbHRpS2lVMFZrOGY5VDlPRGw2ZWlvbFQ0K05SeC80ZG9PNjNLck13cjZzalRaSGc2TnpQM3FkZ2xIWGxQN1pQTzRmSHYvT1ArZXpVNkwwWksvelFtVWdXRG4yYndrdFczY0NIU2l1SkJhOFdSMUtvVDRsajRmNUZ0Y0RWSzJsRUtOQjUzN3BOWHFUbTZWSXpMemI2KzNBQ2E0UDFaemg5WU1iVmFwQnUzOU5tcG9weS81c1VIYVhGTEdtZG16NlJYaWduUkhVbFprMTdsUUlpZm15UnZvVEUrU2lhMUpJOGNSMG9tUjBzbVY2MUxDT21HWjkxWDZXV3NjWnB3K2JudnpmdnBpSEhUclJ3VHhZTDNxcThydWFCc3hKd3A1bVFtTCt5c05XMUxXdE8ySkUzYmtxRnBHMjk5c2w1UFBHdHpsOXhtMjVRVTI2YlV1NnAwUkhzRzlqb1dGTTZJR21Eb2xlUGRWS1pjejFlOWQxODJLRXh6VS91bkZOMEVoYlBqOFRuUFdUSnVzOGdySnUxNWR2VzZpV0p5bmoyZndlb2NUL05Rbkd4bEYyNWt4ZS9IZUN6STZINXVMQmpqS29sODZIRXhwNHp2OEJGMzNrNHJDdjE3SktRV1BaU2dIWjduY2FHc3ZmVGszYzhxTmFMR2JneEdLa1A2RC8vMEgzeFpic2hFcGh2VHFnclNkN201c1N0MHYzRmpldnpkZnpCdnhpOVA1eUxmb3Z1b3orQmIvTjd0LzFDaVkxZUtyTDQ0UG5mMWhXY0ljMk15Z0h5d0RlZkg5UVpVb2ppTUV3Vjg1eDVsT0xURnRKNGk5ZDk5RTlOeUlmQ0tYZ082clVaOC81ZCs3ODhlMEhIeGJ3Z1JvZXZDR0FjcEw3SnYva3B4M0tSdnpMMFZlNzQ0SWZadi9ydHR3YmladUN5cWlaR1ArK0taU1R6dkZQNHFHOXJidVZPOHdXMk5JTGxPRGVGUC9jZEp1czJSNDd6Ymg4WFhZVW0vKzJIeGFSalc3NnBqbzIwMTBpUmJiWFE0TG1rN0xud3pkNVYyZ09NdjhjelFKV3U3eTZHeFRqdmV4ZmN4TEMrYS9QVnQ0K0p6N0hObTRobnJnemw4YzM3VWZ2Y2RMb2VSdFRseTRGd05EK2VCNGt4OCtsYm12Y0tleGkrcHpkUXI2bGd6dGJNbFl1NW1TMFNRMVM4VTR5K1krTkFTY1dmVGxuaHVMNy9nMlp0VXVmMXhLdmQ5Qi8wOTZoenJWWitlOG5jN2ZKN3diN0lpU296WUNZbm40c0pQMExtNVJBSnY1Q2JFbEFLUlhuSUZ4aTVqRDBtbGh4amREcjdjU0NnV3M1NjRMVTZwS1VCcXhvc3BRYkVvTGpwWHNjaGN4ZXhjaWN2NFdEaFhjbDdhbGhjbmtkdm1RM1hWaWtMcHRuTC9aU08xSHFiTHl2M1JXeHZFbi9GZDFxa20yL2QrSGhsTE1jbDNqUnZOR0cxcUt0TFVsRzFxaWsxTmhVMEZFVWpacHFxRDY5Q0k2eDBXNXlqSzEvVTY2TjFJUllyODBMaVlNcWZIeDduWjdIck9YTVBPRzNvVjVtMFVaSUo1OWlxckRVcnRiQTJVTXI3NmZwNWZLWHcxSzVtMUh5blpES0ZGTDVWVXN1MDhacmZuMkFXdHpSNGRsaFE1WWE5VFQ4OHpXa2RPZDlwVXJFdXBWY2ovSllxVmxQcldrM3c1T1NKSkp4Z1EzNlFDYWtjbWNuTEFDNTJJUTBnYjR5MkFFWTRpTDZiTHRLNzRjQ0tQZjRsRUh2L0Y4L0pmd3Y0a2JDekIvN3dFWUZ3ekpueDU2ZWY1Q2ZyRU1EbU93Ujk1cDRzNW9JRGdTbkRWNUtnN1NZeG0rTHJMRUE5aW1pSE9EZDFKa2kvZnFWb2dVR0phcVNiU0h1ZUNJelFoS2VhbjVDTERISjJmZ1k1TUZRdkJiM251SUJiUHJuQllDc0h2ZWZhNlNQNUJIaERtZ200azl4ZituWWllTjYrb1hBVE9jaGJPY29TelhBaG5nSmRjZEVWdHgzQTh5MGwxVzJSRjVZWkFKV2FCWHlnZWNJdGx0Nis2enhIeHBHNkJSTUdRNWFLekdjNXFRUTFzVXRtc24rVi9zYXlmaU1WaTJhVEU0cEtleUdaVGNucjFkU0lCT3M3TGlHMVo4R2ZlbXBnQThjb21vUU1lVHo2d08zTmVkSlU4ZDJFOG1jL0xzU0ZhNS8rRmFyRG9XZUJxOEFsZnpEZmpaTklOM3ZObFNxT0JQdTdsNDNqcy9XVC9XRWdBdGpnWi9BNWhZMXY1bE1BT3pWb0FMS0ZsRDVNRmZsYjBGTUdNcklmZ3Q3M1Rvb0Q0SFN5RFNaUFhaUnpYaE9Ma2g3MG4xSUYwR0w5aWJRaFRqdDIzMENiVjVVNk5VN0hCT3NVbDl3elhKQnU2aDBoZ2o3eFFwR1JKTmZDTE5zZnM0VzdBSHVzK3pYYVJZamdQQ2xKeVNkRTRBaDlTdTR3OE1hQ09CSldETm91MFN3MFlNdUlEa0xwYVhSNmliRUpnN21yaE43TFRCM2FhbjQrT3AyVnkzcFNaRWJlbVdYUGdJZC9UMDV0SnlONjZGTExrMFRONk5rMXVETGJHWFNZcE4vUWttSnRIMHI2UmZjQVZabFFFWTExV0IzbTJKU3V1WDlpODl3ankwMVhJQlR0cGhTRnh5NnhIeldTM2hpY21lVDg4aGptTnp2T2ExYy83eXFQenFHdElIOS9OOGd6SFVGekJjeWMyOTJGdkNxbDM4aFRQbE41QzlubC9wZkJIR2N6eWxkTjZQSndyOTdRWU5ORWMxZWpwNXhWS25IZUtTajdRSzRiSDlBREc1Qm4xM1pJMHREVEZtb2wxNVVoLzRmZlFGekRldVp6aTRnbEFvSDdzMzJLTU0wcENXSWNjNXAyMFhVOXBiOTkxWDVXSEd2WldIY0xnbytORXVPakNpcGlxdVlQNk96WmFXd3c4TUdHOXEyZnRHWEdCbDcrdkptV25KMmo3cGFBVGJSYlFzaWQzaXJ4cnZtYjBLK0lzd2ZvOG1BejA0TVk3d2M4aGNpNGVwT2xkbm5EOTBlNHBjWEEycGd0bVFyY1NCWmlWdDVnVTBGVUkwYjBXSkk0UDNReU1tNWpxYjZqZm5OaVZ3MGdMcVY0UkIrMURmbzljSTZSa0xhdU9pSksyWXpSYkl3SG5NSTZKREdZdkpzaXBNN2J4d245QWMvRWorK2xEMis4NGZWVHNmTnpTcEhOSHc3czlmU1BXYjNyRXpPL0w2WHhPd2VOVEs5YlFReHgvZXJrVHdtR2RjczdzUkRIaHIweWtnQ3Y4UkR3aEZoNGY4YXlweDRNeEczakl0d0U2cU0xOU1yejk5MU94WGErcm1oUFhzN3laMDJuRVV0U0lwYXhHakp0SjFJYkYyZkREaVAzdi9uSGZhUFNTSEx6M0M3K1pwWmtHdmNMc2VsdlkwM0lwenQzK3BXazVxeS83THI0WVJpUjRsaUZwNHF0MDF6NVZsSHNsUkZPbE4rNklKMnZSVGwxQ09HRnZPalMrS2o1eUI1M29nWDdUdXNzVCsvemNqL29ZY1V5clZaelkrNzhoaXNXWUVMa2RuWGNGWGwwTHJyMGVQejBlZDdlTFcva2llR3Z5Y2J0RUh1WkY1RjI1Z3dteDFIcndCbU5lNE50YkQxSExxM3A2SkxqMkNQSytFVDlqVHlpRVJYWEs4K3ZCMTJKcTVxSVZoVFVIY2IzR0J2SXJnT0t0dHg3ZS9tMjV3RDNZdXg2OHVXTUZZZjNER2hNeUp0SWx3bkRjWGJnVlk5Tmp1UU9Sc1pQQ1h1RzNzN20wOXpBZ3RaKzdGUE92QnBpeEg3dFdJTDV3K3R1VmFlVUNmWHZqd0hsMTFlc1ZmcGZlc3ZBOHlQMWNuclE0enFJbXBtMlkxWG41dVNPeGlmQ0UwamhoWmR6Q3lqaGhaWHg0SUpKMUJuK3A1L3Zaak4vLzRpeVZ4MGpNc1NGOEFrWjRCVTh4c1Y0TXIxbVNZbGQ3RUhZSk5ja2czc2U3Ny91WldScmRlY0duRVpDTEpIamx0KzVKQWdxdm1PVEcybkYrUWJBZnYvYVhYNXc5T3k2SUpHOFNkSHZtNldWeEF2YVpuSnhSbFRzdTVBdjQ2UkljRTZKSDVjSFVoTGhzRUJmZGNkYjNkYlErZFY1dmt3L2JhUkw5QU1EZTE5dmVWcnRyTnJDMlBOTHdkS1RodklDQWw3UkhHczY3SFd6VEU1R21KOWgwajAxUG1MUWEzQ2FrNlZ5cDJsemU1VUtOTXIrVm9MbEZVbHZObHEzdzlBM2hRODYzcEREaTBwaHA2YzAzdmpockw5d2djd2dSWTcxZnpLeHBvMHltSysweGNmVlVIR2VMTTJIRGt1SWducXM0dzBmZTNjS1g0RGtjdGs0R2xoNFRqL016Z1p3Q3d1aUp4Zm5kL2g5aEhJV1RBbG8zV1l3VWNlaW4vN1VPVHByakR0Q0lyMDZqejVSZ1pBOHZlYmRmS0hxaXpOMnZnM2hLQk9vd043QlBncmM0bkMwbWVhSkgvSVZOeVQwblNkVm9wVzN6aTJQMFR4M254cVZQVStGRDFyazNndmxpeHFSUHEvRXpRSXRtSlJaODBweUR6TjAwZEZaQXlyQy9ncWt5emsxeUdpMHJKcVZ0V2tXaDZLbnRjV0VGUklnWG1OQ1NHdU1ZelplUnQ2eGIra2VWcG53MkgxZ2REazlPQ2J2Z1FFN2N3dDJKZWJhalJuZ1N4bFZhSmM2Sk9hNXVSV0MwUlRrVUFTdklROEYrV3RVVTBOMnBGVnZzbEhwSHRxT1VQQXN5bjZIVi9pRWRIT21ONkx0WWhYUzlvSitrN2Y5d1Zyekk0cU1YcXYwcmdzOWRWdWxDSWhDa3pPdGY0bkszb1VBc0prdTJlWVlyVDA2S3hNUFh5RXRUQjRYdkpPRTdjV3Y0bGdFYlFyZnhGYjRSZUh2NDloUytQYjBGMHQ0eUtmQ3Q4S3lBblJEQXpxblZPelhxUk5FWWdkZXZDdVlIbmtQM050ZTBTUVQ4bERLMXRLb1FZMFRFM2dPdzRHVVNiNlhWVmNINzVKNnBwYUszeW90MGVCTlhmelY0Q0lKVFRneXEzQjBwb3BTSXJKeWtWQ3pPSUJWc1pOc3l1SjFTMi9vcWZ0OXplcW8vblE1azgweVhsRnM3dnQ2WTdXUGhKS2N6MW5HV2hwTjYyZWh3NGZteUM1VU92bVU5U0t5dEFIcmwyNmVueUxCTVRWTjNHOE5YMUhKVEVHU21xNDdZZ1NieklabzBxVFVDUzl3NGJCbnBpWnhlSmpTcUhYYWtrV2ZkcWNRQ2U0dXkrOVVEZjA3NGpiUXUvQXdEMG5CclBpcDZxSVRGNEtoSjdtaHljSjdsUVZuQkJqRXV3a05XUE0wUUc2Uk5SdHpiS3piSUVwNEZHMlRPSUVRY29TSFA0ZVlvTnRpMnlrTnNrSWxnQTFENzRqYXNvZGdnSFdJRFh6L3JSN0JCV2d5K0hEYklzTzZkc1VGYXpqWUpOa2haTXBNSzhVRStza2p6Z2cveXhBY1o0Z010ZUVxOXhRM3hnYTlIOXc3cDhFVHhRVnc3WDlDUEhzcEo3M2ZBQjc0Z0NvY1AwdHZ4UVdZVUgyUjJ3Z2VaRUI5a2xQSTVmSkNPNElPRVd2Q2FSSWdTRkJOWUZnUWtVaTQzQThWVWhKQ1VNNkZFQ0hvbmlsRVNQVVNaT1cxdVpraUh2U0U1RmtGKzJuN1hydUlFVm5GaXgxVXN4OVBrb0dxYVlqeVpJVHQxVHVOSUtjZDQvV0pjRzVjeTdDK21qY3RPajZzQi9SeXl2QUxXdHlmcjI5UDE3WEZkcXd1VmVORXQ4UVM5dkhwWXNvS2JZcElMNDZqcnQ2aVhVd3EwUllpRUgvMlluRjZ4SjM2MHgxUjNLV1RJZlE5SlhTTVN0dXNocVNNbVI0VU9hVDF1a1JCQUJGL1NJWTFqclR5NUMyMlVOZkdVb3ltY2xmMXV5K25FTEovbUtYL0RGd29TTWlUR0N4bTViZUREdFVPRmRpNWtTRUlXeGZLQ1lYdmVSSHRBYjJSM2k0Um5sYkxMbXl6QXQzK2pyVjNoenZ6ZnlMd2tRcVlyNU11R0ZXcVZyNzAyZTBxNzl3dXY2WVVyMUVsOXlQL1NhNmgxN3RyTHRGUkpmTWgvZzFIS0FDdEJaeTM0Nm8vL3hvOG5lOGRaT0pEanpWOXhnWmNSdUdiMDVqSWRnaU5VbWZFT1I3cFZ5Ni94YnJuejQxUVNXZWI3UjE2YmxZdmRHUDQwd2ttYXBtVk44anlXYjlZa0hoOTNiWjN4V0RtWHhwQ1BkOTJXQ240TUhmRGlWaEhoa1NZVDVHVlBqR3VRTmVrSzh0UjR0dkMxTE4yMjh6Smp1VENhbGFHZldPaThuYzJreGFpYXQrYko1WHRLRU1RZG9zOHV4SWZOOXlMTlQ5QUZFejU5ZnB5OGdDYysrWDEreVNPUEZzdnJIaVBvSHBocmFZQTBWdHNvYnZ5RXpMQlZaT2pKRWM2dWlFdUU2VFMxUWluanI5ckpLaWJrbnNiVk5ZaTVYOHRLQ1VxM2NyT2s3bHFoYzl6ZlVlaVF3ZXZLREFIT1VZSlF4d2ZSKzFWZGlmSkFpNTdVNVVMaUZnL3VYamtmVm9JZXNuK1lhSVJFSGtMaUQ3MDJxeENKWklSenQ1b2NrM2FUSThxaXpJcDgyRTZLdGFYVGtsekRncWVsUFNMMllWSDhKWjBXQ0R0Qm53T2ZmODJ1bFI4VCtMdDYzTC8rTTNZeEFEU1AreS85akFYTFYxK2JKZFVXYVVRRUhpd05FWUIwcFFZL3hDUUoyMnV0alNqYktBZzlJNndTQm9PYnpwNXdWQWhORlJOaUFmT21ybGFyUnVDcVM0U29nSXhqY0xlc2NMYm95MnpSdFo4Uk1vZVhUd3J1U01yY2dub0hGSEtFVFJEMVF5QlVBck9yWDAyNHIzcHVkV3VkK0R6bkExOWE1YVM4S2F2ZUMxRlJlc2Z2cStzZU44YVpKOGU5Y0d3QmZobXhEYUJQTEpteTRVNm5BbXFTWUJaT21Gb2V6bmg1T2NLS1NicmxHdFNvWFlYQVFucWVVQkc2VlgycjdpVzl3NER6NUtYRFlrbThUOXIzeWZBOUdEbGlQN0NpVm8xZ3JEUWIzelppM29vYnJMZ2JMT2VDUk5GOFdPd2JydGpYdzJKZmp4WmpTQmtIV3dHQk9odkUxNnlWSHZXd2x1ampWVjYycEgwT1hoTHA4ZlVpSklDK2xjUlB5emhsem82blNiWHk5TlVuTEpYZWJxdXRBQ3NBamlubE5BcSt2cGVpQ1MxSzdZTVdKZnBYNlRkcFNhTS9sQ3A5NVNQOTA5b3dNQlZoY2YyeThwRVNHcEh4SFIvcGgveGhRcXNvY0puSHhJV1Y0eU5USmhIaEl4UGIrTWlFM0JpbW4wMk44SkZEbVZLT29rVzV5SVRsSWhNUkx0S0tNTHNLbHFtb1lPbmZncEhrMVVSV3NIUWRza3MwcGIwdjZIY1A1YVQ3MHFtUWgxY0pUUm5KaEpKL3pacWxhb3RFZjVvYWpJVHdOUW42MVBFcERLOVpJTm9PVG9KYkZYQzhrRnRNYk9jV1BlRVdQY2N0ZXBaYlRLanZITlZFUmNWSFVZaGtoZ3FueEZEdnBOeGlRcjlydVVVdmxQa1N5aTBtSExlWXNLcVdPM1hUcHlEM3FJNXdpMDZ3VEpPcERWVTRhVkhoS05NWVY2TkF4elI2d2pRbWhHbE1LTk9ZVUtZeFRiSVJNbzA4WG9VTVlCcUZ5WlpjUERDdFRHTkdsRFhpcEN3eUs1bm94OWgwMi8vNERreGpQTUkweHQxUUpYWGc0c28weHBWcGRBcTdmQ2hrMzRwZVpPUjBpS01YZERLbTlDSkRRZmhXOUVJb3lyZEY4TjEzS3I0TFBxcldwelNmT1l2Nmd5a1JQMmhuN3QzamYrRzEyUS81SWxEZVErcjRJWjkrdURKeW12TUxRalZ2SnA5S0o1SHAwSXFRYWk5SWh5d2pGWVVKZ25CYVNCWUZIcmt4VitTOGhJVmpDajhnaTJuYm40d3NOS0UxQ3NucDNlV2V0RUJ5MmtGeU9wUjdrcUhja3d3blZBUi9VZlNGT000YlFYVlc3a21Ia0p3R0pLZDNrM3NTS3Zja2RwRjdIQ1JuVlB3WlVkWW9KTnYxN2lBNXZhdjRRL1BnVEFqSjZWRDh5UXpGbjh5SStKTVpGWC9reHVMaHg5aDAyLy9FZGtoT1U0RmdJVm5Dbm1aTjZzQWxGSklUQ3NrSmhXUW5ZbmprYnltZmUzOEhFY1BQRmVMZVVEL3ZoZjY2ZHJ3YXpIaTVUMC9HTWxlSGV5cFlSTnkyc3QzeHBRdjI3QkMrQkpRYXhFN0xWVXR4SWxoUHBvc2FFN0pSQ2IyRUtTYVpWK25rWEpTcmdvUmxIMFRKL0ducjhrdWhNK1lJZEl5alJtc0hFT2gwU0tEbFNzRVVhMHJ5V0VDZTk2WW5sUUNudGhIb3RDUFFjWDBmVndJdFJZVkFTMUU2eDlUQlQzSHlhRHRMQXAzUlRSOFM2SlFSbjhEU25yZ1dqN3N2c3cxYUViZlhXRS9Lb1RPN2E3UmZ5U1ZGYUZaUjRBbm5tRXlCdlkwYWl6b09EaVNhVHc0d0pGaDNRVVh2dEg0MkhTSFFLVkZkeGZRcnJQbk9Zb2o5eGNKY1QwS2x4S0p3bEVBbkhJR09SL0d6SUMwUWFHcHYwR01RYUMwcnF2VFVDR3BPaWJaV3gwYzZKRnQ0ckVKNlg5RHZIc3BKOTZWVFlrSVFXVURzcjZNR0tidGd1U0FGcU9RT1JSVmt2cTQweW1LMldFaWhrOGI2Tk1EcWVsS1hHTGtjT1dwbzllMitpS2k2RlAvR01aT3hYWG5RWWQyeGtQMk1LenIrK2hjdFhrYmlaTTdWK1kxSW5ic3dxSkU2SFVjeDZiWURGTnJKWTRwUmRsTFpQeUxnb2g5Q2UrcjBDR09UVXM0UW5LallNOFV0WnowRWVYK0VKOFhReW5YcWtmTFVaV3Q1dHkwVEh5S3RJZHduRmU2VHA3V0pnUHZST3JRTkN2d1MyaEg0a3lOQW5ReUJQeGtCZnYvdGdkK1BmTnUvYVFVb2l5b2U3djRXSzhEZnhxRU1WMEF5dWdKaW95c2dNVndCeWRFVmtOeStBcExERlJDZGljUk5LMENNdTRXekl1ZXlEV29pTUJrTEY4WmtUbGl1N1VzakxKVGJrWHVOUjJsK1lqdjNtZ2k1MTdoeXIvRlI3bFdNd0dMS3ZjWTQ0ekdGb3BpUXJrbVMvUGd1ekd0Y1NYN2NrZng0VGd2ZnlXdDlTUExqSWNsUFJIVVhzaTlDYzZOK01lbDBua2xMOUJQcVNqOUdHSTZ3cjNFaCtuRWwrbkV1R3JXQVNCVVRVZlkxVHFLZmtoWXhGNmJFRW4yUmxNVEhiakl5WThub3grUWFQdTE1eks0ZnQwNkxjWkk1WmZ0TlhIV2VNU1V4TW5JeEpmb3hwVHN4Ui9SWm1ub1RzU084YW1KVG9rYkpUUW9CLzc1WXpCY25IYVFpaFgrZnRZWUVqMWpmcmtyYkozWEdOOUVIdk5OTjlCZzMwUXUvbnkycWcyVXdCVnFVUmxPK05Rd2crM01aekhLVXNFOEpRUmRITnB4eDFDR21HclNOOFhOdlptTFpxMUVOa1U4Vm0rb09JbXlCcDB4Qk1wQkw2ZVVJVW1xSXAwVWxidmVTWXJMWjVjdENwbzJNcXRwa3lKMmVEWk4wZmx5Y2R5VVV1K0dkT2d0bEpxY0c5b1QzTUxGdTRGdCtTSXkyM1BhOW9LeEV1RkNTaFQva09jbkpuRFZUVDBWcGhSS0lKTlVsc2ZNeWlUdFVIWGRmdHpwa0V5cWpWTnRoZEZKU1VZSXhIZTQyYWVWbjdhRU5xU2x4eTM0TTJUd3BLa3hvVXZmcUJBMm9yMVlwbWh3V2xiekpxS1k3SWNaZEVkcGx0eXJkV0NqNXRBZ3BTVS9NUEo0elFybklmQW16bDRwUXJ1eW9Ja1dZcmJnU0xYQm5jWjIyN1VRck8wSzBrc2JxWUh3bkJHcFJ4eVFuUTNxVklyM1NBNTRwVmFRSXVVdXBZc2NWMXkrcklrVkNTYWRJU1VaSTFaQUVKYldLUWxHdUVFMUZTRlhXSkZXUkV1WkxLNmxLMnkxSG11WEpaN09qaXBReFI2VUUvS0pVS21tcFZISkhSVXFVU28xRnRzbkdoRXFOa1VxbGRsT2tKTWlwcCtuQjQ1Q09UMEhQQlNaMUYwWjZYOUR2SHNwSjk2VlRraVg4VkV3VktVa0ZNN3NqeDV0UENQSFdja3FBTFRNRXRzd29zQm0xUExybHFwUkNlaTV4WkdteUxKR2ZTZVQrdTNnc2VUVW8yQnVMUExFU0tqdyt4Vkk4bGtWVUkvU0taMzZLSXNYSmdyWGU4WU5IeEpIdTQ5dVI1WFk4U1N1b2xTQy9Nb0ljZ1UrZGtSaytKVllDampqNmROV2cwTUE2ZkphK2FyY29LRGY1SXJ6UndSQkdhNHA2QXU1VXI4ckpSWFJlYXBMOU9PUktXZkZOZEsvVzZYTEs3ayt0RFFjdUJSd2FSV0ppVENjT0ttd21yV0kwRTFLSTZYeHJHK3FyS1JXN3RpYWV5dVE4dnRFanVkR1B5UjJFY1U1M0xHcFFOREpWUG1pSllGR1FsbHhmcUpTVmZESnlZUkhHVW14T2d6dHBGeGdJWE1iWWR6NzhkUnBUeVF6R2d0bnBPQ1lxdG1wOHpjUEp3UnlqaXY4enEyZkllYXZYckZxeXFUQkxkaVQzOHhPUVdLVzFDaDZ1bTFZS2pVdHZZNnJhRmtIVWl5d1M2WjkxVnJxalBPbzVQT2ZkU2g1TmhQS29aK1hSNU52SW8wbVZSNU5hVlBDY1orVlJpK2VjUE9vTitYSlArWEl4bC9kVUhrMkU4cWdYeXFQZXJ2S29GeXFDNDFxRlpjbTlpTUk0bEVlVEl5eDVja1FlVGR4S0h2WDBOSFB5SFhManliZVhSNzNkNU5Ia2lEenFSYmp4NUE3eXFQZHU1RkYvdXp3YVV4cnBoL0tvMlBXNlZXQjk3SVViT281Z1NqVUpKNDc2SStLb3QwMGMxYXVuUkRBTnEvWkMzbUUzY1hSMHY4VGJKbzVxblY4ZnJaUG00N0doT0pxSTdvN0VoN3NqaVZGZ1Q0VzdJNmx3ZDhSS290dDNSOUk3U3FKYU5HNDNOVkk1MWVqbVZaVTczQjNKRG5kSFVwSGRrV0Z4L2JJQ3U3K3IvT21QQUxFZkFydi9ib0ZkUHJzTjJMTzc3bzY4UTJEbmlZK0k2SmtWWU0rR3V5TTdpWjRXcExPUjNaRWhzTjhrZXZydlhQUlVZeGdCbGUwUUVvRy9XTGdHUkdoSTNMUUt3a0xXdUZvVmVqdUxubFEzeDBUMGpEbDFjeXdVUFdPaDZCa2JMdExRN2k2MnplNHVGaFU5WTZIb0dZUG9HZHROOVBSVTlQUzJpNTdKSFFWUDN3bWVRMjJ6TlZOeTJ1YllUb0puY2loNE9tMXo3R2JCTXprVVBQMVE4QnpWTmtjK0pxN3F0ZDhxY2crVnpmRlEyUnd6RXJZRGxkUmg4MVR1OUpTKzZMQlo4ZkpUT1QrbHJoN2U5SGEvWUNCaDc1cVZTeHZjbVRrVG0rY2lqYjRxNXQzdFg5ZXVYYjBjQ1Y4eStma3BBdU9jZDhIa29wbUs0NUhZVXlZYSsraVUycCtuVEZndFBuSnBKUFpSMXVxdVNUSFhLVkhLcVdlaW52bmhsNlJjYm51NVJLU2NPK3dmcmZ5RjYrSjYyYVo4RFNsR3VJWVh5SHk5RUxtYjVZWHJHSXFwNmNRY09Ta0U1TngxZk9TRHlDSVdKZmlDMXNyM0VwSXFueGM5aFAvOGRNSVd2VDR2Qnh2RVQyWkNqOXlKUFA0VUQyM0t6MGVuaW1sZXB5azJXVk1ZUjUyRmg1K24yd1N4ZXl6NmM3TnlHVWhzald3RUJ0ZEZDV29BSDE1RlROTmkvdVhaaFMxQVpLcC80L0lyZ1ArMWxjSWZBemVaMUtwY0svRkhudHpjQktDNkovN2RldlErVHBQS2VBZ0MrTExjeUNCVjg5SUdkb2wvaVhtMGRBdDRWS3RPaDFXblYybVJHWHhWcTA2dzZuazVrVDRYZnhHdzh1QkwxOTBnSjY1UGMyNlFuR015Ynd0REJLMFp4MHpJOGsrSlZhWUd1QWZHRXlFOEFCT2JpNm5UbzZSMTJ4NExya0c4V1VVTDZBSkVVa3k2OEJkWmZuMldQNDlvVm5WZnd5bTZjWjNkRHUrQTV1bW9SS1JoRTJnVDJxS2tKeTUrT3Vsd1k0NDl3c2krd0tOa25INjYxc2svQi9rRThlY1l2blRqdVdLNHRPSlBpWUxVck9naG1adUdMZWhEdG1halV4dzJ6c2pkdzFFejluWnZNM0daMDNtWnRoaVhibHd1aHMzTVBEOHZDeVgyRXByKzhJdlhNWmF4NTYrakxmYUVkQUp2dUtzOEhvRnFjWi9Bcy9WdmlSb251akt1RTliRng0czdqMDlhUlMrcktibWJTalM5MGdrVTkxWmtySVZ3WUhtczJySDIrRk9RbkNORDdZdEppWFFOMkhBdXpoWS8rT0oxQUZyNnh0enNpd1NPbDBLSXUwNW5EUmd1T3ExVm56SDZyL0JuV1RsN0tlb0Rjbm1KeHpFYzREY3dLbGJqSS91bllIcnlrb2ZqQWV5WnYweTVTRExsYmRrOGNWYUtkL2RGYXBDQ01adGhmc2ZYT1NYaWhUL1AzaUZVaDBjOGdYTjRtVm1TdDJUdjdISWhkekZtYisrTEF3alZyeWlDajZ6Y2VGR3UyVklDcVllZTNxQlllZU1sSXFVYnhjU0xITHFZU2J5bzF5N0Y5SHMrdnBmN1dzeVBYZld2QkRFMU1HQ0hZaU40T3htWjI2ZE04bVlFaXhMeGtSS3BrUktwYlNXRU8vS3VVNlM1THBqTTZpaUo2ZVFzSWUrWlllc3VzWGNYK1VOc3o1UVhHQkhNSzc0QUpkZFRUUHVZemVXTjVpS1VKSEpmdFQyOCtwOU1EOSsrZCsrc1o5Ky94MDlmblpTN1pjVEw4UzUzMEl4Zy8yRmtmRHVwZWg3b0tqRWtDM2JKbUNHbEFPcjh4TFVySzhIM1hMdHlWaTMwQWQyU2dwL0hsU0xINXJmUi9ja1JRanQ1Q3dJOUVSTG5FYWFpNkkvVTROK0NWRThJbTJqSjllVE41Rm9td1I4bHZhY3NLUmhTY2pRRUszUmlCS2ROeVBxeWNvdS9BeVBnUlQ1OE0yOHd3VkxYNTZlMjFXUEovYzZmNHZnaTI2U2JzYWVFZVBMUzlSalB3ZkxxaHZsaUJsUWdZNGxuSmlTZUdTV2VYL0lGVjQ0VG03N2hjKzM3bzVYeFVuWWV6WTBya2MraXNxeXRMS3VWMFFIbFN0QlprZnErNkEvcC9Ldit0RGhXNWczdThibjdYaHJTQU85NnNUQTMrZUoxekp1T3dhdC84TnIzL0JWbW1oUk5QQWNsZWVuOW5LZWxGYUUvTjhlSnRHK3Y4YnI1ZStLZjh1Y2Vma2t6MjZ0WVk2aVZuSlR2Y3I3SkN5RjV6YXFXQ3V2U3QxK0xTVDF2eHJRZVpONnRucTlFNnZsYWJIczliMmc5WDdIMWZHWDNlbDZOMVBQR1RmWHduaXAvVG9qYnE3YXVWNk4xelYyOUhCa2kzaE9BY1l3T0RFaERXUDNMcmlTcmV6bFd6R3NaVFhOVW5tVDlxUnVYd3haY2k2M01RZGFOakRZdjRraXRyamluYXZmRU84VTlhRXR4TDhQWGJDdXZ1WHFMKzlqT3kxalVQL3dEVjNrUHZIa0pYeHFQVFAwQkZqN0k5TVNWNG0zQXRJZ2VZalN2N1E5N2EvYWc3dXRtSDM0dm0wbXpsNjNkYnlieDRERHNZWkhKSzVmUmp0c3UzYUFYVSt1MHVyakhzRkhGMi9GVkRwbE5IVWZXZlZySnBFbGN1V3oyR1BuK3VBa3JtVE12bXIybzl2cGxzNCtCRjVtK2p5WDJtdjJ1bnYyOE9wSXVNZk5TSWIrOUQzVWRtdnVtdnIvdENyMW1zMVQ0UFY3ZWdXL2hHL0l0TW1oc3pTUnY5TGlpUFFHbVJWYTJqQVgyYUM4TkJ6S2hMVWlZTytpRzgwcVJWODJ3Vko2bGdLNmwyZGM1blhlZ0FoL0RnSFl6K1RMVEVzcklPVlRKUlgzUTNINWRuR1NTeS9hRkNTbHdubU56OTcyb3FSWW9oYU11eHNoWVBVZFA2TUUzd1kxTnB5aW5QT2U0WWdvQlE4YVFIMFNrR0tsejlrWE5GYW56dTR2NVlaMXZ1VHJCM0lLWm5qNlVpN0tOTytHOWNPOUZja3dTVVBJRUZGWm5lYnlRd2VOTk5NamdycVZMQmQ5UGo0d1dmVnFtZm9TekpFOS95TkJGN3B1Vzh5UlRqZDRJYjEvMG85eDljWTh1bWRsd21kSC9TZ2k5NUt5TGhNVHIwbXVlTGhCWUI0UElyaWM0aWduTDdPSURjM0c3QkNXUzFNZ2U2b21VdVV3UUZPSlBHU25KV1kyWkFobUF3a2VuYnBEdjVJeUwzbjJVR0FxSEx4bUh2SEpST0FmL28xTnJXdVNTVmdCa2NsTkpUMHRxc1FRakNTMFdrdythaWV2aVpNRXhqQlBLb0g3Rlg5bjVWdHZjdi9EOWhMci9rbnQyZDNROG9QcUJud1VQRmFYeGFjZUhiRjUyNlgrcUFKMmUrOGlMdkJOdkx2RlN5S3Q4NUhKNHpXM2tkb0pMbERFMGQycVlXNEhMWmJma252N0NSQmp4NWRhbTFDdExCSVEwTDUxY3NuVVdMdkdjK1gwQ0p0WmZhWWptWGdpKzd4dkNZQU1nci9NV1hMbXhtQ09WMFpGS2gweWhNRmJYUHlTWFl4WjJjWlNRKzZUdkovVTZaUm0zSFRQcHVMMVdqTHNiUE9uUlZYMEd2UFhYZW9Mc3h0enRMN3JQdnZFd3htaE9UM2FLTWhkcGY1UFdPd0dHMmV6Z1JQSnRIeDVVaXBxWDhMVmY5M1laaTArK3hiTXV0eGlMdURyVlhSTmNGZzdGempjMS80OTArK3EvRXhEU3E4Q0hMYVhxOEQyRFlyd25Odyt3MmZFbGpOYXV6ZjV2SWV2ckZGNFc5d3RoQzEwblVyTGRaanZ4TmpQNG1mQkM3TjF2bUk0ME96bG5YYXloMld4cGJLa1l1M1ZMWTlwU2VqMWoyNUp5d0ZiYmxncmJ0dU5vNVJKZzFmWG5aZ0hTVndIeXBXbTZ5UFZEQWRLM0F1U0xsRGdnUUw1RUhRdUE0U1c5RmpNcVFQNmJuQk5DdnVhOVF5SGtKcmxqUENLWEZDZXdDb2xCLzk0bGtjSUlBaXpjUWhJWi96dExJdU5SU2FTd215U2kwc2RRVHBnZUYrSVZIeXBiZElHT3Y0MzB3VzljVngwQWgrbW1XbmVvTVd6YmR2a2xGRXRHeFpEQ3FPUkE3aUpHYlJYK0p0NUdERkVkbnB0WFVlVGRMSXE4NGIydEtKSXgyVlZ4OWtqUkpxSnlmRVMyZk1FcXl3eC9rMndhbHBWbFFmZWc1UWdWck15UGR6RXloRmpuNE4rUURaSDk1TUVRbm5BNUpxNFVENEFuU0FnTGFJVWIxSDR3NURialVpNHY3Q1I1VThlbGthQlQ3RXhjTCs0bEcxa3dFOElKa2gvV1c3akpSTEhzUVdvLzhUd2tmT2p0bDZkcG1KRmFvYkQxaVd0WEhUdnVrN0c4QTlYc0ZjYVNMQ0NaTDFaYVVGN1M1eXRrMkdjTzRHWGVjcVlKVStETE9GNEs2V2NCNFFUSUEvdktBeWNZZU5GeGtjaEVMaDM4QjFuZWc4S2hnbFU2R0dGVWZXVlU5MUN3TUxlejAxRWUxR0VyVVNaYTcycVk1ZjNna0tpL0pzdmtDeC9IN3lJaXJOTTAyRjB5Y1B1cEd5RTdiOTNDT3daeHAxVVFNb2owcjY2K0dsU25LNmF6NVBEMlU5Tk8zV0l4RmZKNG9tL1VXRUZ6cUY1WDFlRlc3V2lFbTdwdXRiMGg1MmVWai9zakhHQlVOVGtkc2xDcWNDVWU5WE9PQzcyWmFhWHF4b3hmNTlWR1p2ODgrbjMxWXlZV1FZZUNTb2dSWStERDVtOWNGczlYekR1U2l5di9vOFJhcXZZYnQ2eWtZOTJteHlONGVsejVOdkRwdS9CdEE5QUZJLzdCcjVBaUFLTGlLdG5aVlhUWjZyOFU5SWNMcVpna3pDZ2tzOFF3bjExYUxIK1pYL2RZRmJobSsvbzZIVlYxOUlhdXdxNFhkSEg3VDdaVkV0R09GLzVJZGNTaS83TWpyNTlJZk1qT3pDN1hibjFmd3ZFVzVtMTRpMTIwZlNjdUQ1VjkxMTY3ZWxudU5wdjd5RXNvUUIyck9COFBpMktFdkxsUDJHWm5sRGwxMFRjOGNyQUVqN0Jua21TOE1KNjVJTVphS1U2cVkxKzkrUkZsNDZXYlZJK1Ixb1NiQitFRlhuL2pHT0VJejh6cnhHek8xOS82bjhod3oybmFyRnkvL2wvOXRWeDdUdVpDcHRCQmNVVGc1NWJsV3k5ZFZkYUYzRWp3Q2VHTnVhYklxbUQ0MENUSDFIQ1k2SkVqRlJrbVppdklONkxyclpnYUhidzAxb095ZXFub0dNbUw1MDM2TW8zcWZDelFYWHlScFVkV3ovUFhYODk5UFE2bU94WkN3eTJZN2gwbGxUZGVmK1J5S0g2ODhjYnJDZzJ4dWR0ZmVrWE5uZWUxNEtRdGtybWt1VE15VDd6TUhuUml4VzdxQ2Z2SkdGbE55YVdVUFNibjlHTnJLK0hWNi9QRGJ3b0VwTGREZ0xTQVFrRnNqYlYrTTkxVjF3RUVnRFFORTkxMHYvNEdwMXN0TzkxMGYvTnRwNXZjL0Z1ZkdFNDNHTEczd3VtMmttUmFCa0VPMU1wdER6dE9yL1JrMS9GSmtJSlkwOVhvZ01nYk92bVNIU0JPOTI3M1FoRDF2R0xaK3U3UDVmWTVXemF4U0NuY1ZuZzl1ejN0MEE1cHR6TnRVbXlYOXRQT21jYk9ZUjVpSnVTNVkxaE9TeUZ0aW1sN3dueVNkbTFzcENTQTdNNGRjbjNQVGJtK2hibjJqMzd6eGV3d01mem9meTZKdnhpTEphNHFWTWR2QWRYUlh2NERpSGRWUFZieWMxZkZoUjBFb2srWk5ldnNMWGpyVDB0ckk1bnB0dHRYcjNXYUt6NEhXaU5uVGNVaGR5RjloOVJSc0MrdkZZaWFFd0dnV1Y0bDBOQnBkVFM1eXdUR2NuczlYbG55WG41MmtxNHQzaHZMcGIxdjliNDF0Z3BoNWx0OS9zUnlLVFR3dlhHRzVjZkwzY203Ujd4aWpKWEdiS1V4VmhvREFYaWZVQnpqcmFLNllteG5LUTFmbG9wKzFvL0ZyWFc5dXUwVVR3M1hDdGFoQkVLRlQ0MEp2OExvUzI5TjJoY0k0WVdKZGVWZDRhOHp6cXNOYjdjVG4vN2VxT056MzlwZzZuVWZZc1VYcWNCNjNCTnZrM2ovZ0hySUtId2pReGQ3dTFmb0xBTWpsUVppQ0hhMy85NDluaWR1MWZmTFhodWd3TjFuNElWT1FqTnF3eWdiakt0ZkNDVHQ3ajBUM2gzaXdsU3RSdFJRQnBNdTlqSjZIVVhPdHBSVGhlQS9HY01zMGdxMEwrYzl1a0JMOFRWOTllbXhIR2NpT01SWDE3NFpYME9tcnVTU0dOK3NkN3U1TWM1dkZwTTNsaHQzOE8raElWeVRib1Y0ZXc3SWxacmhpa0hLYlJna1RmSDIzQjRKVDNtNXU1VFpRZndHZFNIZ2JnR09QemcyblRUa1psNHBmTytZU2I2U3V5MWNiemVvQTJHdVpPRy9Ic3ROUjliaERaUFVONmtiM0lCR3FQQkQ2TlpOOVJkK2VBeElOdUZxVDd5U213cnpGRDR6QnY0NDd0N0ZYN0dyL3hWRllIS1ZqQkVNVkppK1VmakhZMUtoeEYvQndETkhyRkRjRnYvV1hPNTNYenVja1BXVCsxZi9NWGZOdTFqcnJ0ZTZwbHZyRDdxdFd0VWNlK1laYzZKUnI3WDY1bFMzMis0ZU5ndUR2bW0xKzZiZHFwbjJvamsyKzQ5bUQ5OTMrUDdEeDU3emdrcTlhaDRyUC91czE2aDNlc3YxL3JQZUU0T1p1VzZ0dlBxc3Q5enZkMHFkYm50enkydTFiZUNKOHZxV3QxRHExVnE5ZXIrK1h1OXZlZlVxdmlXQjFtSzl4Y0JTbzcxUWJwVFdCdVVHbzczQndreW4xakROZHIvZWJwbGFyMTl2bGlYb2NweG9EMXI5N3BaM2RyMk4zK3BtbjQ5S3VWOWJZZ0RkMi9JV2F3dmRRUm1CbFhKTG5pZmF6U1krek9DWldxdldyVmRNamYwMTlaWXA0eXViL1ZxM1ZXNllSbjJoeTB3WHQ1cWQ1WFlMemFuVlZvK1dFVmdaTkxadUdyNFBZdmhzbWd3ZjNuU1FyVnJyZEd0c1VmV3dXVVJxcGQzc29BOExkYllmSTl2UWVrdTlQc2F1MlN2VlcxV01UaFg5dzV0eXRXcGF0Vm9WMVMvMEZudW1QT2kzT1FJVmVkdXRWUWVWbXVrdjEwd0RIMmhWdHN6Q2xsbHNEREFmclNYVHh1eDF5cFhWV3I5bjZ1aHl0WTVNRFptRWZwZER4Qy8zYmQ4cjdWYWxWbTV3WUV6NCtseDlhYmwvcGx2RGtIYTNPdjMyYW8wVHl0OXFUVkl3RlNWR3k0TnFmYUZSS3kzV04ydlYwbWdHd3lqR3ZGYmQ4aHJ0RGJQWXJhME4yRmp2VkxQV1haSlF0MUlpQUpUYWxjcWdVMlpLSFgvVmRtT0JiV3pVS24xelVpS1Y1UnArVWFhTk1Ta2hlSjdkT29QbWJwUzN2RTZsV1Zwb0RMb0lMdkhuWkwxNVJwN2w3cW9FcEVNWE9WaGgrakRXeEYrLzBpbTFVSGRENHBzbERhSFpOb1FaeElpekd4b3ZkL3FibUNWK3VOUGI5SmJYTnIxcVo5UHIxWnVkUnEzWjNQUTJNWmQ4em03ZTFXZ2dhNk5lN3BVNjlVMXZvVnRyVld0ZENWZmJHNjBtbnIxT3JiYnBWZnA5QVFNRTYwdXRkcmRtd2tpOTZyNVdSZ2lMWWFsMlpIT21VOW1VbWF5MDI2djFXcy8wMjJhaFpucWNTb0owcDlNQXdHQjZ6T0lBc0Zvek1nRzlmdSt3R2ZScWdLK05SaDBMSEIycU4rdUFVMEJ4ZithRTFHVWV2WFJwM2l6V2E0MnFXUzgzQnFoMUN5c0hMYTcwTVR6ZUduK2FDdzArQU9YdFZndFRwVU5WWXRwZHN3K3dWeC9jOVA2enpidG1qOG93NEJIOTgyWStZSXlaZldaMjAxcy9laDkrWjJhZitjRHNNMGlabWQzOHdPeW1RVktudmVIMVd2aHB0dmw3a1Q4RVVWT3Q5N0RpQmNyYUhTS0h4bUhUdyt6b1JIOW5yY0V3QUxqV3NtR0Y2SFlEbU9kQ3Uyb1RLKzF1bCszR3NMZXhmQmVaMWtPMXBkNHlRcTFlcjdiaFBRb2N1SFVTZ2JWcXQ3d2hrTlljTkd5b3pFQjFjOTNyTERXM0J1dmU4bUJ4a1UvTUQrQVlnVEovV3ZqcnIzdHJ2WFZ2c1ZIdUxlUEp1ZGtxZFpiTHZScG1ISytiNjE0UGZ4c1YvT2hFbzFPbE1tS3JEUlpiOTFhUWEybmRPNGEvWHFPMjdsWDQwMXl2cm50TCtIdTJ1UkF0dUZIR3UyUDRhNjhmYm5hT0hXNGVLeCsrZjZtRHY2T0hteXRIRDNkNkhhUXRISzczbXZ4YjUwLzU4Q0pLek41M0ZOL3JiZ3k4K1ZwMzRBRjRCMTZ6YzMrNU92RFdxNTN5QUNCZTNUUVlyUjRILzY2QkIrQnFOQmlvcmkvME4vc1kxRllmcU5RTG5qcmQ3Z0publFqako3QytLc1BvMlNkZCtHTVh6ZzJUNXk2ZWRwR0Z1ajZCSUJzU3dDZEtRR1UxaWFCdkpRbTA4R01lZk5EY2plejNNT0wxWmg2cWR0dWRFakJoWjlESDR0T0ZTK1RSbFdVQzBpUW9kQUI4aitVRjJMZFp6N1lBN3FCdzFYSy9ETFE5YUZYTnhuS3R4UUtWV3E5SDlGcHZNU09XYktXK3VHVUFLYVlKMm1DYTlVcTMzZU5hcUFKZlk3V1ZVZmZXczZoYXY3ZWdDRnRMNDJ1bHluSVp5NlpSd3BwQjFMT0xjM3R5dmJVOVpScTlrMVNYUUJTZ3pUYzJxNG04a1E5dWYvR3hWbS9RNlFEVTBieVRseTRhNHZIMjlreXRObjlQTE5jeGZHemdSZ2tycmNaZ0E4dXYxZ3FqRzdXRjlUNkdlYkEwNkFFQWxnZXRWU0RwVGh1UllMWGNMTmZQUE1xd0xLMHlWbTBZYml3TW1pNmwzYTB2MVRGa0xuNnVWcTRhRFI5cE1OekJDZ1ZFMWJwSGV1MUdtMWtVUzVaQUNmcHNFZUIvSFRRRW53NVRNTzc5ZHFYZEFIVUFRWlNrUllISzBnWllsOXBvbm1FU0FhVVNpWU1HbHlSd0UrczBPMnZtMExZTE9ua2VFQWZHRklFcUk0Tld0eXpQSnJtbzhnTGFQUkRrdGJoWUF4VUFRSUUxWUk1T3UxcmhjOTQrZTEyTWNYdXAxRnREb05hcDk5Q2VFb2ZNMHdHWjBUQ0hUNFBncGhvMUYyd0tvSmNXdStVbVNvSGZRV0ozVUZObTZpZ0xobmhpRFMydDl5cmxicFc0Y05BUnlPd1FPRzEwZWF2VHhseTBsMHdQckJkcFNCdngraUs0UTYrM1d1OGdJeGl4RVhqV2xBamNhZ0pJVG5WYlVxOHk4eERJVWFYRTFmWnhJWGJmZGU5aXZkdnJtNDg4YVBoV1lNblY2RXJOUE5Tc1Z4Y0dpL2RpQ1VnU0Z6OVM3UmVHMlFBRnk3WHV2UzBBUzIwa016Z3p0SmpWMjh5Vi9pWmowcmdlYzR5K0hvbnhkYjBWZVZ1T2hIZHRIS29JazhqMmtPQjB3UWk3Y2lEVkxzd0ZyaTI4MTc2OGVZRVBYNHl1YjAxM1dPem0zQnlqYmNtV1R5QndnS2RZYk4rVVJPRHBiM1ZxK280QUMwU0xaY1BmaTJCaFRhMWNXVGJLeDVvb0cwdk1SNXhYYVFBeFlsSTdiUllCTDdzOHc0QUFxQ0VVZ2ZmdWdNNjJIS3BHT2R2ZjcvellVd2FjRWhxcjY3Wm5OakNwcGh3dUluYTlDOTdZOU1wZ3ZZaWYrK2lkT2ZiaG94K2VCUXF1SGdHUDJ5WVlhUG9EWnFHT1NvQkxoQ0hYajFaVU1QQXVMWk5INnJVSDVQVXNQaVlIdm9YdlZVUkFraXlVY3REZGNuL1FNMXhwYks1aUJJYkNyRS9hR1pZaEVINnFXZXN2dDBGcXVvWlR3V1QwR3d3SXZoRjl2NGorREt1WjcyMHRTQ0JvNnZOc282RUJ6R1czQkU3UUJtYzAyT3pVbGloSWFiOHdKQXlkcld6Tm5LLzF5MmRiWE5KTlhiQXlZc0FUelNIeGlTUmhBWS9FVkRpS3BsVnJpK1ZCQXhTQ1A1VWFmaGI2UjJlUHpwYnVPNHBCRGlPempNeGR1cGN4TTJQdU8ycTJKY3hLUXFYZDJlcVNTL01hdGNYK2pBWXRnMncwMW05M09EaVljNDMzQmhCaFNLS3JkZkp4a1Z3THdQWTJ1c0Vwc1BtSFFUSjNacU1tNFNVQzh5SitoQjJERExXb2E2VzNRVXdmd3BXOE52b2EzMkFydllWMkg0S1pCQysxT3pNU21KTTBEYnYyUzJUWWZJbHViMzJZUnhvdk1XbTdaZzVENStTNzlkYXEwT3hTdDRyb1NTeFE0TWUxOXVJaUdnNUJ6NFYwYmRpSVJlM2tkaldCSkFaY0pQQ3hUWUJrNG9JUXJnbk5JaG9JcUZvUUVTRmpDelNPU0JTMFZsZGN2V2RzdVFpdUlpWENNbWwyb3U5RWFBVTVrZSs2RjVRQjY1QzhXYkZMTzFGZUFMM0JyTlEzd2ZDSnlQWlV2YzNnSE9RUkc2eXVWMHV0OG5wSnhWMEtqeVVzb2pMcGlVdXJ0VlFFQ3FYalJXbkQyU05QR3N1cW12SWlnRnV4bUMxa2wzTUZVMFFVYy9iRWR4cFhyOHV5TnFqamQ1RXlkYjNDWnVMbmlUWWw5V1cza05HTnd5SzZWOEd4VnBnWkdLRmtJenJyWHBtTVpIOG9SSG4xQm1Rc3BhMTFodGJMNVU1ZGc4TloxeGdhWDBZZ1dLRGdYbkYwbmErRUVOVVZaVktiSW94eXljWUZuN3BJeUhiWnVBNlg1WG81NTJpbW9FRHdFVXVZUDFjbmdsRzg3SjE1Y3Q0NDFzTll6RTdXdzdRR3pZVmE5ekFsMGxhN05VTytmRWJmUjZwUzNoeXNNcWNEN1JWK0pwckJncFJpbitnTEpYODdwVnR0enVncmJRMkJRSUU0NU0wWDY4Tk14MVlocC9XOW8vcDRlcm1HWDlGd0xVaW92bVRtR0xEaW82RlVnTUlSY0xmQ1pDOHFrZlU4RWpsd3ZjMzFucmVFcGRTVFVLV01ueE5nR3djOXI5M0J6M3kzM3NTREVycmxwQTFtdDlVRHRac1IvUWVCbUFvbDh0Yzk3Nkx5OFpMU1hGK3UzaXZOcUpUUm9BZk5yRkpMeHc3M1BJaXUvVHJ4dDFNRlJBZUVoQkU4TDJuNWNuc0F5WCtCUzdYTWVjRm9LaW52Vmd5WUc3UUZMeGVwb3BDWlk1Tmt0dEd6V3F1RGgzQnhKWWFFdmxjSFhkWGZvV0VWaU04U3JvZWF2UnBGQ1ZUU0s1SDJoY1ZLNFd0WGZ2aCtpUm84cWdJWTZVQmlJZFlzV1lBbE5lOVpYb0pBaDdhMXFtQnk2eFRIU0hNeHh0UUVOc3g2dVVzQ3lRYXpIcTZURWdjQzJEUU1OdGYxQ1RpZzRrYkN5bHhMMEtKVlN4aTFCSGhxRFhFYUYyc2JSSndTZDNSbE9PeWprSzJaeUJjS0RxT2EwQ0l5ZkpNb0xJeFJTeVdnRzZhY0wyOENkSnBBTzB1cXprTjNCUzd3aWFVMjUralNpWG1uR1JRSnJNcU9Mclg0c1BoZWxnM0VyZldhYlJpWkU2ZE1CQmF3SldUbUVUd0ZVS2h3cU5mYmRXRGkyaEptYVIyemlma3BEM285VWFzMWU5RjFVRWZzL01rUHpvQWg3SGtielRKWXcxNkRZV0wxSmNoTFBXREdjaE5TdENIUGFkNDM3TWJOMm1DUW9Ka09pMWhkWVorVHVRVDQ2aHJsL1JYK2wwSG1qZVI3LzkxQXM1aUw0S2tURGNUTis5OS9UM2xkbUgrd3Mrc3k1dVRYUmY2emFSVm1CRkZ2OTdjZzZpRjRzb3N4ZnArR1dSc21xMnNBYTRhWW5PQm1ITjlWb1ZLdTNGTk5heVJ6bjRTb1I0YTBiOVpCeUFqR1hGeXM0TERvRHNoa2N6b3F5elh3QWdCZXM4d3BvVTUrb1FiRTNPTVAxZzlMYllCaVJMNWlaOGZHck95cHdsdDFOQStsc1E2bUczRHZST3VlcDZzYlU5UHU0c1BLb0hDUnRNSHNMZ3pRYW56MXZLZzYyb3Y5YjBOYXQ3Mkt0ampseWlnSjFoV2pVRjhaOU1BV0thTnIwdzhESGJTTWs0UlFmYjBobWt2TFdMcHNqaHFQVUdIM2pzeDQyR2swcTlOUkhZMmljZ0tKc05NOVpPb3ZBNGVEd2VuSXNpeHRZTTRnbVFCcmxIdWxFSG5ya20xaWZRdk00YW1MYVZ1R3NEQkhQdkt1MnBaSm9vUzFWSXUrR0M1NFFSMDlsY1NHNUtmVFV5bHpvZE56QWlhQ2xDMzVlSUEvS01pVVNodWdWTzIzQVUyZURyc0JITjMzb0xudnlOSEQ1dWlEOXgwNWR0amNqOGNESXN3MEJod0ZiWFdIYWp1cWJxZ3pGblpEWHAyVE5PbHZIUlNHbUhqa3ZRNmNNRStkbWlKaW5WT3JBS0xtYlVUL2RZL0FYSnRZUXhpdFNESGxmZ1RQcWNDb2lqUXJiV0xxMStzMkp6a3FhcTB0dlNFMnI5aFhpdGtITGJDSzlRb1pSKzdkdEhyeWJoMUVFaWdSZzZ3NDB1NnZNQ3pZY1RnUjdnMDVOQk15WURZWmszTkVGak0zYVlTRGRObVhlczFTMDZFMEJQcU5ucmNDb1FzUHhWRENGMWtFcmNIek4zM2J2dUFnRGhOSHRIQTk3NjdxTU54cnQrb1ZWdG81VnNianREQlFzaENhbEdGRTd3K2MwMWRLN2NpOGNoRGtLY3A4Q0ZiaDNoNFl2a3BsSU9TVDNlTUtXK1JXQU5GSmY2UHRNTzA2aGdQb1FrRVZVN3hRVjZZVjd6RG16VEltZklGcllJVFVZanBuUXNHVHMxdXJEanJFek16WFdVRlh0bHBZZ25XU25Gb0RiSW0zM3U0dTFFY3hEdGZRa0hFbTRwS2RuNjZnSVBETXZSSVJ1K01hM2hHbFY2UUxTbFZ2ZzYxRGFGRWZvTVlsRFMxdllGVElHV3U2YUdSc21JeHZHTktOTTIyYUlCaDVvNHh6cVlxaFZHTEdwUXBxcUh5TGNKdVdxMWRoeHlaZHVFU1N2RVUrU3lrZHgxbmVQR2s1YzBQV1RjQ2ppc29odC9hOHN5R1ZydTd3Rm1PQkVQV2FmR0FRNm54ZVhHNXY5QWV0V2svVUFwb1YyRnVnQjdRQmFBd0EzZ2JXc3BvUzdodVNlR3dyZ2NGZGZkdjhWcWNvVk5HaXU5cG1wZGJwYzA5UUU5QXVzTFdsNVkyU2pXUGNSQjlWcTdvVXlOdWxCUmZCUk1zU0VnWmxuYkppcmI5QktuajI1SVVabStlajgxWjRERi9PendqeFBCdkpzVmdtVU8rYXcrMkJLdlZ0QTZNTnYzUmsvc2hjbUE5ZnVSbWx1TmRoR2NMazNOdTJiKzV0MnhmbWNFTTdJTXNERG1aYjhuREVSNUpHVjY0YjB2SW1acTNaQnVjbks1ejRYNUV0VVQwM1hXYUk0SGVxajkzQ2hLa1cyMFNHWkFmNVNnUUFLeTA0T3FMVVczcG1DeitwYkhCdG5ac3RiWktvdXFnUXJTSzZWdDNlakp0ZXlIY2FiU3Bad0Vkb0oreTJqWFJOT0N6aEU3ZVZPWHZ5eEtVajFacm96T3JQV3FiaFZnVkNtV2UzWFAzdW9DVmIveTdoM055RkM3dFBsVnNjWnlNelkrV0puV2lIZS9OMDhOU3AwMDllT0I5Y092V002VVhrd0F0blR6OGpBaTFXZmEzU0piekpaUEJkb0R2MkpnaGNsdFBjdStmQ0hFSUIxbk5WZEY0MzU2YUtTRFQxNWlIS2wrOTdueG1tVUdrUEZxYTFvUEVTSnJFTEZ0Z2J4cmE0SzdScnZsTWlJSU91a3hndnRRU0hod3lmeTFScE45cGRTRDZRQVlaeEU0M0xacmozWktQS1IxRGgwTTVjSUQrbUlGb09XUTVWQUpHNW82VGhKblAreVl1WDhObGVyN3lrK0FCOGlBQ2k4SlNpNG0wMGxGUXFIMi81Y012K0F5djBxVTdhSUhjdjJtOXdKV3I1VU92ZHRCY0UzbGVzT3FLYlF0dVo5aDN6eUtZR0JhQWUwS0hJMzZPRmRxZ3YvT2lqR05FbVFWQVZDK1Q4YjEwQUMyVDN2S1NUUFEvd0F3SmVCZFlHSlE0SERZTzEyRmFWL3JJb2hJUTRENW14NW1CVDJFcVNVeHNXSXdLemphSDBuUFVNSld3MEJDblZhaTlVS0E3WGhyS3FEaXFjNG9SOEZEVmtRQW9RSGlzZ2tWdGRQaXBWU0p5ZFpRYUhFbXFOL3pObHdhVWlaYk5NdWxvbWU5bmx0bThOSDZ4U00zTGl3Z25sclpVYW92bkNFbGtjSkVERndWNUMxdk56NE9udVBkYnp6RjMzSHUxOW1EL2VESC9seDd0cjl2am1YWGowOUo5dDQ0eU4zZFg3RG5OWDcwR0VEcHRXaGM4aitLdFg3MTgveXNXd2Z1OWRaUFBhbTFzemtwbS9oKzhpMzdqWkJhbnRrczN4SGgwMDI0T3V0MFpUR2EvZDYzcDEvdGxOMUM3eTFEdjRxZUFIN0htNzY1M0EwQTlJallRWHgwT0pDQUwxMHByU0tlcWFiVWlZR3h1T2JPM1lsT3FnMlNuMWFtVE1KYk9vNklaQ0dsOWJlNU5ocGt2Q2FTbTNJNm84M1gzVjFCMmxhVzREZ1k5MTNLTFZZNUdiaEdBR2xvVm1YdSt5ZE92YmJpcThDQ3JUOWZyazJycmUwUThlRjJBVG1aSnlJeldwWHFmWHdrY2FLeHhLakJxQWFhbnJ6ZkpubmNxcVdwZGEyZlY2YlFNaDNWVDJUZ0RhZXhTR3ZZdjFCaDlXcUZWTnVSREcrcUxGS0tCQU5sMTVjL0RvcmRWV2U2UEZwVVIxaCtQS21OMHR0dUdXdnhidDFteVUybDN1YTJGcGJsRDdVQVU4NGZ0UHRiR3lEYmV4c0tocG1ZQTFDR3lBZnFuZUFQSUVXUGVTY0dSZVpGOW1wcjA0VTZsRlVtVkRaNWc0M0FlSkpFU0NzdjloNHlmMEliQkYybDdTZFNVckxrTHJ2WE5jTERRVkVBM3lScmZPeENkQ3RDRE01ckNEbHV3cUtxZFVPY1QrM0VsVDZ3VFpIMlRzaEF0QUVtdHNOU1c0V3E3em9UeFFsN3cyY0NZQ2dSb3NoQW9Wb2ZhTmNyMHBtWlZ5WTRLZnZoQ0dyZXJxWXZzWmMzUGkwNUcwUzkxeW5jOFJReE5NbmFwc1ZYWjBtcnFoQXJjZUVSVnE1VzZqUHF5ZGEzbFVYYmFySHMyOU9HZHRQbzJTbng0QVFYRDJTS2JGR2QxWXExVnZtYTBPbVFMZ1hwMnB2YlA4VGZCY3dCRHZPRCtwenNYbCtnS1poMXZsZXlkNVJJTjR5NHhQeW05bnNBQjViRm5XUms4M0lTQWdlYUcwN1JKYWJXVzB2ZmQzVnZzbEd4WTdKdUdxTGw4Mm5jck1Relo5WkFmRFRuUm96R1JudWlPUWFKWENrTVNFMVMrQklBdkF0RzVPRkZ4cnc2Y0Y3MnJZSWo5QU5HUlovWWozWkdmUU15ZHRSRFRtNUFrYnRkWlNmOWtvcmp4aUhrVmptK1dXeGowd3dEUFJEQjVLOVpmQnpBblh4WVJ6QUVrYVFucGNnQTJyS25TR3dEWVdxZ1kveHYzdGdQdmJadnNydXdSZCtpNUNDRllDa1FMVlhNRGtIUWpMcWlZRXp0K21VdlNzYlJnK0FjSzFJRldXZXhnM3JkVnEvbTJraFdZME5ROHdvb1F3YUJwbzlDcm96d0xuRDZtOWFxblpXMWdzQWZ1M2JMd1JpWlBONk4xM0hPeE5OT0hvc1cwSjl4L2RsbkRmOFlYUmhBZGNUTFNKR25ZS1JmdW1ISWJFa3V4ZUc5R3RreEFsZUVNazRORk9GSTl6K3VodjFGdnJhMTYzdlNhR3E5WGxOYSsvdElieXBHbHIzaUs0YWUrQjNqcjQrczJPM2NkQmdOTG1VTWtXY25taHhkeWlNczNFWlppdkpWQWdNK2lJZWhlRDFTdjFPbDU1dmR1eFRWR2lneGgvTU1ZZGI2M2piYlh0NTBCRUxQR2tRdGk3dU5YcUwzY1FlSXcvVkI1MTJ5WGRUR21CaEhpa0kxNWxDVDl6dFFYOFhtSUl3REtQNTlrVytMcUJWU0V4NFZLMzNwbDVGSUZIN2RQdTZtMDJPNkZkN2lZR3FOcmVJRS9qclpHTXFFRFhYbFNpSWdzeURKQW9hVXgyZml0TjdRU2YzR0ZuZExEQWgraWxKZVMrMCt6TkxHamwyN1dMbGd5SVhyUE16Vnp1Ym02VTYvMm8xS3FXVnFHT1dzVTB3b29nb0hydDR6UDNmZGU5dzEzTmowU3lOaHZzV1EyL0VXTlZ4SmFlclV0N01VaGV0VktxTlBDOEtCcTlFd3l5WTk1OHVWUGVLais5WEhlRk1Ua1JZQ3NoZG5LdzBPdlgwQ0tNaCt2dVJtMUJwcm9jR2VkT2ZiTVppWE1paUpwbXRxVnZncDFsSEJqYk83RXNNZ0FRMVlXUjJCbDhIbjJUMUszQityRmp4K1M1NGdKbENaUzUwWDQvYWpwNi9IN05kL1NveldjRFpRMGN1MDlmMzNlZmZXMER4NDdOdW5wbmJRVXV3UWJLTG5Ec1BqenRWa2hwcWViSUJMZFF1VUV2T3h2a3N1L3FlT3R0YTNsT25TbmdGM1FDS1JYYVA0dmVydTFkcUVFODhVNlJtT0c1Z2RIQTQweTUzdW90dEJGcWxsZHJwV2RyQ0owRUV3bE0xbW1UY3hFOEh6dzFYKzcyWkx0R0REMTRMZ0cvYlhCZURZcSs3YmFZWjN1bkJ0MzJ6S1ZhWlJuaFI5V2lzR1pzL0ZTenJmdG1GOEVxMisyZ2ZudHhjWGdvd01nR2dhTjFhaFZoMDZyclF2T0FCc0RpdFRUY2F3TEVOYmplckdwZ29ibGUwbENudkdoRHRJWmFMdDFmdFZGclE5OWR3aWhod3R0WTM5VTZIdHptc1RzRkpZb2xhdDAyVkJSQXFodm9ybEs0TFNHUllJQ0YxT3JiM1l1WnMwd0Q1SFpyYmJXWUlxKy9EaXJWOXJybERRMVUxL1U1Nk9zVDNBSWxlQVlybUVBYjdJTlBBeXZicTYzWlV0SjNEVGViK3FRNWlLMkRvMkZmb3NNYXdyallmQmdYRFhGY05MUmNkWUZXODlpdzVORmg4RDRObmdULzJyWkdLTTAyZ2czK05KdjQyYW9zNGZkQ3U3YzExd1hVZUJjaGw0ZkJhclZSMDdDVlRJaStXMWh3a01qYmVIYnJUVDdQbDd0dFBQUjhScmtCUU5MREdSb2NpUGExSjRBUU5mckhzZ0IwMStXWUNUbUxoVktsckpFdTJLWnVhNmtFZmdzSVMySUw5NEo3cjh2Ym1qMmZJOW9sU1ZGZVRnN1VTRHdpdUlyS2djTENvS1h2c0pSMjJJTytLZHR3WCtUbWQ4cU5seXMwdXo1eDZlYjN0S1dYazAvblQ5MzgwcDJLMnVuZG8vY0NJeGxuQUUwK0UvS08xVkllTWVmblQ1MlpPV2FDRTJiSUIwSWtwYkl0MUdXMnFYRUJ6ZHkrdlNFRy9kMTJ3MjZFMmVOTGk1RU5RdW9KWEpBVE5YUHo2UXdUVmE0NnBwcDZWNk1IWmtoZnRmdzJwYktvNFoyc0hqRUM0QURVV2oxYkg2ZHJweGVFbi91T0hJdWVKUnQ1NzB6MHJYV0phSmxLdzVnWUg0ZlJzdzJ3REgwYnNWWmxWSytZRXp5YmhHVzhMallHQzFScXY4OEs0VE1rNFhVNUtsSHZhbEVNaGdSNFBxZmIzclJnOU02TkhuWUd3eWhrM2Z6U3RsWjVKeFVKTyszR3NNOTFGeFp6UVdmSzR2WmJ2YWlGTGNWdW0zd0JvTk1WMkRubmttUjNmNkVNWkNXR2NFUFU2SjJtUEhSNjBIT2ZKRmxpT09CSkdHa1N6d2R1R2NXZTF0Z1NHRThQbW5nQ21pVVhrM09HTG9LcW1zQ1d0VEFCZkd4bGxieEttS0k4bWlvNWFMeUxqM2VvbFhYbldEeFpMeVZ3TE9GOGllbW0ybEZaU0JSVjNsYXJEUG5iYmNkdzlXanVjelhNM29ubCt1SWk0VkdBdWxWRFVNUkNOUzZyQTQ3RkVQL3cxdUd0V3Urd1RvcDlWQThUSE1sUjNidGFhNnpYVVNQR0RmaXhYYWxnT05FcGpJQ2N1TUpqdGJhRkJwY1lkR1RZcTFkQkh6eHdPbXg1RTRUZG95YmtDQWdRZ3IybGxyZWdwZzQ4N2lLRzkzcUd3NTVZWUp1eDdJVERiMUVzMEkxakFpRUVVdlRGcy90Um5oNmRrcU5WM21sdU1QWTE3STRNTWxqZWFHbEl6OTh4ZEY1MkJ5K1NyQzROM3ozWkFKdnZ5amR0YUI1akhxbnpZcTA4VW9XTENwbHdrZFBjUXE1V1haa1RXMlhOSUFISWRoaWZYZ3UvNjRQR2Fsa1FsdkE0UE9acFFoN1FrNk9TTGU4Sk1XSXlRWk5IUkJGZkxPUG5FaXNTN3VIWVp0T2Jid3lha1RNc1hybGNLV0VOTldrYzRGaXhidFBiN0RTOUR2NGlUREppSXFPbzVURDFYVE0ycUhiRDNwRnFiZjNJZ0RwdUY3SGhaU3diOEVldHB0ZnFZd0l4NzAxSTd2aUJjRXpMcnRJVFQ1NDhkUzc0VHFKTXg3dTF5a3VOMnJkQnVtb3N0VVVBOTRoemg3SE9rbXRjR2FIT1lsT0ZnR2F0T2VSZlNueFBhVThEUzFodUFEaU5iSlp0b05kdWFBQjRldEVtVlRlUGFpaXNxc3dpQy9nUS9yQlVTdlVHSStXbUY4cmdJcTZJeFE0WGEyZ2xNbklpQVhKNXJUOWpYL1NvTWJSYkIyTHNKUnNOOWhpT2NhWDduRzZ4cUhJV002MnREUXFnaStiUnA0MXMrNHMxWWRVcFZqQm1RM1VwOExSc2ZobHIzU05tdDhCYXdLNFYrMEg5emtuNVBZLytucERRUmVxZ0hrTmc2U2hhZXY4c2ZxYytmdXlCNy9qZ2Q5dzFhRTU5L0g0YnVxczM5ZkZadnJwcjhCMzNSK1BiczFiZHE0WCtzUS9oMFVPbmF2ZUZvYVBIRUZxdmJ6YThTaFUvRjVhM01NZkFWcERBa0FSK0Fld0ZCcXpoZFp2cjdZYWVwTFRVM2NwS3ZmV2xEMncyRzE2L2o1OFdtQkd3ZCtCajNtY3V0QkhHY3J1NGpQVlBwRUVES0U5T1ZUWEwxSTMwKzB5WVV4RUZNb0VCVDRvRUt4MHplSktzaVhtVVFVZ2ZkYlNvSmo4RUR1Q3lUVFZGOXhxTHRVak1HY2xIa2lMVXc2YllMUXhib3ViMHlrWXQ3MTFpYUc4L21uenU5S2xiWlR3bnlXZmFFQVU0ZHRYU1drZmFvSmJqVFI0Wjl0b1YvSUdyd01NZWVtQ3dQb3dpaEZVRDRSR2RnTFMrWHRZUHVUUmoweTdVMXV0OG5wSU14QkpOSGwxdmpHZ2h2S2hWQzdkTWg1RkhhK1gxTGNOekhwZ0pUbzBObjZ5VnNUQTBmR201Vys2NXlHS1p2NG95Z1F6eDBRNSsxdmhqSlYzNUhxQzk1SmdYeDB0SXFnbFRseEZma2hCV3B3MHhEY3ZKeGxwVVh6WWdPYkFSSWhWQ1hLcVNvNm9qWldqTGhaZjRlWXBLUWU4OCtBVStuNmkxeFF4VElpZkMwQmxSRmxJbHN4QzJtQUZCYU5YK0tzMVBHeHp4M2lxM3RWeXdvdzlhc21nSXlMeXVJUzM2Ykx1NzZyVkE4UGprZnJMSGZmRDJBa05QVUgvYkFYSDBScXgxaER1UUV3UkNPVWVWOU52ZXpiZDcvWmw1RFRWNnEwYUM0bGZCSm5hT25HYmd6SXc4Nkd6aEF4SjZ0TjJmaDh5bkV5YWhrN1ZhUndJb05ITzYzVmdWNGlWTXBzUXdxMkNyRUtBNm1neTg5M2dYakZrWGk5cXpPNVhiTGNDdDJ3R25KTkk4QVRkWldzUUYybm9KOFFzYUVqd25vUUJzbGdRdWRZR1g5V1dibkdDM3BiR0kvb1hSRWYyYTFvK2VhdWc4b1ZiVHV1MGxXZklneTdaWXRXNkRaOHFRM1czNFlnY3NsQWFwZ2JCZlZIaXhPZFNuZzR2Tzk3WXF5eldlZ0xjSlo5cjlaUmMrRFpab2puWnJYcVZiRVV0YzFXVVJ6bGE5amZJNjFXeTYwTHlsTWsweWVpVm5pZTcxeXlnR2JxcUQ1N0ZWNytpcTE3MXZkaFhZR1hMd0FEL0hqNVhFU2kvQ0c2Q1ZrRWp3MDErcnE4UXRyRWVkU3BGb3Z2WnFYWmlieDVmTENGVkJHT3ZlTW5JdDFiMkZSU1RVOFVGd2cvZ21mOCsxWjA3WFJXRlY5NXE5WjVmbC9KMWF6SlVvcEpTcXRRNFM3RnBzejNBRTJMa2FUL3d2ZTQzeWtxanVRY1QxVEtHWVdoSkNyQTJQYXZtZFhhZHM2dkIwM2REQTAyWTRvYllXTStjMGV2ZmQxVjYvUkltRTYrZ2UzZmQ0Mkd4TC9iQzVlMlkwNlI3SnlqVzNVYTlLUGIxdVpZZDZSbE9sbnBHazdmVkVkRktVNERTUlc3ck9DS0xVS2JPYnlnSFE3S0p2Z29zWHpRV013cE5ka1U1MUY2V2xSNDNDL1kwNWlWWGErT2xCTXNFamNHWjMzRGNlMEZoamtjbFdPVWRFaDZ6MTFqSmdxS1VORTdGSzNLbklrY3FCbk43c1F5b2JMS0dSRlRlZGxrOEJyZXdKYStJMXkxMzh0dkZYeHg5bER5cnNFYnlvandZUTU3cnNKaDhSTENZVGRxOU5IL1RyalNQZ0JFdnVLQTFlZ0Qvd0ZrVVo1dFU2U3p4QXhyUEJvT2V0SmN0Qk1IUnhBOXhZcUpZZW1wU0ZwMERVMHRodVRESXY5MmI0NUhzK2JuWndRZ2xOOW1Wa3U3cmRzVmd1ck55VkdTWXNZWGk0UTJlZExUamJjTUIydHlYSjRZS3FZRUNaY3FyYzJ6SnFETTJvK3Z3WW5nRDByTXpRVUFQLzJpYmxWWklOdnV2UlBHWG5WM1ZsUm15czJpNjEybUoxTU9JaXB0cXVVYW1xTDA0T3JBbWVGYkE5eXp1NDh6K1JrMDhqSjZaNlEwTVhNNUpYeTJQc3JIZzlmQ25HZWVGYURkTkZDZlR4aDcvTHVPMCtIcnlsSVdGTnpxNVd0WUVqM3hnMXhGR3pvTU9oN1RCdE9ob05JTnBublRVdnl6bWtjTW9sWEhKSG5jS1ViWWNKU25idlRod00yYUMxS3ZTYVlJYVd3TDdnaHhwTWV0U2dZWFlVeFRZbG9TRy9DckFTM0txMEswdktWUzhzMmVQL1lHUGtLTFlZRTRnaHNIZlhrbXl5TlRZWGJaMjlqVVh3eW90ZXU3OFkrVW9Uc1g0UHFmaXI0NDlhK1FVOGg1NVN5djFTcmMyWDlSYVN5NDFGMjVpbCtpS3dSQVcvOXgzbjd6SCtMQzZ1MDdHSU4wOGVZcDRoWjBsUVVvd0ZNdEhvMVE2M0RyZmFoNjNrNTU3VnczeXZsZmNoY25scnROMmlHNWRTcFYxRGlKenpJcjErM0gvc2c4Yy85TUMzQjNNblRwNDZYVjZvVkpGY3J5NkdPNWZobHFXemZPK1hGNzMxenZGRjc2NFB6RDV3NzdGRlBMNGREMFR4dCtqWlBTak10elViS3FtdE9CTzZmU3hUQ2VtbXRweUIwSGluRjRtSWJVZEppOVFxNjNZSFJCTjZ0RHVNSm9pKzJnYXhFQzlmTnRQY1g1TUVWZVZwcGVvV2dVSFo0NjZYYlgzNGFTL2UzVzkyaERLVTEwdTlaZmVxNWh3cW1UQys3WEN3TmZjS1gwdGpobEgyU1l6MFhBSVhpeUFvUFF5Z1d3cDNuM2x5L2g3TmMzRzVYVnNxSXpBUERzNmM2YmJiNnpYUmdQUkZPV0VaTWczTDVrMkxPOVQyL0pVbmg1UWpwMDlNVDA3dmJjblpJaDVxQ0hOMmhweVZWMTRLZzZ2Z0syZksxTTU0b3FNUmZvTk1BZmpmRGZNMEF4ZjRZdzlpaUYrVTBGcVFoRkxQajFJb2tsZjBmbVMzai9CL21XY1hlMkpZQ2hZWnFBVElzdDdyRFdwQ29yeTVPZ2dsSHVWdW0wL1ZBcTF1MGFaZUdGNFhQbCt2dHZoT0l1ZkMwQW1nQ1J2QzJQRWNwaEJobEcxWGwyeHd2cjFSdFVGVkt3M3J1Tml2MVJvU3ZkRGVLbXVJdlk5a0Z0ZFI0WXRoTENETzAzU1FndmFTRk9pQzMwRmdZYWw3VEV6K3ZlN1NnZzFoRHIwek5LMTZtcDVHNkNtdHZOTFc4T2tHQ1kyR2cxYS9qb0hReUJKcmFBTUtPTytiWFhuV1cvS01uT21YK1BBRXYwUnZQa1liSm84Y29wVlU1MEVpbW5aaW1XNVNHQUp1a0NmaGtZZm1BRWNEY0JvOFBpOHhOVVNNYkk3VnZLZWZmbm8wSWRTU3JYOFFNZGs4ZkxRTmFnRitmYkRnZ3FCbUlFd01nbmZqSnZyNnduckpSZEUvRngyZUZhRVIzNkRlViszWGRyTlFjay9NdnQ3RFQwdCsyaDF1Ym5yaW9vTEduUXQ4bmdjUHNIV0JJY0dzZHRvdkRicHJBKzRYeWJRUFkxUllEbU5nQUlEVStyS3g1RDBodjdUeDRXSmN3QUNKZjVhU2hJSm5zZWk5OCszMWV1Mkl4UmV5Wld1NG1jVlhVZUhlTEVLSVo2S0lvdVlTRHlVanBxb1BFY1VhREN6Vld2aTlpTVdOeDQ2Mnk0Wk9zTGl2MEsxWk85M1FtNU05R2krR3pMSlA1dlppYUxwQXd6a2U2MjFLWUk2dU5kUVpEWS96dDdsdEFkSE5XajhkdWRpWFZvWnZvdXE3OVZiMTNtWnZocmhCMzFYazNFZEpJdFlpMjBWR1RMMDEwUklGemJEamZvVytvNWlqb1NaSFBGSmhsN2JnTGhOUDA0c0pkU1dhcDBkQlV1UDIxR0NrZkIvQXB4VXYyQ2YxeGhxMFcxdWtEcFlrU0xJdzhLTTdJaWFhWDBUQjRURzdZZHVNYlpzbVJmWXh6cDg5ZjBvVEkvdU5kNStmdTBjVEhXTjFpWkZqcTcwS2hoc0NvVDQ3ZFptU21yY3lhSVZOQUZuUWRXVGpaYlBVcHJNU3BBWnJBOXFMUTNTeUs0RUo1elZCOVZnaEhUelZXbUtxR0wyVzlGUVpUMmUzYWtNRjJEcW9STE0ycWdDemFVOUF0TnFxOVllYmdzbzduajVOZHU0d0NRdkVjSENpdFFaV0dZQy93WHA0N2x5V1YwbjhoQ0VBZWIxbUlZR3hhcmNwUUVSTXlsOXVOY2l1a1RRTlk2dEdaKzVJcVp4THA3Mm9LS1RyTGJETTVhb1lrZEt0WkhpQ1NRNVVSUTl4MkNNdVE4dWFNT2RHRi9CZnE1Yks2eHJuNFFjblZNMDhaQThnOTNsQXJvUUZYN0taeEp4YWd1V21PQkpDRSt6V250M0Y1ZG04VUZlT3RQK2Z1RGNCaitTb0RzZXI5L0phK0ZqZkY3YmJpK1dWYkIxelNhdVZ2ZmFPUnVldVJ0THFtRDFzTTU1VG10MjVkaTVKaXpFTE1lQUVBaVNjR3dpeEUyNmM0SVFqSEFrNEZ4QllEQ0dHWHdJNG1FQVNTSUJ3aElTQXcvN2ZWZDA5MHkydEhQSjlmMzNxZVYxVnI4NnVlbFgxNnIxWERkTFM1VGdrbTJzZDkrSUtaUTNFbzVtS1pkRWpVMkZQdGdEYXJzbS9JOFRTWGltV3hHTzRRdUs4MUFUTFM2Z3ZSY3FYR1ZRc0ZrVUJ6cHNiUlZ0NjRNZ3ptUXJ5YXBHQkE3WFRndkk2Vno3SVlHVVppVUJuTGtWOEl4MFZhQzF5QU5uTTg5c1kvb3lDR3loNFBxUG1ZY2tCR3lPMWxDNnd0Ymk0M2l1eFYzbXhhdnVnTlJHSEkyazdUdFJncTZvS1ZmeXRMdVlROEVpWXFWZktlVDJaMFhaQnI4MVJocDYvWnlXeExDU0tUVHkyaHJOTlMvR2R5dFF6NW5DbVhxdENWemNQWldEUHBFaDhTMUUvNlpFOVBnb0RFQndwVXQrazkvMTFORVNoR2trTUY3VlZoU1lFcE5WN1dialRSQnVaZExUSjVnbG9ZM2lDUFZpYU5jNk9aQ1V0YjdUblk0MTY5ckFrdCtMZ3dQVDJJRXhXeWdoRmZrcGVFNDUzRkk2eXZPMTNGSG15dmZrZEYwd0RlVjR1RFZnNUx1NE85RXVPS0MxSjI3RzY5VVlTbENxSjh2WHhKS3hteVltbDBpOEpmcE1DNnZlRTA0SEZzZ01jRGl5WUkwQWNuQmtrdmVoMFZwS0xWcUd5am9ESzRtS1MwMGh3dUk4REZ5dDkvWDFjV1g1Qm56N3RReTlvU3JJL3BDdHF2V1hwRGRBVDlBTG9DZTBEdFpMMkMybnNlc0JLd1hyTDBodTFhRWczVjhqUlNDRkh1NFFjVFdHbGlVS3B0bmdxcFpUbE4waktla3ZJSzJWSmJ5dXJKLzA2Z2wvait5MTBldE9GQ0RpL1ZNQlJJaXZBNFVEWk9odEozb3VOZ0U5bjV0T1orYXpNZkk3TWZNN01mSTdNZk03TWZJN01mSTdNYkNUdENCQ0FiNDJBbHZGemhkTHhqRG9BaEJJaGJ1Q1ViWHlWdWRzcUJidDlvR2NWR05Rd1o1VUk0TUt6Uk9zWDUxcEc0ZHhITDlPT01KUGY5VXFBTk9EVVVDWUh2N2tNN0lSVUhpVXVnZUJxbWg0WCtvdEVTYWl5Y05mUkdHTTJUN3RnY0N3WEdrSGlLS2hHeXM4dnVDc01Bd3czRXNYYUlxUkZCQW9OVE9BQ01vN0haRVJyTEtzOEFiTGJRZnNLTFY5a0NRT1RHSTI1MFRnOHJUamlQQXZlR0VlQVZWV2VJdUpLQWdta1pVTlJrU2xuSXRDMEpVWXhKS1V0eE5tbWs4UTlVMTFGaFRONG0yY2diRHhSQmlFdjNPZWtPWkIrb3dtb0FpL3A1M2lsaDhLWkRkUzhZYzA2aGFjTnpsV3BmRngrcHdNUHNqVWN6K1hwTll1LzAvbjBKRUxjTWVFa2d4d1ZwdEpKb2RKSm0wb25IVlE2YVZQcHBJTktKMjBxblhSUTZhUlE2YVJRNmFRbXpFbUxNQ2N6dHB4NkUyRk9hc0tjdEFoejBrR1lrMDdDbkhRUTVxU1RNQ2NkaERucEpNekpac0tjYkNiTXlXWnluR1J5bkdSeW5OVGtPS25KY1ZLVDQ2UW14MGxOanBNV09VNWE1RGlweVhGU2srT2tKc2RKVFk2VEZqbE9XdVJZdDE1SU4wM0kwU0FoUnh1RUhOVzJVZ29Ha2hZUlRscEVPR2tSNGFSTmhKTVdFVTRLRWRaWmEzeS9oVTV2RmhGMmZwV0FvMFJXZ01QQlJOaFJWSHhISXF3ejgrbk1mRlptUGtkbVBtZG1Qa2RtUG1kbVBrZG1Qa2RtTnBKMkJBZ2dFUVl3bTFsY1RHVFkwSGdjdms3TkgrejN3MWhiU2F1VjVUU2Yzc0pxa05wSlEvaEVLR2lzcW9rYWVGVFRzQ0FUd3FtRzZwWDg2aUhZTHFtYlV0MTN3a28xaFlyUitJNW5WN2xpcW9Ja1VDK3UyRHFjYzAwbFByWndwdlloQVNwdHRab2xveXdYTXNhcmVCNnBTRnBCRGFNR0xTU0c1MU5rdVZoRlc5eERGcDlmOXFaMjBHaXJ4NGdvUWRvK29nRGs4SmxtTysrMnh4eW5ibnZNaUcxZEo0N0xoRzdJeEgzZktCY1JKaVU4a1Eyai9HOGF0YzF4blF4TGZhQmx4MkMrSStWZnRSOHlRUTRFMjJMREYrS2YxRXJ3UFV1d3c4eW5SV0laMzlMQnROL2ZTUEQ3U2lNUm9EZFdGSUVkZDNXcGhNNlV3MUZvK0J3dWgwaXdFejlUekZobWZpeHYvRHBvTXp0TlpocnBSSkNvTTRyUExTRVhCZCsxUWQ4NnZQTXVZcnFTV3NyeDE1WlhGQWV3T0NPT09QQTZpbXFBYVZhdFJpbVY4TUx3eExSbGZoWHFXRnhaU3FzVDhCVGhTV1hoQjltcUFOQm9mUndnSzQxbjBtVE5GR2JFT2hvWkVlYUpaZ0tKTkZZcWswUEVDWDJOZ0lsSFc3WnRWR0VBNDJhRCtCWWxzZ3hoR2Zrd3lhSVBkMHZXT1NXMnNDVlpoZHBtZUZzQXZHWGpXcWxQYWNYQWVNYjIwOHAvVHI5MTdTcXpMSi9lQUFPMm5OeWl1Q1JybDdNMWI3SnVML3EvYUkwcW1iSEV1N1N0T3F3L3JTZnNjekxMNkE3TDVxR211emI1UU5hVWlLc3ZmVjhyRjFmWWZoZTFHSCsvSkttYjJqR2txUndSMWtYVzVzdzNnT3hSRmc5czYydVFZUTdMNkV0YUxZaHlNWXVHNDJVTkZXaFh4ZGRkQ0plMVBXMEg1Qk5vL0EvZllya3Ftd0tlS0pRVGFFb1NoWlJvVldSNTJGeGFCeWVyVWxxdW1tSkFBU1g4Uk1tMXdnT3h2SkZvTEZicEVkTXkrbTVybGlmcmkxMU9iWEd5dHJhRVhCdEVzOC90dEcwb3JSeVQxdGJPa1VyUkVSSFRkVzJ0eHU2U2xrRVh4NmtNdHJLb2MrSm82N0RWNFRvQkhRY1dGNzVZY2hpWGRBcXdFMWVLcHhBWWY2UUhUcHhXcXFRb3I5RG5zOStUdWVOQXE3QUdhQ0NmQ1pqdTMxZ2VoNTFwREpodWRrNFVuUzRtWG15S2RUYkQ4NVB0d2wxTW9vaHZTTmNROHU0RTMxTFZWRm90d2xOSUFxbXFKNEJlVitHbmdELzJPV29GWGNTaGhiNkVGcEpnRWtqajJRM1Vkd2g2RlRod2c0QWZlNmR0REhtblNBZG8xbDJ6YVljcStpQ0ZIbXozQmZpbnA5M1hEMzdORG9GVkM0dCsybFA0cTlwOXR5TE9TanY4SG1rdkFCakUxM1F2L0k1REt3NVZZRWRuWWlMNEQ2a01vb0VTSENLMVNncUJzRDBoYk1UaU5GcDNLc0Nvc1YrakNiWm9SM29CbEovWmJiWVg4QWNHN09KeVNoMHZORklxaXo5TEdmaEp3Rk5ZcnFaVUZjV0UxUW42eFlXS3FxWGhwNUtBbndUK1pCcVZsTTNSaHVWRU9kVWtxQXl1Nm1veHhjWnNWS3BRanFPMmlXb1U0RWQ0eEFkSUM5NWtkVWRrM09Yc3NDR1JEVFduV0RhMEZjdmVIb3FVSkdaQy9QeHVJR3M0NjNTRHowcWpBTGp3RkV2d2s0UG5SQnArVnZOUUVIaFMrVHdHMVZKTEFNTXdXNko1RDlxTnprSkN5R3RYa1V3ZXdVZ0tTNFh1cFFRUkRwSXRWSWRLRlJqeS9FNTZDMnhwVFF2ajBHdHRDVUU1Z2IrRkhLd05WUloyWms3Wk1SRWJVOW1jVmYxVVBRbU9CSHBVRm5YREpyTHdsc2VEMTVSQ2JUc1NOT0RqQTM0VlhhazR1enpNeHRtS25XdzNNR0ZLR3ZpVHdoL01CMVlaOE4ycUtmamMrRlBBbnl3ODFTVGtYNEdmWEQ2Sm5RSVdxbmdsQ1JZS2ZuTDRrdENmSTRWU1FOVmx6YzdzMWJ6Nm5oU0xCL0hKZlcraDFPaHBSYVV4QzNRTURkZG9kSll5WXBtNVRJc3ZqOWVxOWlUQm8xeGhFV0cxSmJzbVA0N3Q0VVZuZWhWWHVlUStBR2MyTEVEUWtnbnFpTFI0MVZLdFBtaElyc1ZMUkVZOUVPbENnSmJTMksrdW9PWUFYU3VlOFp1S3o4c1BJR3FaZEd1VDFxdnhTcXJITmFaUzZxWmJVMENxMm0vMTN6M1lleSs4cElqMElVd1VLdkhscEdvazFRb01UM1VNVFUwQ1REZVNDUEJjRmpWelZTMUpDcDlKd2k4bTFVbklseFcrcy9DU2dCMnU4dUVQeWRva1ZUTEpNZ1REbFVSU1Zjb25FN0FLVDlpV2RWQk1yQnEzZk9BRlQ1Y1UwQXdsT3JrMGYwU0p0aWVJcFdIYnRNQXJoOENUclhIRVlZcE5XTUlaVGJUSnBLQzVVaEVJTFdvd1pJcVdrVkp0Kzc3SnZLZzJSVVYzMnh5T3p0Z0JuaWRHaVZyTDRaRHoyTWg1bktUUWFET1ptVVh0VFg0UkVYbkw2QzlwTjNXUlhkT3VXcjdhVlFFWGRMK3VlcnJjeGRkeFVTQ0pBM1pSaEZienFwZ0pMU24wb3BkRW1HU3QydHNnemE4OEwvSDFrZUtNR0Qwd1o2MUQzM20wL1NaQ2hyYjRTMXJpU1FOWmlodG9EOUFLbEd4cHo2UVBjM0J4SVptUnY5UDZUNktxVFlaYlNRaHFpeVZLWFp3MXNQa1UzZUx1T1E2aTFvcUlZcE5WdHV1aFNCcFdPNnBWNkMrSlBQd202cFVFbjNmajNneUZKQk9vTm9vYVl3cm9TUWxEY1VFRUVQaytzQ3ZPd085eU5kNDRBV21laUM4QkdDdEJhcmxNc1pqUXluUzJMVUE2SE12WEN3bVVYTXZIT1Z3dE9kNTVaRFJnV2xaaE00S3JVbGo3cUhRQ3FEYUtrQitIdE9FWnJhZVdxam5Jb0F3L2hjWlNndmU0aVh4NUNSR2d5UjJYR0xFdko3eWFLQ1RBc2J5eUNEOTErajNCWUlsQmxmMFlMQkU0UWU4bCttM0FUeFYvc3NzbkVKeWczeVgreFIrdGgxOXp2Z09kZ084R1R3cWVkTmFtQ0NwVlQyc1h6SitRUmdvL1JTR1pJSFlhTVk4R0VpaDZsbEE5Wm5lY04ramRkL0lsTXZlcXU5dlQ5NnFieEJNSTc5MitlOVd1ZTlUZGlwWjBSOVg4NGNPSDhZY081ZVBUOCtNanMvRVFPQ2VtNXZ0RDhXajRNRjFXTm5CWXRiZkRZZy9BcllmTmR2bFhNN01UTWRRMlM5RTlhOVRMWUlrelF0ZDRESnArbjY4YldkTzVZajJqNWFOUjFoVk55bkYyUStIaCtPekl3WVVSOEppZm01NVhZOUY1dFRBM09hOUdEaytBYTJRZXJVdVJGQ3hmbDJLR3cxT2tLV3Z6d2kzOVlTOVU5SjRmRHMrcnFlbVorVGsxRDFtcmllall3dnpFNUJ5Uy9TUXNXTWZibyszZzJEL1lIaDNFbHlQZDdZWHU5dlI4KzdqNHpCMmFWWE96WE9LNWtka1l0TkRJN096MHJBckg0cFBUWS9IUjZkbklTRHd5UGRucU5UWHQ0Um5vNjJmZitWRjRqb3hBMnNQd01qUXI5MGdobHdDendnYVpZVW1jdERrR3IvTVIrb25pejR5S2pJZG5vSUdtMFZzZGlZekI3OExVZ2FucFExUG9NNlcvMzhTVW1oMlptUXdmR1F0UFRNWERrME1MMFRpK09uM25aOE9SQSt3N1B3TFBNUHhRWmFIQVF4UEQ2SndLZy84ay9vek1SakdEcUlJSDNpYWlhbUk0cWthR29nb2JVbEdqNFhVbW9kMCtNNnJtb2pQekk2YmY4UjRJNGZ1aFNUVTNpVGVkUVc3d003VXdPYW1HRmtaSG9Xbm5wNmZqYzlFd2VNeVBBdGJ3cEhVNXlsVEVmb2ZYK2FGSjZDWXpJN01UMFpHcCtUQTZvSFJUOERJL2UwQk5Id0FRT2VDdS9jeEkrSUM3OXVRN005RjB6U0pPQStaa2FUR1hNaWNtMU16NEJOUU9Tam1tcXpjMDFtb3NHV2Era2VsUmx5OFpjOEZOaDNpSWJBU2lUa3lOWWllQWp6MDNvbWJDODVIeFF5T1QwTFFqMkxRamFuSjBCTnAyd1F3Ry9NSHVFVFU4RWwwNERHMDBOVDBQSDJkaGFsaU5Ua3pPTjNtTVRFV21oNXQ4aGtkYWZlamoyazRZR2hQVFV3NlB1Zm5aa1hEVTRURXpPejJQZmRuaE5UUTMycHJpd2xSNFlYNThlbmJpNk1nd1ZHeG1ZVDRlbmhxT1R5L000eXQwMktreEswQzc1aU5xZERhQ3ZTQ0NuUTlja3hFVm5wa0ExeWc0SWdDSDRKbFpHRks1K1hvUit0QVE5dm9oeDRWV2NyM0lIU2FNMC9qd0JGR3dxU0VGUFdKSXpZN0JjOHNRWkJvTFQwSlhEcytIY1Z5RmtTaW9nek9CeVhCMENON2FxL3ZVWGVxT3NibnlFbW01NWdjbjJDeHhMSmRaUm1XLzRRd3VrNnAzcm9Vems0Tk4xN21ReGxtZXlSUE5lbXZ4cm1IQ0VHbE9aTTZhZzZHREhtTlRBeWpaMUJvVlpkdWpzUDcxU2pLVHZsT2RLSlgzMG0yQ2hiM0tVb0xkcTBybEJDd0I5K0lCWUI0QTJ1RXE0cldvZTlXdTI5bkEvQ0JhK1I2RU9XY1BxNW50VVl1N0EzdGdwN1RidHdjSEJ3S2FsN3BXQi9nOFprRE1NVGtPdlFad2ZUQUFpVUJZSWorZ0NuVTBkWmc2UHVBNHF4cHdIRlFONEh3MzREaXFHbENyQ2ZCTXhBTURBMm94VVNna0FnT3MrUm1DbDB3dUVlLzNRZm9oL0FuQ3o4TDhhRGZtdDl2S2FyZmF2VHZnRDZWRFNmK2Uvc1RBN2xTNkwrRHpoZnF5NllBdjBlZFA5KzhtY3hyZDFWcTZPd21POE96RWtEazNQOXc5QkE1YllyTWZaMThVUE12ME8rUXlWTEhoNzBlZGtDQUFtdC9qcXdFLzR2YVJXbkVKUUtIUVorcys5ZUZORUtLNjZodm8wL1FTWDZ1cFdpWWU3S1B6SEZqTWhCeWNDWmpuUTNTZUJnbUhWTDBBUDVSNkNPK3BMQlZEbUVrVC92RVFxUU9FU0Z0NU9SV2lNemd0d0orRVJWRWM0bVJTL2RBay9mRUFPSFNKUW5hSlFxaEJGVklkOVdLVldJZWQ1ZU8xN2p0SkJmQ092U1kwNmU3UVFMQS90TnZzTmdFTlBwRS9GTUxUTGlwcGdMS0VYN3lZcFp6eHc5dHlvcUVYQ0p5STZiY0wwUjNvRHFtSmtZaHB1L0RNSGZieFZBOTRzM1pQbFNBc3ZVNEVvU21DV0gxdWlXQlQ3WVAwb1lKMHFKMk81OUpCYVllZ2FFeXFEUDQ0bXlNSTVBZWZrU0JNZFVHVjJoTWsvVEhZUDhIT29JcXpOYnB3UFlLR1JiUnREeGFkczdZOVpKRkVaWkoxcE9UNjR0T0FTdUFQMUNaQTU5d0JxMDRRMHFpQ3M0WS9WZmpCQS8yQUl0dnFBVWQ5SWJRY3NGUTNBbHpoZ1BPQ1E5TDNEeUNmS0tBcWVjVEhIKytMVURraENHNmtJTWRTQ2NYeDBDSWtXZUN6blFGV0NRa1FUeVZBTzRLQVdvSGg1MXl5QjVyYU1LRG01K0dad0orWkFFNmkrRElTd0FrdUFEMGpGTUNlRVF4Z3o0QmZIc1h3Y2l5RFY0K1VBd0VaNEFHMWZ3VG1NM01tRUxDSFdrRFZWeHVySVlDcjhFS3dzVnBIQ0VNd0lBeWNibmpqL2hzSytyc0R6WGN3bTRIVzJ4ZHY4K3U3RisrRURvM2Z5YStXaS9oVGdKOXNIbjZPTCtKYmx2d1M4S3UvSGI1Vi9mVEYvTFpkVTc5cXBPREgvblIrN0txQVcwWjgycXI1SGQ4TkVvVzkxWEtwbEk1WGkyay9maEkvOTFCRVQvaXh2ZjBXdFl2N2tRSUhBVGhHcmg5YUdKOFJ2NXpvSW1rbUNOMVh4dzM2Y1Z6NitWZ1EyaEZhYmpVRWJ3Vy96NjkyOS9oVlB6eDk4SVRnQ2NJVGdFZmFNVERRYmI4SHV2M09FZXR2R3JGWTcyTjF0RUJnMzN0T0tyYld0WnhpWnQ3UEYrcGFzdFlrUmd5K2VJNmNJaHZaY3U4RWZoWS85aGtmZGhtZm1tSFRma2QyUlpLUmlqblFuY3pWK05aRHRaUU9EZUN2M3dlZ3ZwUUdHZ3h4WUZwQXkzWm1DTitEUG1oZitCR0NGRVMvQU1iWkhhQW8wQk45MG8zMEFoUXcvQkFya1NzQ1FPTmtkRzJ6cXVDUDduQStwUDZ3Q1dMbEhMN2NNSTd1eVVRajI5czMwQk9DaGdVbk1vWmczdkV4aXloT3IySlUzT3oycmFBYi8rQnorT0J6K09CeitPQnorT0J6K0dqaDFldUhGOTdzVzhTSEJSTk5oM1VBc3lNMk5OdlpZMGJ3eXA4RUM5QTZoWWZRNGp2MnZCNFRMZG5nRlpBb21FcG5GR3pzUmE2aHFhVGltUk9EcHE4SGFnajVycWxjdy9lZHdZcllwK0N6aWMwSitHN2dSaHZzcUptSzErdkV0VmtWSCtzQzFFcG9ld0k1THVRbkcxZElRV3Zhb3BZVG1lV0RTYlZzWHlycVJ5SmwrN1NiQVVaQzZXSjlueU16aWU5QWIybzNQSXJvN2FVMURjS2VubDZVT3hPK0NmUWdNZ2xoRjZpREx2Mm9WWHVyMEl3VFJkUGZiWWxaZFhtZzYxT21LdDJLbkUxVW1tVzFXSVZRem9uNW9wZU1MWllzOThzbEdoblM1OWFwMC9sc2p6a3Zxa09zZkV1SHNwaUtuTFAxV3JxbUhLc0hOakhMckhOcWx3Nk5VaFRxcVNWemlXMDVKOUo0NHBJeE0zU0hGVzVDb1QrZ2Rhc2VOYUp0SE1qeElHbDg2MlBySGhYRncyaTJtUnlPVFZDL3hhTjZ0b1VrRjZWWmQ2NzFvUEZTdVNLUno2VnNLeVJpT1o0c3IxcXRaOWxqeGlTcVBVMDNUZWpMSWJUVlh4WlJwNnM0TXJURzdVWFZxWXpjT28xeWhXYXU1ckJUWXZkYVR0ZlN5RzA2ZTBUYnF2OEhHWXhNenMzRGNDalJLVDBldWJHWU9mYWNSZXZha1BhMHR1emZvOExVSzFJWjY0NVg1bGtMMDA3YjNFZ2xpbndQRnV1VzR2MUxLSytBNXE2SzFxbG9BdTI2ZE4rSnY5b0kvQytYdnR3S3UxYlNFMnlyVzM4MnZwVUY2OTZqV2hYbXNSL21TOFhGSHRYU2E1dUgyNEsrakNFMkZJTTRNRGFzKzh4RWViTEh1aFRGTTRFb2NvR2hDdG02eUZiV2lGVlVMME1OSWtPell1WWN4blhOcE9zN29jdzF2SFVSMTNWMFkrNHlYcHVzV3ZRUzZCQVRhNEREMWJJU29iV2JURG9EN2ZrL09nUEhvVlRodmlLcXZyM2dMaFQ0emxIbTRQWUFFVk9zcnJxNGxEdDJQRjhvbHNvbllCbFRieXl2cko1a2RkYXg4WW45QnlhalU5TXpCMmZuNWhkaWh3NGZPV3Fydk43V0RWMmppdmE3SGNvYjVTWXIyalI4aVJSeENabW4zZGxERitzcUVxMGQ1TjY5RnpwNnZWdUw1M2NwczB2ZHBtN2xpeWRZb1VlcnlsaGZiUHhrWit1VkQwMTNrZkNsYldZSFhiTFhSWGF0aFZKMWtnUVBuUjhpU2NIREFZeUFkM2wwTEdWV09oV2FRV2RyVmsyTWRMTWpHdXVFZGtiekFHWkhGVkxzM05DOURXYUhyYkordXltM0hrQ01McWdWNUFFVTNjUURxR0tqYysyTGt0eHAySmVpZXFSekU5K2RiVjkzajdPZTZ6N3VSSU1zcE9ycnhSa3pYa3hxbjJwSGF6S2Nza25YbER0U2hzL3h2MGk1S1psT1hFRjJrSUg3VGx6QjZOZCsrelZDRkZhNzZNUUtEUWs2THh1MjdBYnFNYzE0emdsVjdNSFNjc0xHbXVOcjEwUjB5NDJFbmRUQ3duWGFXaWp6Y3JrYmp2RUo1eDF1N3V2ZUhCWWd6WVEyTTl4OE9SemU5S1d4NlFZa044bFNNM3pJSkRmN1FNZGtZYXU5UUZXNjhMcEpmQU0wdnBPNDVXU0lsMjBkZmw4Z1NDVWV6alVPbTN6VlFxY3E0YlVTMG9sTjNMTEJZSExlTG9icVRhUFRDN09SU0s5SVlYUXFGSkczRElXajlkZHpSMkU5OTI3TW9OdFNkdDlnWEsvTG1HeWhIMTRjZDJCRWJwUk8xWUhtdWJpdm9jR1pUbHdjeTV0MEwzWlVFc3RtUjlFK0ZZT09UMmE3YUlaQ0pmbU96RjdvNUNnbGh6Mjk0MVk1amU4eWQycXBzYmdWWVdlWDJkR0JaT2pXVGw5bmwrbnI3S1Frb0V5cFFybkRRdXN5WVFWTDVCSnlXMGFGaDJlVG14VmgvZHdzTkdkdURsa3diWnZSTm5jSFJCSHQrQXZ4cEdVc2psQi9COTZ6YmI5MVY4bUpZa2tkL0FxN0Z1dk5KMi9FRGVQMW10OCthUlFpYjM4NVdocEJzMFB4TzdUUUdOUUZDSVNzaFhFQzFMTWFCTnpwNzdEdTYrQTFsMTV4bWZiRVF6MkloMU9uV3JPUGRuckkydnJOaFNMcW9VS0Q0QnF1UTcrTFhSWVNMZldLRnpRdEU0c1FLVVdYYXNGN0RyRTcydE0wcHZIQ1IvaWNIUTViaEozcU1Pd3RyR01yNzZHVXk4cG9RSHA3T0RaeHVKTjRTNlM0cGkrNXRpemRBdldSMjdJNkpqcUhJL09kMWlyS2E1MEJrMWZMQnJIS3U4STFkbzk0TTQ0Z1dGY1UyVDFxTXJFb3UwTmVoZ3VpckhQT2pTZ3BlbWZkbk5oNk9QRHhtYncwTHhQc1B0aHhjTWIxUWFMaHczTWpZMDNlYzlQeDJVaHNhR0cwMVhkdWFwaDhvN1N3Nk1qMExQYkFlaThKWkpNT3ptR2RFaG51Vkc1VHlKcW1sek93YWFxdE5vc3Fkc0RlR1FoNG9LOGZlc3phMzM4aE9oT0N0SmtTRmhKRjJBc1c1TDVTbXZTYzB4Q3lHRVBjV2JLd1BHK2RFc3BrZGNlaEhFMVdrRHZWZm1SYWRnU2VYK3oyZHlxMFk5ak5ON25TWlhjc29Nd1RUekt6bU1OOFp1Ym45dTcxQVNuNzVVbGxSNTN1Rlc1RkpuVUJvV3ZlR0E0aXQ3R0NuSU9LTm1kajAraTFDdUpGYmFHSGNGUDY5OXdhZUg1SHNYc0F2RHFFZ1lHWFV1SFYzWlZNRmhOMSt3cjdITDY1bUY2aFMwMVp5MkFZVnZaQzdUdEVQMXJ1WkU0bHlteUVHdGtNdDBDdk11KzR3L1JEdnNscU5vN2w2MUJtaHdvR1ZvSUJ1V1RWM0dXWjM5Mmw5dTVTdSs3WnRVdjEzdlU4MVdYaWVkRE85dXBPZU9WVElYSFlaMFBpVWEvazlLc2NGbG5SMkpJd3UxRUlGYldRZFdpS2o1SEU1WER3NllHMk4wOTM1NW4yMlVLMWllOEhqYmZUTXNjaFV2NFlwZWVlNGs1VlhhM1dNb1VoSG5oN2Q1SkJlb3VlRDhJcWFCRkZteFRyZDZ0MmVnYmJzMllyNGhEWmJGWjN0MWZ2cFY5em45bGV4dGRFWXVWZXRsOU1GdkJ3bndKZlRGM1lOZzdieTBGODRSdjI2TlcrcG9XY1dpeUNCR0RCemJKRkZYcTNWNHphNmJBT0IxNWxvSGUxR3V5cVlEV0R0MTN0YXEvdU1uR20wVndnMnp5cnNFdVNyZG90R0tYSG5MUHdxQWRWVVJTOEtVczhTQlFQMUw3a2t2S09EdDV3ZzRmR01yRkhna2NYTlNLVlE1Mm9tYVl5NFc4U2JWdkxqWUY0cTFhRzJGTzRVY1psd0lYS2JEdi9RaTNhaWZxSUxQaUVBc1Vydjh4anZxRFZwM3NETDYzUEM5dFVoRGtlc0k0d0kvUHpjOFNRV1dXT1RUZGtBckFMYWdPSTFRVGFMVWVPRHF1ZUlEZWlSSlpqY2lmYm1BZkNkdDdZMmdkZHBhWTNwU2p2eFVzWXhIVmt5ZjJmOG14ektMZTRnbXpKTkdLQ2FDTjNmSDhnYW1KQ0libHJJRHVKVjlDV2VhRUszZUVEQkpLNFhxS1NJdnc0bDVVL2ZUSFlNdksyMkZKd0c5cUVxY3FWb25JQ3JSazZ5ZEpLbXhvcGxDRWI2Vk1tV1JKaTI3RW1YZ3JoeEtucWcybk5kblVFMFFrMkd1bUF3ZWdJOWNqYkVTczJZL0lZZ2R5enVVWE4wanRIc1NoWTA1Vm9vaW8zcGc3bnFyaHJnaWlvWlJvanV4ek9wTnlZVVMwQzZNQUt4L3llWlJwQ0ZMSHh6QmVyd3ljUk9UamZDdlEwQ0M2VVlJRWhmdXlqMVUraTB6RnRaWkU0cGlpbkZZTHdURFZkTlV2SlkzUjFHUjZmUUkxODFMbmI2R1lQWVR5QUYzb1FlMGZmcWVVSVdCaWVEK01paWxxYVY4SzRBcTZzTXJObTJXNHQwdm5nL1RKeWU5cTAzbHNHamIyV1NWQzZYc25BNmpWQk5haDNPVGhKSENIQ1dpTzJxQ0kxSUtZNEtCaklYaGcwbWFPd3Q3MXU4aFUyK0Zhc0YrSjAvd1U0Mm9nQmREeXorandUUW5La041Z2dCcmMyMTBscEltSk9qMDRkTWhlZWhjenF2UmlvYTViRVlTMm1CL0VpS0RwUUljWjJBaWVROW5xWC9tOVR5M1RmSmJlRkhFR0FyOTJpbXE5TDNwcFBMaFFhTi9RY0V4SnpmbXplNXpQSjRRYUdjSXRMalNucHpvQVhiZlBYSm5HOUZZM2UxbXE3U202VjFLRXBTOGtubXl2eU5jSTBoelB6bmhqOUVCY3h0VEN2WmdhUnA5Z2E0cVVMTnJxMnhPZkFvVlR1YnEvZjIxT3QxYW85dWgxYUExUHJCZUxKYkV2Z25IVkF3TWM2VkFabVNrSTViTGIxSGFidUdMdWdDakJ0RXNXMmpLUHI3NDljUWlyMUlPRm5HaVg3QnB5Y01POEc5VUNnYXpqS3EzTDFKRzAxNUc0T2RBdnJmQU9KNlBzVzA1clpRWGNTeDRoV1JKeXBpSHBiVXpKeWMzcnVKSGZqY3IyRzNZR09hbEFoQW9YK05VM25ac0cxRmpMd2hWY253NGtvRUo1bG9EeWEzSTJsTFMrMVlrYWEzTHdLb1pac1QydmNxbVc3VTg1QjdJTWNXM0hEd20xUFF6MzBVTFF4Vy9PMUZhMGN1ZFBCbGJYUHJYa2xiMTM2YVljUk8wa2pkTm1aVzFXMDlQeGdYVlB0MUpjaWQ1RWxhQk9GKzduR2VMZVhYblZaRXpqUjhxSHBLRGQ0bHphOGdQYmZsd2dQUG5mTzZSYnJxNE1tckhhdGxWbVZ6TkhrQjgxNFhGN2o5bzVVVXhvWnp0UmxIYlJZekxvMnlaTVRnM0dWVG5pb0YwRVBQd21Fem43TURpMElqbFFCRmJrNjdUUEdCS3NEb3F3VDNRMUVvdVc1R3E1QVJHOHJaNW5KMXB5R2RqN0pBSUNXay9EMEpLTVhxcGtpU1o0N3k0Y25nQ1ZLY2taTVB3cDVXb0dCak93TnZHSEw3aHpJRzZTOWpLYXpUQjR6ZkY2UkxxWHExZ1U2dUptR3p3cGZyRXJMR05ROXAycGdadlo5cUhwdm9mT2krK25FejhGSGFFZFcxYlBQaDFTNTdWVWdMQyttWWVZTzQybVlPY2RLbUlRSFMySDVxRlI5WFJneVVtV2IyNlRyWTNFR0VYVnowWVREYXNoZ2wyV2YwMnJZYXNZMWlManQ4Q3ZKY0VLZFVPaUZpRGxWc2s3NzdhMHdoYVRSL2w2VitBMjA2MEEveHlSR0szeml6VmloZW1tTHlxTm95NFQyTVV5Z3NFNjBtck5XcnMya3J3ZStjanhiNEZLR1krT0hhRXRjMWFIY2daRG1PWWFPODNKUVhJa2thbnpIOVNEWjc4cGtqbGR4OGM0cUlGRHJLa3pSOUhsSTdJUllIdHlkMklobmp2bjlaUnNQcnpUZUNGNHRtNjZ0aVpkMjRORVVpMDJ6QWVSMU15YzhtNWJ5UjdIV0NueCtuYXZLWlNCeTNDeFhGME5FdWFyQzRuRUN2YkF2MlF0MGRBS2Q1V1VDS3VwQlB5RXlTcWJzV05xZUVsbWc4clJYTFNNMXlMSVVrc0M3VUVCQ2Jqd2UrR3AxSVNRa2liVHRta2ZCQk5obVdFVGFubllLb3YzcHB5TmFaSWphVkFHYm9GN0dqald3VGt6ZnVqRURqcGhOWGNjNnJTY0szMlgxSlJpSFRXWmUvODkzWEUxV1pDRzdHSzl2c3R6ZExOSkVFN0VRMklRcDY3ME1pZmdFQXlnS0pUZnQ4Z3Jmc1RmVnF4OHk4TjY3UkxZRXhBaEEwKzZUcEFCeHBxQlc0STlJazEyR0RhN1JtbW9YWHVlK0M3dU8zV0FlcVZnaDUyWVd0TEZGYmpwRzE5eitOc3ZvWG9zMzc3Q0lIcUpCOWJTMUo4NXdSMmkxZG1UMUJJdDYwTVR1c0pCRUhCSm9yYm5wUVhNVTEwWElISUU5M3pGSWZ3ajF4NkJyUUpYYjZKWjZKSVFRdkJmZlV0WmJPSjNHMVFUMkRKbzQyN2xyVmVoTU1PVTRKN1R2NUdsQ3JkUGhBaXJlcldwMGJrd25scjNxUTVraG5odmxmbVI5TldDSlZXL0V0em5TT2t0RnFnd0tqTVhGTWtTaVVrbXMyamZhVUtLSU5DMjJqYWtuYXM5MGpxR01qVFl4a2FCM2xjS21wVk56b2h0dHlya01FbnVudXBPektDQWlUUXdIRzRFZTdDT3dtUlV6QmwxNnhjK0dFQW1QdFAvNDFMMDlUVDRpQ0RaSURtdW5YaStuOVozbnlKcHJiK3EwYU44cWorWVBTdFZha1NRK0JHVmhkcExYZTdJY3QzTFVtdXRjTFVHV2JacXNKdVV1d3VZd0J6dWpSa3k0ZHFLTllsdkUxSWEydEQvYkloSFRPT3lKbXh6NmNscmxIMCtsdEhRQm8wU3NQcVI3SE85R21rTFg3SkJySVRPU014QTNMZGtzQ3NRMjdWbnM3U1lhdkpYMWNZZFdEbzZqWjV3OE93YzlPb3lzWDEyOHpTcDF1MEhQYm0ySGtKQTlyZzVza1NUWlVYYVJVRnEzdmk4eXJxWFZlRXRYd2QyL1pUWFNGZ1l5RTcwTkhGK3J4WlJZUUNHTEgwQUhVa3NGWlAvUWNNbTBFaG5MU0p1c1Zld1JDaHRlSUU1TVM1OWx4S3lqdjBLWDVJMnRiQThUam1PZ2plNFFjZWc1cGdua1VtS05tRUtpVVJ0YUJpVHFLM1EvTEExTmU2UTJSeXc5bTRqMnVMT0tiOTA1UVFuekdsWmswM0FIeUx2OERBMmZNcXdzVmgyYmF0ejA2SzVGdm5HSkNldVpCQnNJd2Vpb2ZTYUdRNXdEenV0aWU1NWhHMUJLYWtXeXJZS0xLcWNVazE2WDJaYzRtMHRsaWQrR0YrYUtjdWF0OTk2MGw3TEdlOWRaVVQzdXZ1RFlYa0ZMdFlRTlRDZXFWYk1GQ2M5dEJFMnVaTFQ0bjRJNFBEK0gwM01PK1NJSWNPbVBld2RrSWRxczFWYXVMSy9PbXRiNjJtUlFBUVZKYXNpOHdJNkw4b3lWMHZGTTBZcWliNWxsam9MMm5iV0ZlN3dtWWN2S1lkWGZYKzZ0QmdQbDNteStWdTVOSi9QbHR2V3ZnVVptY1RzZ3paUFZZMTZQSmxCS3QxZ2lsdjNKTlZqMnBXZkJzZ2ZjOFZ6TmcyR3lYaGgwK2x3K2gzY3NZa3JOYzR5TTJiVlJjTGxKTTFRelNoZmZRMEpOeU9PNXFrbUlYTFRWWEg0Y1FVTFJuTGVUaUJ3RjZ1YTM0aTk1MTdPZTdCWXk1SXF4WVo3R1VyMkcxNHB1a0NicG50eW1EdWtNc01memhhMjYzN0RSY04yYnJKSEl2ckRxemtzU3pxSk5sK3RWWVNhbWhvQlV5ZnpkcG1odHlueFpiZm9MbGhuNVVsV3YzWUJnNCtqUGNzdWNxT2VBVWpHTFNGSzNTNWNEWkcyU1RwTXZXWGR3eStxNWpRU2pNMFU3STVhSVdSVmg2a3FHVE1WdnNNMlNwVkkra3lpNjkwR0JOZlpCVGR5QnF1d2F4UkFZN3BsUlB4blM3U2lhdDVuK3p1Y0hjS1Z0TzI2RGRER1ZJcTRNK0VvTmErZUI5YmRHbFRVTVd6eEw0cGxJNVpuVWF2dlkzY2hTb2J1RWFobkIwVnNYVFF4U290Y1FuNGpGOVdWMDFueHFNemt6cFd5WGxxa0Q1OXo4M05IV2txemxhMGx3cjVNYVVGZVAxQ3pmTmVKRnpva0JKZkpNZWU2YzhXWTg0M242RHFOWi9uVlRHeHFiOFlobis2NVppc2kwVnlrczN6WGl6Yzh1VEoyelhZYlBpUkh4YkRudHkydE1mVG1MTU9KNW9tc2o0d1owQW9hbVQ2empNTHlKdWh5MGtFaTl3cklxWjNOam1ac2lZOUxIREFHZVFHMWMyeVlrVHRmWTU5SGNIMHk2OXBZR1JZTXFoVnd4ZzJ4R1hqTEQ2TVZwUG8vakwyR0twUjByMVM2WjdVV2VuT1hUeXJpaXI4QjJ5ejRhU2NscEpFNmNmRE01RUFROUplS21SSXVXMjhVZDRzbWRwTG1SZVhXOHR3QkVqSmRGdUY0dWQ1TmxRd2NueWxwMkwrYVQrYlhXUC9aTWJ0MnZwbGNPbG4wNkpzVnRTc1E3bU1tUXE1STVtVXdCRHhqenBXVllseVJXb1dySWpTMWtVS01Dc0NBU3E3UlBUSTFPUTRHcVZIdGVUSTlPaGlONkp6aUVnazl0ZU1sUXpWcmVRT0hxbFp5RDNOU3F2U2dORDlRb3FUVXNjQ0hsUEsyaWkyQ3NJekFNUXA0ZE0wYlp3M3VGVUs1V2w5ckVwZzUxQjYwY0FWMnFZRjBTQkNTZk5rLzRZV2k3cmI4T2RUQzVPNjVOSVorWUpGK0ZlY3o4SzdaRllMT2FiU01vYlNwY3EvRUkwamN3bFlyMkNhWHJHTlUrTzhIV0JYcnBaRjYzcHkzY0RvdFowUG1zb3BCS1JWTVV6VGF6RHBqMExJc2luM0lEWGk0ZHBOUGpMbVlNVUR6TFhxTndmdXlQS2RhSllLZ2xVT09CcmVTa0dXZkRMUzVmRHhmSGc5Sk90a3FJVmdWQjJhaDBQY1gxa0pYTVh1ckJpTUZ2SkxUVW5nVktsaTBqa3lGcm9zTmVBNkpPQTUwcU9FVFVON2dRSU1WZUhjSGpmaXJtUWxhMEtkTU5YRTVsTnlJS1lNcUhuSWc1am1HZGEwM3JURXdrRHVKMHJzM0hRMFY5RnNCTE9BekphV0hWakN1R2RiREk5NHpSSlJvYzBsRW02RHdnaDFidGJFbHNRODNGbXg3OEhtMm9FVWpiaUVSalVmb0xVUi84cUxUZnFEaDhkUjhBZWxScThDcXhVQ0JKWWhKOGJkZVhlVXVuZUpZNzdHZTVyNmE1SlNrN29DcDhpY3dnalRIdVJNeEV4SE1wYWd6ckFwMDJzdHpBQ3k4V2ZkRDdZZjVXeURRaHNXMms5NmttY1Jhc1Z2TzJCcmtyRFUxcHFabG9LWXBuRHBpM1pRYVplUnQ1Q0syVVNqV3RKZWVRZ3huRXIwVTNTakthWXgrNkxsN1QxVGUyeGlTZThPTFpYUkp4bWxoc2VsT2FvWnQ3TUFiTVAzcS8zNGFHbDJ5Q1ZjZGdhNmkzYWF2UmZNT3JNOEJKTm1YYVFzcGFUYmVoNEtFdCtndmZpVGlJek5NajJaOEdONGJWVWc3QnI3UjVjRjZmNE1nNWtnTk5qZ2VKWERtODBYeWxMZGNoVW5oZFpGTTF1d1NiS0xROXhwaVczSWpGQ3JDc213a0dOQ3VOb1RoYVFZN3pkeUJLaHB0dnpBRS9EekhiOEpoZnAyZHozMWhUeTZKL2R0ZG9PZzdUMW5KWW41Z1JIWjlmS0kvV2laSHcxb3Q2dUNqTzQxM0IwTVVsYzhWTS80a1U0YTVZWmlVY0o0U0ZldEhjMzFseW41ZFl0Wkw5WFpHOE1BTWFoYklnb3p4eW4zRHB3dmJvckJhMGtxZElIdHVkZXBIMXhUTnBKeUx4aFhrR1FsdWhOWDZ2bnBRakt1dW5qZXpaNm11Q2FLVFdLNVY0cXFZUHMvYnBCRzBKbTNTdDdKU3drWGEyWXFTczF5NTZaMEhkSmg4dFBzTlIrZURHcWVhWGtmdVptc3RDTkpNVVgzWEhrQncxTHdvbGM3Z2V2RnBpUlQyOURyZDBTM1JxTTdaWk4wNjR5OUhsUklyVDdubTZBbnJPMEtudzlabjJzblJRcGxDSEVUMFoxWjVTQ3psSHNFMWZtdThiMUdjeDZUV3dtNjRoUEJleSt5ckREU2JzaFVyYlVjdmx3YWZDVDdKR0VJdGdVMmpFaTAxcjgzV1IraEdmQ2lsbE9vTjNpOEJPQmt2b0ZPN3lGQnB5U1QwN1k3Z3Ixb0xxc09MY0tzemtSdllVUFZvRGQyNE5BYVp6NHplZDJiVlhIVi9ETEZYT1dkVU54b3ZxblZnekQ1SDNWVlhMSkxzamhyVjNRNFdTVk1yVmtNaEFva1Z4Q2lha1hVNVdJTjdYeFRPdUE5L3VnbDRGYnhaanQwVUl1aHhNNEdwL3lNRUpaanZtam9iUmJCdmIvbnliVTJBZU1tSEIwVzVhdlhXdGZ4dU92dUdaTDVXRWxIQ1o1ZGhIdW5hT0hkVk9HM21raWUyZFg0VXB0TnFsVHl0YmcyV09XaHVCRFhMVTlIMTBGaFlTcU9WRUk2NnRLOUo0aEJWek5sNGxsVmE4Q0pmMWZYUVFJQk1sSTlxbTczKzNRa21VTXUzWTllbUFGa1dwa1lXNWtmRHc4R3luaFdDVHlnN2JzMFZla0w2dzdyeHRTZ1I4VWQ2TWlrdzNTMnBSSnlyQlhxVGVzS3pmUzh0NmdSaU5BcHIyVVYwczI3QVgwNktFV0ZqVlBrajRaUkowckRjeVRkd2l1c3Aza1BaUWU3R0xRUnE1aXJ6aENwVFVYOWpKbHpxS281aHY1T000R1ZLKzVLcVZPQ3VIQU8xZWU0RVR0OHVXZGpCWEhBb0t0QlBRMGN3bWREdXhKbS9XQUxQT0VXbjJxeVVXOTdLd09LNWpDVTN6eGszQmw3Nm1nL1c2em1rQzVweHR6WHNUMFYydzJsL3NlVlA1SFd0aVJzSU5ETVVjdFlpRzlGWm5Jc1R4c25IWkZ5ZjlVQ1FDQlREbE1uTVN6NEJ3TlAxQzVzWEpwVS91cVRDNUt0QVJydUVVRkFkMXA5RXdOTlpvVUdvMGlBbldLM0Y1NWIxZk9UWFlYcmJYRTVRNVJjZkFVakdUSzhiaEY0YkRJS1d0djZUanZKMnY3TEpiMVRZbElTekVRV2U3ODVaa0dDMC9NdytGK00xZEpxOFdCRGxjaGQyOWxnNlV3MkpxUXdxMTd1TzJobjI1VEFHNWRMQVJ3QU1STERzTkIxVFRPWXpmZmxCL3hOWU5Kb3ZZcHpXZkFZbW1wV3p1MkQ5VGZSeTdETXE2bDFVK2RFSDBncklGVll2cU1VUE5UNEZPSWNCVVBaa0JJcStwVHZ1YVV6NFUyNVlSOGhBL0Z2blN0VllCRzQrZUp2TVphQ2dKWGJ3a2RpeG4vbmVDMVk3enU5YXNPVkd5aHFHMWJJbS9nZDBuWDBMTDZtNkZNY2NCRkgxNjNiMlF3VzdwTHRDbXRCSG5reXZzOTNHcVZrZm5vR2s1cVA4U2M2RmxnYWhQcHRrZXZlWmlDU2JTUU40ZWFJcW9RNXlmZG0zbEhzZUZFYzFSMXREMldSTi9mWldlbG1paXhHYWZsanRDbWVEVHJKN1BzSmVlRXBvOFJZTFg5dkJ1TktLWDBtYU9rd1JxTzd4dmdjOEhHYTBsdkhWV2R5NGhVVG93blNselY2UGpCODN2czFRa3FwN0wxS29WemFrS2xNRGJHdkRUdUd1U2R0d2piRyt2WFFvcWxyL1Z1clZnbXF3VGFPME83SVRsVUVLNFQwMzdnbEx5R0cwbFlkY2hyeTI3QWJvRHNjbkxWUURMMzBOTFIzTWJOcUttazBPeWwyS0haUW4vSE9tbW4wMjY2WlowSGVtSlVMTk8xUzJrVGRZWUpHVWJTM1BZYzBXU1JDdXllQjIyVzY5cFMxMXVXR3ZJdVZMWmxZVk9zOHN5Z01XeW9sMjZEWllTTWpYcmVCUFc2VzZUSFI4ZUlxYkZHMm1lUWhLVldpK1pjR0hSVEE0R2p3U1BBbWxMeDAxV1Z2dWFhUDdScG1EdHpPL29zVG5KakVFVzZ1d1BKSE9pZVF2cTRzWHhzREkrRjQ3T1RJN0VJeWhsazdhWngxUTNvSHVRQ1M0RmhQZnFHS2JNcWhDMnlmSlNLWjl4cnZWSjZIK3dxYlkyOVM4MXpXMVZSck9rcUZFVTFqRTZiUXgzUXN4N2FzWTZSTW9tTms0Mlg4ZjdralJEcHprcDNtblFjVjF6UUdSa2N0NjBkVXlhQTIycTRBNXpERWtPbUNVMkFaYVUzY1BUc1FsYzg2UWJxVWh2dXRHSUlKSHUwblFZY1hwb1pjbjNSQThLbllVNWdGOHI1VHA5UStFVDVSMk9wTk9Cc2dmUUUwalZIbGtmemFWTTJkSVY5RTJidndoeFAya1JBcVhLb2xSM1dqaUlPYlpnWkhWSWZXWmgzbW9Pd0VNZEtMRnMyaGVSMFNtQkpiT1VXaXIwb29TREIxYkpDOHNTN2tMNVJHU2RrZThHaFo0SWR3MmhKd3B6eWlyVlNIcUZEaEF6SzVuVUdoeE9mUkNEdXMyOGF5L1puYUdOcjJKdlhrdlpNNUVjNmpqUXJTMi8wN09WUVpWZzNWS2JQZW1rYXhhWFVzNUVySHN4a0ltZ0NSNlRSbjNsaVFORjYzMVVFaGExUmFwV0lBOE9USmlrell2TENEeE0wZVlMdEM0TlgxRk94Lzdra3krVldPWkwwbWdXQmtON1JuS2NpNGlXWElLckFKSWxpcmtTUzhOS05pSEk2eWtWaUhnZzIyKzV1MzBSYjlwYXZIY0Q4cjNreThYQUt5aXNYTkxyNU5KZTFSd2huVithYnZhNkYxV1NpallmbUphSjltWkZ2bURHT3N3S3g0WW41aUxoMmVINDFQVFVnWkVqbnZLeFdzTnBJZ1pVQkxubGNoZ3NjbEg2UWtCYUJRWFIvbXF2MytmejQ3anB0MTJqTTNOTmN5dlpaVW5JdGFYSVlHTTVreUlMdXlDSEtqS050YVYrTXo4YlByQnUwYkRHRThNT3hsMGh2WlMrQzl5c2Q1Y3FaYkt3TDgraDN2Z2dLaUVNYmtEbGxBNnllYXJWdDhCbzRWTU1DdENIa28wbnlUczc5bXhhY3NJYWhqMW1WRnZvb2E4TGplZTN5V0toc1NUbk9MeFRJd1lFVjAxV3EwN2s5QWFRYlRGNkZHeGdLWGxVcnU1cEh1bU82eGhRZmJ4SE13RkpEMXVHbXhBUWt1dkJvNEdlVm1GenpnT1dGRDI0WEFhS1hhcFhlU0xqS2R3NlkrS3p4QjdjYjVIQVBXK2pYRUlLZHBmbkN3TlJVaGE2L1V4NE5oeVY2eEJzY2tJSGNaZ3NpVUpqNHRBYWxtNG51cWZRR2lUVW1iaEFzNU9qOWtFcUhTRXlrNmJIRExNMXJCeVhEemNlRmlzVUYxR1ZIT2t3NXFrb1RSNjJlUkRub1c4WEVldGQzV3pvRUQ3U0xrdjFNY0dGcFh0WmRHNFp1VGJYNG1KWXRBNHhyRzR0MTZPaUhMVHdnUENUOFpFWkxKYW45VUVDR2xqRkJNaU1kSWFHVlF1VGxvZHJPRFlhbllleFB6b3hPU0lVQlQraTZGcHEzbDJ6UGR0QjUzTDgvNXF0MTRObWhia0o0NmlwWDdVMXZGRFFvc2V4R0dyU1RWaTF6dFNZYk1LeXpEb2R0KzBqaUVKVmozdTE1dTZ1UGM2NVRBUlFIWnc3V3BGS08yMDhoazJBN1RnOG1QRCt6ZFdjOC9JcDNmdXh0UGp0WEtNVnV3SE94V1RQcmFQYUtTelh2ZTEycXRwNHE2M3dDczBwbThPcS90TENseUpsSVl2QmJpV1J6V1I0WVBCeEZEUm1Qc05ta1lrc1dDb0hQYTN5Z2Q2aHRDejJDdGJmMVhGdWlFYWptVkloOHR6RTVBRk5ORncwQ0VXVDlZbTBqT2hXRklkNjhCb1kwNHVMSm14SHJGQ0w0b29zc0VqQ282VXZZVUtpYjcwSTRZQTl6YnNkVkJ2UWluM2ExTEZ0R2hhRlQ2eDhMZEdSUktzOG1ZUFQzTVBTUWNVcTNYbmtWRXQyOEhWNlVHWmErTUFrQzBFVUlsdkprSWJma3BhT0FMUTFxS2dsZXRaRFdxYWtmNmhaS0VBN2U1ckVqMnZWdEUxRVNmNkpDQU1TS3VzYzMwUEJxMm51QVpJbGRvOWxFSGEwMXp0WjJtTWRYTHE0S2hpdzQyVFBIY2ZDVFRmaldvU0VMTSswSEN3eGlwNUZYZCtuQU1OYXE1NDF4YkFGV3RQUVBnbThNY0hlelRuQ1M3Wk91cnM3OE5Cb1RzQ2oweFM1MTY4VnpBTkdoeDZBRlZLemlBdCtVeVpIaUE2akh4ZjlWWmdpVWdtY21nb2tTbExQMVhqemdVSExhSjFBeDIyVlJlQWVMOW8xeE94SUZKMkdtTFIwU29zWVFnOHFQUktYMDVaeEl2bDZXb2RnNitxN1M3VUlBOHF0MGtUR1RkbXpGcythNVp4YURub2Q2Z3c5YXpDck54RFBXaHJabGdONnpBV20rS3RvVVhCMEZCZjhWdjhYQ2xiTTRGVVZlTFRCQy9NeG1QN05pYXdXSElaMnhzVTZxYW1nZmh3YTNhaVJiSzVjdjAxSmt3NEZXL1RJWnNoZ2tDZ2ZOQXNQT0VyV2VrU0t0MEpwbmdrUGZyMGg3T0Z6bnFvdHRtbDlsQzZhZjBoSFE5ZU9WaEJJN2F2VmZKZTVXS3pYOHZTVlNQd3hRemJPYVQwbks2S2VaZ3NHdkx0MUd1ZWcwVmxQV3F1TDlRYWdzSUpsOWNUZERKbGxXQjlhc3ptM1k5UlI3ekJwUzNMblhvNW1Vd3JpUmNqbG15UTc2bUhjZlZEeWF0VzRGMzlhbjNrU1pvdTdZRzIxUFdjZGQ2aER3bzRuUGc2Y1E2NGJzZHhsbWtsYkF4WnFhK21TNEdsbmp6YW9JWGErNlV2RHRwNXNMMEtMNVVTT3l4WmdqVTdIdXZreWNqN0JuTUUwd25Rd1JlTG4rc1FacHlIZVQrTWRodE9qenBZUm8rTTBTYVpoMlkxTEFhZVFiTEsrMkdQTzRkWHNPcFJXcDFtNkdwSFRDdWRwdVlrVnlaTlZZeDQ4eENKeHJMdGxnZDRqeXNRVjRuZngzRDFvdHJWWHUrRnZEWDZDeDA2U0xFWjBDR2xKbUhuU3lLa1dHcDNuNU9HaWdXV3kvTlM1NW1aZnppWnlaTGlEVDJYMVNyM0RXKyt5YzExekg5WGx1TGI0UWFaM3ZNMStBSll3Q1JDcFRlRkdxN2hMdUNYNTNIRmRhZXdVK25odUhUVGlxenZ3SnBxM00wdVpmTGtMbHIxNDN6bzBvQXpzVXRhME5iOFFpMjVGNiswVm96RTlKRDJXVHhSN1NwWEZYbzdjUzlYQmRrRDd2VFRyVTR0MnArbEVxaUJiT2RxS21oM09zSDNzd0xUV3FVZTl5Q1ltYUY3RFNuVTZsTVQ1V2dHSHBLbER6TlN5N01HbmloMm9MdGtpbEtxMTMxcVR0Tmp3VGNtVjdOUjZLRG1OMXRXU0Z2Rkd4THFpVXdBTnFvOHJTenpOdCtRWmNtbjQ3ZFRpRVdZQ1dSREVQVVdkc1R6MjkxWDczSEdRenUrdGt3ZFljSmZsNUtHREFqdmxYQ0pqU2NDYXhLQ1VLdzBJWVhwaDNqNzA3OTNBdVQ5SGF6YndoTXMvVWJ4QURyNFlrWUt1aThhVWNQdmNLVnlENXBGQXUzOWJqWmtORXpDN29OMjVmMmhpM0hSMEVsTkFUSktKRHBFbjFnYlBaR1NVNWFvU0FMTW9rU0hhNjlwSEcyNUxRUnd1WWhxazYxOTBoVEpEaG9iNVdoaU9OUmZwbzR2L1ZFa3ZNMWxqS3BQUUlRNTJ2SmdFWUFYdGpMWlNBaDFSWDRiRU1UUkhmRmZuTGxxSWFYS2ZxQ3dTTzRLeDlIU3RqVzdiSVRwSHVqOVl1bzltam1tckxGNTVPWktHNXN1UmNwTjFMVlBGMGozYTFlRkExZTFOcVZyN1haMk0yK2lCWFRyZnl1enMyTmpRME4zaDhMM1NsTm8yUld0MHRzcUFkMDFZV3FxaWp5MUx5bFloT2RTWTJJQlNSWnVZenRXRUZxdWxMZWhXYjlLaEtCaUJMSkpzYmlXVGppUDNrMU1vc2lHc0VrNWkvbjRlVUhZaytDWU5Gdkxua2VhT0UycUp3akpjZUdwVUtlQ2hWZEp4ekxoMnVyWlJEZmsrTnpsbGtTeDZTZHhqYWpSazc1QllEUEcyV1dYZXZ2NURuN1BmNU5BQlpHWjQwYlF0WWFPUEM4Tnp4TnpFUXQ5bE9jSmJ0Qlo3ejJQaXhUc1prZ3UzbVVwdHFuM2x3alo5aTVqZmJQY0ZrZUszbWdOMittaWJ4TzBuNnhlMllZQVZSN0VSWkhwMTJqNG1EOHZhTWJtYzlvNjFSMHQrU2hzZzVxUTNVTUo1dVgrb2U2U283YXVrMkxJb0YxUjVYVXg5SVNrcnJCbFB1YXFObnFZdURydzNtMFJHSDIwQyt0YmVXOEhsdTdBTlk1eFBQK3ExMnd4MW5sTHE0ZThhS2gwY1VQcHZPenpuSy9mZkplY2I2bnNwUS9uZ2ZhdEh1UDdiSlBCNzJ3MlZBUHpRQnZIM0FIN25RNGJxY1BpNS81Nk9iRjRucmZYK1hnNzF2UVRnRjc3WFhOOUw0Ym5zZjVubWVuKzZ2VTZwamRYLzJmNXRMUnYwclM2QXg0VG5Pbmh1Z3VmMzRYa2VwanRqcUgwQXV3VmlQZ21COXdsTUNrd0pUQXZNU1B5c3dFV0JTd0FOZ0Rrc2dFQURubVBpZnh3ZzlxazhQSHZoS2NCekdKNGlQS1B3L0I0OE5YamVCczltd0g4N3dBNkE3d0M0QmVDN0FkNEJFT3Z3VG5qK0VPc0g3aitUdUYvQWVJY045VGRZZi9CL0Nzc0I3ZkEwZ0t2Qi9RMHF6eVlxRTBKbjIxNElEOTY1Z25DMTNnZ2dERFRxcStLdUlwenM2K3RqMkU5d1NHQWdORFJHN3JIWk1NTFpzU0dDWWZCQW1QVDNMeElNRFZRSTlvY1NCRmVTN0w5U0ViamFRRGcxN2U5SE9CeWJucWIwUWdFZlE3Ly9OUWo5dnVNQ0YxK0s1UTc0Zlp0UFFYNnhoUW1EWUtXTWNHNWhlTzVGRUk0M1ByNkkwdzlzQTMrOFpmZzhoQ0hmd0Zzd0hLK0ZCUGVSa0g5bSt5bXFiMmdydWdQK2Z2eGVlTnNqd3NLeGN1SjhTbjk0UDdyVGhhUi9PL3NucndRNEZ6dm9SNGozaFFyTVhjWCtRZXlIaFhLb2dYQjRJbllZNGVIWXhEREM0RVFzc0FVZzNsYUxzQXJ3YWt5L2tTb0xOQm1XeGQybllSRmhPSlp1Q1BTei85SUpnWUszcFAwREFrTUMrd1QyQ3d4ZUR6QTJFL1RmaXUxYVBwbTREZnMvTEZHUnJnME16Y3o1c1h5RmxMa2J3MkVwOFVHRy9tNkFoMlluUndZQm5raFhsdjNRVGdlUER4Mi9rUHpEaDdEUExtVWFmb0tORkVISUw0UGpFaGErZm9FQmdVR0JJWUs1dnJMQUV3SURBb01DK3dUMk0vUUx2bC93L1lMdkYzeS80UHNKUHh6TEZkbmRXRUZZYWZSVHZpdUovQ0tYZzJHNmtmQUxiTHdDKzAzWk4vQk9obnV1UDRWNFBqK09yWUsvWVFwa04vUWZodjRHanJsQ29PRkh1SlMyWUVCZ1VHQklZSi9BZm9HN0JRNEkzQ013UWVtdTlCVUZsaG1HeEIwU2QxRGNRWEt2cFB2OEFrTUMrd1R1RVpnUW1CU1lFcGdXbUJHWVpkaVE5TGcrSzFLZkZhblBpdFJuUmVxekl2VlprZnFzU0gxV3BENEFKZCtHNU51UWZCdVNiMFB5WFJML0pjbzNIQ3R3ZmN1QnhtRWVuNEY3QWRZV0UrWjlDSFBaTE5MNnhWeldSRHBjaHZVeHd1alVtSWwwdUpIcTloK2k3MTROSUQxT3cySTZ4ZU9yS0hBSnh5bmVKNzJEeCs4dzBidVlmNFZodll4elJIVXhaNTdDK09VVjg0OEFabFlxNW1zeDNYSnFTV0JSWUZWZ2lXRkl3a01yQVlEWmZDNzFMb0N3M2s5L0RQTk5sUDBDK3dRZUVSZ1dHUDFUZ01PSGg0TUNKeTZEZ2tSOXN6NkJZWUZqREk4RUJJWUlEb2ovZ09BTmpIRzhnU01hQmdRSy9oSEdDOHhxT0hZNXdMbWxpaytnWDJCQVlGQmdTR0Nmd0g2QnU2OENXRjdKMTRJQWk2azhObnZUSDg2M0tGeUs4MlFpMVIxRVdNVWJ3WGNZZUR0MmFBZjZ3K3BjbWVoZnFCZ0VsNU00ajZacjFaVEFKWUY1Z1JtRXlOekVlVGNENlc0RDJJRCtpQkM2WWVKU1RIZXhXcmdkNS9kOE1uVSt3R2c0RW14ajJIOHJ3QjY4SzVwaHdHQVlOS2k4UVJQaEFsRFFtd0FXQzZVcXdxbVJ5Y256RkpWMytYS0EyWHd3Y0lYQUt3bjJoNjRTdUExZ0hmQU1nTFhsVWhWbjhtcHB1WWJ1ZkRsVlVBSXZCSmdyQmtJWENEeWZZREN3WGVBV2liY1ZJTTc3Q0tlbXAwWnduWEF3bFM4TFBJR3dlaUpWdmd6ZHc5RkFnR0hrZWVoZnpxd2duSnM1UElYcmptcW1rZHFDc0ZwbzRMb2tPNW1JZEdHOTgrVUVybHZ3dk9ncUNDOHNGZnl0M3hQWGE3aU5KYmdTWERSV0RKWHE5MWtMMGZOZzdidFlMcVMxRzFiNWVFbUNXc3hVVks2V1VPbDZEZWJiREpRSjNoTkZWUzVWVkJHZXBVd1M1dStpZ2cyeGdnMjhXcXhrWUJ4bG9FdzFWYXREZU1WVXFhV2NxbGZTYWduQ2Ewc0pkUnppNVhNMVNDT3ZZSCtoTXRXYXlpY2FsRysyWkJLczFLc1VELzl5bFJ4OHU2U3FsSW9xbGFtcWF2NDRQQTIxbWt1cktxUmZnRzZZck9kVi9YaEZKVE1BVHliVjhjUkpsVGlaNGFkU2dIcVVWQUh5TzU2ckFKMDZEbVU3RHU0aXBRL05wbzVEV1k4bklPMWlHdWhYVWhVelplalBSVWdiMDRUNlZTR04rakZWVHBpcUJPVXBKQ0F0Q0s4bEN0Q3VlVW9uaVdrc0ZhQXVKZFhJWmZEdWFzZ3JEN2lyOUNRS1M1QjJCZUlYb0cvQXM1eVF1bkk1Q3ZsRmxTbVhXai9kL3k5L3kxQ25aT0tFU2lYdzI5VFVpWG9HdmkyMHd5clVGOXoxM0tKS255eXBZL0xkTG9MK2Q3MUFVK0JOQW5jcTNnZmM3RWovNFo4WmFzZlBZVDhIejJQdzdIakdVRitBNTlUL3dIN2hGK0IvMWxEbGRYY25Sb3Y3dFMzdXMyZWRyaDNxTjVwQ3IxQy91Vzc5RGNWRFljc2E0WnRvbHdMN0FjdWRiWEVmYTNFdnRiaHpMZTVGbmZSOTdINDlPUzVZSS8vTjZnVEI4eXgzcGNYOWhoYjNyekEwdFB1bEJKK3pSdnBiYURmbGRITWZEMXJ1S3FkdmFIZXR4ZjNHRnZlRG5PODI3WDRaNTIrRm4yNXhQMFR3WWl1L043VzQzOVhrYnYzYlNycy9wWFpiN2pxWFo1dDJOMXJjeXkzdWxSYjN5N2w4bHZ2WFd0eS95dVV4dFB1M1d0enZibkszL20xVFRBTjJHOXI5YUl0N2xlTnYwKzZUTGU0WHRManZiM0cvZ3V0em5uYi9lb3Y3elMzdTl4RDhDeXYrZTdrODI3M0xmNTU2SWVkM25uYS9xc1g5MnkzdUQ3VzRYOG5wYjlQdVY3ZTQzOUxpZmgzQlQxbnV4MXJjYitYMEw5THUzMkgzTGRyOSt3US9hK0gvQWNHN3RtdjMrOWk5eHZmYXJwaE83ejVQdTEvVDRpNFRESDVoazdnZklQajViVHI4UlMzdUY3ZTRIMmx4LzJHTCt4U1h6M0kvM09KK0NkZDNHOU9UN2VwM3RWdHRJL2Z2YWZjcGc5eHZZM2RNeDM4N3V5L1c3bmV3ZTVkMnY1UGRQZHI5UndSL2JPWC9mb0tmMGdTbzVlOTg5UUdDUDkrbTNSL2srcTJCbjduZVVEOGNNdFFuZ1RJL2RMZWhla09HK2xEWVVPODdZcWp4WGxoVGd2KzJmYkQyTzJxb2IrODAxS0hiREhVNytIK3picWdiWVplNE5XNm85Z2lzQ1FPR2VnWGdmZktBb2I1VU10U1A0UVAveDNXRzJndGhSeURzSXhjYTZpNkk5dzdBK1VOSS8vNEJtQWtndno4RDl3Y0E5eDBKZUtZTTlmVjVRNTN3R2FvUC9BclRBS0ZzNDFkQmVuc045UmFJOXptSTh6SElvd2ZTZWhXRStYTlFObmo2SnczMUlLUjFDN3gvR2ZBZUFMeDdJTTRKd0NsdU10VHNSWVo2Yjk1UXo3elFVR2NoL1VjQTU2c0xNSWZlYnFoM3dkcjdMb2cvQVhISEFmNFUydVFqblliNkFaVDlpNURtR3dIM0xtaUh6ME85L2hQcS9DajQ5ZDVwcUgrQnRMOE5ZZnNCZmgxZ2F0UlF5MUN2NTBMWjNyWEhVRytHT3Z4Z3lWQnZ1dEpROTBMNzNRRHBmUUJ3THdUNEM0RHo4SHp1UGtPOTdqSkRYVGRtcUs4QTdzL2JvVTBoblFmZ095UWdQd1ZsK2ptVSsxWUQ2Z2p0OEREZ3ZnL3EveTFvbXp6VWJ3K0ViUS9DTjRQMTU1ZkE3MU5aYUZONC9oWEN2Z1Z0K1NRUXhvY2huMVg0QmgrSDlONEFiYndLWmEvRGV4alNld1RjR1FoNzd5MkcrajM0NXJkQTJlK0N1cndTbmhISTYwS283MWVoSHY4Q3orbGRodG9DN2ZVaWJOT29vVzZETk02Qy96T3pVTVllUS8wSW5pOWVZcWpuUS9pN29SM25NUTlJWXpjOHZ1M1FYeUNmTzZHOFkxVkQvUmZVOVJsSSsvUUlsQVg4bjRCMGVxQ05QZ3R0RzRId1A0UCtjdFd3b2Y0UzJ1Y3NsR1VSK3NlSG9IenZnYlMvQ1hGbjRYdThCUHozZ2Zzb2ZPdDNRSnQ4RGQ0WDRia0kydXdEa0U0ZmhEOE9iZkk3OEozZmNyNmgvZ3JDM2dOK2I0UHYvd1Y0Znd6eStNK1R3ajgrZjFNVC8zaXR2NytFNTY5dy9NSHoxL0Fnei9MTDhId05IdVJUUGczUFA4THpMWGkrQ2M4L3dmTXY4SHdIbm0vRDg2L3cvQnM4MzRQbnUvQjhINTUvaCtlSE9NYmgrUkU4L3dIUGY4THpFM2grQnM5LzQzaUc1eGw0VEZNUlJVYXFnNVFHcWNWTzhFT3EvM1Y0a05yaWpMZ1RGb2xJQ1hBMnZ3OFdpcDhFK0hmdzNMQ1QrYTlwZ0JsNGtCb2hoZGdFNzVmQWN6RThqOFBpNlRhQU9GTjlGTk1EOXo4RC9DazhuNEFIS1NqT290Y0N6bTlDRngwSHVBMGVuTWx3SDM4TGxPZGhnSS9EOHhmd2ZBa2U2Q0pxRHA3TElPeHllSjRMei9Yd1hBM1BOZkQ4RitCOHBoMVdsd0JoQzZXR3dlOVJlUGJBTXdpUEFRMndDWjZiNFAyUE1XK0FOOERqZytmUE1TNDh5RS8rTER5Zmh1ZHo4RHdCeitmaE9RUFAzOEx6SkR4bm9SSmZCUGdWZUw0S3o5L0RnOHl1VDhKMDhqVjRjSGI2TzRCL0Q4OVg0UGt3dUo4QytGVjRQZ1ZQT0RJNWV5UDRoV2RteDB5RTRja1pnck1qYzdndVR6U3ExWjBFL1JIazE2ZVd5bmxjbjZkSy9hRjJndmtLVHBXby9vY2tQNTByWnZGc1pMaThNdEtKN2tvbWl6ek1ER3pxMFI4bHNwR1hpVnFHWFFEeGVqWGtXU2JTbFFKT0VkbmFhcmtYSUJxL1JGN25VanBmd1UxcUR1SWhEK1pZT2JDRWEwdTBvaGtpdUpUdUk1aExZUHBvTWFvZm9aUURCWDUyTTJ6Z2FDZzBNaXZrMzFoSzd3RTRGNTB3a1ZlS1BJcmJxWjZwQ09hTE1oQjNBRVRsZWVSSlZXdkpmQWZCVkttZFlMbDZKOEZLOWk2QzFkUStodWt3dytvUXc1TVJnclhxTU1HVEFYS25hK1VSZ0xYalMybmtkZUg5TjJNRWw5TGpDQ3VKNHhNTXFSNDFhRWVDaFZSNlAzMkhSUGtBKzY5TUVxd1hvd0RyNlJxMXczS2lrWm5DZHE2bXE5UDRIUktwNEF6Q1RDcDRFQ0Y4ajFuRXk2VXpjd2l6bVpWNVRMZFFhaXh3K2tXYzR0T05GUEhncXNuRk12THdscVI5NnZWYytnakFTSzc0cXFQNDNTcVp6TjBBVWR6cUhtbzNibitVbUVDZUgrcThQUjloSW5jeXpyQjBIN1p6dGJxRXUxdlVzVXN5ekZFOUFSK1pUZW5zWkNKTjdSWk1FeSt2RVV6akRpbzlYYTdpVGloZHlKZHh4elJYR0M3Z1RpbFNtcHpFSFZXam5Jb2NwMzZSYXVDT0pKWFA1d3BjbjBpUllDUENLMm4rMnlIUERZclBsZ3lCbStYWklrL3JHZG5ibjN5Tzc5dVhYL0xVUjN1M0svT0MzOHArL09UblAvdkdkdzk5K3kwblRyL3VONzc1dmtmUG5ubEo2cWNMKzEvNzBPV0hUMjZhdmZHcFRZYXhDZjd3MXpDVXZhL1QrMGRyMlN6ckhUWEQ0SEZ4K25TNDBSckJpa0xyTk5wY08xQjBmVnIvdW1DK2lzTGNocnVvU3ozQytlOEhkK213VjBDcHB5NHdhSmQxcVhMdnJsdnhQd3Z6Wk94WERGcTFieVQ5cndKKzVNVUdyWkkza3Y2V3F3MVYrcTVCcS95TnBIOEU1dnlicmpIVW4wamFaK1ZQOEQ0aGFQc3VGZHluL1B6Z1g1c0wzLzdUK0JOWDhxUHgxOWdXV1BoZnVKd2ZqYjhXSjBQakYyR3Q4MlpZdDc1cmcvV2RnZlhQTFFXRDVyZU40QitIdGVMM2I0STFtR0h6Qkx6K2REbWpzQmE5Qk1xelEvRFBMbnZYV09QZkNmaFB2QlRXbEJ0TS96Q1U1MmJvRHpjYkd5di9zLzdEakhEd2JiZWRXSU9sYlFaeFRzd0xtOWRSeUQxQmpnYU8yNXBIY21lZnkvWC9taWRENkdtWTBoK0gzdlAxOEdiQmZRaldsMzgzYW45LzJhNnRpZi9JZmlnWHJBMW50bkJaOXgyWWRPRHYyeWZ4SXJyOVhnWDR2N2pVSU1MRnVleG9LZE1wU2wvakx3RitFTkxmdDJXdHZzdmwwV0huWDg5djQxWjl6VFhMajdnZnZjSlFmMkU0NnR2VTRXMThRL0QvYUxPaDNyNTVyZkZoNDI4Uy9EaU1wVTlkdnRiNGMrTS9BZnVhbnladC9CM253TDhJMXQrZEFSdmZQQWYrRHFBRlF3NTZzUDFjK0cyd3hqY2Q3V09zajc4ZDByN0trWDV6QkRmK0FPd3RYakhteE4reUx2NS93cGY0K1hWTy9PM3I0aCs1dlNYOVU5N2wxOS8zcGJEL2ZwdWovKzlUclgvTjZmODFqSmZ2RlJ6cHI4RjQxZW5mQy91a3o5L2hMSDlyLzIvR3IwNUFmM1AyejVZdjNJb2Z4UGtRK3M5L2JGbWZQdWwrZThGdTJDK2VaNmpEVzlhWEg5SmhQVUF2NC9EY3QyVmo5UEpHcU9zYmY5VlE5MjlaYTd3LzNqVGVINFR4M2diOTdaVEdYK3BaRno4TTMrb1cySisvYXkyR3QyTzhJMjc2U3JzL3JqY2VOZjVPR09zdkJXSS92R1d0K2RuR3g3OHZ3RWJzNGxmRGVxRzVQVTlKK244aE1LTHpmU3ZVZHhubS96ZXRtWDR6UFh3ZjhoODZEWFZtVFhwNHFva2UzZ3JmTnd1dUwyd1EveWRRbmdsd1BibEIvQmRBLzE5OEdlei9wZjNYbzI4dkJGeDg3cngrNC9naGFLbTcyamRHUHhIL1VlaHZMN3AyWS9RWjhkOEw0LzNRc0kyLzVSejRsd0s5T3I5L1kvUVQ4WGZjWXFpbnJ6bzMvZEg0UDkxcnFKTk8vSFhvSitMLzI0V3dYbTdDMzd3dS9yV3d0dDYyeTRsLzNycjRXNkZ2RHNIemR4dWtKL2ZEdHowSzQvZmJHNlFuejlscXFQMlhHZW9IVzlaZlgydDhuSzkvQUl1N242NDVYaGhmcC9QWXVLRyszZ1hydGEzcmoxK04vN09MZ2I1QityNnRYbWMwN3ZIN2lieWhja0FuSHBQNm5uckRtenpycS9Hbm9FMnZodkh5WWMveDFVeC9aZ0FYbi90dTNqait0d0RyMzZiUDNmK2Q2ZmMrNzl6alMrT3Y3R3VtbitjcXp4c0EveThkNDdHNS9kMzRmd1pmN2w4ZDY2VmZuQVAvdXpBZXZ3aDdpc2VsZlFLdU1qWFBGd3RBLzhNdmdqS3QyMzhVMVJKeGNhOTE0NlhuTHIvR0g4MFk2dm5YT01lWGQvdG8vQzhpci9uQXVkdGY0MThSNFBKci9MVytyOFpmQnZyek1uZ0d0akt2NE03WGVvOHdUVFZ1aHZYSjR5bERiZG02UWZsYndIOHQ0Ry9mSUw2Vzd4M2VJTDZXaDU3WklQNTNvYS85Rko1NUdlL2ZkZ2srTi9lSGQwSmZLOE56ZU92RzZOdW5nZjY4TjJlb2V5VDl2M1FKZlRlbi8yei8vcUNIK2VYM1hYZHVmam5pNGgrZStPSXBLNTZzNG1rcW5xRGlxZVlERHR3WENUd0Z6NHZoZWRjdVdLdGN1MmtkR3EzVTc4SzY5bDhXRE9XSCthNWpGN2ZQV3ZSV3A1T0E3L1ZPb09kZHU5YW41OXIvSHNCNGJBVDYyNjcxdjYvK2pKKzYybEExZUxadkVQK3RNNGI2bjUyR01qZUkveG1ZVHgrRitlSnl3YTgvNEYwRGk5OEFhN0ZQQWY3VjUwaGY0MzhKMG44QzFuRFBQV2Y2SE9OL29DMS9DdlJrWU5mNi9WT1gvd0g0Wm44THp4MjcxbCtmYS93ZlFmdjh5VUZEWFhDTzhqOHU4QzhIWUc4Qno0NE40ajhOYmY5NVdFTlBickI5ZmdmNU4xRCsrWFAwSDQwZmg3N3dmbmlXenBIK1BvRmZnN205SGVhTi9BYngrNkVzcjRjMVpYbFg2MXJQRy8vYjBKNTFhRTg4WC9FdU81ZC9zK0JlRGZ1RmV5NVphNzZ3L3pUK3RVQjc3aDFZYTc1dzQyZWdmMFZPd0x4OWp2R3Iwd2xEMmhmQS9uR2Z1Ykh4OGdpMDUrdmc2VEEzdHQ1N0x1RHV3dlhWQnZIZkVZZjFGWXlaK3pjNGZ0OEFiYmxRZy8zak9jYUxUdjhGc0wrK0MvQWYzQ0IrRU9iM1M2OHoxRU1ieEQrNEJkb2U2UFFyZC9HM1d2RkMvK1JqK3pUKzlrSEFyY0QrY2RkNi9VZnQwL1VOdy9ybk9taWYxNTJqZlhSYTNZQi9KK0MvU2RML2RCTVdyaC9nNzhNdjJiZE8zdXYrYmYvczV6OFB6eE1DejhEejJXZGdudmwySDllUXV4NzhQdnJvb3dzTEM2NzRFUExNajdlZVRXOTZhdnUySDIxL2NCUVBVSi9jOU41L3ZmR1BMMWZwUzJKZFcxOXpZdkR4eHg4L2RlclVQbUl1VW1jK2MvYnM2Yk5uczJmUEJpRjFkSjA1Yy9iTTZiTm5zbWZQQk0rZVVSaDQrc3paMDZmUG5zNmVQUjA4ZTFvaGJ2Yk0yZXpwczluczJXendiRlpoMU9DWnM4SFRaNFBaczhIZzJhQTZpNUo0Wjg2cTAyZFY5cXdLUXJFeFlVd2Ewb0xJZ0swd0gvdzdmZVpNOXN5WjRKa3pDck1GMStuVFowNW56NXdPbmptdHNCUVFtRDE5SnBzOWt3MmV5U29zRk9BR1Q1OEpaczhFZzJlQ0Nzb0lVYytvMDJkVTlvd0tubEVLaTR4MWdFSkRLYUZZQ211QU9VSFNrQlpFVmxnaGRNTmY5dlRwNE9uVEN1c0gyWUlybXoyZERaN09LcXd1bEFJQ2c5blR3ZURwb0lMYVE2RUE5N1RLbmxiQjAwcGhZMkJqUVd4b0RxaS93cmJCS2tGaVVHZ29wY0ttd293aGJVZ2EwbExZY2hnTWJ2Z0xack1LR3hMcUI5bUNLeGpNQmhXMEsxUVhTZ0dCV1JYTXd2akJqM1FHQzRYdERnMnRzTld4N1U1alZHd09oUjhCYTNnYVU4SkNLL3dtV0k3VG1EQW1yZkFUSWZacHpBZi9GSHd4YUVpb0gyUUxyaUIxRGtXZlg5RUhWdlFKRlgwa1JaOUJVVU1yYWtwRmphV29PUlJWV0ZHVkZCVmFVYkVVWlV5eWhHZnAyQnV4SWZqN0NuV3FQa1luK2c4cGxNaURqajJzVUlBVTEzSy9SUEQzdi8vOXA1NTY2bU1mKzloNzN2T2VoeDU2YUhsNUdRYk44UER3enAwN0w3a0VJejkyMHliMUlYalV6azNxQ3dCUkQyVTh3SG9xU3dJUEMxd1JxUFZxaHNPeENNSzVhSXowWUdKemMrTUlEd3BlVE9DWTRDMUU1MklJYTlXbE5NS0pxV2hFNnp0czRYd0l6Z3VjRkJnNzdEK0E4T2pxV0FsaFZQenoxVWJoTW9sL09hWUhjRE83L1JpK29PUFBSVU1vVHpvYW5RazU5YVNHRC9mNW5QcFNFRHhITURRWFFJaHhFUjYxNC9rUkRrMGU5VG4xcmhZay9GRE1QNHB3Ym1SNERPR3MrS01lRm9XSEQ4V29IS1BEbE05b2JQUVFwUnVaNXZ4amg2TUlaNklod3B2VCtSNGVJMzhvWnBUTE4wOTZYMk1qMDFTUE1XaG5oT1BEaHhsZjRnOUhEMUMrdzBlaVV2NnhDWVFqTStNVVBoSU5oVG05U0lUeW13cFJ2V0p6TTVUdXd1VHdZY21IeXpNeE04UGw0dlNoM2JnZEt4bUNCNlc4TTVQY1RtT1RNWEtQaVg5MGlzc3hOaDhON2VEMkpqMFhhTmNndThlMHUwOWd2MERDSDQ0ZHB2RHdUTWlQTURJOXFhSHZZazR2Y0RIakJ5N2k5RUlNUTM3czY0ZWlNZitsREFNSXh3N0hSbGcvclpvV1BiVjBzMTViTmM4d0lQcHNmVDZFcVhRamhUQXlIQnNYMk5lc1Q1ZXFOcWVUSTNkWjRzMU5jbnB6azhNeHJWOW5VSDlhOUxOKzBTTHBHNkcxR3ZTZm1ZaVNQMEE2cVlsRlpnbkNzd1A5NGRraC9aWGN3N0ZaaytKSFIrWVFUa1puS0wxcVBrZDZUU1BSUUl6Q2QvdjhBZ01DZ3dKREF2dWtQQTNNYitpUTM0ZndNRFFzN2cyaSt3WE9SUUlJSjhXTitvdGFyeEhoL2xuVUU3SERBVXcraCtKUHpqM0htUTY0blhxUkUrRFBlcEd6UlhTSG9hRVJIcHlJRWY3Y1pKVDBKU01TZjJML0pJVkhZL3RuQ0Q4MjRSZEk1WXZPenhIK1VaMGZaSHdOanB2Ukl3c1JHcGV4OFdzeHZTTUxNZFMzd2orRW13Vk9pTDdva1lVanBNZDZKQlFnR0JONFpHR0s0aTBjc2VBUmhQWFZocC8wV1dOMXY1ZitxOWFMbmRIcHhQd2E5ak1NaERpOUdLVVhnd0pRZWFTY1J3WjhYSzRCay9Sc3g0ZVBSRGpld2g3Q0g1NC95dVgxVS81VGt2NVVMT0FYL3lHcEQ4T0YyQjVuL0lTVUQ3SmZrUHJIdUQzOFBvRithWjhBdzVENGg2amMrNlhkOWt2NGZnbmZMK0dRWDVqeGZRSURXdCtYOEdkai9qNkIvUXk1UFdaandVQ1RYckM0eDJaSHVIMThleVlGVXIwbUF1SU9pRHNrN3BDNGZXSEJEd3UrdUFQaURvazdwTjJqNGg2VitCR0pINUg0NGc2SU95VHVrTGg5RXQ4M09vUlN5Nk96aHhhMEhyTFdQM2JxR1VjQWJqdlZyR2U4QmNjSE5LRFdOOVo2eHMvRmRHTkJ2OEJBaVdESVh5Ylk1OVA2dUFKOTNhY1FobnhIeWQzbnU1dGd2NForZ1lGakRNUDNNQnhGT0FwMC92M2szdTBUNkg4RndRSGZPd251OFpGTTNsek1ieklNb093ZDBESC9UVHp1L0NoYmQzZ2xVVVFaaGNsb3dJY3lkSVZLUG9NUWFRNUNwRVY0bWdmTGlBakNRcldSUWhpWkRVY1JwaW9Ka3JrN05NN3U1YVZFUWVzWjQ1cHJlQ0Z5QU9GTWJPUm9INlZ6ZEJ4bDY0NU9UZ3hkY0FybnYrbERLQnNZT2h5TlhjSDE4aU9jZzNVRXlvNk5Rdm0xSGpaeTFtclZWQXBsN2hZbTV5ZFExZzZtdzBtVXNUc0lkSnVndjhjbjBJK3ljRER2Qk4vQWNBWmw1QTdGSXY1UmRvZmZTTzZaQU1yS1RVNUhwbEZXN2hBTTFBa2VId01vSXhjT3o0VUVSbEJXYm5ZKzRFZHBpZEdaT1QvS2VkV1dNaVdVbVp1SDlyc0U2ak0vRy9DaHJGeGtMaktNTW5KSG8wTXgzREVkaU1ZaUtBTVhDY2ZtSHFkeE14ZlErcXdJby9zREVZU1ROanlBY0dKbVA0V0hZOGNDS0NzWGl4WlRXditWOUZ4bnBzWVFBdkJyL1ZlVXJZeE03cC9WK3E0b081azRXYTRnbkowNUd0YjY0TWlMbUp2cEN5SC9NYnd3Rzc2ZlllQ1VZajFYMURJNU1CYnpvL2JTWkhoc0RtWGh3dEhZNkp1by9XZkRBc2NZSHZFSkRBZ01NUndYLzNIeEgyZi9nNEovVVBBUFNub0hKYjJvK0VjbFhsVFNpMHI4cU9CSFo4ZFEreVUyTkRtQ01yNGovcUFQdFV0V2FxWEt3OWorSTVGcGJROEF6eG5DbzVPUlI2Z2Z6dmwvbDJEWWp6TEQ4ekNmb2xZQ3pGZUJ0MVA3VFViZXdYZ0JyZmUvQ2RMeCtRTU5oQW1BS0FzOEZvZ0dCQVlGaGdUMm9keng2RVFraHZLeWtmR0RoeitDK1F6UFJWQitPTElRaTZEczVtd3M1UHM0ZlllWUh4azdzM09SQ01JSmdEc2duOGpvK1BDbEFLTituMThnNit1R3g0NzhVdnE5THIxaGlkZXFQK3pRQTc0QzIzRXk0cnNheCszNFFRMzlBZ01DZ3dKREF2c0U3aGE0NTVwVHVDK0lSYTVGZDJSbTlqcUFDN0FlUjczN2NNem52L0VVclc4aXFIQTlOenNXdVJuZ1JEUWFhZ2M0TkIvdzNZTGhoK1lpdXdBZWlrUmpIUUJuWVh4MkFody9FcDIvRmRPWkhZcmNobkFzNmhQb0Z4Z1FHQlFZRXRnbnNGL2c3aTZBazNPUjJSN092NjhYODQwTngzd0V4OE1CZ2tFZjZUWG5VdzQ5V0lQbzUxYUJGd2pjTGhBRjR4QnUyMkVRZlVYOVlGenZYQ1VROVlkUkRoUDFnM0hOZFBPTXdYekRxdzJTeERCMjhIbkRoVmN6Ukgvc294ZnRZSDNJSzBRUDhnYUFmb0YweG1ZYUNtbG9DTndvVi93Y3dCOFJlTG5BZllnSDRTZ3l5dnJOSEE5cEYrcGRJeTNhREhnSmdKc0FKaVZlV3NxRjhyTjNJVDhWWUI5QTFBUkUvZTZ6a2kreVRUc0I0cUwyeXNPRzZnTjRIcmp2QTdnZDliRUJ0Z05FY2FwYkFLWUFQZ2Z3TWdBdkFKaEZpSUtDMEhDb3gzMkZ3Q3NCM2dnUWpRVWd2L0xWQUs4RHR3RUw5RUdBbTdiZ0hzWWdoaHRDWXl1M0N6USt0WmR4QlpkVHdXVGpSL3dyMlc0TE5taUhRTlFuTndBYVVJNXhnSnNFc2g2MzFtTm5HQWtEM0dlby9VZTRIWDZyd3ZWSFJRRU0zd1lROWEzUGY0VHR2ano2US9pZVVPN1JPYmIzVW9yWnZRbkwwWFdxOFBUb1Z6OS95UWYrUnAySzV6LzJyN3ZBN3hQdmVkNTNEbi8yeFBBajE1ejltZkd0SjVLWFEzbStPUFNOc1kvMi8zcjBvV2NTbWVsWC9rb2V5LzYrbC8vOG5adTZmejcwdGllM2Z1NjFEOTcrRkg3ZjIxclNhNE0rOUpMdjNuanNNMSs5WnVSUC95WDJ0Ky8vOXpkZHJ6eisvc0RIZlc2bWZ3Tm5YVDVETkVHVmFHUXEwZ1I5bWJ5LzNJSDdrRUNjYzFEYkVlVzMvNlJ2L2JNdS9ZZjgxOHV1TlN3WjVUWCtMUDdyQVJoLzQ5ZktXRkxubGc4YUJ2eUZoM2lNYkFULzAvdmgrd0wrY3plSS84ZUEvL1RMRFhYMUJ2R3YzQXpmK1hZZTZ4czVYeXBjYWFpdlhNRTYwUnRKLzluK2ZhVnVxR2tvVDEvVlVKMmRobnF5WXFoL21EYlVld0crNlNKRHZSTEMvMlFUakkwWEdLcDNBZm9lNExVZE5kUTM3amZVSTlDMkx3RC9WNkJOckpNd3ppSCs5MDhZNmllTGhub0h4THYzTmtOOURmQ0hJb1o2cUdhb0c3c005Vm9JMzlwdWYrbkhJSjhkQTRaNk9lREhwd3oxNGlyRHl3QithOVpRUHdiL3o1eHZxRGNEM3NjQi9ockUvOUw1ZG56VTMvdW4xeGlxdU1kUUQ4SjMrT2F2UWwyZ2ZMZTl5bER2Z25JOUg4cDAyeTJHNmk4QkhZWDNMM2ZBdUliODNqWm1xT04zRytvMVVOZVhqQmhxejI0WXZ6QzI3cDVwN29WMDkydnZZaTY3UnZzbExCemNoWHZqbk9mQVdRUEZnUU9yd0RWdzlsbzRhRG5GRytjK0N5ZFpLSytSRHVxRndKWitqVkM3UExBdVhSZG43N3FoOXA5VEx1RFRWZTV2Znk3OTdJUHkvWFBTdnk2dWNuOTdTdnBYUmZwWHUvU3ZMMGwvMG44ZmgvZ2ZnRDZDV3Nxb1Nmd0dlSDg5UEtnVmpIdkRqMEE0UHFqVmoydmhPNkgvNElOV0FGNjN3Zkk3LzJBTkdRejE5ZThlMkJNZWlneVBqTnJ1UkRLVnp1QlhNUlpQN3VqODBKUG16dUExbjB3OTd5YmpramM5RWJ6bTZwczJ4VDZ5OTRVUFRIL3pya3QrK05idEgzN2xmT1R4bFUyNy9yRjhnMi9IanN1Ulo3SUZmejdqa05ZMGxwNElqbi9Cb3ptOTA5ODhPSm81bHJuNTk3OXphZUR5YTI4Si9mN2J3aTk1bmpGejI3VTM1OFo5KzNvdXVYVDdKMSs1SmR3eEdmckJEY1psUDNyNmp2dE1zd056M0k2Ni9xOHoxODJ2dUtQakhVK2FnZUFGSjY1K0tMbmptbXRlTnZES1lSOVVhS3EwKzNQLy9Za1hILy94L2Y5UXpQL3RIVnNmM3ZsQS9CbFlNbDMyeWkwb3o3SVp2L3htRlhoUTErZjcva3N2ZVZicEZ4TXZ2N01hZmRNRm03ZTk1VG5WZjM3OGcxZW5MdHp6OU4yYm52emtOZGV1dmpJUXV2a0hWNzc0c3Y4NmUycVRNbjU0NnRTcGh6RTNFOWNVcDliUGo5dnYxdUQxbjBvK3NuM2ZmUGIyVi8zVjBLWWQ3ZW11WC8zMlM3OTEwNEhYL01xMjEvL050dEUzbXAvK2Y1SHRsL3o1RFpPL2NiR3g3OHJ2bnRkVXEvU0RWbnBMVHpUbGcvVXhOOUplRnh2RnM0K3J4NDJCeC9mdG04RTA0ZU52Rzk5bnArdFIvaHVPR2JRR3dSRndHWXlKemZJK0N2UEtKWWY1SGZWUHRvaC9JQSt3ekd2VEkyaExVZDR2aGJnZGdqT3dhdEE1QnY1OWRkRVFqWGRZZXdHZDlndk9kN1lhbG8ySlgzK0ExNUw0OXhXSWF3ak8xNE9HTmVmL0J5d0d1OFRmK1lmekpPNjljWitQNlNILzJlY0l4M0d3R2FqUFp1TThZL08yODdiNWZzR0U0K2txcC94V3FNTWJCZGU1aHNIOUpGcUdjTW9NaEdDZStDMFBYSysva013cGo5NjVpZFlLdUE5RkhoRmFJM2lyQTAvWDUrYVFXNFpBMS8wYWp6QTlQLy9rZnFNSkYvKzBER3ovU1hjOGZjYTg1d0YzUEswaWR0VUQ3bmhhRnVVWDQ0YVYvOE1WanEzYjZGamVEdE4vV3J4cXk0VFJsTDh6L1dOYjNQRzBmWkFGMFJWd3lzTG9mdk9URlhjNU5kOTRPZWpPVDB3eXFBTWViYVpsUlY5OTBoMm1hZWpIVnQxaGVqejVQZExVNjdFSFBkTFV0amRIL080NlhDN3dQeVB1c0NzRTludmtkNlhBK3ozQ3JoTDRONnZ1Tks4V2VDcm8vZzdYQ0x4bnE3czlyeFc0dE5VZFQ0Ly9BY252SWtmWWN3WCtnMGQ3Nm8zR2x6M0NiaEFZTGJuRGJoUzQ2MzUzV1V5Qkx6cnBEcnRKNEQ2SjU1UWYzeWt3ZkxzN3YrY0pQTzZSbjdZM2RIeVhPNnhkNEpkejdqQXhFYUltZXR6NWlma0x0UlIwaDNVSTNPelJ6em9GL256RkhYYXJ3QWZ5N3JEYmRCMGk3ckF1Z1lzZTM2RmI0TzBMN3ZiVW1pQXY5ZWlmdlFMLzN4NTNtS2JuSDd6RzNRYzFvK1g5Uys1NFdwWjRPT2N1aTdZbjlDcVBzb1FFZnNlanJmc0VQaE54bDZWZjRHemVIYWJ0QWZWNXRJdWVTYjdqVWM0OUFsL2g4UjBHZFh5UHNYbTd3S2YzdXZ2WkhRSy9NZTVPVTYvQjQ2TjJXZDRsZFA1T0NTdmY3czd2TG9FUDN1RU8yeWZ3UW8rd3NNQUZqem9NQ2Z3TlI3ekhwQ3dSQ2ZzamozbGxXT0JtajNsc1JPQi92ZEFkTmlydzNmZTd3L1RPNVVNZTlITmM0TDZRdXl3VEFyczg2TVIrZ1Z1VzNOLzlnTURQZTR4cHJhSDVVWS94RUJYNFpZOTRVd0tmNkxYamZWamFjMXJDWHBwMWwwVlV4dFdmZTR5SGd6cS9yZTU0c3dKZmM1azczcHpBSnozU25CZFkyZW9PMHhKbmY3UG9EdE5zc2hkNmxPV1F3RmRmNXY1K2V1MzU0QVAyV3VOeGFaY2pFcmJQNHhzZDFlWDBvSzEzQ3h6MUNMdEhZSFMvTyt4ZWdTOHYyOS9vMDFLVzUwdlloenphTEM3d0hSNWg5d244bVdPc1BDbHBKaVRzdHlmcytuMU53cElTOWl0NWQ5MjE0YzV2Sk56OVdodHovRTJmT3l3ajhPODk2S2RtUVFROCtxN21ZVFFTN3JBbGdXT2IzZm5sQkQ0MzdnNDdKdkRUWlhlYTJncmRveDVybTd6QW5SN3paa0hnWnpmYjlmdVd0S2UyRDNIc2ZIZmR0ZlhGSnozNmkrYTdORHpDVGdpOE0rY09xd2o4bnNlNnB5cndmbzkxbHRaRGJ6dm1YcnZWQlQ3bE1SODFCTDdWWTl3dUM3em5PbmVZbHFuOW1FZThWWUVMSG11aWt3Si96Nk1zTHhEb0w3bnJmci9BeUF2Y1lTOFUrTm90N20razlURmU3OUVudEg3Ry9nZmM4VTRKUExMWkhmWmlnWCthZGRmaEpRSnYzdWFPcDNucERZK3hvamtKRjdTN3cxNHFjTnFqbkpvWC93bVA5YTdtejMvR2c3NW9mdjFEZDdqRGZsWGc3UjdyckY4VCtCV1BiL3NLZ1M5ZWRvZTlVbURmTGU3djhPc0MzK3JSSjE0bDhHVVJkN3hYQzN6SmlqdnNOUUpYUFdpV3R1NzVWWSsxbExiMDJUdnNqcWV0aG43bmVuZCttby80WVk5Kzlub05QV2pXR3dRT0hYV0hhUjdIcEVlWTFuaDh5R1BQZkZyZ2o0THVPVUR6UXY1eHdSM3Z6UUtmVk82d3R3Z2M4ZWlEdnkzUWpOdGgzeFg2cWZrbS8rU3hwdjBkZ2FjY2E4WC9rSGdQNi9wNXJLOGZFYmpnMFQ5L1YrQUhQTUorVCtEZUY3akQzaWJ3clI1ajgrMENQN2ZrcnZzN2ROb2U5UHFkQXUvd0dBL3ZFbGp3MkZPK1crQ0ZIdnllOXdpczczV0h2VmZnaDMzMm11Z1phYzlISmV6aWtEdWU1dlY5ZGRHOXp2b0RnZmQ0ekZYdkU5andvSkdQQ1R6bEVmYUhBcC94b0V0L0pQREg3WFlkOU4vN0JmN1FvejAvSVBEakhuVHdnd0xESG4zK1F3TGY1YkhXLzJPQlYzak1PUjhXdU9DeGZ2bUl3Sjk1ckhjL0tyRG9NY2Q5VE9EUFBkWmdmeUx3MHplNzIrVlBCUjcwb0QwZkYvZ2R2M3NjYWNYYjczdU1zY2NGbnZZWUQzcHl6UGpkN1dsSTJFZDczR0diSk94R2o3bHhzNFM5MklOZWI1R3dnc2QrYzZ1RUxhNjR3N1pKMkQ4dnU4UE9rN0J2ZUlSdGw3QS84RWp6ZkFsYmxYSGsvR3ZUYVpiY1ljK1JzSCs0Mi8yTkxwQ3d4MlQ5c3MwUmRxR0UvZHU0TzgyTEpHemVzZS9mSWp6eWl5WHNyMHZ1TkhkSTJMOTdyTXN2a2JDZm5POHU1NlVTZHZVTDNlMXltWVNsUGI3UjVSTDJHbys1NmdvSit5c1AybnFsaEkzRzNXRlhTZGhqTzl6bHZGckNvajN1c0dzazdNdUw3ajUvcllTWnQ3amI3RG9KZTdNSHpYcXVoT1VkUEpZTDVEdGNMMkZqSHZQUkRSSjJLT091MzQwUzl1T2NPOHlVc0JNZVlUZEoyRjVIbjdoY3lySlR3cjdvc1daL25vUmRkWVU3elpzbDdCODk5akx0RXJiUTZXN3JXeVRzV3g1dHZVdkNmdHRqMzk4aFlXYzk2R2VuaEJrWHVjdDVxNFNwWSs1NHQwbllWUjdyM1M0SnkzVzd3N29sN0xNZWRlK1JzQmQ2aFBWSzJPYzgydG9uWWYvc01RZjRKZXl2cm5HM1MwREN0bnVzQzRJUzlzVWxkNW9oQ2J2T2c1ZW5aZDMrTHVaQnl5WHN4RDBldEZ6Q252Q0l0MW5DRmozaWJaR3duQWZkMWZKMlNZK3diUkoycDhjY2Q1NkVqWHVFYVptOVE0YzlhTG1FZmUxZWQxaWJoRVU5NGoxSHdyN29FVS9MQ203MmlIZWhoUDJtUjd5TEpPeS9EN25ETHBhd2h6emk3WkN3UGc4YWVhbUV2YUhiZzE1TFdMZEh2TXUxL09QelBlaTFoSjN5cU4rVkVuYlVvNXhYU2RoblBlcDN0WVE5dWNrZGRvMkUzZVhCTTc1V3dsYjN1c091azdDdmVOVDl1UkwyVG8rdzZ5WHN3eDVoTjBqWVgzdUVhWm5RUC9Pb255RmhNeDd0c2tuQ0NoN3hOa3ZZaFI1dHZlWC9ZKzg3d0tKSW1yK3Jad01zTEVsQVJFR0NLR0JFeFF3N2dEbG5FY0djTTJZNWxHRE80YzR6NTNEbTdKa0RuUG5PbkQzRDRSblFNMkZXREh6VnV6MHd5dzY3eTRVWHZ1ZjV0eFk3TS9XYm51cnFxdTdxbVo1cHhrdVJHRC9RRHpGcWJkREtrRWNZNzVhRXIzQ005ekRHa0NkanZGU0pzYmFjOGZvN0d2SVVqUGVtbmlGUHlYajFpa2o0Tk9QVnFDSGgwNHkzUU9yWk5lUHRrNGpMcllUem9nMTUxb3pYVEtKOGFrRm5Eb1k4Rzhhclc5K1FaOHQ0YW9ucjJUR2VwWVN1N1JuUFJXSk02Y0I0a1JKamtnS01OMDFpL09ESWVDc2w2dDJKOGFJbHhrRE9qSGRjUXM2Q2pQZXpoSnd1alBlNmh5R3ZrRkMrNG9ZOFY4WXJJOEVyekhnVEplcTlDT01OSzJqSWMyTzhBeEk2YzJjOGQ0bCtzeWpqN1pUb3A2R1FqamRjd3Y4STQrMlZ1R2ZGTWQ2ZklSSSt4bmdySkhRbUYvSnNJK0ZqakZkSGdxZGt2SVlTL21EQmVHc2w3Tk9TOGZaSStJT0s4Y0lhU1BnWTR6a0VTZmdZNDMydElPRmpqRGRMUW1jMmpPY2VLdUZqakRkVW9wMndZN3ltRXY1Z3ozZ1JFbjdyd0hpcXVoTDE3c24wS1dHRGhQR0tTUERvaEhsNnRKdUVIeEhHU3g0aGNWNklqbGRGUXArRThmd2tlQnpqTlpiZ3lSaXZqUVFQNnJINFRPcDZqQmNpZFQzRzZ5aVZKNXNEbGl6UlRnanp4bjZYMElzd3g2MW9INGt5aU9hL1plY0o4OTZFYnpDTDc1VW9HTzk3TndsZllid2RFdlpwd1hpMUpkcElTOGFiTENHTGl2SGVTSlRQaXZFYVNQaVlOZU5kbFBJVnhyTm5ldEdMTVJtdm9sTENWeGp2bHNUMTdCalBycnBobnZhTTV5eHhQUWZHV3lpaGx3S00xMEhDTngwWjc3R0V6cHdZTDBEQzM1MFpMNzIyUkgvRWVHc2w1bks0TU40SkNYMFdFdXhGb3Axd1pieDZOUTF0cVREajdaZklzd2pqSFpUb1Y5d1k3NTJFdjdzTGRoWmdXSWFpakJjcUVTOTVNSjYxaEQ0OUdjK3loV0dlWG94WFEyTDg3czE0VXlUa0xNWjRjeVQ2RlIvR1d5RnhyNnM0NDhrbGRGYUM4YVlWTkpUVGwvR0N5eHVlSjh4aExTQlJkbi9HS3lMeDNLa2s0eVZLMkc0cHhndVR1SWNrekdsOXkrNmZpY2ZvWlJqdmNCSERNcFJsdk0wUzF5dkhlTWZ0REhrQmpIZEFJdjRVNXVhMmx2Q3hDb3lYSkdHREZSa3YzTmFRRjhoNHB5WGtyTVI0ZFNWc29qTGo5WkRRV1JYaGVoSjlZMVdoRDVDd2lXcENleTB4L3F2T2VJVWwrb2NhaktlUTRBVXgzaUtKOFVvdzQzVnFhc2pUTUY1UGlYdlV2S0F6aVRrTElZejNRS0o4b1l5WDB0T1FGOFo0T3lYMFdaUHhLa3ZFdE1EbWdCZG56ekNKaUVVWXo3TzNJWTlqdk4xRkRIa3l4bE5KMkpLYzhSWklqQzBVakZkTklsWlVNbDZBQk0rQzhTYVVNZVJaTXQ1d0NaNks4WTVJeUdMRmVFT2tZbFBHMnlkaDgycGhUcjJFcm0wWXI0ZkUvQkJieHJzWllzaXpZenhmQ1o0OTQ2a2xiRW1ZMzE5SG90MHR3SGlmSmViM09ETGVGNG54aWhQamhVajR0TE9nRjRuMnBTRGpMYXBteUhOaHZCZk01c1gzS2dzeG5rdDF3L05jR1crSHhKZ0UySHNMUlZvTGxwbGxvY0w3RFg0U1BJN3h6aXFGWTFuU3lCaXZlRC9EOCtTTTV6dlE4RHdGNDUyV3lGUEplQ29KV1lSM0x3NHFzNDRKeVpMeFZxc004NlFMU0ZHZVQwZERIbUc4bXlNTWVSempsZXduVVhiRzIxblRrQ2NYZUJMbFV6QWVhQ1RLem5pZFJobnlMQmh2a3E4aHo1THh1Z1FZOGxTTTE5TFNrR2ZGZUsrK00rUlpNMTZDeFBYVWpEZmF6WkJudzNqMVhReDV0b3ozdnBVaHo0N3hpa3ZveFo3eExnWksxRzJDN3AyWjV2V3piTUtOUGJNaGpQZlRTRU43NFJpdlhoMURIa3pTSGR1b2xPZ0RHTzlPTllrK2dQRktONURvQXlicHJ0ZGFKS2NmazFQT2VOc1VocklvR08rc3ZTRlB5WGlmWWd4NUZvdzNxWDhXTDBEUWk3M3VkMGhMSFU4Y2cxa3grU0tZWGk0em16cks1dEFlWjdZU0gwM1h6ZFp0djJYbnpHTy9SMW43R3NuT2VjcnkyQkdnbi9kUnR1L0M2dHhIVGNCQnJkc2Uxa3ozdXp0SXYyekNHbEtVNkRORytuNklEZHVtcGFKakREb0hRL3RPUCtqZUVhSHorZWo3SURRbitpNkczbmZTMGU4bjBYdkU2V2hLQndCcTBja2Vvekh1YTQ4eGZCczhwc0g0b2l6MkhhV3dqZmRBZWR4QVB4Rk9KbGNvTFd0dHdyUHh2SklhdzdwWUpkb2VxZFN0UFJRd1ZQY091YUI3T205bEF5dlhSaEYrRkxZOVk3RXUvVmo1UW16MFduV1dVbW9LNzYzRVpzUEQyK3p5Nk41M0Z0NVRla0MvK1krK0VNRDBBeXJ4VzZscHZJQVgzdnRwd2VadkJVRk9LUVh4TDBOck1DelhuY0FiNWtmR3ZoZGVnT0Yzb3E5ZW1wR0Z6Mmw5QXdlR0QrRUpQQk90YjVEVCtqTUN2Z0RhNUFtL0xMeitSM0lOOFM1dENOaTB5Y0p6T2VRdjZLWWR0dDJiMjRueTU0emoxNkUveFlqeGN1UDRQemdDYWExRmVFOXB2Q1BEOThEMnUwUTlFVDdCZUhuRHV4S28xRldFMTZzeHcvcGFqdmF6YjVBWUw3MGVqcEIvYVd3YktzdkVlT24xY0FUNWw1WkcvYmNVNDBNazhhNE1UOWUzV1ROTmpFK1F4QXYyU2VlUVhhc2t4b3NMYkNqL2J5MElYSytpaC9jMGhuZEJlMXMrV0ErZllBenZZVVZnbm1jV1BxZjFPZ1Q5Vy9ZZzBLeFZGdDR6QjN4aGh0L0MydThReUNsbCtTL0Z6c1I0cXJXYmFmOTFZUGlTR0dmWWl1ek5tUDlTZkNxT3o2NFdNcy9lS0g0MjJnUGYzN1IraFB5ZjQzanN1SGo5cFlTYzlVbnh0YkQ5cm0rR3ZRbjQ3M0FjdkhhQVh2M2FHOE92dy9hcTJ3RFQ5bVBGOElEMm82bXRodytSd25zTCtrSGQxTVg4WjBsMUU3cHpNdXVYWXFkbWs5OVkrMHp4em5ZRTdFVDRuTnJEYWd5ZlVoanJkNEJwZXhEeVQyRDNEdWc3UDBxUVNsbnRJVTNCR0hPTWFVaTA3eWpRTTlWNldIMTdvSWxIZXhzK250QmhmcmF5NnVjdnZJL3IwWWZBZExTZktEUHhaMUVlRjZ5dmFFbDhsanlaeXpDd3RUUzZtY2hmd0lld2NYc3ZFL2tMUjBKWVcwdmYrVEVIUHhEdDdYUWNnZmxFWEZjcDlIVTNOSnlYSjlsdlhVR2ZYQWtDRnRNSkxEYkVBL3RldXg1K0Q4Yk5TeEcvbkVpdHFjbSs3eDdTUEVUQTE1YWpqeUYrTmNON1NPRmhWaVkrQS9WL0Vkdi9kUXl2N3dZUzlvQ3hlbDBQb24xSHdsQS9XZCtIRWZCTnNieExFSjhBNHZLK3pWRS82UVRiZE1TUGs4emZVSjVEcnRqbVlqc3Q1OHpEVjJCenppeE40SVVqMVJsZWJTYmVsK0h0emNTN01ieVRtZmg5Yko1RklUUHhqUm5lelV4OEE0YjNOQlBmamNudll5YStEc1A3bVlrdnhzWkl3dmVVVE9GcjRWaHBBZmEvZ2N4UmpMWFBGQnZ0a0lVdzFaNVQvT1ZJQWdORjhaS3g5cG5pejJOOFBrNFVueHVMVHlqK0ZNWUNGNmRtNFhPS3p3WDhKb1crL0o0bThJc0c2dU5EVE9DRHNQOTlPeWxMbmdRVCtDYXgrdm5ySzlRUVB3VGJrOGpKb3Y0NmgvaGZ3Q3N3OXZjVDQzT0kvd1g4Mm16bHpXbjhJdUI3QjJURDJ4dkhOOEcremxjY2oza2F4NWZIanFpYmx3Z2ZZaHd2YjVkTm5nVGplR0U5c2FvbS9JdCtmeUUzNjRrSmVIUFhFeFB3NXE0bkp1RE5YVTlNd05QMXhLNkk0dTJjMWhNVDhQY3hIb3YxMEswL2JVNS9KS3huV0V0Zk1RYnlGNGJjcldjbzRNMWR6MURBbTd1ZW9ZQTNkejFEQVcvdWVvWUMzdHoxREFXOHVlc1pDbmk2bnVHcEVtSzg5SHFHQW41RFVSMTJHaGlQRDRXOWoreStaRDlpSGo0RjVhLy9uVzY5Y0hQaWpYSFdPdFEyeWZ3Tis2OWZHK01ZWXl5QnZTUzdMZWpMSTl5L3VvVDRNNGhQa3NUcmovZHBtb0R0N2Y2SmFIY201Qkh3dFZIM1g0dnExanVudHJaUXV4ekpFeUZPTmZDWG0raGZ0NHJxMW12UHRtU3JKUDQ0MWxsR0RjUkx0bGRaNVhWZ1dMcGVuM3NMc1QxSXl5L2dROVFFZXBZeTdZOENmZ0xpaDRyd09mbWpnTzhyMDIvZmpNWFBGSi9RV3grdk1JR3ZnTG81STdwZnBEU0Jkd3dsd0tIKzZUdVU1dWovR2JhM05lb1M3VHVRNXVBL0lENGM4YXZOeEhNb3orQzZ1bnU0NXVCVmlBOHNxbHMvM2h6OGJpenpXR3pmRnB1d0gwZUd2VlBldlA1SXdFOVFteGNmQ3ZqV3JmWHhPZG1QZ0c5dnB2MEkrRjQxOVBFV0p2RFo3UzJuOWwvQWQ4bVd2NVVKL0tRbSt2aWM0bFVCWDMya1B0N0JCTDVyTlgxOFFSUDRRWjMxOGJZbThEMVIvNzFFNjIrYndtL0cvbjJGeUIrZFRPQ3ZaN08zQkJQNHVVSi9BZWIxRjNld2ZoVWN4dW5NMEhLeW53SU1POTZSd1BQeHB0dERBYThLSTlCS0ZNL2taTThDdnFFZmdWVHgvVUFqOFQvRlQyYitzdHlFL3dwN3ZidmhHS1lqMGI2RGE2ci9wZGdEZHViNXU0QWYzTUk4Znhmd1JiTDVpN0grZ3VKblloMHZyVUMwNzloSzM2K2p5U2Z6L3N6Z01ybkRoOVhSclpjZUloMDhnUGgrUHNXRzB6Nnlvbm4yUVBIT09INngwcGpYUDFMOHBpQjkvUmdiTDFOOHcrWTQvbTF1T2w0VjhOZkxFdmhsZWhiZTJIaVo0aFVOOU9VSk1ZSG4rbWUzbndTaitGSFp4bzlpdEJTK2NHUzIvSTM0QzhYM1FIdjRJdjdlbzVIeEw4WFhSdXdhMGYwSFkrTmZpai9zbGswZUkrTmZpdmZBc2U5NjBmakYyUGlVNHRNUlgxR01Oekplb1BnOWFHK1hLNHZ4MHMrYkJMeGRRd0x6cXVDWU1Mc3FzK0VGZittR1Bya1QyNnNiWnVJdEVKdU0rZDgyRTIrTjhxd3NTTWZaNXVHanl0TFlpc0JqaGpmMnZJYW1LeEZvLzVNSVBETXoveDhaS3RBRVhvai94NVRXb2E2WUdDODRNT3hwcksrUTB1YkY1eFJQbnhlTUVPR050YmNVWDExQklFMTAvOGRZKzBQeHRiQi82U0hLMzFoOFR2R2RsT2d6UE5xREdlV2x5WTg5MzA4emtGMGZMeHlaMFlQQTNTa0Uza3JpTTVPMlBhZFlHay91SzJlZVBpbCtxVE9CQWM3bTZaUGltMk5mdWluUVBIMVNmRUdNcitwMDFpbkhIUDMwOGlWZ1c0bUEzRXo4ZEl4bDdKd0lYREFUZjljSHgwZEkyMWo4WUhoTzF2MGZpcVh4LzlVbXB2WHB5UENQTUVaeHhoalVVbEllenlUZGIwQm0vK3VQOXFuRW1PTVVaNTcvM2tWL240MXRrTnBFZVlWdnhZN0JlT01VNHUzTnhCOWg4ZFVaSnMrU0hPNlB1V0pIc2creGcwVGZtckF5aWdjdFhoT25qemRtUHhSZmlLMUVmTUdrUEtERjVrWWVpdjhUL2ZHc0s0NDNUY1NUd3JkcExkQ1d5eVBkTnRQZUlrb1E2RTd2a1ptSkg0ajFPd1VyOTRHWitGWG82MFhSWHg0enZJMFJmQlZzYTQ4Z2ZnbmlqNEhwL0NsK0IrTDNJLzZVbWZoRGlPK00rRE5tNGhjaWZqVGlMNEJwKzZmNGpZaXZqdmdVTS9OZmdtM1FZSlY1N1NIRld6VWw4RUowdjlGWWUwanhvZGdldmhIZDN6Wm16eFJQNzduNCtKalh2MUE4blY4MFZ6VCtNamJmZytMbjJCSndDTXZDRzd0ZlJQRzBQVStTWitHTjNTK2krTUk0dG5nZm40WFA2WDZDZ0orSCtvOFQ2Y2RVL2NwUi82dEVlSlVKdkFyeEowWDRuTzQvQ0hpTlhMOTlNT1V2bTdJL0R5TEc4WXV4dkw5MnlaSkhieTZrQlA0ZzloWE5jVHppeFB6M21SNCtUZnVjUHluamo4eitvZ0hLNzRmNFFnemZ3Tlk0dmhCZW96N0c4MjVDZTJKRWZwcCt4dkg0VFUrTWgwMDhENkw5UlFPMG5aL1FubTI4TVA0eEU3OE80MkVONG0rYmlTK0U0MnRlTlA4cUxZZjJYTUEzUVBzLzRtSGEzd1c4SFk3dnFwazVINHppbzlFZm40anlOelorcFBpcUdKOTBLNXFGOXpTQnI0MzJsaWg2M2xmSUJENEJ4OWJYUlBJRW1NQjNSMzA2b3pGNGtwemlINXJzTSsyblZCdTBON1JSSDhuK1NFaFo5eE9PSW5ZUGx0ZVA0VjMxY0liMjFvbk9RY1R4V21sSmVRenh6ekZXU2hpb1crUExuUDV4Q3BhMUErYi96QVJla0xNWXV4OFlLT2t2Tk9ublB3d0J2VVpqUFRPOG54N1djSDV2TXJzWFVwVmxuV0VrUHFIcE5YdTJrRWFNNDRWMjhnN0R2elVUbjRKOVkzZ0JBaCtKcnUvU3h3dnpmMUpxQ3ZMM1p2SGhhalB2disydzBLSG9iVnlWSkY1N25acldERHVmNFJOTTRLbXRVK3dlRnB1ZklnYjMvNFdrZC8vL0JNT2YwY05iaHVTRW44L3VUZEp2U0J2YVoxYjlDdXNUSkhsakxJTVVSQ1RuWDJYaTZYaGhZek1DalVZUWFESENkTHdoNEdsOCs2YTc2WGhEd0I4UEp0Qm1pT240UWNBWHFVK2cwbERUOFlPQVA0UDVkeFRsbjFQOElPQ3ZJYjZ2Q0cvc2VRVEZuOEx4eTlrYXB0dG5BVjhTeHhmbFJkOXB6eWwrRVBBWFVQZVZSTjl1Ti9iOGd1SVBqOG9kUGgzeHoyT3o4TlltOEhNUkd5cktQNmY1bGdKK0dlSzNpL0kzOXJ5RDRnZDhoL0hWVVBQeHFkMXpaMisyR0c4OHdzNGl4QXo3RDJxZU8vdW4rTnpZUDhXdmp6WGYvaW4rMUFqejdaL2ljMlAvRko4Yis2ZjRRQndQMWlocm52MVRmQWUwL1daMXpMTi9pdStFRFhPZ2xYbjJUUEdMWWpDR2l6SFBuaW5lQ1dPTzU2UE1zMmVLYjR5MjMwNWsvem5GNXdLK0ZaWjNvbTBXM3Rqek9JcS9qL1l3WElUUEtUNFg4TVd3ckdWRTVUWDJ2SkxpczdjbnhwNVhVcnduNnIrTWFOMmhBaWJ3dWZGSHJYL1Z5WjA5ckZQbHpoNEs1dEllSG8zS25UMWNHSlU3ZStodG16dDdpTExOblQxa2IvOU4xZS91U0FMSlNMVWsyME9hc3ZDZWlPL1JqOEFmdzdMeTEwLzYrWHZtc3YzMHpHWDdTZkVmZTJOOExwTEhXUHRKOGJtSkh6eHoyWDU2NXJMOXBQZ0dXTjRUb3ZlRGpMV2ZGUDhEOWwrclJma2I4eGVLOSs1RFlKc0liOHhmS0g0Mit2b2lrYjhiOHhmUFhQbzd4VHZYejExNU8vQzVLMjkvUG5mbFBSVkI0QUZTUFdKNnZzMFhpZmhXUCtublQvSERGZGhuekRMUC9pbmVEK3VYbTJtZVByOUl4RCttNUhsVUwzZnkyTmZQblR4dU9OQ3NpTlRJREgyZXlhVStLWjdPZjBpeU0wOStpbCtMQS8wdGZ1YkpUL0cxTWUrMm92eU56VitpK1BzWSszaUxubWNaYTM4b3ZqSG0zVm1VdjdIMmgrSy94N0hGQXRINHdsajdjeWFYOWtEeDlOdU5zVWh5QTEzcTQ0VWp6VEIyYm8wMjFNeEUvUXI5VGdENjJBeWtYWkx6ZWJMd1JSaDJRN2I1QThicWkrTDN0dExIRzdNSGlyZWhNVGZTcEJ6bHA4a3poTFl6Rkh0Z0lNb2ZhVnFmQXQ2L0FkWnhRZFAyS2VEamF1S1lwNXRwK3hUdzF4Q2YwTTIwZlFyNGU0anYzdGkwZlFyNHh1aVA2V0RhUGdWODhTQUNZem5UOWluZ3I1VEhNYkRJSDNQcUh6UExpL3FmR21HNnZ4RHd6aGdyN1NoRmdMN1NRbU14dy90Rk9qek5pMktIc0hjRjVETHozamVjU0orUjFDVVFJTXV1Ry8za3pYNTcwYlcra1FJbDM4Zk1rc2ViWVJQcTZ0dHpUdmZIQkx5NTh6OEZ2RzlwOC94RndKOXJhcDQvQ3ZqWERoaERGTUJ4bTh6WS9kczBudUlwTnVzN0lhYmxwL2lqYnViTFQvSHoyYjN0T2NUNGV2SEM4OU5WYks1QkdxZkQ1eVIvNXYxUE5uWVpLVE9PRjY3OUZPMzVQVkpWbVhGNUJKNEYxcGNqVWl1ajdaVlRpQ1BEMmpZeXBwK3NKT0RETFkzVnJ5RitVRDk5ZkU2dkdRdjRzR3o0SE82Qlp1SWZaSHQvTFNjZkUvQWpTaENZZ0ZUUGhEOEs2MFA2NFBneHFTdkdKeWJ3d2xxVEhOcHlIU1M2SmhrZEMrYlVuZ2puM2NUMnYwdERvbDN6empwN3B0cWtqKzlkaE1CUXBGNnl6UHZiOFZKNFFmN1ZYaGpmSWsweWdSZXVYWmpONXhuS0trcWlqOCtnNzRNWFlOakxHdXlEZlUzM1h3SmVpUVBIcFdyVC9aZUF2MXFid05zZzAvMlJnSitFL3ZzVSs0dFJNcW5uQlZuNkYvekZFZHVnNmVnc0NRemZFYVJTUkVqT3ZtYzgwZnNyUWgva3lYNlpQQWx0V3JlbXl6V0dCRmFzV0hIamhnMGxpOWYvbmk2TjYrbCtjcERid2dVTFhJZGRyTzJDR0dlbkd0c2RmL0NwWDZDQWd3TU5rK3p0N2V6c1p0NnZhdHV4Wm96TjJUTm4xRFpIQTlRSEhxKzBMdFBOeXhyenNWb2RIV3cxWmNrTlZjZXdXRldENzMxVTIyOWZ0cHc4YVpMbGVQc3dLb3JsNkxSa2kwa1RKMXBZRG10bWNXcVFtMFVkelZQbHRoVUhsUmE5WnlsNzl1aWg3QmF0VVU3c1hFaDUwZVd0b3NQUWl3cGw1RGFGeTQ1WkN1c3VneFVvajZMa3lHcUtGbnVMS3BRS2hlSjRrMmR5ZnVJVmVjQ0tRL0tHczliS3NReHl6K1RSOG9nWHZlWHpUN2FSMTY1VlM5NHFxb0s4cHFXWFhCRnFyMTAyUmM2bnlmaVBLYkxLSlM3SmpoMDlLck03ODdOc1hQVjFza3RXaTJRUHFzNlEzVXRLbEJWYk5reFc1VUp2MlkxbUhXVFAzVnZLeGdYV2sxMmVIU3hEWGNrOEMvckxLbFQxa0huUGM1WWRDMURMNURLWjdJbDFPamU3L2l1dTNQN0huRG9xaFJ0YjVnWW5LM09CVTBlYzRzcHNTK0tVNWZkeGRYL2Z6cUYrdUcvTFYzSE9CeGR6VjlOLzVQeWpabkkyZjB6aXhvNFp3ODJ2UFlycjZqdWNrL2xHYzh0cjl1SDZqT3JHemIvUWdldkRSM0FsVHJYa0N2VnB3bUU5Y0svZTErUm1wV2k0YXluVnVESWZBamxac1FEdVROZFNuR3hmQ2E2WXR6ZTNaYWs3VjdLc0srZDl3WW56SG1mUEhhaXY1c1o2V25JT2x2UXRiZUJlV1h3aFl6dytrbloxM2hMUFVXbGtWTkl6VXNUeENkazg1Q0g1ODk0OU1yRDlYV0w1NkhmU0kvWTZDWE8vUWlKK3UwQjZqejlMeWpmOGxReDJPMGxlZlR4S0JxVWtrWDJYRHBIdnorOG54Njd0SVc2UGQ1SHVzaDJrbjk5V3dvVnZJaDltckNkRkx2eEV3Z3F2SmlIOVY1Qy9UaTBsem1VV0U3UXIwc3gySHJHZk9vZjhiUGM5Y1YwOGs3Z0dUQ2V6ZjV0Q09nMllSTG9VbWtCR25oNUx4aVFta2s0aDhlU2RZalR4dXZRZE9iMTZKRGsvZWpncDFING9tUlEybUNqTFJwTVJIZ1BJTHdYN2tYT09mY2lZZ3IzSXlhSTl5SVRTM2NnNnZndHhhZHVKSEJ6V2dZeWRIMFhDazlvUm4rZHR5WldpNFFUdGgvdzRxeVdKdjlDY2NNN05pSFdISm1UeXhrYWs3OWNHWkZuTCtzUjVTMTF5U0YySFRCeFlpM1M5RmtiQ1FrT0owemFlblBIV2tNZ0ZRV1NIWXcxeWRIWTFNc2F4S2ttWlg1bGM4S3BFNm15cFNDcHBLcERaRndOSW8xN2xTSHV1TFBsNVdXblNNS1FVY1h6Z1Q3aXBma1JkeVpmNC9WbWNvRCtRWHJXTGtaalBYbVRRTGs5U0w5cUR2QzFibFBSTmN5TnJkaFVoODJJTGsycTFYY2tZaDBLa2QwcEI4bWk3TTNrMTNvbU1pWElrTXlzVklPaURoSHRwUjhMUDJ4THJIVGJFZVo2YURJeXpKZzY5ck1qYmxpcmlFR1pKT2xld0lIZDlsQ1RCVlVIQzdPWEVUU1VqS2psSE9FSU1ReHg3RnpkUEg3OVNaUU1xVnE1YVBVZ1RFbGFyVHIwR2pSbzNiZGFpVmV2d3R1MGlvenAwN05TbGE3Y2VQWHYxN3R1di80Q0IwWU9IREIwMmZNVEltTzlpUjQyT2kwOUlIRE4yM1BnSkV5ZE5uakoxMnZRWk0yZk5tdjM5RDNOK25EdHYzdndGQ3hjdFhyeGs2YkxseTFlc1hMVjY5WnFmMXE1YnQzN0R4bzJiTm0vWnNuWGJ0dTA3ZHU3YzlmUHUzWHYyN3QyM2YvK0Jnd2NQSFQ1OEpDa3ArWmRmamg0N2R2ekVpWk9uVHAzKzlkZmZ6cHc1ZS9iYytmTVhMbHk4ZE9ueWxTdFhyMTY3ZnYzR2padS8vMzdyMXUzYmQrN2UvZU9QbEpSN2YvNTUvLzZEQnc4ZlBVcE5mZno0eVpPL25qNTk5dXo1OHhjdlhyNU1TM3YxK3ZXYk4yL2Z2bnYzL3YySER4OC9mdnFVbnY3NTg1Y3ZYNzkrbysrcXBwQWtXWUpGaUxYVUw2V1JrQWJHZnJOM1VFMmpodzJwMTcxenQ1emltREVuT0ppR3RCeHAxa2tPdGlHbDBOL2IrSXNVY0NmSEZ3ZTBLWVRJb1JQU2NpUlBEa21HcEVCU0lUa2dlU0dGSWlVaUVRV1NFa2wvRkNLTW5SV3NiNkJ4Z25ZOEFycitrSTRyYVBjcmZKdU0zdk9sL1RPOWwwdlhHS01Qc1pPUXNQT0RYNUNPSXRINWI4ZVJUaURSbDhUby9MYlRTTDhpL1laRTU2K2RSYXFJTVJEdFJCS1NkTjhUTTVYR0t3ak1yRXEwY2hxTFZ3MWpjZk9TRlRpQkh3UkovbHBsZTd2b2I2VmtUa2NzVWQzVHNsaUx5TWJCd2RGWkFCQUxyQXNyUEs2R2dsQVdLa01WcUlyUllBdllndm85aFRyOUZTN0JYL0FXM3NGNytBQ2ZxRXBJYS9vTk52eXRDRDFnSWRVemJpZHAveGJXL2kwRVhSQ3RHK0I0d2l5NEFxL2dLM3lEREMyWHcrZzBCRWJCZm5nQ1g3Ukg2UDJWb3RBZGEvWWRvdlNVanVlSFFDZElnT1ZvQXltR0ZZTDJabzJTVjRKOWNBNnV3ZTl3Qi82QWUzQWZIc0JEZUFTcDhCaXY4aGM4aFdmd0hGN0FTL1NqVi9BYTNtU1c2Q09XS1IwK295U1pFdXJsWHhxYVFEK0loemtvd1ViVXluYllpWEllUjZzN2hTVS9EeGZnTWw3M090ekFhOStHdTNqdFAvRnFiekh2cjZ5OFJLdGRKM0FCRC9CRlNjT2dHVFRIeUtzdmpJU3hNQU0xdUFhMm92ekgwR3F2b3Z3UG1LeFV3cy9hSER3Z0VPdWxIdFRIODdxZ3pudENERXlHNlRBVHZvY2ZZQWtzaFJVbzEwRTgvNXhXbnF1b3FYdFkvaGRhS1hReUtNQVpDa05wekNjSUdrQUV0SVAyMEJ1R3d6ak1Zejc4QkR0Z0Y5YklBU3pYWlN6Rll5ekR1MHk5aUhSQzZIY1RaZWdicjBVMVNvL0pvUVRLcm45TUNRR29xUzk2eDZ4QWcyVjlMem9tUjkzVVI4MSsxRHZtREkxUXFwZWlZNVlZVWJhR1phamZMNkw4bktBbGx2NFcxbUxXTVJucSs2MkJmSjVZUS9ySEZGQU95NnN2bnhxQ1VRdmlZd29vaExyZmhGY1E0K3loRG14QUxZaVBPYUN0ckVINVBvdGtkb2Vtc0JqclU4SzIvaS9sUHBIRjZHbHBXQmVDZDlsQU1Xd2hHZ3E2SlRLME9qWDZXbW0wOGo0d0dpYWhmUzlGejkyTC9uVWV6MDNCTnVFNXRnRnYwTDRsdlorRVlHdVRwTjBxaGZhV2dPZGV6YW81WXFvOUtvczJYd0c5dkJyd2FOVnRZVEI2MTI3MHpGdm9qOC9RWHQ3ajliN29Xamt5ay9acDJkcWJXdGc2ZEVlL25JeVdmZ2l2L0Vob1NSay9Fam5ic0FXNmlONm15L0dEcmhWbGZDLzA4UHJvMzcyMHZqMGJ5NzRPMjRiOTJIT2V3dGJoQ3R6RTgyamJRRDM4QldyeXRiYXQrcWlWS2tzSGplbkt1OXIyZXgrZWQ1VzFhZWtTNWEwR2tUajZINGZ0MEhMMGtYMG8yVmxzRDFPdzFYMkZ1UnJpN2JBVkxJUGFxWTF0V1JTMlpJT3hKeGlQcmVBOFBIOGRsbXd2NnZXa1Z0TGZzU1cvajNJK1F5bmZZaWsvTTYwSnRaTlpUOW55RDBNdkhBWHJVZXZYc1hRVTZZVjEwUldHd2x6TStTYVdXcXpQc1Nqdkl6ejJ5bGlQUUtxamZKZXhIekdPS2dVZFlCcHN4amFQdHNDUFdhNGZHUElyazk4Qnl6NE5NUSt3WERubnBZUWlVQXZiK1EwbzM1OW9zVzlZTGVtakxMQ2RMQVYxb1J2cVlnRmUrVEJHUDlkUWI0K3d2bDVxejlIMXVCUlhBZlU5Qlh1dlMxajdhY2o1bEMwditoVmhDMnpEZkNBVTg1dU1kbjhTclpiV285aG1LVXFCcmJnamVLR1ZOMFk3RzRjMjlqTkdDamV3dHA0aU9xc1ZWbUZlSFZEcmgxQ21COW9lN1VPbW5lbmtNbzNKYmo5eDJxTlZhZVNIdjY0UWgyV2xXMnBzbzNmUjk2eTBXaW1KeDYvcTdCVWoxMExZUjZ6SCt0RDFoVEtNTEN0aHkzQksyM3JyNUxEQ1ZpUUNWcUp2Zk15TVVpendQQjd6T1lJNitDenFEUnpRZmp1Z2YxekdzbjRSSGJkQmpkVEJmSGVqL3QrSmVuODU5ditGTWJMcWdqWjBFcVg0cUtkeEZkWk1TZFRqS1BTZUsxalBuN0wxb1BhWWF4QjB4aWpxQU1ZWHI3Qk0zL1I2T210d3hWNnNHY1lTcTdBT0htcXZySStRbzhURnNOZnRBbE5SUTlkUXgrSmFqOWYrclVRalovd3RpSkhPRSsyV05lcHpEN01mSmZqajhlc3NHdEhwYzROSW4vWVlNOGFqUGw4eGZkTCsxeGV0YlNYNjhIdDJIU3BwVWFpSjVkeUhVbjdLUEdxRjhsZkM4czNEODU5ZzZiSjZUbXJaalNFVzdmQWk2dVd6cUV3MjJ2SjB4dkxzUnd0OXExZGVTNHdHQTFpN2ZRRTk5cU9CUG4xUWlyN3dJMXJjYmZTRDlHd1JnUTMyMkZVd09rckE2T00wV3ZRYmJic2pqaU9zOEFxbHNJM3RqMjNlSHJTeXY3Q01YN0xwc3p5MllQVFhDZlh5ak9tekxyWnQ3NWw5bHNMajE1aDlLbEV2NFdpZkQxazByTURlUzROMjl3dWUrWVVobktBODlqcExVQk12TXlNNmU5UnhBN1MzclZnejcwUVN1cUQ4bmJGOFIvSDhMTWt0OEhnRmFJUGwyb0N5UFJIRlMwcU01bnpSY3Z0aGpMdGYyejZtaTJ6WEJxV3J5dlJ4Q2x1aU55S2JselByYXdRRHNKZmRoZEtsb2lSZlJOWnRpZTFFY1N4TmV6eC9GWmJvRnRia1I1RnYwQnF4d3l0VXhDaHBJUFpXMjdXdG5kaktFN1IvUzZLMjZLOHo1dk0wMDkvMzR0WG90aVY2VUFJaVByRTlEeXpuTnBUbE05T25FMVNITVdqaEw1anVhSW5Mb0k2Mm9MKy9ZaWlsMWc3YllqN3JzQTFOeld3N0N1RDRySzVXTi91d2hYdkJha1NHZXZIQVhreW5sNVBZbzc1aGVkTzJoRVlmZ24xY1FWMi96Mnc3ZGY1Y25aMTNBbHVLTkpHMkZlZzNyamdLYTZqVjU4L1lVcWVpZFgvVzAyY0J0UDBnOUswRVdJMFJ6UjJVU0t4UDJvTGJZczhSa0ZrbkY5Q3VYb3ZpcFVuNlBTYlJUZ1FuNTdWL0Qybi83dFQrM2FMOXUwcjdkd25yQStsZm5jYTFmU2g1clAxN1QvdjN0dmJ2WlNZSC9YdEorL2V3OXU4TzdkLzEycjhydFgvbmEvOEdhUC9xZW1sZHZXcGpLcUtyN2JPaUhJakJ1VDlvLzg3Uy9wMnUvVHVGMVQvOSs1djI3d0h0MzIzYXYrdTBmMWRvL3k1a1dvajY5ZkNOM1g4cy9IUHhvNUhQdm50NzVrdWdiSUwxSk1kdXJqM2NHM2lHK2E2dUpGS1VqSEM2ZTFxVVdPSTQ0WmdNRTkzREprUzNRWTJiSmVRcTVYSzVRcTVRY0VpNGdidWNYRzZoUFNTbjkzTTUzVGtLaFZKN1RNRlp5T250WnUyVzlrZXBRSmhDbXdtZWk1djRJOWZtSXB5aDBKNkJPNXcyWCtHWWhWSjdybEtiSVdJNUMwRVcrbCtwNVhJMGY2VmN5MUFvWkJhVVE3L2JUdkYwQzY5SHJ5blRGWmpLU25uMFhMbUNTVUlMaldjcXRDSnE4OWZtYkprdFdWblRaRVdUU3FXeXRMYXlzYkcyVTZ0dHJHelVOalpxYTJ0TEs1V1dnenlhVkphMk5tcGJ0WjJOV2szNWFtdExheTNNeGxxWGp6cDcvcFpXdHRaMlZqYld1dHlzckMxdHJXeHQxWmdIbmt4UHNsSmx3K3Z2NDhXdDFTeHpsRktGWkcydHRoWU9xSEJIamZJZ2hPYW50bFpiMHN6dGJLeHNiYkFVS0JibXAxSmx5bzg3eU1DaVlhWjRJcDZ0elFIbHgyeHRzT2hxSzYweU1HZjZUNlZTbzRKc3RJZVlBcXpWdW4xdGxsWldhbG84T3pYTmtSNm0vMjFzYlhGYnJkYnBReWVoV3B1NTloUWJheXcvMWJBT1ltbXIwaTh4UFp0V2dscU4rVktJblRYVm5MYmdWSDlhQldtRjB3bUZOVWFQVXozUy83UTY3SFJIOEpCS0s3NzJkSldWTGEyY25WT216Wm4zNDRKNXE0YldiRkVqcWw2M2lDajljRzdybk9YYmRtemVzbnI3bG1PN1R5VHRycVVKQzZvM3JIVzc0WlBtelZnK1l4Rmt0VldHSTJmZDNXVVFQL2pOQWd0M25na2o3VitTdWN2T3pVSVQxcjZ3RFYzU25hRGJZdnRDUHV6Nk9zcVNSWWRoZWJFckM1Y1NzaFlPaVhNbWhzWExMQWZSTDJLbVZHQjRtb1NTTXVXVWdJcExhSENuWGw5QllwbUIvUk4rSlBJMmlOcEZLbVZTNlpXTENEbUpKR01FUkZ6MkxHUldWcG1sTkN5N01kWG9Gd0pBcUk2c09oSnFHc1FHSkYxZW9WYXp1Rm5WYTBRcWNla0VsbEFZN1g5MXNhQ1cvY1l0MlhYdWdaMW5sY2JkUjgvYmV2cWVZOG13aU1HVFYrNjkrRWp0V3FGZTU1RS9iRHIxUitIU3Rkc05ucmhzMTlsN05nVXJOZXN6WnZHdXN3L3NYRXVIdEJzeVk5Mnh1NDZGTkMyNmpaeTk3dkMxZ2g0Vm12WWNPVy9EYi9lZDNjdUU5aGsxZCtPeGxLTGxHM2FPbWJGbS84V0hqcTZCZGRvUG5mbFQwcTNDM3BxR25ZZlBYdnZMVFZldnFuVWlCODFjYyt3UForK0s5VG9QbTczeDJGMG45d28xMncyYnRlNzRuWUllQVdFZGgzMlAxeWprVmJIeDBBbExkNTFLY1hhckU5NW4xSThiZnJsWjJLdFNTTXRoOHplZnVWZkVPN1JqdjhSRld5N2RjeXBjcit1Z3NRdTNuYnJsWFNxNFNmdkJpN2FmZmVqaVhybnpxQ21yZGw1OFdMUkUxWWpoaVV0M25FcDFkaS9QdHg0NFkxWHkzU0lCalh1T1g3cnoyUFhIN3VVYWRCMDFiOXVKMjgrOVNnWTNhaCt6YU12NWUrNlZ3cU1uTGR4dzhNTDlRa1VEVzQyZCs5UCszeDRXRHdocDFXdjQ0dTJuSDFtNGxLaGN1M1czb1dOL1dMa2orY0lmTDIxYy9hdlVidGtsT243R2tvMEhmcnY5ekE0TEZkd2txay9jcFBscjk1MjlsMmJsN0ZPQmI5cHhRTnowSlpzUG5iM3ozTUdwZU1VYVRTTDZ4azZZdTNydjJaUTBLenZQaWpXYmQ0cE9uTEYwODZFenQ1OVpPaGV2R05xMHk2QzRLWXZXN1V5NitMdmF6cnNLM3lTODMvQ3hjOWJ1KyszV00zdEhUNStxVFNQN0RaKzBjT1ArTTdlZlc3dVZxdDRnb3ZmSWlYUFg3RHAyK2M5WFNudXZza0VOby9yR1RsNjhmdC9KYS9lc0hZdVdyb2FBbUluejErLy85ZmUvMUk3dVphdlZiZHR0NUxnNWEzYWZ2UEhFd2FWWTJhcU5vL3JFVGtCNXo5eDlidXRRcGhMZk1LTHZrSEh6Tmg0OGR5ZE5aZS91VjdWdTI1NGpKaS9jZU9qczNlZjJqajRCMVJxRjl4NCtidTdhZmIvKy9renQ0RjY1YnZNT3ZlSW0vYmg2OStrN3orM2N5bW1hZGg2U09HUFJ1bDIvWFBqamhhVnQwVEthSmgwR3hzOWN0alhwL0I4dkhZcVcxelNONmp0aTNPemxXdzZmdWYzVTF0R25USENqeUg0eFV4WnV3dnhmcUF0NGxBbHFGTmszZHNyQ2pRZk8zSGxtNCtCUnFsS2RsajBIai8wUnkzLzd1VVBCWWlXck4yay9ZUFRVUlJzT25rdEpzN1R6cmxDelpkY2hZNy9IK3JpWTh0TEczaitzZnB1T0F4TW16MTIxNTl5OVZ3NnV4UVA1aGxFOVJveWJ0WHpya1N1cGpoN2xRMXQyR3piK2h4VmJEcHk2ZXY5MUFZL0FXbTE3RG91Yjh1T3E3VlErZS9keXdZM2E5Um1CZ0cyWVg1cWRjN0VLd2ZYYmRCNHdJbkg2MWhPL1AwOEhlajlRcHYwblo3OW5SUzdYRGZmOTJIRUZSczYyMm1jaE5NNVdZU1F0QS9vNVZTVkdRcGFFMDAzRnM3TzBrRnVyWlp5TmxVS3Bzc1ZCV0liZFo3dDNkcy9zN3RsZHNUdG10OTF1aWQxNHUzNTJ6ZXpLMnpuWXZiQTlaYnZDZG9SdFExdDMyMmMyKzJ6RzJ6U3hjYmI1WGIxRTNVRmRWSDNMZXA1MU00eG9qbGdOdGZLMXVxR2FwS3FpZW1BNTA3SzY1WDJMcVJZVkxLNHJSeWs5bGI4b3VtRk10a1plVzM1ZmxpanprQjNrSXJoM1pEWXBRMDVEZHhSb1VVYVZqTXZmQm42ei9yYjJhNjJ2OTc3RWYzSC9jdUJ6NU9mUDZZdlROZWtwbjhaOTh2OTA3dU93ais0ZlQzd1k5TUh0dytuM0k5Lzd2Yi81YnRxNzBIY2YzMjU3Mi90dDhiZC92bG41cHV1YkVtK2V2dDd4T3ZaMTNkZE9yKysvK3ZuVjVGY2RYMVY5VmVEVnk3VHphZHZTNXFURnBuVk5hNW9XbEZZNnpTUE5LYzA2VFpGRzBpQk5qdnExeEZGTklhQlBlbTZBcDlCMFpTYU9RRVlHRGpUbytDTURSRzFjRml3RGZ6T3lXc1FNUWpJeU9DN2pHOGQ5K3lhVGZmdWFiUnFWN3R5TVREd0k5OWExMTZHc2J4azBXc2RmdlB3M2pOMDVrdkh0YXdiK0FueVRFY0J0VHY0bGc4aGxKT1BybHd5TWs3bU1yM0tTOGVWekJxZFVjQmxmMHI5eHlzL2ZPSVdTeS9qODZadk1Vc2w5UzFkdzN6NWJ5cjU5K3ZCVmxqbk5YcTRzWktIUVBzWlV1L25iZlBsZ1Y5TFZsbnpUK0g5NFh6ejBpeXhkSG1ieDBkNjJ4RmN2QVc5VDBOZEZuZUVUVWlUOWsxV1ZVZzZFV0JLaWZOZWcwb2UzVlJxOXRmd3FhMS9rUzJIZkdyS1BIRFMyVm4wc1dEcmR3azlWV0tiNjVOVDlrMXoyc1dSaGVPVlZpM1A1VnFYc056dFpock85ZjNxUllGL0Z1NUp0NWVSYlVLanlTOGJuK2xYSkI4Y083aDlBM1ZVcHQzemVvK3didEZVWnAzcmFxdDZMZDJWNy9XVlpvRVNBQzZUVmFmblVXdkZ1V01HUDZTN0Qzc3BrSHp1NnlkL2JOUTU2bFNFZnhYMlJsV2hWS0pXektXbmo0ZnlsYXRtTWpHSk4zemgrQ20zNzRiV1R2SG41KzA3UVVQWlM4YUYwMUVmeXRXQnRqL1NPL204VnZqWHR2eEJJSDFubDlwdlMzOGtmTjFkWXl5dzRVRm0xUFJ1RVExRlBoWldsblpXVGE1Q2xhd2pxb0JNQVd4OUFkM2ZLRStnenlLTGErVUlKMmpzc0tuQUVmd2pIRWZRSUdBVnhlRlRBc3ZXa0xDeXQxTGIyVG9YY3ZQMENncHAwMDdjTVlXQ0d3eENsMGxKZFFQOGRTVjJpb2ErOXZiMnpjeUYzYng4eEl5UHozemRDemZVYmZPWFlyMHhydnVld0NLZVE5aUp0UUZxSnREQ0VyckVBTUExcE1kSmNwTytSWnJEOU9VaFRSQmk2UDUveG95VkluSHJ3QUkyUVN0QnZRL0J3WVZVdzNGaWxnWHBlUEp4cHhOZUxEMDBNU3doTkNFblFJSVVrUkRXSmFoclZwRjNUb2Y1RC9BYjdqU3M4cnZCc2h4WHFiVmJiclF2dERKaFNlV0xsY1pVbVZCMWZaVnlWY2NHRDYzUnEwTFpoMi9BR0VXR1JOYnZWNkZkaHBOOTN4VHVYYWxLaFpaTld6ZHMyYk5NZ3ZHNjcrdTBidEcvUTMyK3d6ekR2WWQ0ekhXWVgrTjV4cFhxTjFRNkxROHJEbHR0Vkxqc3FEK0Y3aEhXcDNiVkJSTjNJK3BGTkl0bzBpd3BySDlLalJzK2dYa0hEQW1OTFR5azIzcU56aWNabGd0dTFEK3Bkc3EvL2dESkRTd3dxRVYxaVZPRnhSU1k1VG5OYVpMdk1mbW1CRFRiYnJRNVlKaW0zcXBaWk9lK29NYUJ1bTRhdFc3V01ER3RiUDd4ZVZNTXU5WHBYNzF0NVNPRGdLdEZWRXl1Tzg1dnJOYzI5UzdIR0pVdkdkQXJyVjJxZzM3RFNzWjRqZlVaNHhYdE44SjdxL0lQTGZLZWxyZ3NMLytTODJYNnZ6VjZydVRaVDdRcnU0QWMzYU5HcVpWU0xucHBPOVRyVjdGNi9iNzFCVllZSGpnNGNIamlzeXNUeWszMlhlTTUyNyt6VldQLzFmeUcxYTlhd05sKzF2SiszdTFPQnpBZi9BN3ExYTlXa2JtajFpbVY4UFFzN3NmZmdoZy9vMmI1TnM0WjFRbXRVS3VmbjRXS25uYjRYTnlLNlY4ZUlsazNxaFFWVkx1ZnI2YXBkdzIxQy9NakJQVHRIdHRZZDlTL203bUp2UldaTkhqTnFVTi91SGR1MmFGUW5wQnJtN0ZYWWpzeWZQV1ZjN0xDQnZidEV0V25Xb0dad2xmS2xmSnpJeWtWelpveVBqeG5TcjBlbmRxMGExOFhybFMxS05xMVpPbi9tNUxHamgwZjM2ZFlodkRrVnVvelRLWlpPSkIvY3MyUHp1bFZMRjh4SjdKVlp0QlNXbG1QYXQyL2ZqaDNySmdRWEZ3Nm1ZVHAvL3Z5SkUzdG1oZmt0WndsUis1S1RrL2ZzMlRRbHBFUWFTNGc2ZitiTW1lVGtYVFBEL1BheGxLeExGQm5xZTU0bFJKMDVmZnIwd1lQYnBvZjVKWXZTTDcvOHNuZnY1cW1odm1kWVF0VHBFeWRPSERpd2RWcFlacjM0V1ppWi9PeGMzRHk4ZlVyNCtwY3NWYnBNMlhMbHlsZW9HRmlwY3BVcTFhclhDQXJXOEh4b1dNMWF0ZXZVcmV2bjVPVWZVS2xhY0VoWTdicjFHelpxMHF4RjYvQ0l5S2dPbmJwMDc5bTdiNzhCMFlPSGpZaUpIUldYNE9maVd6R29adjJtTGNNak8zVHUxcU4zMzRGRGhzZU1pa3NjTzNIcWpObHo1aTVZdEd6VlQrczNiZG0rczVoYitkQW1FVjM3RGg0Wk4yN1M5TmsvTGxpMlp1TzJYZnNPSlowOGUvbkc3WHNQSDc5ODk5blpxM3JUenRHako4OVo4dE9XM1llT25qNS84LzdUTjU4ZGl2RnQrc1JPbmI5bSs0SGo1NjdkZmZRODNkV2pTc1BJM3NNU3BueS9jTVc2TGJ2MkhUNTE0ZnJkaDAvVDNtWFkrNFJHREVpWXRXenp2bVBuYi83NTErdDBhLzhHUFJQbWJUcHk4ZDZyREZXcHBnT21yTnAvL3Y1N3RXL2Ryckd6VnU4K2NlM0JxNitxMHMwSHpWaVhkTzFwaGtYNWR2SExqOXorb0t6WWNjS0czLzZ5S0JjZXUyanZsZWZLd002VHQxeElVMVRyTXk4cFZWRmo0TkpmM3lpcTlQemhRSW9pYU5DS2N4L2xvZDl0VFpIWGpOLzlWMlp6bVMwSngvMjEvMXJndjFoWURhZmdyb0ZUK2JOL3NkcC9xL0ZmR2xpUklzU1grSVArdjFqMkwwMzd6NHBZa2ZKRVErcVJaaVFXOVArbHNYL2xTWGt0UmtQQ1NVZlNnL1FqYWFEL1Q0Y29qL3h3TGFZakdVeEdramd5TnZzNDBkTEczdEhacFZEaEltN3VSVDA4UGIyOHZZdjUrQlF2bnNsbjkvNEVBcG5hTHFCaUVKOTA5TXo1dERjWVlXQ3Z4UkVMa011VVJNSFpnYVdGV21ZdHR5VXFwUTFucGNqc3pWVDB0cE10bmZBVThtdnRJbzB5V294cHQ3UEx5cjZkaHYzZmhJSC9TLysvSi9KLzlILzAvekhSd1NlZHUwcHZBTkNCbjNZT0plam1wOUs1cGZSZEd6cWZrcTZoUzk5N291OXF1b051TFRZdnBHSkl0TVB3QmRyckFaUkNLb05VRHFrOFVrVWsrcUNwQ2hKZEY1Qyt5MEpYbWFVQmZ5aFNUYVRhU0hXUjZpTTFSR3FNMUJTcE9WSkxKUHBpUlRoU0JGSWtVbnZRdmR2Ukdha3JFcjFUMEJPcE4xSmZwUDVJQTVFR0lRMEIraDBzd0xFV1FBeFNMR2lYK0FYNjRrd2kwbGlrOFVnVGtTWWpUVVdhampRVGFUYlNEMEMvTXd3d0Qya0JFcjF0dndScEdkSUswSzN2dXdacExlalc4YVhyOTI1RzJvcTBIV2tuMHM5SWU1RDJJUjFBT2dTNmViL0pvSnZ2UytmNjBubStkSTR2bmQ5TDUvYWVSN3FJZEJucEt0SjFwSnRJdDVEdUlQMkJkQS9wUHRKRHBGU2tKMGhQa1o0anZVUjZoZlFHNlIzU0I2UlBTSitSdm9MdS9nSzl1VUNYYktETGJ0RlBXOUZQVWRKUDl0c2cwZGVVNmV0WWprajB0VGo2cXA0ckVsMU9rNzVXUkQvcjVvVkVQMjlJUDZsUFh4dnlSNktmK0tMTEZOTFhvdW5yaWZSejdIU0pWYnBzS2wzK2dMN09ISXhFUDUwYWlrU1hVS2RMWE5KWEgrbnlhSFJKUlByS0tuMzFrSDQ2blg3aWluN1dLeHlKdmdwS1g4ZHRqMFNYYzdkaE51blBiS28xcS9QWlRPZFVUeXAyWGZycDh6Vkk5NmpjSE5vTTBtYWtUMGoxMFFtV0lMMURhbzZqbXUxSXp1Z1VvNUdlSUVVb3NVNlFhcU9USkNPRldtS2RJVFZHaDdtSjFCdkhUVitSZmtUbktZK0RwWXRJdzFBNGQxdXNVNlFZZEtZeTlsaFBTQ3ZRcVRvWFFKMmhZejFIMnVlRWRvY08xaDRIOHBYUXlSd0tZYjBoWGNXQ0hTcU1Ob1VPdDhBTmJSS2RibnhSdEZsMHZFUlAzRWJubSs2TlBIVEE5VGpJUDRST2VMVUVub3VPNklBS3FWUVM4MFJubkZ3YXI0RU8rYndzWGpNQXI0MU91YUlDeW9LT1dRWWRNNll5eW9qTzZZN09PYXc2eW80T1doNlYrYU1HeTRSTzJodWQ5R1lZbHJVV2xoa2ROUlFkTmJrZTZxSUI2Z1NkTlFLZDlVa1QxRlV6MUZrTDFCMDZiSE9zaUhkdFVLZHRVYmZ0VU1mb3RKdlJhYnVqMDNxaDA5N3JnblhSRGV1a0I5WU5EdGRVZmJDdTBIRi9Sc2Vkalk0N0NDdXhOVHB1TURxdVB6cXVLenF1RFRxdUFoMVhPd1VGSFZlQmptdURqdXVLanV1UGpodU1qdHNhSFhjUU91NXNOSUNmMFhIdm9PT3E1dU0xRnVLMUZ1TTFsK0sxbDZNTTZMVGQwV2szbzlOK1FxZXR2d2xsM1lJeWIwUFowV0czby9FNDc4VXk3Y2V5SGNReW9yT2VSV2V0ZlF6TGZnSjFnSTU2SEIyMThUblV6UVhVRVRycFYzVFNIMitnN3RCQkw2TGhEVXRCbmFKem5rYm5qSG1NdWtiSGZJaU91U0pOMS9ZbE1wK2xuNmZoMFFaRDBmWW1vdDI1b3AxbFVCdERlMHBGTy9xRXRoT1BkcEtJdG1HQmR1Q0s5WDRFNjVsZ25hWmlIY1pnZlIzQlJqUzVFWjZQT25kRi9jYjN3LzJSeUVmOWZFSTlaTkNKQlZndUM1VGY5UnBlRHh1S1JHd0VVZ3NRaUVHbjVkRVJROXNSbURpVWdPc3NBaG1iY1A4M0FxbC9FZmhrelVGOFdRNFNXM0JnTVpJRDEyVWNIRG5KQVhuTlFhcTdER0lheXVESWR6SkkzaWlEaVhkbDRPb29oL2o2Y2toT2xFUHFBVGw4K2lDSGpFbzRHQml1QUl1OUNuRDlvZ0ErVEFtSlU1U1Fla1VKTVY0V3dFZGJRQ2c2MWtRblMzRHRZd2taeVpZUTZxYUMxSkVxK0hSZEJmSFZyQ0J4aVJWWXlLM0J0YjgxSExsaERhU3VHbEwzcUNHbWxBMGNXV0VEeVlWdFllSmNXM0IxdG9QNHVYYTRidytwSyt6aFV5a0h5TmpyQUtSK0FiQzRYUUJjQnpzQ2IrMEVpV3VkSUxXT004UThjUVorWmtFSXJlb0NFeCs0Z091Y1FwQlJ4eFZDdjdwQzZ1N0M4R2xJRVlnUGRJUEVqMjVna2VRT3JsT0x3cEVJRHlDbFBTR1ZlRUhNTFM4NHN0Y2JrdEVSSjhiNWdHdlA0aERmc2dRazEvU0YxQ3ArOEttY1AyU1VLb240VW1BUlVCcGNxNVlCdmxaWlNHeFZEbEo3QlVCTVlubmdsMWFBMENNVjhmcUI0R3BiR1RKcVZJSFFBVlVoZFhVMStQUkhkWWozQ0lMRXJzRmdzVWtEcnA5NE9OSWdGTWlLTUVqOVhCTmlJbXZEa1NOMUlObXZIcGEvUHJpcUdrSjhRaU5JL3RJWVVrYzNoVSt5NXBBeG93VVFqMVpnc2FzMXVEWUpCLzU1VzBpYzNRNVNxMGRoK2RzRHY2UWpoTGJwalBydkNxNDN1a0hHOGg0UU9yQVhwSWIxZ1U5RitrRjhlbjl0VzcwZTdWU0Y3U0ZXRDRSaXU2YkNObXM5dGtYSjJMWVFiQ2Y4MGQ5VjZMT0o2SE9KMkxHcHNOUHhEeVJBUmhGSVBrOWdmUUFIcXVVY2hIcWd2V3lWZ2FxbEhOYmpRREgwaGdJU0R5bkIvNkFGcUs1WkFyR3hBdExWR2xTL3E4Ri9xQzBrVnJTSDBNSUZZSDFKSjFEMUxBakpGd3RCYVA4aW9Bb3FDdXREdkNCNXRBK1E5NzdndjZrVXFGYVZnOFE3RlNHeFExVlErUWVEZjBnWWtMVjFJYmxUWTFnZjNSTHpqSURRNVozUWozdUNxdmxBV0I4MkFrS1h4VU5pbjBuZ3YyNDJxS0lXQVpteUJramxiYURxZGdEOEM1MkV4RGFYSWJSWUNxd2Y4eHhVTVo4aDJjcUtoQWE1RWxVQmY3SitWaldTZkxBQklZdWlpSC9BUUtKS0hFTVN2NTlMRW50dkpDcnJaT0kvNmpvaHY3d2d5ZmVVM1BvVUQwNTFyQm9YT3JzVmw5dzRtbE5sVE9QV2I5akFoYlk1elNWYVBPSDhqNmxrcXU5THljaUlKaklTTTFpbVdqcFA1di9za0N5eDkwTlpxSnV0ZkwxVlZibXFSbGQ1OHM2Wjh0RFlRM0xWL0dmeTlmYnVpdVNuVFJRa1lJekMvOEZ1aGNydXVTSnhqNDh5OFVGN3BXckpmS1gvNHl0S2NyYUFSWEtMRmhickUzNndVSFc0WmhINnVyQmxjcTNPbHFyMjZ5M1hoNzJ4RFAycVVTWE9tYWJ5dDcrdFVvMHNZMFd1SkZpUjB0ZXNWSlBLV1B1blRiQk83UGVuZGFnaVJMMytsMlZxMVdaaWszeW11MDFveVRNMnFuT0J0dXVUbHRrbVc5bllrWjlIMmZtZmVtR25hdHpWUHJIUjcvYUo1MXM2cVA0NDcrQS9ya2tCY3VwOGdlU2RMUjNYTi92ZFViV3VxMVBvMFpkT3lSdmpuRlY5N1F1dXQxcFRNSFJPa0V1aXczVVgvMmxEQzZsc25WM0ppcjJ1cEduSHdpcHZWUkYvbjkxRkVqdjJjQXU5NitxK2ZzTUZkOVg1S1VXVFc5ZnpDSzJ2OGxUdE91dTVmdm1QWHNtdW5iMUp5WUJpL3JjNUgxV05tejZKelhjVy80SDIxMmlqZHRobU9tQTdHWWtCcE0wTWpBT3hiYTZHQVViWFJ3UiszTW1CUjdJTXZOd1ZzUEc2RXU1d0tyRFlhUTJudjlsQ3hZd0M4UEM4QzVTYjZRN2xPL2pBNTA2bFlmUGhTakJ2UlFoRVZHa01zdTJSVUtsbVArQkx4RVBvM0RuUThQSW1HTzExQ254UFA0SW5CVlhrY21RNU12NTVCR2xhWWpKcDN2MFFXV1Q3Z1RTZVdwbmJVMzhVRjNQb0ZMZXFvNXZzNnBZUnNvN2xic2s2OTYwcmYvcjZvTnc5S2toUnQrWUpoYXBocEhLSTJ4ZGw4WjdyTFFiZTYybzVxRjVwVlkxT01xdm5iNTVZWGIrYVlyM2dqOGZxbXE4NTIySHZ5OW5GMzQ2MlQxeDh3bUZxNVFxT2gzYnNjdXJwMWJTZy95S3VrR1BvQmRmalFmdUt6RXc2N0Q3YjRrK1BXNjE5dktkL25PRHpvYmExNzc0bE8venY5NG9yN1Z3NHV0eXlNcE1yclBEL3JWS3BwVldxdFM5K0lXaGkxN2toOVMybTFkcDVla2U5N2dQVWpiY2VYZGg4KzhxT2JXSmZSa1dXV1RDbms4dEN5eDQzUCt6dk8vYm81a0UvdTk0ZmNjUzdmWnc3eGlDRE1BNllqWDNzMXhJRXVxczVlREpDQmd0V0txQVMrbk9aYUJ1NDk4QVJ2STY2d2ZNOWZqRHMrNm9RVWE4eCtLZjNoT0lmSjBQd3lWM1F2TVJmc04yeE5MbHphUlFaLy9vdU9kMmlOYmV2MUgzTzJXbWFyTEZsSzNueUlGNFJXcmFsOHV5OE9SWS9UbE9wcW8zWWExVS9mSjFhOFd1S2JYdkhQZzdsZlJzN1hkenhnOHVoRXZXS3JFa2E1ckgrUnorZm00djcrNy9iMTZKYy8xT1BLcTM0cVZwdzU5Q28ycHVYZFdyeTg0dUl0cTR6b3JyMmRvc2IrSERzMVZFWmRHcmdPZ0l6KzhyZzFWSWw4TVhVa0J6c0RETjNGNE5YWDZwQlJ2TklJT2xUd1c3WVJSaDBwQUxoRis0bHliZjdjM2JuTzhvR3pWZ3F6NGdOVnBMZExTMW5MdjVpOWFwelcxdCs3YlFDeWNXUHU4enNIbGowVmFKVGlZelBhOHVSeGRWcjJIWHhyajlvUWxJRVAyVk0vK1MyOThjUld6bk05bEtCUTJsSENIMVJIRUtiMW9YWk5SUEE0Y01kSUhXR0VQSjlPODZCN0pYTnJuUlFFVHB6cldXbzhwemFZY2VpQXJQdEZoWW1oWWNYSjQwc0FtY3ZEYS9yc0dSVHA5Q2ZaaWNXYTE0UWptTmY0ckt2THl4NGZ3UDZUbDVPYkk1OTR6eElNNFhYVFhkVnhYNEJkbGRYcmk2MHRxZWxyLy9YMFVHeFA2ZEd1bzl3bjd4MWVablRtMmZFd3VSSHJxVGEzQTVjY01FYjhwKzdqbERkOHp2aDRDVUw5QnhXYjB6VjBlSGhuWTVFYnVVU2IvZ3FQNHpyWVBQazIrWWk4Vk9mVms3Yzg3Q1hpMnh4Y3JJNnc3WmFuL0hlcmk5bU4wd2NXV3BweFh1cVZoaFZhU0NrZ3dhUzVCcEllSTdia3pHcXhKUkVuL21jRFlaY3BqNXUwNnUyT0ZDMHVtWHYyOVhIUEErdk1ibnJqaHF5a29xZ2dOdlZnblpwUmdTNXJWb2FkUEgxOGFCdkUxNEZMZHBvSDZ6WVhESjQzQzkxZ2xzKzZoYnNNSGxNOE1SbFB3VC90bU5OOE1YRGU0T3JIemtUM0dycnZXQ25LUitDYll0YmFHNitMYURwV041RDArdDZLYzJVKzFVMUFTM3FhT1o0dE5JY3FkdEZNK05FdEdiYnZIaE5pOGlKbWs1Mk16WHpIODdWeE54YXFvbCs4WlBtUnBHdG1zK2Q5bWdjRGh6UjFQRTlwZG16OG9KbVpNbWJtamtIN21uVUxmL1MzSDMrV3FPYy9GbHoySjdqUGRvcGVaOWxWbnl6dTdaOHFZS09mR2h0Rjc1NG55TDhrTEVlL0xtWnhmaEgwMzM1b2FOSzhYeTdjcnhyaVlwODZ0M0svSUt4MWZtS2pocisrTFJRZnNUTFdueDg5WHE4Yi8rRy9Ma0pUZmlIRTVyenIvcTE0bWRVRGVkN1A0bmdhOGRIOGVtZk92QkRJanJ6VzVkMDVaTlBkT2ZQWCtuSk81enF6VjlhM3BjZjBMRS8zMHcra0g4N001cC94QTNtRDdVZndudXNHTW9mT1R1TUQzOHduTi8yY0FRLzc5SkkvdjdHR0g3STRPOTRYOTlZUHZYWFdINUpoMUY4cGZ1aitNVVJvL2xEdjR6bUozakU4WGVqNC9pTmUrTDQ4Mi9qK0JMKzhmeUUxdkg4NGUvaStia0w0dmt6TytKNXA1UHh2TnYxZUg3TS9Yait6ck40ZnZlYmVIN0t4M2orMU9kNC90clhlTjRpSTU1ZmcvUVk2U3NTUUlKSldqNXJVZms1MTQ4RjdqMFdYRG5GczNLVmdDVWZxM1NjUEtYcS9aZkthdkRyZ0dyakZoMnJOcy9PdGZyUVA3cFc5eDI3cXZyTU9mZXJmOWU4Y0EybmpZMXFmQ282dmthRjBBMDFuc1JmcTNHcmhTS29XWEt4b0VudjZnVGRpQndZVkdIYmpLQm1lOWNGbmY5eVBPajFqa2RCRHlZcWd2bFZyc0gxajVVTFBzZlZDMDRiMmlWNGFybjQ0TWZlTTRNN1BsZ1cvUFA5N2NITmZZOEhoKys2R2Z4eCtzdmdxNUV5elo3NWRwcU9vOTAwU1pZbE5mSnFWVFVOck90cUhzYTIwYXlaMEVOalVXS0VoaXM1VHZOSVBsM3pwOGRjemZIaHl6UWY1T3MxY2NkM2FEcnVQS2h4UFgxQ2t3b1hOZmRiM2RJb2pqekU4OU0wY3c2bWEzYXY0UGk0K3hiOGFFOGJmbWJyQXZ6MGVCZCs2Q0kzdnRsUFhuem9raEw4K05HbCtLVzFBbmk3dEVCKyt1aHFmTVpmd1h4YzVUQSt2RU1kM3FKekE3NXNjQlAreUt2bS9JWFJyZmwxS1czNVM2NVJ2TFYvUno3VXRncy83SFEzM2oyeUp6LzFhRzgrUnRhUFgxNWtBRzl0RTgzdnZqR0l2eEEvaE44ckc4YWY3ejZjbjdoMkJOL3AxNUc4NTRVWXZ1cis3L2k0S2JIODNMQlJmSVVIby9pUDBhUDVnMytONXFGbEhQL2R4amgrLzdzNHZuWEZlSDVEOTNpK3hveDR2dTZXZU40RzdXRC96WGkrZjJvOGIvY3FucC8ySVo3ZmpEYWcrb1o4clBkelNPbXMvdTBmY25BaGxZTnBmM0ZRNnprSEgxOXlzQTdIR2EzZWNYRHdQUWNqUDNEd0RLbnFSdzZpa1dZaHJVUGFSZWxiVGwrakFkMk5McHJZdDZyb2t3bTJMNVByZmhYYURZNG90UnNjc1ZBb1pYTGgreVJDenNMM3FpcXkzeXJzbDJlL2RnekFaL3VZRk9Ia2x2YWVJUWxGS3VzZlowL3A2dFZ2MExCUjR5Wk5telZ2MGJKVjZ6YmhiU1BhZGU3U3RWdDMrcG1BUHJydkJBeksvRkJBQUh2VVY3VmFxWExaaTltcWdtNUtueUIzNTRwRSt3NjZJSC81MFVTN0xYd2Y1bUFjeVh3M25hYWJrM1g3d2pLZWUrTjAzNFpqbnoySDczdm85b1h5KzAvVjdjdFllY3VNMXUwTDN5bmRGVWUwOXhZRlBXbW02dll0R041L3RHNWZXTmF3K0dpaWZWOWUwR2ZnVk4yK0hjTnZpOVB0V3pDQll5YnE5bzh5ZnBzUTNYNFZscC9YYUtJdG0xQXY1eWZyOXRteVBkQjFvbTcvTjNiK3BqamRmaFcyUDREeFQ3Sjk5OUc2ZCtlRityV2ZxdHNYSGd3V1p2dm5HYjlUaUc2L0NydCtueENpL1laTWxRK3lCQ3JDTkJrUnZwblRpZjVaTW9SQUhDcGoxR0FDUjJ3SkxCcEdZSUlmZ1dVNExoK0d0bnNRK1N1UlB4bjVENUUvRy9uOWtUOFdmOFB4ZHhYK3JzVGY3eEMzRzNGK2lQdU11QVE4L2dNZVg0ekh2OFBqQzNGL0RPN0hJdjhBOGcvZzhhVjRmQ1VlWDRySEorSHhlN2FDMC96N2FRVmVyejllYnp4ZVp6TmVad1R1YjhMOTRyaWZodnZMY1g4eTdvL0QvZCtvL0xFRVBpRlpIdHEwcnhySytMa2pnY01iOXQ0dGozcFJkOWR1L3pFOFZ0amV0MmtxbnQ5ZWcvZ0Qrdy9lUjB5MVR0cnRIVnR3K3lhZWE3bC8rOEdMdU8yTHh3OXMyL2ZIS053KzN4cTMxKzdlT0g4UWdVcGQ2UGJHUDg1Z1BncjZ0dGErM1R1VEVGTVE4Um56Wnk4ZWpESUVveS9zMlg3Z2NDcHVGMFVIc2R5eFllMDJ4RHlsK1cvYnVsR094eHNpL2h2aXUrSjJXY1J2Tzd4dS8zVEVMRzZCbUsyYnQ1V2c5VWRsMjdSeHN6TnVSK0gyeHUyN3RwL0JjZ2QySTlDMldlTXJSMUNHalUxMTE0MUFqRFBtWS9uYitmTXhLR2V3U3J0OXJpNGVmelpWdTMybUVPSjlwbW0zZjN1SDEwcWcrZisyZHEzVklHcHJ1UDNyMnJXbE1QOVFMTmViUVNUekc4SDAreEhDOXhSeVNxSEhBaUgwQW82bmpxSFAvNG5qKzYvWVZQb2hlYU5QZWhzNWtTVlZPb0R6TFFERmFmeTlpci9uQVFwaVk2TDBCU2l3Q01BcENXa0IwZy8vM01iK1RoSmt5djViejRGQTFkNW9YK2kvd2I3WXh0WWxVQS9iVmplc0Y3cE80N2JNNzFicTVtYkpXSkpuU3dvVFNma1BrN25UUi82cmhCMWRKWmxGNVNMeUV2NlczbFVDM0RRSzM3S2xTeFpVRlNwV28ycjVBdTdXZktDeWNIRS9yM0xCWlVvNXUxUjNzS3JvNnVNWjVGVE52b0tIbzExUld4dTFoZHFob0VKbDZ5UzN0bmRSV3RrNWoxemQ1M3FiUFNjZjM0cjI5SGx4N2xEeVZydFI3MHFlbUZqWHNVN0FPdkpqbmE4MzVpZjAzdnFoMXRUdGtSa1poNjlIVGZaMm1OWDNoMEh6djg2b0dmT1RsK1d1K2wyS0YzMGZzak1rcVhtN0RpVTJuTno5cEwxOXVXc3RuV3B4aVk5VzNEajErWExxbzdQM3ZLNVpWRGs2MGVicTIrZE83V29ybnR4Zi8zSFZ5eTgzdVlFOXB6UXFPVDJzV25wRzR2dEJFNzA3TCttdnJ2cndhNjIvRHE5ZWYvNXV3MDRORDd5UFBuams4SW00Ulg3cHZpditHaC93OG9yQ2ZaSzgyb1VyTng4dXVQWG80NmlWSHQzYmJEcFd5OXYvN2J5TWtqWFhGcHV6c2RyeUg3NGNqWWpzL3YwWjljelJiMTltWEd3L2JuelR1SFVEVXg2Vi91WlVrNnhhNFdEWlpFeGN5dytWWGxjL2RPRFM5Wkt6TDA5NHFyT3BiVFhoVkpPZS9aTTMxalR2dTJVWDZHTTE2SDcyYk9ZNkt2OXVvdlA4TUlYTURERVNjWWxTZ0ZhZWhIRmxRM05lODllY1pGOFRJNElTNy9xcWE5cVpCditORkIyR2YxYk9LZHcvVEcwUysyK210RnE3bHR5TXFUbnlyMXI2NnlrMXE5WHM1Wi9YSGhSdVdNczVoelB6UndvSTJsVHowc1gyZ3lzRXZUQ0JuREo0K3FlVmZ1UDRXS2N0ZGU5OU40Ny94bzRIRFFoZTg2MzdQbjdoQXByMjhSbEdjeEhTaGFDQ2JWS1hicFZkQ25wbEFxblI1aDhSb3R1THlIazVhYk5TYnUyL0dmOWwvYXRMamJzMDQ3L3FIYmZYL0hpdHhHUHJzZzZhRDJibEV4M3M4RmVaeEFYekJnVy96Wlc4L3pSdDAweC8vdlB5RHllMmFkTC9rL3pUcXErZHNXN0JMK0Z2cWovV096NnJSdE5GdGxhNzduOWZneldFc0lyWGoxZm94TW5TUm5MZXhMNzEzenZjYWFyVkVVV0lEZHN2VktaV3E4OWVxcENTYkgvZDIzbUxSdHoveEg4UnowaExhQitTMXBObzEvWk1vYyswUTNUYjFIaGU0bkVNcTdUcjVIcUg2TFk5a1o3ZzhRU0dkdzhoMm9FWHhkTjFnZ1Q4VWRIMml2cEVPMWU4RTlKSzNONUdTNDIwcFg1V25wdHhPNGxkZHkzRjQ0QXBBUU8xTHRFWUp5TjJKQzFmdEc1Tkc1cm53T2dzR2RyZ3RpZkswQmIzRytPMmJyQ0daYUY0Ykl5MzRYNGRlcHdHZmJnZlNyZnBnQXlQVjZQYjdLUExJWFNiZnI0TEJ5L05jYnVWVEplL0syNjNVZWp5ck1EeXBPY1dwVEpZNlBKdnlQS2h2S3IwdUZxWHB3ODlqZzE1Sit5a2VMcnRxc3UvRk4wdUNwQ0VuZDFzVmk3Ni9iUHByRndkY1AvUDBWa3l1TVhwWktaMTgzaTA3cnBWOGJyRGErcktSYmYvRW0yWGRDUndqbUUrTjljZGI0ZDVEYUVZdkg0MDdqOFFiUmREL0dJNzNmYWI1cnJqdTdBc1R6dnI1T21GaDNxaGJGVDN0RDZpY0hzV3E0dEkzTjdHdGdkRTY5WlpwZVZKeFhPVDhKcHUxSlpHNi9SQTgvZU8wNVU5aFMza1F1MHZZQmphbFV4bmYxUkYxRUpmaW81N2k0NC9FUjEzRngybjlsZUliVlA3UzJxdncwUTJScmsvWnNBTy9FMS9laDFXMHUvMVptUkFSUnlmeEdkY2dTa1kzNmJoL3JjSUF1L2UzWWFWalhBYzh1QVlOS3VwODVPbGREejA5Q3gwMG41alBBTitzU2N3cGRTZjBKZXUwMTZ5SkxUQ3NkRGR2UlBoSHA3WGNlbHkyTlNFNWd0UUhYOHY5UzRLTGloalJud3plSXI4Ymo4K2grZWh1UC94Tmt6QTgyODdCY0h6NmpwNUFyWDVUNFVuZEgvcVZOaU0rZTZkWUEzUGNFeThmdjE2NkVlUGR3TTRnWElkMnRNWGRtSTVwdUsvU1hpOGRkOXljQWpsejVnR3NBajF2cURDR1JqU2cyam4rYXpBNnp5Wit4MmNRdHpNZ3pPaE1WNm5YdkJVa09PNHZGelRwbENMVGtJNWR4SDJZTG5td0dVNFMrWER3Y2xoK3AzbEl4bndBSy9mdTNkdlNNZjlvck15b0NSZWY0ZTNOL3lFK1dTa3AwRkR6TmQ3cWpmY0hFaTBMMTFZVjhCeTNiNE5NNUgvRWZYZUh1WEp1STVaWVhsK1grTUpObmpkaElRRU9FL0xndzNEWDNJY0gyZVVnM0owbmZDTU5EaEFyOTk3Ri9SRytjOUdSWUV0amtFYXdoZzRCL1FscERUNEZhK2Y5bWdhVENwTjROR2pkT2hWRzQrbnZZTXVtTitvTDlnZVZLTnluWVhyS08vbUc0K2dBT28vRGEvM0IvSlRVTS92OFhycDZaY2dIUGRudlpnRlBsaSt5NWN2dzFGNjNkM0o4Q1BxSzJQNWQ3QVIrWjQ3TnNCMnpHZml1WFI0aDdnUmt4WkFFU3pYdG1OMzRhNmN5cE1DSEoyOGcvVTlEL0VWemxZQWQveE5UM3NFZS9ycDlERWpVTmYrYWREZWVwemRBUGJhZWo0TE0xQXYrMXRmaG5vNEp2OGgrZ2Jzdy9PQ2RnNkNZT1RIOW5vQnc2bCswaGRDSU5aUHZZdG5vQ0hxNDZUemVQZ1Y1WEYxallZdXdXaXZHZW5nUThmTkQrN0JGbHJ1QnovRFFsb3ZkemREdE5ZVEV1QUJqdHUrdm5zRUFZMm8zZ0dHb2x4OVp4U0RPOVJlMWdERVlyNFp0UUdXb1R5L1IxK0RBMWhQTHg1dmdCVjQvZm1mNTBNTHpIL3JpeGNRaWJnYjBUOUFZZ0RpWDE2Ri9kaE9aL3krRC95VldFL2plYmhJOVpmMEc5UkczN3V6L0E0b3FKNVNIa0dUMXJUOENaQklyNE1TTlVOOUhKdzVFMG9pUDdUM1BlaU8rMU5yTzhJYStsMytoTUhRRG4vZnJ1NEVaL0Q2WmFlR1F3ME5udmZ1QmNTZ2ZTMXZVUVpXNGRnMEtTa0pmdEhXeTFOb2p2bjBhWGNXTE5HdW9oTm13UUZhTCtucE1FcnJWL0hnaWZ3NlkzWkJGWlRyMHE1cHNJSTJUcWlJRjYyd1BFZHV3Si9sRWQrMUxyVEJjb2FrWElBVDZBY3Z4cnlBOHRnbXZydTdFL1pSZmFMZEpHamJoM2NnVjJoZmhnTWU4MStJOVgwRTI2T21TRVVHRStDUW1nMUJlMFVxeS9yZDExZ1BUNUNlb1oyT3c3SVVRRG5WTGVqNmhBVGFXV0xmVW9aQVNhVEdTSjJRcHFFOE1rTDAxcmtTMzZVUzdsMVlnUDRjeDV6NG5BbSt1ZWxjTE1tOFp5b2tjWXhweWZJVDV5dGVjNFB5aGZ1d25JZ3ZrK0RuOUExMXFUUThSbmMvMTFOMFRCeXpXckxyaWVXU1paTkw0SE1pUGlmQk55OFcxcVhvSE9ReWxxODVjaGtybHptcFlYbGRQZVkzK3lwV1hxZXYvQ2JYVDFRdWpzdDNjdlhSeXBYLzlQVUhwM3MrRTJLbVhQOTFpbUJycy8wczEzOXVsRjJ1bkxiLzYxUzdYODV5WmRmUi8xS3U4U04wY28zSjRmci82M29VMHB4ODJqKzJ6S2Z0YXFsODJxNmV5Q0dlRVBkL1Fqd2hqaGZFMXhYaUJYRzh3VW53YzlOdjI0N1d0YXZpWkNxT0VkL3pwWHpoWFJNaTRzc2srTG1KYzBhTjBOVmpKOUV4c2ZxRS9NVTZGTWM3eHZoS1VWbXkxNytwZEdLa1RpN3hPL2ppdUk2SXR1V2lYK0Vhd3JON3diYkV1T3puNTBhdUVZMk42MHRxVy93cnBRK3ArREczY20weVVvODUxWU81OVFnNThNMUpzaGpwZWhUTG1MMGV6S2xIWTNaZ1RrbzBVbzg1MVlPNTlXaHMyMVM2RzV2N2ZzalllQ2w3MnlyVi9wbVRaS1Avbmx3NVhkZVUzT2FtVHYxMDgyYVdpNDZaTXo0MDFwNmJHaithNmk5b09oZ3RMWmV4OC81cnVXa2E3aXN0bDZueW1ycXVLYm1ObFp1bXFJSFNjdjJYMXpWSFh4MmlpRUhmSmJaYmU4YXpnOXpaN2Q5Tm5hTjBWem5leHZCamVua3AxNmsydXF2RWF1UEMvQmRIajgybmNpMUJ1ZVRZcnM3Nkg4bVZ2Vy9MU2U0MlViciswVXQwVEJ5UFVqMXE1eCtLemhQSEdXSytUTVNYUy9DTnJTZVlQVzFyWTNqL0t6L0lWYnE5b2I3WU9vTVp3bnZpQlBUYkZrRW1CWk9CaUhCaVBvRCsrYm15cjNCRGZRazJrbDB1VHNUL3IrWFNHTkVYQjZiMUpYWGRmME91clViMGxWMHVLWDM5VjNJVnkwRmZ4dkkxcHg2TjJhYzVhVTRPK3ZxbmNobXpUM05TcFgrb3I1ejR4dXpUblBUVFA5UlhUbnhqOW1sT3FoU0laeEZpZEE1clhxUnREdmxUcnRSTytWT3V5dUdHNHpSamNXSDJjVmgyUG1lQ2IyNDZINldUeTBGMExEL0k1UjV1ZUg4MVA4aTFPMG9uVjM3VGx6emM4TDV2ZnBCckNZdFg4NXUrdnViVGRpTE5TSnhEazlDL2lKOHRpOGZWWXI1VW5DUEZOeWZGRzRrTHMrY3I1di9YY3FXYTZMZU5YZGVZWE1iMGJVNGFiaUxPK2J0eUdkTzNPZW5RQ04zN1dRazV5Q1YxdisvZnVFK1pVMHFPMXVYY0pJZHhyYkh4bnpualI1RGc1OGErMXVVd3JzMXJ1YXFZNkxkVkxEK2h2ckszcTluNTJkdlY3SHh6MCt3Mnh1T2N2SkxyYmdmaitySmkrUW41WjVjck96KzdYTm41NXFhSUNPUDZ5aXU1OW5Vd0h1ZmtsVnlCRWNiandyeVNTMlVpenNrcnUrL2F4bmhjbUZkeUxlOWdYRjk1Vlk5RklvenJLNi9rOGpReDdzaXJldnl1alhGL3pDdTVMcFhWMVdPQVNDYngrVkwzMTQzeGlRbSt1WW13ZHFLOFNDNVQ1ZjBuK2pRM1JiWXgxRmQra0d0NkIrUDZrdktuZitLdjVpYkxDT1A2eWl1NXBwaXdMNm54OGo4Wmo1dWJYcG13cjd5U0swcjduQS95M1hPK3dQSzY1Kzc1VGE2d0tOMXowZG1pWS85bGU1OTkzSjFUTzdLNGplSHoydndnVjZrb25YM2xOMzJOYjJObzkvbEJMcWNvbmQzbk4zME5hR1Bvai9sQnJyODZHUGZIZnp0ZXpTNVhUdjFVOXdqai9waFhjaDN2WU53ZjgwcXVrQWpqL3BoWGNtM3FZTndmODBvdTN3amovcGhYY3QweTBULysyODg3c3N1VlV4d1VGbTdjSC9OS3JsOU05STk1SlpkL3VIRi96Q3U1MXB2b0gvTktMdnR3NC82WVYzSlZWK0plUG56T042VXRNWGgySXp3WG9IcWtuNVNnendYb2R3MkppTTlKOExQUGw4dk96ODE4T1RzMjNoYnJNRC9JRlRreTkrOWJjZG40UklKUEpQamk4MHlsajIxemZ6OWFubzB2aytCekV2emNQT3NiL1RmdTMvOHY1T3JmWHRkT3JCQWRFL3NtMWFQMis1YWdYemVjQkY4OFIxd3V3VmVJK0VvSnZ2Q05VSnJ1aGh2T2M4OFBjblhMUVYrbThqVWxsNmx5bVpMcmFnNzZ5bXU1cnYzTjd4YVllcytDU1BCejAwNDR0OWM5ZDA4VUhSUDdtejNMVjF4ZXNiK0orYmw5NW04c1RRZzNuQStRSCtRNkZLQ3pyMjFzMzlUOUt6REJKeWI0NXQ3LytvSEZYOXRGY3YyWDl6SE5qWFBTMnhqcUt6L0lGYVBRN2VXMytDcytKSC9LOWFwVC9veFhWMGJuVDMxMTcyYzRQK2QvOGI2ZXFYUjB0TFJjUXZvdjNqTTBKOFg2U3N2MVg3NW5hRTQ2bklPKy9zbDF6WG0vMFZRYVpHTGVrSnJsSjR5SHNyZWIyZm5aMitYc2ZIUFRzN2JHNXczbGxWd24yaHZYbHkzTHp5WUh1Ykx6czh1Vm5XOXVDaldocjd5U3E1R0pjVnBlMWVOSkUrUGF2SkpyZjN2aitzcXJlcXhrUWw5NUpWZEZFL09zOHFvZXQ3UTFQczhxeitScWIxeGZlVldQL2liMGxWZHllWnFZbnlOVkQvK2tuczFOaTlvYW4yK1NWM0t0YVc5Y1gxTDE4RS9xMmR6a2FVSmZlU1hYNEh6NjNidG85bDBmVDlGSjR2TTUwVEVpd1JkaVUxa09mS256elVuYjg2bGNjL0twWE12enFWeC90akdVUyt4UHB0Nm55dWs5SG1Qbm01TmloZmQwOHBsY0k4THpwNzZVN2ZPbnZwcm1VMzA5enFmMjFTR2Y2dXREUHRYWGxsNGtNLy84bEJwSEdINXZTRnpldkhxLzQxSUhuVno1N1gyWWxMYkc5WlZYNDdUdUp2U1ZWM0x0WmM5RkUwVEgvdXZueEthZW05SlVsejFIVHN4bmNsM3JsRC9iaVJnajcyWFNNaHViUHlId2M1by9rWjJmbS92MzM0emNqODVMdWZ3N0dIOHUrbStQdDdNL2Y4ekpYMWUzTmY1Y05LL2ttbXRDWC8vMiswUG16bDkxaURDdXI3eVM2L3ZlK2JPZGNPbGcvRHVVZjdjZitidXBjQWZkVmI1dmEvdzdsUDlydVg1c3E3dktPQlA2K3J0eHl0OU5FNW0rTWt6bzYzOHRGeGVodThyMHYvSGRLR1B6ZDhUdGZYWitidHA3TnhQUCtmSktMc3ZSK2JPZCtCUnAzTzcvN3Z1eGZ6ZDlZZXY3dGpUeHZkci90Vnh0MlBkcTA0VDc1RnlXVEdMNzhRU2RYWGlJNURMR3oyNS9VdWViay9vSzk4bnptVnpwTEw3Zi9qK1NTMmFtM01PRStDdWZ5Zlc2UmY1c0o4TDUvQ25YNHZiRzI2Ky8rM3puNzZabDdYVlhjVEhSYi8rdjVTck00cHhIZ3I1RXd2d2JmdjUzMHhPbXI4NkN2dktKWE4yWXZ0cWFlQy96Mzc2ZlkrNDQ3WEpiNCsrQjVaVmN2SW4zTXZOS3J2MXRqYjhIbGxkeTlZM0ovYnBJeHU2VEMzd2l3UmVmWnlxTmovMTdjdVYwWFZOeW01dStWcytmL2RBSE5sOU9YQlpqOTdkb0V1NXpDbndMMEwrL0pkekh6TTRYdjFkaUtnMk9NSHp2SkQvSUpldENvTkVJQW9NQ2lYYjdlRENCSXZVSm5NSGZhMGgwSGVXU2NRUXVJQ1o5RklHNXNlWlp5WUR2aUZuNUI1WWwwQUh6N3pTU3dDTDBRYWVPQkJyVHRhN3gySDI4VnJFWTNiVTlSK3J5RzFCR1A3K1B2Zlh6YTRESGYvaC8zTDE1WEUzZDJ3ZDhSWXFFU3BINVNOSThUemhhSVdTb0RBMG9OS28wanlKMFZLZ01GYUVvUlVYbVVNYVRmWnJUUENxRVpDaEQ1elFhSXVkZGUzZTY3K1ArM2IvbmRyL1A4Lzd6N3M5bnRjOTNmYSsxMXJXdWRhMXJyYjNQM2ljWEFaRFpKZ0N4dUV3aS90enBKZ0JYMUhsNk13eFp0QlRiRnJHWTFkWHFtZDZkSXlPTVMrUXpYTnFsNDljMzZkOE4raW9ZYmxRZ20rYjRSakxPdkY0N3k3OVg5TkNxY3VVcjdwK21KdG8wMDVtN2Znd0xYWlFuYzg2K1ZlTG8ybHJObTc3ZElsRXJTaFV2YmZzdytkVEdwL1B1Nyt3WDJyKzBTTzc4MW5jVFRsZysxcjBkK0huc0VkTksxV3VlN09sbk5yOHdlTGpucDhEZWhia3p6OXE5RW85ZFU2Tnh3NmRyVk9UeVJ3b1hYZDlQU3Rqd1pPNjlIZDlHN0Z0U09EdmQ2YTNVY1lzR25leUF2akdIVFNwVXJucDBURXZhOUh4Qnp1NkI0V0dMODJlbE9yd2VmMnhkbmRZdHY1N1JCMWVXS1YxMit6amx0UFd6K1ErQ3Z3c2ZXRlk4NTRKejI4U1RWbzE2ZDdaL0dSZHRWcVYyM1lzekkzbkxTMFNFY0FQMC8vUWQ4aUR2MWZ0cDZGS2ZoMklNNlU5K1dwclVaeG92ai9TcHJlNyt2K1NSZFRqYXUxT2ZEWGw1cFA4RjZIdi93UTk1QzI3RGU2aU5vVGlGMi9BZXFtOG9MdUUyZnNrYlB0aUc5MUFiUS90N1AxM3RYOW9kUFpqM2l4dzVKNEwrNHBmeGFsR0xZbzMwZktxK3M3TFRuMlcvdDg2em5Oc2wzclVoTFJRZGJkZzg5WEw4SmVFbUFlc3dpWWY3TkdUemQ0dGErRzk2NlB2enhndkdCYUhtMC81ZHAzTnpYVSsvMmIvc0lhY29LWGRjK1ZsUldTL2w5eXFYd3YxWE5GL010SGthOFMxdzdScURlSThpall5U09jTXppME0yRUQyalc0cVd4VjVvV09OUUt1U3NvQ0M1VCtUT0hQMlpVMVIvZUNpYmpCK2p2ODdjVDhUcGdjaTJRTlZIZVh2M0tmc2VQZHRPbkZ1NWRYS0c5OEdWZWFscjNJc250Uit0a1JWS2VMeFBaMnl2ZDhvMnNRbTVhWk5HdXV0Tlg3WGRlRTQyTTFQN2x1alV1U3N1TlptYWxTWmE5M2lwdXJCRG8vMjlITktESklOS3drY09LejdVejMwWTg5RjlkZHFYMUc4UHU0Tjhpc2ovaVU3K2ovVHBNUGdzRnpuS2RLRCtsVGhscXhNNGhTc0lrSytZUU12QjRlQ29wVS9abXovT2kvQjkvcndFejczUkFyQWUvcWYxWTdYaFVIbG5rWDhuMzQzcnY0WGxiWDVUM2tMazM4blg0UHI3c2J6dGI4b0hpZnc3ZVZFNUFSQXpGUUQ1L3lyUDRuSzVMeGNPeVg4dytYZnlJM0g5MzNBWjVkK1VmMnJ5NytTOWNHd3RreENnOWsza05SS1hkd3l5bmNSZjVlWEgvanQ1TjF6L1RTd3YrWnZ5UW1QL25id3pydjgxbGcvNlRYbmRzZjlPM2hWZmozOFNGZ0FYK1BXWjRNR2pKWjkzWGt6SzM4UnkxNFgvbmZ3NlhIOHRQbnYvcHZ3KzRYOG5YekpDQUZvTUJJQmNGc2g1WGpFL1pPdVpsSGRvVU02UXhUdi80Yy9SQnY5T1BoL1gzNGZsdFg5VC9ocVduWTUrWHo0Rnk0dGllVHI4M2Z0WC95a3ZpT1VqMWdwUWE4U2Y4cDJEOVJ0R3Mzam5QK2Y3Mm44bnZ4M3JjZ0FubzcvVlowaXRQK1hYVHNOOXhVbjl2OGxDQy9ZM0R1VnZwS3pZdjVUdnhVbHgyZUJNSC9xT2drODJsOStmU2ZucGxnS2dnMVBFMy9XWE9uNzEvMkM4WDR2RWFkZC8xTTEzc05aUS9TVmxwNUcvdTZuNGUvcVE4Z3BZZmhxZi9MQi9rRCtCOTNrTkUvNlVILzRQOHN1eEJycDg5Uy84Qi9rWlhnSWdvdlNuL0pKL2tCK0w1VnY1NmwvNkQvS1RzYndxWC8zTC9rSCtKTjREVy9QVnYrZ2Y1RzlqK1p0ODhvdi9RZjRjbGcvbGt6ZjZCL25MS3dSZzhVb0JrRlVhSEZzYS9QWDQxWDhtanhNQU9aemtsZjdjcy8zbm9mL0hmQ0d3UC9UcTRmVUx5MHZBZi9PNVRqUWtyMkdJNXk1TzZyOHBYNEhYaXpCTkhOK1UvcWZ2bGY2VUwvaVg4anZ4M3NvTXh4UHovNnJMbi9LazdKZlpBcEN1OEtmOWZ6MSt0VDhwejhieU1RcS9ONzlJK2VsekJlRG9BUUZZL1l2KzJvYURaOVhCTStQUCtIbDdtQUFzeGZaZno3UG5QL1UzVEUwQTdKendma3pwajNpQ0F4U0gzNjBwUENSL0NNczdoZVA5RlUvK1ZBSjUzUHV2OFdjcTFtVlVxQUE0S3YxZXZBckE5ZC9ZaTlkZnBiK0x6Ny9haHp5VThQV2o4VUVCY1A5TithMlNBakJoSDE1L2xYNkpWUXllL0MvckwzbGs0OWpjaFpNeC9FLytJRTNabjVTVnhyNGp2dmIzL0lHVVQ4WGpkWEhZNy9rREtWKzlHSzh4L3I4WGIwbDUxbXA4L2I0R3p6R2wvN3kzeEhkUStwT3l6dmg2M2RiMTkvUW41VmZoOWRyTzVmZjBKK1dYWXA5ZTR2SjcrcFB5OWU1NFA0T1Q4Uy8rTDJNNHBQZmdTZjBQLzE4akpRQjdjS0lwL2Q3Ky85OGU1RkNSOTRuSWU4cmtUeU1JL1pkR2hIbjVJL0Y1RkU3NHNnVHdaUW1JL2hmNU1ieDh2TDBGSEc1QkRDZnlYM1JKL0JmNThieDg3TTZBdXd2a2tqb1JKK24vSWorSmx6OFpuNmZnTkJVbnZKMkE2ZjlGZnNhL3VkbjQvNk9ESmpENExMWU1Uck53a3YwdmRwajkvOUkrK0hJUTVnZ01udVY1NTZGRUxndDRPZ0g1RlNKZUVtRWhUb3R3d2xNZWpIRENsOEt3RkNkeXUyaU1FMTdhQUMvbmdKZHpXSVVUdm13RWZHa0taampocVFONDJzUHQwTFB6VTNObTVJZUhaMGkycnVEbXNhSXI5UVA3Y3ZJaTNyQnpYZSs0NUJXOEtrNzFWaGZLazk2NTRVcjhpZmhjSmFiK1BsQ1d5YTFrMnd1TFBEbkhFbTNiY2JSNHkxVFd5UnVYSDFtY2p5WVdOeTM5T3MrcC82SHNKaXUvaGZhMkR5Ty92MTZURjVhVDA3ZHZsV3JNVC9HY0orbGZQYTVvcjJjTzlYZW9mZWRENk9IeXpNUkZwVUdxRVNWTW9UejE5R2N6T2FVT0M3WG1Pa1hsOXQ1a0RVcDNvaU55WjduN3A2b1FSay9pTG8vUGowSk4yMjljS3o3ZFRFd2FyaWd0c1dTQ29aeDM1SVQ0Y0QzV2pUUGZ6b2NrSWtOV1FJVk1sZDRzMWxCN1p5L2E2WTJhc0lpNGNDMWc3OFJMS2NqNGpFbFdYbU1YY2QvcUIzUENGeVhEY3lLZmxkU21tYktDYTgyMUkrd3RERG16NTYvYzZJdithSjk4WG1VNjMzZ1pYUms4ay9maGFuRktPVE9jMm9ObTNock1KKytua1hPd0d1Y3Yra3QrQ3VsUHljT3BQUngvUGptdTNqaWYzS3N4SGd6bWsvZmRWSEErQytjdjRXdVh2STRteDlVd1pUQS80OWlmOHAwNHRmRHlZZmVmOG1TKzdkbkJmQm5MWC9QaDNHQSt3K0RYL0JSZXZyalNyL21HcVlQNWhqTit6Vy9oNWZQcjMwL2l0T0hVSG5wSS8zRzhmRWovTlorc0p3VDNpNEh6ZjkxRC8zbzhseFhhZTN3eEdLNjlPMzNmeHpVQ3JPNWFFM3V4OVZ6a3MwQ2tNZFg3RzFIT2ZwUy82T3JyUC9ZVE41TTRGNHBXRGpmOExHOFRuZGNud25wYkxmUHMyNTV4aHBNRUxjZXEzQlJqZWJSOXY5aFZLMktZNWsxV0lNRGplNUZMYk1jdXBOTkt4S1I4MVhoM0xmdVAraHpudnpRN2ZMS2Z4L2NTMjE3NFJCMTU4d0x0ZjJTZW01RldTNXpreHV6NVBvK0ZtQ01rSkZFUmt4QS96S1lGbms5QkR1eU5pd3phSTRsUkYwYW85WXVjSTRicVU2RVVGREtrMU0rUllDMnlKVFdRTnB5RnRkakduTW9LT0NZdGFIbGtzcUg1Ni9UVEJUUkpWbFpKNE1Qa3lTS0c3K1UwUmw2WjJrOThuK2RkR1ZIN2xHLy9CTFlDL1VLRzVCQ3VWcFJra1dlRmZta0s1emxPSkRITDg4SVlFa05GS1hsL0JBd3ZkWFNUWjl1Q2Q5VDZ5WnArK0NlVi8rb3JoNnlYdGJxbGtNU01uSmYxbE53VmtTZGtQc05icTRiRU5CTUJhcjlIT3pBcW5zUXBjbTRqeUhvWURXdkhrKzFCMmJMSlZQdks5ZE5JYkp2WFJtSGJmWTRVYit0a1ByaHVKN3BSOXcxb0s4OEtVM3IzclJFajh3MTdtR0tVM0tMeklpU21uZThDcWw3RFdaOG9lZWFpRk1xZTNCblBxTE5BK2dzeVA2WDY5bU9xSDV1Y2lpajdXS3RkcC9pNXMvcXBjaGNtRHFQczhXM1JjRXEvRW9rUkpHYjhrQk9nMmprMmVvRHE3enJUTHFxL0dpSHZxUDR0RENxZ2NQK1NkS3FkeExwYUtuL1k5R29xZjFFaFpaZVVhRzFLRHRZSzNhZnFhYVBIa3JoRmJ0a0hxdHlFeVpUOVdXTjZCdjFWNlE2Rld4am4zMUQxZUk3NlJOWFRtTjFDOFhweGJ5bjUxWVhOVlBuUW1oYUszenZqTVZYdmFPc25WUG5vMlRVVWZoMU82ZFZ5ZDJvSmlXMHJmVXFvOGl1ejdsUDk1K28vb01iVnNmOEN4WHVicEZIanFmSDFDbFcrZlc0clphOEdzYWRVUGFaWEd5aDdLa2pXVWUyeU5wY00ybHVHOGc4YVdwQkw1UTh3NzFMdG5DT3lxUHJ6VXpLcDh1TmFMMVBuQnpybnFYSUxjNmg1UUp2eStoU0ZiOUNQVVZqSTdTRFZqdXk1VUFvSEZUdFJ2RXZjZktyZXVZMk5WTDcrMkErVVhVTk92YUw0ejVZdktEei9GZVduc0lCT25WdStMSzZnOGxkYlVPZVdSYU1mVVh5V1FURlYzN09jZkVydjNERjVGTDk0N1VNS2EzK24rcEVpZGZ3VzFROS9yeHRVdTJFKzZWVDVrRFpLZjVaaVBhVTNiTTQrUXNrdFRPK2c2bEUrenFGNFQ4MDNWRDB6ejFMalJhdnhwTWJKOW1ZRDVaOHBQaU1vZTlwbVA2Nm1NTGU4akNwdmtVZnBaOWg4aDlMUDBITUJhN0QrSU1xZkRNKzRaMU55VzZTdVVmbSt3ektvOGtySmlWUzdRZ3VPVTNyZFZRMmo2bWRlQzZMNERvTWVLcjlqS3BzcWwzaVg4aXRHcGk4MTNpMmJnTkxUVnRPK21Xcm51bTRUcGJkUk1UWCt0aUtEL2c0YmZsWlI5UldVVWZxbWxJK2gvS0ZsK3NGQmZlWEVDVXBPaW5GdnNQOUxLRHV5cnZSVGVySmVWbEIyVEhselBZbVNhelNOR096L0xHbyt0blR1SE0waTVWS0RSNUU0cGVISEQwcVBYWG5VK0RFeWtyNVFmbndpOGp2VnJzc3lLbDZsc001VGZ0aGk2MDNwYlhqekVEVWZXQmRIMzZEOC9FZlVvTjNwVTV0SWJKaDBwWkxxMTVVNGlqZDhkSW1LUnkwM0xVYXlxSHBUcWZiaHdWZ2hFaHVpTDFTN3RvVWN5aDRzajE0cUx0RGVxUXpHaVQwMjFEeG1GTkJhS2JrUmphV1VYRHFUbWdlczkrN1UvTE45dFpqeUo4Tjl4djVVLzRjT0taMlJaSHVHNFZPa3lmWVlqUTR5SktadE9qK0gwcWNvUW9IQ0F3MFVUaG05Z2VJTlpYZEprWmhXUDYrYnNrUHdDY3FPTExQWFZKeWx5Y3BUNjREaHRvZlVPZ0I5aWVNcFBNSmRsT0tuSEtEaUhtdllWV285WUIyMWYwbjFSM3YyNFB4Mkx6cUp6QjdZalhDKzhoeEpxeGlaZjUvNUhwMyt2TGQydEIrSGg3K2hWaWMxbVJDbG5YUmhHMGt0dWZONzZUbGxuVHNqaEwxNU9KWStWSTUzSm1wbmFvWHNlakxNa0hkbXdhOEhZMUJ1bENIdnpCcDZIcEJNNVBlZVlkL09nWkdwSi94UWtJSWFxem53WExzUDdKK3hnSjV3SEJiR0xBYUhOVC9od1l2TGNNZXVFT1o1eWtLdHlTSllMdFFDb3o2b3d0U2pOZkJ4Mms5UXVERVYyZzB1UUo5T0tCZzlVSVhFOStHUUplY05DL2RzZ2NleGMyRmQyRnhJN0owTEI3ZUVnL3kzSFBnNll6Njg0SjZFY2ZFalFGeU5BeUliRDRMSERBK28ycU1MbzhybXdGS3pPM0JtS3dLVkQxdmcvcHdBZVB1eEdCWUVkOEdYdWNKd2RHMFVmSGY3QUROdWJJR1JtdzZEK25CTENQNnhGRG92dStHRnJBcDBlMC9CNjR2VFlMTmRMSXljOGc3MkpUaEJpdVFXT0d6b0Fvd21Mc3p4TXdFaElRMG90WlNDUnhsK0VOeHFDMjZIV0RDcFlCbFVPT2ZEcVBabTJCQ21DQWNEQytEODFCTmdkUDA1VExLcWdYU0RFVEJDbUF0YWV4RGthYlpEdk5rTGVMQmJFK1FXNU1OME53NGtmOTBNT2pQbVFVaDNLWFFkbUFhN1ltYkNOdGxkME9EWkQrb3EyMEZxL21MSWxpeUMvRWxKY0xVZ0Q1Uk5Gb0lvYklMOXU1ZkNheDhWT0YxMENyVHNjVXl0M1FWWkYwNkNua1VETkJwOGhsUXhhVEFKL0FHT1NZcmczWGdaSEhaOWhaMlpWakJScWcxWXl5MWgvdU1uY0NGY0gyUm5sY0hqcU8ydzBYd1d2dGk4QjEwaVUyQlM1VXRJMXVEQzF1bmJJTUhLRHE1OFh3WjdRcHBBeHVrT2FMWkh3anZDRmpnRkZlQ3VPd28yb1hxWThLSVIxczkvQVM5T0g0VmFHWG1RMzk4T3JldE5vS2hVRTBhK25nQXR1OHRnSW1zMTlFeTdBTkl0MXFBNlhodkNKT3doREY4ODlSMnhocXVaSVREOWZUY1lyMWdNWXM1MWNPbDVFMXpic2dpMjJWV0NpSHdhMUNWa2dkRDVickRaSGdLcGVXRmdSNCtBS0w4Z3VINW9JM2cxNW9ES2VRZm9KY3JnOEY0T3lPVTZnMFhwRWloOW9ndnlHYldRWjNjWUpCNXRCMEU1U1pCWWVob0tOaFJBU2FFUm1OeU14UmZxUFZDLytDb29MSDhMQXcxNDUvendCMHlQS3dmdlNqYU1OK2lEVDEwTXVOV1dEOFZmNWVIWWlEakk5VEVBMVZHM1lQU1NIb2lRU0lUTHRHQlF6VTZHWlVmeklGaFREVVF0UE1EM1FneTR0YzBBamJJVHNHUENDbGk0b3hWNlgwWkNlOXhKYUgwWERna2FKeUdpd3cyMmJOR0ZCd05qd2ZoVUZqaW51WU9QN3lJNHZFa1RrcVh1QXZQdEtEaXNNUnUrK004RjlSRlRZWXlvQUt3YzZRTEs3UFd3N0ZJTStMY05nNXpIc3ZCbDkzbndOUGFGNUFrY09CSjNIckppUDBQTnVqVlFKZElOdEhndDZGdTVCMjQ2dU1Cemd5MTRNelljOWtXR2dNVmFCZEJ6WklGSGt4aG9HbXVDOWFvQU1QV3BoeVhtbmpCNlZDNG85cm1DNU5ZR21DT2NCSnNFVjBQVy9HZndJYkFRRG55YkNNdmRkc08wT2ZmaGhLc0NGSlZmZ2F1UzVoRFR1ZzBpbmtTQ3N1OXFFRXg3Q051RjQ2QkgzUnZneHh6NDRKTUJXL09XZzJQTEFqajVQQXhTMFVsWUhEY0FZL1lmQW8yRkwrRG8zQ1I0N24wSUp0NXBnNUV2NTRPVW5oTFlNRkpnSStNWWlJa2ZoWEh0VGVET3VBN1B1Q3RCUDJZY2JKQU9CUHQwS2JBcmV3REZrZmRBekRBSGFyc0ZZWG5BSFBoNCt6TThrM2tBSXBLWElGSk9EUnpEQW1IVWZDMFlHemNaMXN5N0JOTlM4K0I2eHpXd2taTUFqendUVU5tWkNDekxrekFjaGNHb3pzK2daSGdJUERRU1lHNldNSWpTcEtBcDN4cjZqaFpBMGRXVllGcWFEaGYwS3VEZFJWMjRmRFFPbmk5eWdVa09MeUR3RUFkY0RxNkZIOC8wNE5yWnkvQlNTZ1B3QnhEOS9oUWNUYlpDeDRnN29PQ2tEbGFXQkN6anpvTnQzKzVCd01NZWtELzJFaTR6MUdIcm9jOGdXQ1lGL1RKQzhPVE5ORmh3S3cyc3BrU0Ric1VvTUYzMEhzWS9UQU90V2RuUWVXa3ltRGxsUUcxdU9vekdWOGJXUVJVdzYxc2dCQjhVaE1pSnZsQjBmaDE0ZWJZQzV5UEE2Ulhyb2VEcEhiaTA5VDRFVmxWQnpiQnBjS05MQlE0bDVFTCsxZTJ3My9ncGZObVVBa1dNWHJqU3FRYlBQNTBDWk1PRTZoY2VFRk04QXhTZjNZYlUyZk1BcnArQ3ErdU93VzByUVZCUXlZS1ZqRDN3VlBnQ0JGNGFDOEVienNJRUNVVm92cU1DL1c4SElQTFpUNGg4T0FCdkF0MUI2T0lQTUdCNHd6NVBLUmc0d0FWNUEyR3djOVlDUmVuOVlKTHpBYytuNnhEdDRRbkhuZWVDQm1FTjRZM0dvUDV5QWhTckxJYlpkanJ3eUxzUzFNdnVBdUUrQUdsd0RrYTR2NEdOejFOZ3B0Y3lzSmVvaFhzMjRlQnR0eHpjTEZzZ1lhMEFyTGJRZytrTmQwQ3Jxd0RHZTI2QlRlcHZZSi9xUlpoMk14L09hdXJDeUR0cDhPRUdqbEZmWmtLMDZ4dVl3OTBPb3NNWk9LNnJnRmxGQ3REU0UrRFd1VHBRMnlRQ1dkOFdnZmpUTXRqOXNCcE9QOHVGeXhOem9QVGNYaGk1elFaVUxTYkNITENBRU1sT2VDVzhIeVJITzhLSmhZZmh3TU1YOEhSQUVkeG0zNGJnU0cwWTBmTVQ3aEZud0dXYkdheFF6QUN6Z28yZzhwVUpqUnZqb2JmNE9Jd3hPUXkwZWVjaHpXb0xTS0lid05BL0R1VTBBZkI1dmg4ZXZiZ05oRzBmbURpSmc0Q3dHeHpLdkFJM1dkV3d4c0lZcG44ZkM4ZDk4eUZWYUQ2d0RIVkFxRGtZV3BhVWc2bENQend1TFlIMm5vV3d5L0VGbkhac2dpY1BOU0R0WkQ1c1gxOFBycThMb2ZQcGVMZy9qdzVMcFplQ1JjQVdxTTNwQTgralJYQkZkUk9NTmVxQXFRYUx3SzdnQUNnTXZJZTJ4ejBnczZzVXZHSjFZR1JMSVhBYkQ0UG50bGJJSENpQ1l5TnpZZGNtZjNDN2VoTXFQSlBBd0RjWWlzUzN3WmVxaTZEZzl4S3lIOTJITzdBR1dtK09BZi83c3ZCMnR5MzROMFhCR0NsbDJDc3RDbnUyeG9HQXdnUkkzaGtJQXdNUHdYSUpCNTdndGZ2VGsvRnc4UDQ5S0RqNUF6UXk1a0NYWno3RUZlcENVNFlsWkdWa1ExWDVXSkNJVkFFdksyMVF0b3lFaE1yWDhKaDJEOXcyWHdJRHhVUVEzMUlPQTZOWHdLdmU3M0JrdmdlMDdsZUc5L1hoOENQckluRFlOYUNxOHdqVTV0cUIva3dqbVBLa0JQYitFSUh2SzdhQjJ0UW1XSmNWRHFZSmg4QmNwaHdVTFpxQlZmUVlSazg2QVpPOTc0THJjVWVRMjJnTGFDMGJRc1RIUVcrMk9Qd282d050cGdwT2JHamZWQTdQTjl1Qzg1SFRjRlNMQTQ4bTNnVzc5YWZobFJVVDFvUVZRWk9CR0R6M01RYVZxYy9odXZSWm1LbThGRGIwTk1LVG5mRnd4cHdGWnZ2N3dWTG9CN3pkY1EwaVpYUkIvNm9NT0I5ckJvdjJTeEFxcHcrbGJhZGh6WmcwU05DNkFSY2J4NExyQ0dOd3V0a0pJUkVYSUdMVlNmaFdvd3N6ajk2QzROQVZFRjgxRXd5VG02RjVtUVc4OHA4SHpoOFh3YytrbDdDNWZnc0VPNmZCL1NzN3dlTHpPVkNLbUFVTDcxdkFCcytSTUZOeFA4eGRGZ2FScjkvQjJ6UDFzUHk3SVhBdDM4UFVjYVZRdUNFSzR2cVZvQzYzRU1ZVlZzR3pqZGRnV2VGKzJMZllIbWJ1bncvS08rSkF6TzRBS0s0S0JvYnlaRmhNU0VDRVhBd0UwU01obytBTnZIMFdEQVh6OGtDdTl3TjhjY1krY0pRQXAxUWxXSERzQnVUc0dnMXBhNXBoem5NSGNIMzFIRTdGVFlJTWhlUGdVaWtQb3pxeXdDaVpCcWJ4cGVBZDZnQjdkczJDY2ZjMDRVTGZFWkMwYklPWlhTTWhHKzlwdlBhWVFQcWtOWkQ5N1RLRXZud01KNTdid1FUZFliak5aQWc3ZHhaOE96eGc3dUdkRUhyM0lyaHAyc0RTT2RZQTJoMVFDOXZoUjY4RkNHd3dnUllmQnYrZTE1RGNSNU1mVkl6OHlidHlqUGlsWDhuSEpXelhsQWZOSjNIWWxNNjVwQnh0OWs3eXNRNkdUT2hyNm9IQWFUMnVPb05WZENML2ZWSjFtVTg0YUZ6a04vZjEyUnkweGxxaVd1QVlCd1d2MlUyLzY4dEJsKzY1YUJ3dzV5Qjkrd0RQbmZvYzlPckZqTDZrNlJ3a2RVZEQ1S2NRQjVWZG5LZDNvWXVOWkxRbFZwMS93VVlxa1hhMkl5dlphSTZpYnNOVGdvMUN6WklzbGJMWVNNSGMrTG53WlRiYVp6RXZjMDhhR3cwKy84RkcvbHMrdFFja3M5RUJnWTkra21mWmFIemxxb1RJZERaNmxxSzQ2TzBWTm5wYldKR3BkNGVOWWpwVFEyTUwyR2pUYklPYnd4dlk2R3JkeG9Ua2RqWmF0dmw3ZHlDWGpSTFg3bnQrZWhJSHVjWndtbWw2SEhRZzdYdXo5SG9PMm5JNldPdmtMZzU2R3BOMjdub2FCeGt1OGJRT3JLYXUvL0RSdmlodVZ1ektyOXV1b0o2Qy90V1ZSQ1Y2dkZhVXUwaDE2TGtVL2NVL1E1V2Nsa2t0TXh5VVl4b015cW55NUU2Z1FkN1pjRWdlb1Avbkl0VkFZdDc4TTh4VFgwUnpjZ2JJcDR4ZUlycTVCVDRLVWF6U3hDb0xpM1Ewc1RyTldWeDhMNitka2tXY3VXUzVkMGkySUpTYmcvWEk3aFZ0SE9sMkJaV3ZYbHA3K1dZWUNwOW5lcnFsMFFMOWV0blRpVHlKaU1sbTgwL1RkYlMrWDF6d21ZTTJOVGNsanJmMVlkb3h0aHVjK3NSQk5Wc1BpTzNjSE1QY0YrTFpMdldhZzhaL2R0WlpXM3VJUGpUdS9VZSt6V0pVSG1TKytQeGN3UTNieGE3a25aM3BGMXQ2eWVrQTZTWEZISlJRcDJYOUpqV0dIdFpUVkdyd2tJTThnc00yblQ5MWtqN2tMejg0QTBjblp4K2hmMW5tcTNUMENtNHZVYzE3d1VNRCtybWFPczFQcVJ3MDJqTW1VbnY0TnVhVXVwL1h0NTdtb0xFNWFvcHJMWTh6aC96TTRvUHBJUTVqTmJOY3c1MlZFOFZCRTNvYjdzMTZGTXRzVWJsNDdWUW9CMTIzc0huL3VvNUJYM01rdlNSK0p3Y1pIMHYvSURXRndSenl6d1dhTHl3NlowUXpQeHcrcFA5dEd3Y1I2OGFqUTVFSDZRRmxYaCt0SFRoSTdxTjRZT0tURTh4Nkc4SHdGbXNPc2xXYlovRGwweW42a0Y4bjZlOHZDMjJMWms1NzhrTm10UWtISGM0L2I3VFFLNHIrK0pCOXhQeWxITFJiOEUzbWlKME0rb25tM2JITEVRZkZaV1M4SGpoeWdqNDBIM1liKzNkTGJ6NUFSK2R2bWxWcWNGQjMyNHg0cFdVTSt2TmRyVTVMbERobzgwZ2ZGSHozQkhPdlE5K3JsN0ljcEhGNWxNZXJMNkgwb1huVVQzaE5QajF6QVRQbXlkUHFFR2tPeWhJUjlRM1ZPMGdmUGZ6TitYMFNIQlJkVmhsNVZOS1RicWxtY1BHNktBZmR2cHhwRW1BU1JoK2FmNnY4cjdRS0xOcFAxMmhhOWNOYmdJTldmSzNiTlBkNU5KMDd3ZkhteUI5c0pHaDlaRDRqZFQreksvbm9sc0xQYk9TeWVtVjV4NHFqektGNWUwUmx6WlN2d2duTXJVMGpQSzU5WXFOYTNUaUQ5aG9mNXBma3Q5clAydGhJYWtybHJVbVRFcGh2TThibnE3eG1JNDlWaWhlTWsvZlJoK1o3bEt2OFRsdUpZOHlwakN1Q1M1NnlrWFhrUk9Qb0MrdVppcXBmWm9vOFpxTXBwNVk3bjFiZXhUeVpzZnBKWHcwYmlWL0pzKzF3V0V3ZmloTWNSNkg1bzdhZW9GdkJ0STZGcFd5MFkvalpwNi9LUGVuVjlOenNjMFZzcEM0eERoM2hIcU8vcUd2c1ZNeG5vOHpyT3g5VXhnVFNoK0xMOWhiemp6blRqdEhIUEI5SXVNbkUvVW4xQWUyNGFPWUY1YVRBbS9mWWFIbnFzZWJ5RndlWWk3WlduWHQ2bTQyMjZJL0xLWG9SeEJ5S1M1OXRnajh0bGRqUEhIZDBVMm5hRFZ5K2NVQjZoTTR4K3RNNTJickxyclBSaU5OUmFuZmlnK2tEeFNmckphNnkwU2p6cWEydkhHTG9RL0hzUTlHazFmdUt0ZWwzbG02SWtydklSam9zUjZWM21uRjA0NWxYcGJ3dXNGRnlZSUxkaWplSG1LT2FBKys5d25FdHc0UXp2MURyRUhNb0RsNTdyeFFadEM2Y1Njc3YxMTZheWticjExc0dQYTg4eHB3dFl4R3FmNDZOSENmdFlWd1NzNkw3WFZ4VmI0SGpvN3pNWm9KejZ4aHpLSDZHM3RNK2NGVmlHNU40T2pwQUFtUDJSWSs3SEdjSHB0cGtKL3BOSEZmWFJMU1lMMmhtTU1QajFuemJqWEdWd2NZOWpqT0NtRU54TjNQM1FkWUs5bjZtLzk1MDQxTVlSNzJ6bUs0NWFUL3prZk1peTQ4WTE5V1AybHlXR0VOSG0xNll1ZUw2cDZXYjNHdldER1lPeFdzM2xyUDV3S2M0dW1hdXVrQUh4aGJ1ankrLyt1aEV0emV0MHUzQitpK3F1cVZXZURhQ0tUSFp3SHdPN3ErMjN2eXUyNjdIbUVOeGZqcDMwcnp3elF6bTFlSlpTeWRqZTNsYStUYXRybzlqZGh3MU92MGtnNDBnYXF5MTg5VVllc0xXcUNmRmw5Z282ME5ucnRxZHcvU2g5WUhiVnBob2U5dUplY2dvZTRJbUhpK2pMVDBid2o0SDAzVzNTeVZjdytNWnRtRDZoUm1qampHTHVMR2pyY2wxYUxyN3dic1hOekdIMXBVTjkySjJmWnZsemh5M3RxVE02RDRiWGZyV0s3TjQ4VkhtYXRNWHlhRTViTFR5eU5aRzk5Sjl6UHZDcGQ1ZExMeXVWY1lxL2JqdVF4OWFqeDc0aWJ6U3FmV2d6NXIxZXBKRENSczV5TmpMQ0JZZVlEcTkzUlM4dFp5TkdqUmFYKytmZXBDdXBiTGkwK2xxUEo4ZU1PdHFIc1F5aDlheFdnMTJva1o1REgzOUxmWHhaNTZ3MGEyTmZwN2hydUYwWW1DSGhSdWVYMWxKUjA1V3ZBeGw3dXlwSTl6dy9EdWdWWFowKytSRDlLSDFyLzlKellybzRCam0xdHVIRllUWmJIVC9XclBsazN3TDVuY3BzN3ZuZXRqSThQUDVCV1BUWXBqek5ydzk3UHNOMi8vWVZmM2V4eTdNb1hWVEoycTlXeXM3bHJsQzZLeDY1Z2dPcW5pK1JhU1I2MCt2elYwWk14M0hteXZ4Ui91LzU4UXlSMDF2dE03RDhlaVc2SFgxYTU1KzlLSDFObTRnMlViejlSSDZ6bXJ1bHNzMExMOWhWRTEwU3poOVpZMlZhdGNjRG5LZWJLcC92Y0tCbnQwbUZPZWh4a0V1azQ2Nks3czUwNGZXNmRyczhqRHBLQWF6UDMrVHhXZ2NYNzM2dVdqVDFXam1ya2poRlNyTE9HajV4UUQ5YTJOaW1OMlJZMFllTU9PZ0M4SUx6dTlMOWFjUHJlL2paQXhwWjJKRG1mRmhqeWE4dHNYdEg4MXRXTDN4Q0gyZjVyUGg3MXc1YUtXYndKVU44OExwdGxrQ1BUUDlPR2lHUVpid3pJWlE1dEMrNE5HWVpmUHZLVVl5RmM3MlNTN2R6MEYxRWZOc0JXLzcweitqZzIycU1Sems0NXUwNWxOaEdEMXNWZkgzTmFjNHFETzJMbHJpU3pSemFEK3gyMzlXYS95MXc4d3U1eU1xeHRjNWFDVHQwa0ptL2hINm5JMTI3Q24zT1VqejQ4WDhPS1Z3K3NuN2JucEtoUnpFM2xlamNkRXhpajYwRCtsNFBmL05mYjBqVE1tSGlWY0hudUgxcUNMV1pIN2tkbnBUekptOXVXMGNGRmx1dXpCM3hEcDZsMCswVWw0UDU0LzFmN2xub0oyN3F5TnRxN3Vkc3grWTJuazQwUnk5blB4b25sNytORjhuUHkvM1FDY3c5OTFCczNPMmMvVUVVeTlQRlY4bkI2OUFKMTg3ZTNjbm1wT3ZyNWN2V0hpNmVYcHQ5L3dEa1JMT25xNDduUnhwZG82T3VCWS8ybFk3RDFmM0hUUXZYNW9ycjBGM0owOW5mNWRmcGYyOEhOeWMvR24rTzd5ZC9rSTQrUWE2T2pqOXBTV3pBSCthMTFhYWg1T0hsKzhPV0xmRHo5L0pZNGpDR201MTk5b09meWtDQWY1YjljSEJ4UTUvTE5sT252MEJpZ0ljL0RUdG5RQUt5QS91K0VNaEZ0UFFKYlB5cUU5a1hpNG10WEVXenRDaXBGbGtoanN2ZzVUSXQvTnpjSFdGQUwvQnM2dWZsNjYyTHU4VTRBZFFUTlVGVUVvV0hDd0dVRWEyQ1ZEdUZPQ3d6UnVnMnMvRmRhdi9ObGMvOENQL1FBMHVycW11cVVseXRjNzJHdnJxV3VvQVRjNzJiZ0JQbk8wMXRUUnc0YWYycnM0NmdQOXNkY1hENWVBOVYwZWRSRG91Ym40T3VJNFdYTGViTDJDZ282dXVnYzlCR3VyNGpPVzA4YjYrSGJlZ3I2OHpWd1BjN2Z4ZFBUWHdScCtYZzJ1V1R4SHJ0VEpOYSs2dFY4Z3cxN0d3OU15V21XaVRLU2taYjVyVkluaDh5OTMxUzQ1YmVvM1J0YkpaUG1MV0ljT0Njc2RxRGRIWkRqV2EwanF2RHkwVzYraXQwNjZYZEtyUU1UbWNicktoMmQrdlFXL0Z2bG1WaG0rcS9hdm5qa24zcTVrM0tmdDE1V0x4THNGNmVxKzBVOVVDMDlqMDZBMC9lc09rYkhrcWFKRXF4UFEyeXFjQnJWWWhJMU5iYXBscTlqQ3d5WXlUTFZQT3F0ZXNWYm1iWldTeFRLMXZtS0VOUzNDV0tCVEloMWRybE1pbWxtdVdhNzh1MXdLaldSWGE5VUdPRlRxVG5WSXJkSnZEcFJyMFdzSm5qWVUzeW5IVmM5dlRVaXZuZmNwNlhUa2ZDbVpWMFh0M09WWXRtUEkydGNyZ1I4VHNQMVRRcHF3Z1c3YzJMZDY4RGx0aHRyaXhkYlpNb3hLMmd2UzZyRVRIWTlnS09tdU1iVWJvbkZ3TkkyYVZxeGRJT2h4YVFWbEJVdWUxNkFxeFBtM0pWZlhtRGhVNlRZbnBXQVgvdmdZOUFXd0YvVGR4RHBVcktDdElaYjgyWFNIK3pjaDhWVys5UTlXQ3J5bnBXSVdnRVJPR1ZOQWhWVENhODl5LzNzTDVlVUNUMDRYbmdjM1p0VW5iWCs2ZGVDYm9kYXpWbVIxdFowK2UyZm54UnVPWllFN3V4T1JkUFRWV3lidS92RHFadk9kN1YyTnlDRmRBT29VeFhHSjl5bDVobWZpVTBOR2FUU2xoNHhaSm53MGZ2M2I5MlgwVDdlUFA3cC9pMjNUMmdGeklTUHNJbVNQRzlwRnlaeUxzb3hUUDNKUTV5Rk5CbDFTQkRCaHBmMXcwMk4vKzY4TjhySGp5YndMRXViNUxjRGwvOGQwcDk5dnYzNTMyTGxKb1MvUi83TnFXRlBUdVl0dVpYWi9menhrVUR4azJPU01sVEdKanh0a0RNcWN5emgzVWZKcVJHcjFvc3NKZmFnV2VDbnFrQ3F0V2RjbkxublF2VmNoSU85cWtlQ1ZybUdGQlpvRk1tWEtVU2xHVHl1RzVuNXRVWS9va0VoeVByYkZNY0RwcGR5Smg2Mm1meHduT3lYc25uSEpKalJVeWREMmZ0SC9qdGt0WGl6YTZYY3NSc25hL1diSFUydVAyOC8zV252YzdpcXk5SGc0STJYam5qVmxtNDFNMDdZQ05iNmxLc1kxZjVRTGhhVU1xNkZOV29KWEtwOFhaa3lyNFZtQVZXa3VWS0JXeTZ1M0xWTzYrOGExU1pmYTJqdjVySi83THdTaFlOSGE1WSt6UzZaR09SMWVvUG5JOFptb3d5aWx1cmVseXArT1dteU9kVG16MGZEUWJYOEIvVWg5U0FjOVk3YWxMU0srbVhNcVI5T3BNYmNxckIxMkt6NnVuRlpKZVRiblVHOUtyczR3YTBOQnNWeDkwYTNGaitRVEJPZ1dkaGVZTmxyN1ozUmFyTXlXMTF4Z3JKRW5XcWVndWNaU3k4bHNpZXVKdjNMcGNxN3BYdTU3VXdjU0s1OWF2Sy83R3JTdm5kMzQxcWlkMWlMWWFkT3ZlMTlHcmhuVFFBSDlYUDExTlNwV2dmb1dNczFIekZDK21uOXFwZU9uaXBmdUtsNi9lNzFlOGNxTjBudExWN0tjN2xhN2QrM0JmNlhwT2Y3OVNacTdJZk9VYmhaT0RsVzgrVW55Z2ZLdGkzbmZsckpvVjgxV3lHellHcTFCbXZmMWsyd09WTzg5M2ZsZTUreXBxdnVxOXQ2ZUNWZSsvdi9SQTlVSEgvZStxeks3UytXbzUvTDZsUVFVYUcyVThzcmJZdVpyU2J0YVRJeHVsUVkzc2hFWThzbC9mNU5XVEkzdHdydUJGd1ppRjJCeXhScUt6WDA5WVFzc05YMnRpMFZGZnA3M1lBZytKODl2ZWVxdG0xdXhHdlJGWEphc1h2b256cXpFYWs5NWp1V1JtWWR4UkU4dXVOM1Ywb3dZOEpDN3ZCYVhXL3lqUW1WZzRwQU1WYWVyZE9QSWlLdjRjaGVFWDFxby9ISFduZFlYMXR3OGZhNVo5NzNaYlNRaCtkK3NrUkdZY1VtZmhZRWNOU1RsZnNIUGx1WVVKYTlBdC9HODkvbHUzMk1aemkyaldvRnYwNWovK3d5MTBCbGNCN0dVS3NpZlhOaWhZcHA4cjVmTngzd1pzQ2IrMzU4cFVsODFzZUt6MmQxcFVHLzNxbktSai9KMFduUVcvT21mdjY2by90S0NpalpqNWFsTlpCeHRTaDZPTmlwN1ozUk5zTWd2eVlreDlON2xqSFhUU0dra2RMTW13ajFjZWFVZCtIY1E2WkN1b2xXZWRFeFgyMTJjMVVqb1l2cG5xeUsrRGVKZHNGYm55akRQZlNvVjltNEpHNU9DdG9Zblh6KzJ1bm81ZTIvMm96MENUSGI1YUE2VDlFbThVZ2IvTjhXSXpwOWtucldIVnFodUZFNzErcUJkQW9udEQ4V3BYblVicmxLOTllTGtVY3lTRGcyWURhVGdSckxRRVhpNnA0Q0JwMUtDcU4yYi91di96NVpKU1dvTlBhYnlNMDJwTnJId2lLS1ZsdHljbUZULzF1Wk8wbldiNnA5SzdXb3ZsTDhYTEhFenh2eU1UbUpibFVxcFFrNzdvT1RYYUFaa0Y5dE1pVlI5anBXZWNVbTVWbGJQVXM0Lzh2MTV1S0tVMStaVFc1Rmw2RTZYMDdnQnM2V1VDdElud3A2VkRrN0NsalFYVXJheFR3bVgrQ01PL3VDZ3ZER01YeFpPMTdQL2NSU21sdGZpVTF2cEZhZkFYWlJRUGhuWSs5eEJsRGVhbEtCYzFEU2s5akVVcXZZSzNmSkh6NnYrNzVZdFNXcHRQYWUyL3MvUXZTdk1zRFliL0swdi9iMVlxU21rZFBxVjEvcUwwZjFvNk5Pa1BTNU5LeTV6OGgxVzZURTB0VHpyMWtGYnQrdFREZXEwakRZL01ZNWM0UkJ2OEhPa1lzMm5udDlueGRuL3NjSDUzbGFhVTF1VlRXcGRVMm16akgwb3JYeXhldG1hbmEzckNIeE14L296NysySmpsZkxNOHlrUkNuOVkrdWI3LzFSYTh4MjF0VWhJUFBFL2JMQjBncnVmWEVpbTlsWXRvb3Bqeis2YnZMTjkwTklSY2g4cTUwZXBscnFrOXVyM3R5K0llVGYrdmNFUDdVL2VGeWlsOWZpVTF2dEx5Q010bmRJNlVmV3ZQczJVa0liQi9SRFkvc2VxU1NuOS85bXFPUmp5OVBtVTF2OVA5L2dQbjhaSy8xdWZ4bkg2RDU4T0ozYytZa3Y4bXJUcjY1MkdmTHJacVltM3VQemgwL3ZJblk5NFlWZ1R2YmZKYWNpblczUzZrWnVYcXo2KzlLUnAxZG5jcXRCN25YaXJjbjVQYzg5am0rMGRmWTIyQjFRQ3l4MVNFelhMVkFuUnFQTE1FdCt5QlFaYzBkNERDMGN2MEs1Wk1tVzNkdTF5cFJ6dE9wUDVBLzcrcTVlcDlOV2JXM24wTmF4M3ZocWdPTzJuc08yKzRSTDZaeG1TMHlOc1EwVlVTMnpEeHU3OFNnc1hYN0hlbGpGbG0wdkx2cW4yTG5iN0IzWUxiOTc5T2xZdk9hZzM2Y0RtblIrdUZtOE9abi83TW4xWDF5T3J6VUhmM3p1LzJQM2psZk9XUGFTZUFmOVdUeGtSRS92SVFUMGYzT1hwV2IvRTQzbkFvSjUzTXY3djlYVHcxdFlpbmJXNDg5Z1IvVGVNZFpWelAxd0pxNXpQemx5OFN1TlJ2SVBvZ3M4bHQ4d011T3Z6RDh1bnhrbG9ibnFWcFJWdDBHV1VHcVZLc01wWHFESERiNWFxNHY3b1ZzeERZM1JxRmk4YjhLdFpxWlNVVmFIWHcvU3IxUHBTN2w5blBIcTNUb1BwOXlzQkRaWXJGL1RWTEIwK3pmL3grdGMyZm8wMndRTjlqMi90ZGtqd1RwZXlPdWlUNFhIN2xJZmlyTzNQY05UdHZsbW1VYlpyWEZsbXlxNlZwYlF5VFYxNUIyOTlhaC94ajNxT01VaTE5UnZEcitmZHZGLzBGSjRscW43UmlOVHo0TnFvSVQzcGxlcERldW9vZEJwaVR5M0pxaitrVmRWQzZuazZyL3h4M2E3Rmg3WDd6TmNkUkM5Y2Jwbm9EdmozaUtoY0xaQzVvWFk3MFhlY2FtYUs3MHJWV3lXRGV1cVNFZXQvczlUL2IrejVkOXVFbXQzR1NSR054NXVlUjFIMmxEdUc5WFMxOTlCUTE5WWp3eTE1QW9GRVdkdVNHU2UxVzB1R2lXcTNzSWFMR2RGeUJaTWtRMWt6cFIxcGoyWk45Vy9KRldZSXlwVFF3dVc5YzRVaVpNK1Z5QnlTdEdVSnhCalo1OHJHbWR1UEVvaDNQUGRJVHRLOEpWS0l4cEFaTzdjbFhNdDBibHZCcktqUjlKVE1ZVFBreUZuZFRxNVVuM2FOSHpaS01TMHpiS0lLa3lhcXdSTFVXcVZSYk9RZ01ucjJybGY1NDc2U1VhS0VYUG5LR1dmelJ4b21Wb2VOYkFxZldTVHRHR2RYTk1rbDdVYXBhbWZ2YXpQbHpJd2JRbE04N25ZSlRmVXBPUnVsK3E3RlhsUWgrNnVHOExTQUpoL2g2VHZheFV2VnF0MWZIVmE2Y21odHFjckZSUHZSYWpsZmE4Y29YdmRmV0tZVExEaXpRTXhJMHE1QTNGaTJSZ1I3anBiWmd0M3lOd1RIbStoM0NVcXVNWTR0TS9pQkF3NnlhZFlhSVdXeDNtZkVoQTB1TTBmclBEYldNdEZSTDZEbGkyclgyK2FQMFgralhxYmJqQU1ZNzJKY2YvQjdRM1huNG1OV1Bhb0xCbDh2YWlHczFkZFlXRmcwb0pnbEg3bGNiaFVoTHRBbGV5dmhFVW91RVhvYllGSEllNDYwaGRoT2ZpMko1Y3FvN3ltckNOSG54eE1Tc055RkpjN2s5NVdFK2d1alZObmxlY2hwd2FJMExwY2dTaDhyeW9mN01CSFhKWFB4eDRSN3hMN3E2MTlDOTk1QkZVdHFBc2F2elNhU1g3VGtkMnAvUVJEemJrZEllU014NDczeXRxRHg1SE93WS9MWVhvMUVTbmIvU052dXp3aGExb3gvUGI2UjJIMW8vSXp6TlJnSHlldGIzMzFNMUdRVmpsNStnOFNNR0l0Tmo0bjdvbXBheTJJeEJ1bkE2bUdQaVZtTFpLU1RmVENPaWRsZm10RkFQSm1lbm1DMkZ1UFZ3eTBYbXpVUUJiTFJseXkxTURaMHk5ZjdYRTlJTmllNTNaSWsrWXlCQzBuMXhDcWJvcldPbi9zUVpFVE9QYnFrbmpCVGpzMTJic0w0YnViYzNvNDY0a1dNZFJuelBzYmUwVWFWSitxSW9NbFB1dTJTTUU3Sm1UamRzSTQ0WUxsVXdwS0JNV01wcC9WOUxWSG4xbFo1MGdIakZuWDlLWEcxeExHUUM2MnpsMkVjOGZSUW9VRXRFYlpFYUJGWEVlT1lPUXF2M3RjUUwzTnVQcE1aaC9GWFl5V1A0elZFNHd2dFpkRTl2UmpmTytXOHNJWXdsSDlSdGJnSjQzaE9YSFZITlZHU0dzUXl5TUZZN0psMCtxbHFJbXAyUzM3SU9ZenZPcXg5dDZ5YTBBNnZseDBSZ1hIbi9pVXlINnVJMFNxVHBsUjZZSnc1TVdERnNpckNYSHB1M1pOMUdLdUxMVEJLcXlRMmhtY1p6WmxIOHUrTnhneXJKTDUvbFZxWVRTUExiMWM0WjF0QjNPZzFlQm9xakhITWNVRUJWamtSL2ROcVV6UzdCN2NmYWFsQUt5ZmVyeHFkOHFTQnhIc1BUOXhiUmlqbGlyRnNjekN1cml0LzFGcEszSDBhb0NTYmpuR01oS3Joa2xKaVdIVnloY3hoakR1bnVXelBlRVJNM1JsZWFCMkFzYnF4cTRmb0k2SlY5K3J5eWswWXM1YWNwL21VRUliMUp2RTdscEs4WkZiMDQySkN0b3hiYWFPR3NiYzkvUzY5bUZnKzVtekFkbW1NYmZWT24wb3RJbUxtR3VpVkNHQ2Njc2RjWTNRUnNmRHI4UWVtSDd0eGVkbkEzWDZGUk0zRlNjTkVHa2ljRngzY1hFQW9EdHpKK1BhUWZPNjVkbzN5MGdMaThoVFJuVk12a2ppTUdaV1pUNmhuUzlyNkhpUHhjcmVFS2ZsRTMxa3JxLzdkR0J1bXhaZ2Z5Q09JK2ROTzMzTEJPR1hIMTNzOXVVUk9YM1JZMGpvU0s4OHVzYzBsNW85OGRPbU9BY2EwTDFZaGxTeml0dUZGSlFGRmt2KzV2Sm5PSWpRWGxwL1lJWVV4WXlVeng0b2dUditvblVZVElPczNQREZTN3lFeDJ0aGtlZStuTG95L0djUlB6Q0ZjbmFMWDlqVmhuTkprNnZ6dEFiRnJqNVg0ckVLTWJkVm9PNXJ2RSsvbHl2eDMzY0NZSWQrV3o3cEgzSjZzTENwd0JtT1c3NjJsNSs4U09kNjNnek9qeU9mTnI5d1NPSHlIdU0za3pJN2FUbUw5SlYzK3Q0bW5HcXQwRGp1UzVROTRqTjJjVFR6Zk1pZm0zaHFNVzg2K3NESE9JbGJWYXFhTlJXVDcyMHllYU4waW5uNFQ4ejJvVExaZitIVUg3U2Foa2YxSlhuMHl4alQ3K0tWamJ4RFh0Y09mZmhjbTY2L2Q1dDUvbmJqbFpqcU8zZGVKKzdOOXhlR25WNG5LWk1WTlFtL0k5N2ozdmZuRXZFek1URmQyTUtyRm1DVmhHSG4ySWpFNXZuWFhCUmFKaDJtdGo3aEExT2dXaGFsZHg1angySG16VHpveGQzeEsvTE1rRWpzdGo3SkpKVjYycmIxKytSQlp2NVRqNitWbmllL3lwbXJKd1NUL01aVGxlNGFZRksxektIc2JpZGV1N2JJNFJTaC8rNVRPM2tEaXZWWDJDMDRRTWNvMUZjdVhrL3BjT3ZSZC9paHg4V3BuVVpFK2liL1JnalVPRVJjMWQ0eDNrcWY0VFRxVHdnbGp2dzl6WktWSi9DbHZ1RVFRY2Z5R3BKRGdTQkxMN2hnbGFFdE03cGY3TXFPRi9KNG1KcnlINDRYOFA5amxUVDFMNGdVNkM1c1BJTldFdlpsaURoZ3o4Z3BTSzQraGlxdHMrdWZaSkI4cG1adDhHcldOangxZThwNk5zWGhsVStaWmRQbEdXUkRqR3NZc2dXcnJxSFIwV2pUcDNHUi9qQmxOaG1FMkYxRjJna2hZN0R3U1czRzJ6Ym1LTEUvWmptb1JJT1hqMzhZSFpLTDRCOXZmQ3BSMjRQRVo4N3B2M1UwMFBIYlg2TzZqSGVUNEgzeXVtb1VxYmI1dnZXS0RNY3Zxd0FhaDJ5anB4ZVpMeW5OSWZwdE80Rk1jMTVYZEREeTdQK0h4bm1xNitQSTlOR3pIaFhNZUQwazg1a0Z4MEFQa01WTFBRKzRneHJRMnpmR0xjNURnK2swNWNldEovb1dQaGdpQkRpVS8wTXFXdzlnd1ZrbkttWVZRMnlkMldOOUhISCtPaHU1YmxvdHlUendMR0NqQVdMMjB3bE11RDhtdjJDODYvVGpHcXd2UE53N1BSOG9Hbk1KV0o0ekZ0T2o1TC9QUndZaEh6c1o2R0ROMnV1bmVMMEFyMUtmTlhEa0s0ODRhK2JuSEN0RWVUdmUrOW1jZk1KYVdyZGhXaE00dHNOV1lkaDNqbUsyZnZob1dvd3ZyNjlDN1VKS2YzTWVTS2tFSC9VWnhESzB3Wm53MlYzaGZndWFzdkJ5anFJeXg0ZGRodWc4ZW9acnVZK05UQk1qM3NKU25kaHdzUlZQb3oyU1RHOS9qZUNkZ3M4YTZETVhjS0I0eCt4ckdMR2E1czBJNVVxczgyYTI2RDJOYjR3YWR6K1VvWUdVYSs3NE55Uy9WenNtdFFQckdiVWxGMmhpM1ZOMFZPRlNKM3ExMVZqTWJnM0hNUk5Zb2l5cVUxTWc5c3ZaZE80N3ZNeVRjeDFhalhWQ2VYRWxnWEgxczdGMmZhalEyLytGVFZnTEczdnZQdU5WWG8rOFRaMTJhNDAveUs3VU82TmFna2FkdVhRRXpqSTFuT1krSnIwRVdCazd0eXhVeFpwUzNjTC9XSU50aHZjY0ZoREIyY1dqY3NxRVdLYVMyT014dWJjUHJvZVFvOVh1MTZHcDI4L1piRHpHMlhTem1LMTJIOG1hZmRMNTBHbVBwVHg1eTIrdVFsZERFYnVFZEdLdGYvMjdXVUlkRXh6OStWbXFKY1l2YWE3Wm1QWEs3YlNZQVl1OFEzWHBSclB1d1BmVGpXU2JEUWYwZFdyZ0pqRDhRaCtsQjlYRmpZUFU3ZENmOThmNExJVWZvVjcxTWhjSDdIVm8xMjl6dHd3ODcrclZ4TDM5eW85K2hnYkViVnMzWnM0dkpMSFFRaHN4M1NPQnBzN0ZMYmhUemM2N05kS2graDhTUExVK2Fpc0xvQnA5SGZPUnkzcUYxS3EyVEJSbDdtSXlUKzhlQ1dCdGF1Mk9VejFadU1GM2l2Zk1QcmxvYmtqMlFJOWNLaCtqYnhQZSs1SnExb1ZxQkxzL1lZWjdNbUVUbmNlRGRodndUelN0OGZqZ3pkVXIyOUhPajIxQ1lZTitaM0lkNzZlL3lhRCs1MTl1UWsyTzV3c1E5M2t4NGhEcTRWVzFvNnNIZ2tiNE1Cak53c3R4N0xxY05YZnVXNUNIUE9reHZUMDBVQkxGMnBMWHE3WnJha0VoNnRQS3hpYURlanZiMnFOOSsvek9LbWVpbkpRU3IyeEZUeDhtTklDTHBSWkdMYU9EZGpnS0N4WHVjaUlOTXdSMTlIN25SN2NpcWJNRTVUNGhrdmhSa3lrQm1PeEpaMmFML0VuWXpvNmFJdnVWV3RhTVJ5ZHlsUGhEQlhId2s5Z2VYMDQ3MHZYZFdCKzhOb3hkdjZaOE9ZdS9SOEt5WGdiRUdrZlI3d1V2SGcvcDdGRGdzZnFVcEk0VHVKY3greHpWN2oxVHR1VTg2OTBRemF5VG9MN2hlNzlGOWZia1RsMEs5bVdPaWx2UnlvOThqVG9aajdCVEdBYWFCYXZ4ejd2WDNTTy9ZeHFnV3d3UE1yZCtYNC82VC9uczZkMlFsb3E5SjdLSkI1M3NrWWgweDV4S0tZZ3BsTGhFSHNRL0k4dW42QkdPdVA3My84d05oVVArQXBEMlVvaTQvUEVUZk1lMmtHS3orZ05SM0JEMHYvUmxCTjFidG13YmVIOUN6eTAwTEFoZEdNOWRxYlpnS01SK1FSR0JlK0REaUNIT2xnWmtpWkg1QVd4Q1hMampneXF5WmZxMlJXL1VCWlhuSFNMUVpoREtEQk5ld3Vad1BLUFhGMkJZRG9XMTA2ekZPejdqalBxSjdJalAwUzRRMjBxMUtMLzNrcW4xRTAraXovS2NMN0dBMjN6LytoR3YyRVNVcjduY1I0KzVnSmpxZGtRWHZqOGpBYkgvMUVtNFUzWERDZ1cvYzZJL29XMzdlaWUwL2Q5SE55Z1JydWRjL29nS2xidlljcmdOemljM0NXbTdWUnpUenczejJIYTQ3OCtVb2g2OWN6a2RrTTFyMTVQQ0ZlNW5yQXJOZmNjZDlRcE8yM1lsenpEMUlmMjNWMzhWVis0UTZpdFFQYzM0Nk1tWGZFTTFjczA4b1lOa25wZ3NLWjM2NVo5N0I5ZnFFUHJXczYwemRFMDV2aUU3QTQvOEpkUjM5ZGxnb3pJOSthdWJzbVpENUNRbU9sWFk4TXVEQ1RGd2E5NXhiOVFuNWZpaWUrbkRQRVhwZ3djQUhMdWNUK2htUmZIWHV3eU4wcGErbkpvQllCL0xaZUM4amRuY0FmZHFYY1dOQXZRTTlMZloyamNtTnBCZU0yL0dCYTlhQlJIK3VMOVFidTU3NTlrQ3pLbmgzSUtOeHVTYVBHU0hNUzZITk15R21BOW5ZRE1SRjcvSm5oZzF6YStKZTcwQjc3R1lXVGdzNVJKKzd6RjBCcWp2UXVodmNtMmNFSXVoOU1VWnZ1WndPRkZtK3RxZ1dQT2x4bnk5WGNNZXhVYTJyQ3Mwd0xJVDV2R1R0TTY0YUd6bU9uRkthQzhGMHpvUkYzVnd6Tmxwek9TNHpnK3RMRjk4YzFjNzFZcU1ORHprMy9ENWJNY2R3ejRoRERCc0psSXplZkpnUnpqU2FtUDZTZTUyTnNtbUxHNFFnaUg0MlJHSXlWTFBSVVJ0TDI2L0RWak1MbVBlRm9aT054Ti9wYkRJeTNNY2NkbmhuSDNjY0I0Mkk1Y3pWK0c3R0xJNTZPeDNVT2NoQzNLLzd5dDRvZXB4MmFCL1hqSU1XRnpmV0wwUlJkTGRWRjM5d3ZUZ29JQ2grYXU4d2UrYkNnbSt2dU5FY3RMSnRlMi9ON3UzMFBhOWI4UGh6a0VicXJsT1RCTHlZWjk1c253clZISFRqU3VWSzlsNGZ1a1oreXhjdWg0TTJIdkFXMEJ2aHlmUzBkZXJsanV0RVQwV21Mcis2SjRxNWZ1ZitIcTVhSjJxNStTUGZOZVFrYytLWUh3TmNzMDVrSFZlbS9aTTRTUTgxcVJnTzNwMm96UElOS3d4QzZlMWwzZGovT3RIa0FMMkhMN2tlVEtlbm9nS1EyWWsreXIyN0ZvSmltZnAxYVFKUTNZbStKQnZ2Nk4vTm9BOE1QTzNuY2pvUnkrMng5d2pCN2N3VEEvZEhnMWdYc2gvdEVWN1BPRUxmMVB1Mm42dldoVGk2QTQ3OVJCTDl5YWtHSEgrNzBMWFZFdDdiNFJUOWxNVk1IUCs2RVB2RjY5WnZBNGZwY3VaemZuQ2p1NUNmNy94bWRZaWxiNkF2a0lETUxoUWhNSnl4SXlTQmZ1ZU13bGR1VlJkeVBwUjhXZk9iRXhQcW8zcTVuQzcwMGZwQ0VoRnlqSjYyLzZBb2lIVWpHZXVCV0RkR01uMzQ0bjA0L25jakxTTDVZeDczR0QzOE01UExOZXRHdnFxcWU5b0VBdWxQWmlyMGNiMjZrWjFvU09DREh5RjArcnhqa2hEVGpaUVdEcU9YRHZObGpuZXdrSVRNYmpSc1JyZFdLT01vYy83YW54KzVWZDJvdTlsTWZ3ODNnbm5pNnQzUjBObU5DaGVxcjE3RDNjZTgzcnJ6TzNkY0QwcVMzeHpoQTN1WklWdXU0UG5mZzZUdTNFR2J1TEZNUytmem9yQzZCK1dFSHBRSkRUbE9uL25sdXpoNDk2RHloakVGOTRGQnY2ZTJBZHUvQjYyNWNGTWxDY1V4RjlVK0Y0VE1IdlJLUDlEYkxXUWYzZXJSelQ1dVZRL1NrQ0RFNWczYlNaZk95c1R6cndkbHJyMngxU01rbnQ1N1hWTUt4SHFSN0w1SlcvUytPdE1WRGk3RDhiOFhMVjdUN1B0T0lJenVrSFc4ald2V2l6WkczcnpyeW8ya3R3UUlZdi92UmViZGVhZHZzSTR6MjNLOU9Oem9YdVNyT0s5N2xPRnB1dUNGaDIrNTEzdlJrdDFqaUR2Y09PYUxPV0lUb2JvWExkalc3T1BJU21DMkduU09nODVlTkhYZHZ0R1JJU2ZwTlN1YkpVQ3NEK21tYmZWeEVyU2w3NXd6WWdLbzk2RlJtck1xSzRrVHpGWGV6ejV4emZwUTQ5a1JJM3lIUlRJdm1tL2hjTDM2a0lUam83SHZpTk4wQ2JGM0V5R21EOFZ3cnU4dDNCTkJQMnJ3YURoazlpR1dLQ0V5Y21FeWt6bHArVFNvN2tNS3kyWi9WOXdiejR6Y2ViZU55K2xEZ3E0ZGpEdDc0djc0L1k1aEFPUTdtQ3hCbkVhUTd4ampKSXpUU0p4RzRTU0MwMmljUk1uMzJuRWFpOU00bk1Sd0VzZEpBcWZ4T0VuaUpJWFRCSndtNGlTTjB5U2NKdU0wQmFlcE9FMGpmNHNBcHhsQXZlOS9Td0FnSDdlZmo5dlBGeVIvcWhBbjNINCtiajhmdDUrUDI4L0g3ZWZqOXZOeCsvbTQvVHJjZmo1dVB4OUE5SUVBaU9MeW9yaThLQzR2K3V6djdyTU0zVCt4cGU2ZnZDVUcveDllQ3pLMTJKQ1FrUEFlN1V4VG9QTGZMekUrYmIyOG04aEhjZ2VWaG42L0t1WHpuODl4bDl6ckRsVitUREFzOWVSbHMvcnBndzhYOFBFajF4TTVOUTBFN1V0TDA4ajBxWU5mZnR2eThldVhUTndlMkVCNHJMN2RrR1kvYTVBMzVPTy9xaHk0T3JtQmFIRE9QUE1tL04zZytORDQrS0R0eDdjOHJDZGFEQlNPdVU0UkhDd1BmTHp0MUx5RGR2VkVlZmdxWTdXbThZUDlidW43azgvWXYxOWRzSjZZTnpxMG8yZFI4NkQrTEQ3ZTJOVmkxZms2d2padXpmNmlHN1RCOGlsOFBDUCsxUE5sZGNSUlJtRzl5WWJaZ3p5RGo2ZTl1dC9hWGtzMEtkMUptQjRzTjhqYjh2RVJMOFp2akt3bFVHYlZiY2xTcWQvakRmbjRvS3J2Q3hWcWljQ242K1JsTjA0WTdEK05qNDkzelkwdnFTRUV6ZHRjbU5kbjhPekQzLy9MbDIyY2E0ak9qRkN0b2hremVQYnA1ZXYvdFc4SFI5UVFXemVPR0NqSWtCc3N6K0xqWS94YVpWT3JpYkhEZS9ldzNVUUgrUlErdmpvcmJyWmhOUkdpMG52bXJtNG44N2Q0Qmg5dnVObEQrbDRWY1lDZWNGblJhZ3pQUG55OGJYUFoxYzVLUXZiNi9zUTdja284Ky9EeG5ZcWV3bk1xQ1RFdU1qZFRtOGl6RHgvUE1uT2JhVk5CVEhFcGZSQjdmeVp2WHZEeEthZUt2MFNYRTlyaHlTNW1PK2I4SHQvU3cyY2ZGZi85ZVdWRTlKMkRHcG1ta3daNUZoL1BZcGcrNmlrbHRzWlVJQWZUKzRQK2w4TEhaN2JPWU00cUpUN2tMbTEyUERRNzU3ZDRCaCsvdWpkeDQ5cEh4T3Y2WE1Fbk5ZcTgrY2ZIVjlPY1VrSktpRkg5ejBLSW5DSDc4ZkV0WXNNaUx4Y1Q2MWVzODQxNTlwczhqYi8rU1czakhoY1JXMXR2cG01N0k4YnpQMzc3WFBCVzV4WVNjMWVMSlM4K00vMzMrSlp1dnY2ZmZmMVdycENJdGhhT09maUN4dk5QUHA1UjVxNWtVa0RRZzNUc2NrVW5Mdmd0UG9XUGo1bE8rK0dUVDh3em4yT3lQNmlMRjkvNCtNNFpYOWNlenlOR0Z2aE1WRDhzeTdNdkgyK3IxcUI0SjVjNGtTb3VuY1pRL1QzZWtMLzk2bDE3R2xsRXIzVjd4QWxYa1FXL3hkUDQrSlpuR3JHZkNLSmJLOVhHUElEbkg4REhneEtlSHc4Sk9wNG95dHFLQzM2TGIrbmk4MS9yYVBQTlRFTG80WmIxVnFMVGVQYm40MXRXelBNNGVwOG91V1RkcmpPWEZ4Ly9pVS9oNDFNMEhpL0p2MHU0V0txWktPd2EvM3M4ZzQrM2ZSdFYyM21iZU9xbjlVanZKQzkrMmZMeE5DRWtQQ1dic05wY1pHYzlqQmYvL29rMzVOZC95b25HaGJlSWwrTy9sVC9kclB4N1BJMlBaNlN5ZFoxdUVLTlNvd00zNzVMazJaK2ZGMmVwaTF3bllvL29ocDNab1BKN2ZBdmY3MHd5SnZrOFgzU1pXT1g5K08zTzBLbS94N1A0ZUpibTUvWCtGd2oyMlc3dHBUK1VjMzZMVCtIbmY5NDdjQ2FWdVBSVHJ1L09zRDc2Yi9FTS90L0pEQnA3T2pTWmVETnF6eTQ1aGtMT2IvRzIvUDFyRUo1eTd5UXg5M3ovTWZQRDhyejV4Vi8rUjJZR0s1cElQRi8zZWRmMGw4emY0bW44dkppYllrc0k4Y2J3NlJqVU9pbm50L2hmZmdmMDc0NS80RmtjUGo0eVFFcU1nZHFWa2hMY2lubnhsY0hITTQ2dHQ2VEZvTm92clVMV3pVUDdLLzd5aitSbkw0OUgycUliTmUrbjhOWUg0T01OMnlJM0xVeEI2eHE3YkZqaUFqei9ZUE9WVjYyL3RqVU55US9rQlBoTjRJMC9nNDluSlV0ZWlzdEF1K1UyVmgvZndldS9JVC8vdk1LdjdBb1NsbTlhMXUweW1XYy9mbDZJcGZIaEdncWUvOGpNUUh3c0wvNTM4TTN2cFRYelQ5NUFwOCtNc2R5a09iUSs4dkV0TlJmNmNtNmhSdE5uNlp0TGVQUFBsbzlQT1dteThYMDJtajV0RTEzSWxhZS9JUi9QK2lCU0IzZVFaa2ZTeGNQVFB3MzZKL0R4aGhzMmJkYTZoNTR1eTVsbkl6NkxaNTlQZlBwZFBWeXk3UUY2Ni9KRmlSRXpucWNmSDIvSUZGZ2Z3VVIxVnpZVzFTd2QyaC95OFRTUnNMbkZEMUhMa25mWFhWZ3FQUDM0K0pabmMyUGJDVFFnY3Ric3NmWlFmT2ZuNTRRZW1aaUx1b1ZWS29NNHZQMU55MGUrOVd2V0hxVkx1VWc3UWQvb3lBV2VmVkw0ZU1aK1VidWFQSFEyYTIrWmU5SndYbnpsNDJPa01uODQ1YU5JMzVXek10U0tCdTFqeU1kbmFvVXRpQzFBUWJjSHpIZUU4ZUk3alo4LysrYnRuRUpVdk52MWJic1dyLzh0SC83a3hRNDlOTFVxUWtHcWRPV0RWVVA3Sno3ZU8rQ2dSR2NSZWpVejhlMWg4YUh4NStOWEcrMDdIRm1NUml5TzlSYmJPblQ5d2NmRDNJL1hINWFnR3VYM2w4d1hDUFBzeTg5L2FkNjQ4Ukh5NHFhc2wrOFc1c1ZmUHI0bGl0NXhyQlM1enJSY3ZkaVhGMTlhM3ZQdGY2eXRtalRLMEtWWFYwd1A2L0QyeHl3K3ZtVysvb0hxTW5SYndueER3VXJlK0tidzhXS2RSZCs5eWxHdDBvbEMzMDlkZy9ISGxvK1BxYzljY0tNQzZXUktmVkhrOHVhdklYLzVOdTdZZFpWSXZYZWg3UnlKdk1IeG9mSHg4UHpOMWI1S0pIN2tnWlBVekZMZTlTOGZuM25MZldwQ0ZWSi9LVnI2cVd3S3ovN3RmTmR2SnJiNlB0VW8xclJqd3JQRXI3ejR6c2ZiMmptckZGU2o5eC9vRXc1SzgvYkhERDYrbmZUUEdqUzFNOTFoN0V6ZS9MUGw0NzllS2JOeHEwRjdKNlIvcVRnMXRQL2s0MTAyT2lRUU5laE96ckkxSGVlSDFsYysvdTVZanlXU3RlakQvYVgzWHh6ZzdZOWEydmpzMTd5cjgyRXQ2aFZjdmFJL2tiZS9ZZkh4dG5XdnVpVHIwRjM2ekxxZHJienhUZUhqeFI0R09ydlZvWkx0WFprVm51Szgvdkh4NmxyYjErYlZJWnNjb2R2bTg2VjU4NXVQYjIrWWxUV3BIaVcxeEh6U2ZUT1MxejgrdnNRbjc3QlBQUXA0N0R5cWNnN3Y0WEVhZi8wVHo3UThxa2RwVFNKVEltbTgvU1B3OFNuNnd0ZGtHdENHWXNlOTNnOTUxLzB0Ny9qOHMyVGRsK0FHeERIY3hPNjR5dHZmc1BoNDJ3MHZjeG9hVUxOVDJrakYwU0k1WDM4T0IxT3Z3YmVhYUs2ZVc3MThQZXo4WGIwOFlibTd1NU96blR2TmZvZS9FODNQeVNmQXlkUEJDWXk4UE94Y2gxNkNXdXZrRitEdXozdkZ5OXZYeWMvSjA1OThuUXRYNkUrem8vbjc3NERWVHI0ZXJuNSt1RUthbzVPbnE1TWptSGs3K1ZJdFVPVzhTZDdmSCtkakpmd0NIRnhvVzEzZG5jajN1eHhkZlowYy9Na1hzb1lZYjE4dkJ5Yy9QMWhLU2pnRnVmcjUrNEdsblh1QUU4M2Z5NHZtYnVmcjdFVGJTcGEwODdjYmZQZUxMT2x0NStCRWMzZmE2aytqZEtCZS8vcjFoUy9jRGE4QVh5eGxIK0MzQTVaNyt1UGVCWGo3azYrTERiNEs1bURuN3Y2bkZNN3g5dksxOHlYZlF3dnd0QXUwYzNXbk9qMzBCcHlmazVNYkxQYjE4dk5UR1d5TzV1N3E2WWJMMnptcWVIbmlRbFFQQjZzR282RmVVdGJBTldPYkxmYnk5TVNacElsSW0vci9QKzNkWjV6a3hua240T2tjSnUvTVJnYXRiUGxzeTdvVnAyYzRXdWw4UHBPU2FPdXNaSktTNzg1bnR6Rm85QXk0M1EwUVFFK2c3ODdNT2VlY2M4NDU1NXh6empubnZQZStieFhRNkptbWZzdnpoL3Z5ZjJ4eFVBR0ZRcUZRS0tEUnZYUUlxSjBzTDlaMGdWMm42am5Ob0QxenRlbFRTLzZ0NHdjcmJYOWx4WmxwUklGbXc3TU1jMHBxdW9uK01oMGRTRnFoYTFQUFdXTTFWcm8ydGRndmZ2Z2JmWEREVnRmN1FPMnF2NFBYdFduTk1kZUU4UjcxRE5xSHlyejh1Z3UwRHVJdi9MYmdsdFpzb0JwQ0d2M25zNWE1VXZVOXZmbXdOZW1vTnV2VXI3bzIwUXZVbXJSSGNzU2R4bVRYRm5QMUNhZG1tOUxJRk9XNDBqOGEvQVhFS05PV3RGQTNHbk1ySFpkMmxEY3JPNitQQWRWY2FsS3hmTk96WGFvZjFUVTZySnNhbGZuSnZJWTVaZGNxVVpma1RHSHpTUGVNZW1ScjIxeEJuMWZsNW90dkllcFpGZW9pMHJZelRwTUtkMHl6NlhWdEVSaDBBcXB6TFByQ1pOZHZQV3BtcCttdnBHTnM4Y25TZG1hWkJwMnJOWXJhck5rd28zUE5ycnMxaTV0UUhhMDZWZGFnVTRaT0JObzFQb2JxcFBrRm5haUJYYldwV0k5T2tHbksvVE4xckJ0eVRQMkFlcEswbXB4b3JmM1F1Ymh2Y3MvVUo1bks3c3VYUUhrdi9hNWY4cEdhTXZ5VkV4WWREZCtpZmFKdC9OWnpBc2QwYXZyNGM0dnFHcW9XYlRVL0g3b0pTdmE1WlhSSFU5LzRwQ3I0Z2QxUWpSQitaVFRxb2IvU085dzZOdEUyWnp6cUpyTDdNb0xvMHFKazJmRm9QOXVpL2FaTG93RTM2UmF0TDUzT1MvbDFXeWhhWFgrWHRUM3ZKdTFmZEcxTGxJRkFyeDFsYksvYnI2MWd4dkhXUktkL0dJNmYvcDNHbDRiS0YwOHpKc0xhMHpsYXJWSjNVR05wYTJONmoybGJwbHF0MVFwY3ExYmtUNDJHN0lqVm9OT2tHbGhoQzYvMHA1cUIxTFBWZDQwYTFiUXl4d2VaOW5WU1RxbFdhanlXemd6cUYzSnVUaG1OaXB4SmRZZE9sdFlnOXZkTmg3cW9OV3RhVmlYczlSVzdXYWVqM0d4VXV2NUJEcnVPa3M3L0s3cWcyVk9PdTlJSWVKem55bSt1KzgvS05kYmN2TmIrTzRyaGptek51dExEd3JCMGJEcERhVnhWa1RNRzk4T3RwRFc0dWNQdkljZWRsUHpIcm5jVEYyWDJ6UHhKWW9mc0Jxa0QwMnU3YmttTnBMcXpWeWIyU2Z4YjZ2YjBYM1E5bmoybmE5UFVyMU5QSnZyU2k3dU95L1ltRGt4MkoxZG5LOGtyazJ1VC81UjZKZDJkdXlkNVIrYWR6Qk9aNTVJYlpuK2UzS2xyKzJRdDVhVGY2L29ndFN6eldOZmpxVjltdDB6K2ErS28xRlhwcnE2LzcxcWN2S0xyZ2xTOWEyMWlwL1FQTTUrbFYzZFppYzBTeDNSZGtqMDE0U2UzK05hL0R2L2Q2Qit2K0dISGY2Smg0L1RmcEgrLzRCKzRPTGJEUDJHMFdlWmZNbzJNa2UzcXVpZXF4VzNaMTdLZlpUZk0vVGozaTl3L3QvM3prL2NGUjNmOXcxRlhmWDliZC9QK3RXdi82ay81MzJUZ2YydnUxUlJONmY2VXRyQnpvdXV2TiszdjJ2YmdRN3U2bnZzb3cvOCtIZi9vME5iMHZ6VnIxNjY5KzR1MWEvZS9KdnozdC9qZnJpdDJMVi9PLzRLZC9HUjZsL3JGODY3dVZ2cGdrZEpUeFZ4WG9xdlFUY1VWc3QyY251VjE5SnB4ZmJHU2V6bTlseitVS3ZSSnlYMng5QVY2WXN0RDBYOEtQV0ZpejhKVnRQZy81c28vWUo3dWx6VUh3c1NCRHVzbzhYOXlaVEQ2VDJGUm1Fai92NEtXVnF4WThZMUZ0S1VYdmpGYnkzQnNlV24wbjhKd21EaThjQlZ0U1d4NWNmU2Z3cEl3a2Y1L281SFM2TmpHNHo5YS9lTk5OdjNwejM2KzJkcHZxeXVSVEtVejJWeStvQ09LM1QyOWZmMERnNHVHaGhjdldicHMrWXIxMXQ5Z3crK3MvTzRmL2ZHNnBmOS9SdnVUenFXeTFMazN1ZmJ6L3U1WE14ejVzZjdYVkx1MjdVcS9sVkhMeDZiYVQyVCtGeG40cUs1SC8xdWYvcmRCVi91L05QRC82bHo5OXp6OTkzejlWLytEQTEwWDZyOFg2YjhYNjcrWDZMK1g2citYNmIrWDY3LzZoLzI3d28rQzlTMVYxeEg2bng3aC8vNGw3ZFFmL1lHNi9mYmFWaHVNZFVoL0tMYjhNUDN2a1hucGozWlk1NjgvUzhwMjV4dlFtK0tQZVorTXhZZi95dFhiWGRHL0Z2aHYvSjlNTE0vbTN6QmU4emkrSmYxdjliTDJ3V0wrRUIxMWpuOEh2cU5rOFhyOTdnL1U2L2Y4cjRCd3ZXTFhnUG5adVU2ZC84V3VkYmZ2MmxUWHYyeEkyOW5rMUcwSHVrOU8vSmx2YjJPVmFmclNxRml6UDZBL05CMHhlSXBjVmpjaVAxaXBNelNhOVRKTm5XZ3lVL09qU0oyVnBpWFduLy9sVDM3eVYvLzZ2N3YrckVsbHJDNEgzLysrekl4L1FET3dKdis0aVJ2NGY3Z3NqbFRsK1ZGWjRVTFhKczl1TjlEOTRlVXIvNTE3RHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQi95SGxYSjlJTm8yNGwzcmt5Y1dLeHE4ZHBiTktzMk01bUhzZjE2dEFXZ1djWjlXVEdhZno4TjV1bE1zYUU0d1hwN2trcjREWHRSdFhKY01Db1ZEd09aUE4rNEZVRHUyN2xCc3RsZjg0M2pWcXRYRFViUVcxOExOOWZMczhZdmwydVZzcG16Zkd0UWw4cmdyWlNLY1l5ekhoMllIVXZ0dXErNmRsdVlEWEtkYXR1dW5QbENYdXlaeWdXWFRFQ3E5eHdabnBYbG1PeFZDZU9MTnQrdWU0MG5NQnAyR2Jmb29VWitwZnBUVnFOYWR0ekdtWGYzc2J5T1hWZzBid1VpaHNjYmxXd1d2RURJK0RZUlFPdFhYVmNxMkVFUTMydEdOZXAxWWFYeGJac09nM2ZxVmxseS9NY2IzR2hIR3pqVTEyMjhwY3NpV1h5TEs1SWVjb3kzS1d4bGpSTTAzS0RzV1d4OGlmc1JtVjVMQXNWMzdETVlNVndLNHJxNkR2bUdzY04xb3RWdFdiN3RLWDFGN1ZpUE11Y3JucE9mWU5ZTHQ5cVZBSm53M2dNRldVRjMxbGFMazhaalFydENMV0R1YWJzVEZ0ZXRlYk1yRnhSc3lhTm1sMTNxYWQ4cjlWZXZtV3QrZTZTdHJUNkd1NHB0T3QvdEx3dHZ1YlFoblRTSDdldk1sblg4ZDhibEtMclpiWFRnZVA1ZjlKSFI4bmdUbHV1Y2gvK0QvMFVybGltVTdHOHN0Mndnei9OVW9UbFZQK3NoME5oMHA4UGNGK3dHMjR6S0U4MHExWEwrLzd5K1RHMEZkY3c3V0R1TDZpTE9wNDlhVGVNV3JsdTJJMGZGTnltUDhXOTBQaVBSYk5tR1o0c3IwcHo0Zzk3NmtaZ1RsRUwwZGt4dVZHeFhKN3dad3kzUEZvYUtYS0hwMjBFNDJPbEtINThiSFRBbW5iYUtqM1d4ekdxTWh6ZXVKL0R2cHlXRWpFdUVkVnEzYlVtSmVKSHd4eGhURk03Nk5yenRsWVBHOU5VNHpXNjQrazYvWGhRVnE3SlBxaXQvcVRZcXNKLzZwWnEwcjdUSWYvTGJ1NE1PdkNmZTFRTzFkUi9KY1c0aHVkTG42VlMvUC9TM3lwR211U3ZleVZQMkZxYkRMVldtYUZqU0NPQ3VXWlRXVW5YbXZmbHB3UHpJa28vaThkSWcvOThhU3ltWWxXTlppMmdzMzdhMmt5YXJuVlEvcWE5c0lvMSs3ZkRzWmlHTlJ0SVUvMGlYZ3VPK0sveExSaVZhYU5ocXYzOHUwNEpnV0hYZnJtbzZkWG9WQXk0ek1BcDgyajVxOFd4T0hQS3JsVmtrNy91clZZcElUeHhmMU5VUVQ1ZmZ0dWpsdFZwLy9mOUtzU25uVDlGUjNMemJwMWNvN2JiWXBBWHF6WWZJWThHUE5PcGJUbXMwbmxRS3M5TTBZREs1L3p2ZEtFeUJMdS8xNXZqM2Z5SEpaNFZlSFBsd0RNYVB1L1JqR2U0cnVYOU43MGRHWlAvZTNkczlmK3hWTHBaMjFabFgvOXhzY3JGSjFMVnBrRkNqUlgvYzdnVjdVL1JHUzI3K1UrTHFsVnFFSXRHRVRvaHFIczIzZUNmT1U0S2I3VlVlVmw3bkZremZGOVMvbVd3V3JVZDZTQmwzY0xHSXNrcGJSUEdUZVFrYm1hMTJhTzZ2RHB5bGJ6c21kTU1yS0xLd01HcVdwYU1rd1ZaNXNwT2RkUCsxUFNhdHRvdUQrQVVJUmVQcllaaXAwellnbXYwK210c3Q2WVhLV3RkTFZacFNHcW9tbm1ySFJYSFpiaDlVcmdVeDltMzFrbTFrWEV2WEN5TitlSGlhQ25RaXhNajQ4MXdzVFEySFM2T2xtWjZaRkZhUC9CbUIrS2hrZkdhTlRjdlpzTGFKbHg1Zk94ZnU2VTYxUXAzcC8vVnJZNkQ5S0gvWFd3Ri9zK3c1TElhZnRPenBNRW1xQ1grYlNEY0ZUa2MxRmJiSnRiVFVUUGNlV2JzWUlwNzBJUWFLN1pMREVscWU4L2RQakVvRzVMWXlseUR5OWtoc1R6cTRqcEtkU0lhb0hkTURIT1VQaFNjSWdkMnAwUnZtRlBDT3lkNndqRFhkNWZFb3RidWhHWHVtbEJIdXVwWlVkeHVDVG9ocWZzRk00NjNSdnJlN29sRnNaZ1pnM3BqdGJKSFlzWEN5REpmeHFqRDdabllNSmJvMXl6TGJaMEQ5a1ROMmlzeEVNc2dkZG83VWFBb2RSbmVSNWJWcFh4ZldWWmp4WDVjWDVsN3RJcmJQOUVYNVpWcHd3SGN5dUc0dzBNeEhSMnJkbUJpa1V1WGhxRE1renFMVGpCZTQ2REVFc282RlFSdVdWM1NHZzRmcnRtNWc2VitOV2VTNjZndUxZY2s2T1RuQWJoY014cVRQUHJadmpNKyt1TkRWYnc3cHJwMHhhTFpUcmxtTlE2VHVyYkhIeDdsVlZjSW1wTkovQkdKOWR2enlybGR0U2RWOHBGU0c5NjBKRnQreFQ4cXNWeEhjYmMyYVJ4cVdEVDVNZWFvOVk5dXo4Nkp4eVNXeGFQOHdLZGlHblN0dFB4akV6MGN6eGMwczJ4WGprc01SZG5xaHFrdnFNY25lcVBZeWRwRTdZVEVRQlRXMTZZVEU4TlJWTE1TR0hyTmsySnJyckhtL0pNVEJRN0xTWEZLb2o5S1U5ZlhVeE85Vlh0V3VoRlB5NnpURW4ydC9lQmVjbnBzRlhVR25LRzJLNE8xREtlK1VYZHIxcG1KSmJKYlRjK2pIZFdSMUd2TXN4STlORVkzYXp3NXA4dkMyV3AxTlRqNHBzN29uNU1ZbGtIZU15WmJzNUtxYzI3SFVxbmx6bFAxOHVtTXAyN2tPVTV3Zm1LNTFJdFBMYXRoZW5QVTgybWlKaGZvQzJLTndpZm5oWHB0V3RSYnU2ampobWhFdmpneHlBbDF2anVoSWFVODJmQ3NTeElyMitLb202OHVUOHk1ZkIxeHFiL1RZYmcwOGQyMkxIUXg1Tmt0elNCczJ1bEdzejVoZVpjbDFsOVlESjhScW9qTFk1VTJ6SnAzUldLeERzdm9SMDN2eVhwWHFtSlV2c0RoaHFPVEpVcStLbDdNdEYyNU9yR28xYlBEVE5mRU05SHBlbTNiU3I1L1hWdDR4THcrRmphbjNOb044UVlPVE9mR2VMcFQ4MjZLaDRQQXZ6blJSenNwaTNKZXpOMml1a1hUbFJ1eENrWDdVM1kxdURXMlhzV2R0VzZMaHoycmVuc3NiTlg4NEk1NHVGRXg3b3lGcTdaVnV5dStIeFd2Zm5jOFBaaHo3NG1GcHlvMTc5NVkyS2J5NzR1RnQzSkxVL2ZId25XcStnTnQ0YW5LZzRrVmJZZllwQlRwbG56R1BSVFBURGtlam9jZHAvcElZbEMzaDV3VzBwTWZiYzh6L1ZnOFBEMVZlVHgrSUthM0huMGl2c00xdzN3eUZxYis2ajRWejI5WFpwOXVPNUN1LzB4YjJLcysyeGIyemVmYXc1WG4yOFArQyszaGJWNU05UEo1UG1IVEVhNDVqY21YMnRJRC8rVjR1Qks0cjhUQ3dacXB5cXZ4Y0xVU3ZKWllYd1prZmQ3T0h6OWViOHMrVlhrakh2YU1OVzhtbHVwWnB6V3RCancvVUEzOUZsMXZhV1NVWmRWRjFTZ1owTWpndngwdnBtNVczbWs3SFF6MzNiYk5XTFB2dFlXYmpmZGo0UmxqMnZvZzNtM3Bhdk5odkpzYjV1aEg4YkJsam40Y0Q5UEo4a2tpSDdicXAvR2k3WXIxV1R4Y3RXWS9qMWVWbHI1b3Izcmp5M2pSMCtiSVYvRURNakhwZmgwTE41dDJaVzNzK2hVWTNxUlJuaXVOakcrYmpKMVhOQ0p2bDJ4ZFJzeW1UNlBVOW0wNTZzWU9zVERkSUpvN0p0ZUxIOWkyRWIzcTdKVDhUaXUzR3F2bjVkZzVYcDVoYjdOTFVvWTlQbzRTTjhFM2lyc21sOG5GVVNZSFJuUFdydGtHWmVEMWQydGYzOWs5Rm5aOWYycVBlTG81VmQ4ekZxYVprYmxYTEZ5cDFveTk0L21EMGNvKzhmRDBhR1hmZUg3SDlmZUxoK3MxZC85NC9ucWxma0FzVENOczdjQlllTm8xellOaTRYckZuRDQ0bnI5V3N3OUpMb29mWjVQK00yMGVtbHpxMDIwdVhWSGxST0pCcU94VXEzUVpQQ3c1d0RmK3pWbSs1NldaSUkxS2h5ZHBoa3Zkc1MzeWlHUS9SZHBWaHc1cElQT0RJNU04WHd5bVpFc08zZGtlbFJ5aUxEcUgzR3R4dHFObFJTZTI0akhKSmNhMERyZmRmeDJiSEdoTnJOVms2TGhrZnpTalZ6SEgwMmJWdXZxKytZVGtvSTVvM1FxZW1GemFGdGU2RlR3cDJTUGRqM1pwMHZIbVRrNHVpaWJMZElsdVNPODVKYmtpbk0wYVRicngwQSt5OU13cU9hVERFNFp2bXpJdnJ2dW5KWWQxYk1XZTVMRkdSWjgrUDFxTisyY2sxMi9iZ0Z3OUxINnE1em9OM3pvenVVaGZIK3FWamZYMHp6OHIyU3NyK0ZQTm9PTE1OTTdXWVdrYnN6RjdUcktiRDVBL1MxdXlnM09UeFNuRDExVStMOW1qemdUVGNkYlkxdm5KQVJYaysxSVZkVUZ5L2ZsUk5JZHdiVDA0WHBnY2tHM0ZKcGdYSmZ1alhaaVdlZjNGeVVKVW9VdVNmYkljUFl1NE5ObXQ4c3J0eDJXNlBMbS9vbExkMnR6bGVtM2V4QlhVYXRIbTlLQlBIZVhLZUMxVTlGVzBtMUZCVitzaWVQWjNUWEpSdEJ6ZDhGMnJjMHNQdTA1dlpONGppT3ZwOEliUnJVY1FOK2pHNXRpYTNiQnUxR0crS2VUcTNKVGsrN1FGejI5YTNlN201RkRyMFViNEtNUy9KY2szR0J5MWRlRFNMRDBJckZ1VGZJUEJUV0xNVFJwMmd3OEQxOEl6Wm01TERuZEt1ajNaclk3ZHRGRnJXbmNrdTNXUmt6U0kzeW1ycUZzU0RrdUNYYmtyT2FnejBVVktIOUM3dVlZUzF0a2w1ejNKZkdDcVkzcHZza2VOOFB6a3VWcTVMMW5rRkhWQTcxZlp1Q2tlU0JaNFVZN0lnMnBaMnZ1aDVCQXZ6MnZ1aDF1eGZLUHZ6TWlqakVlU1BSd2JkdlZIWlorNDliWnk3TVpqc2sveXFOS1k4SjFhazdvUXBUMU9KWGwybmNiWTVnU2ZiMDdBc1U4a2U5U3E2a25qazhuZTJFbXlhdVFwT1FDdFdaelRtSDVhaGpXN01qcGRVdmV5ejBnZUZSSFE0RW0zcE0vS3FLR2kxRUJybThGenlhRllUTmpubmxmampaek50UFlMeVFGNWNrOWpsei9YTUgyamFyMllMS2lIVzVUOFVuS0ljOHYwWGFwVnJqWWI1c3ZKZ3JyOFVJNVhra1g5MEpUT2dGZWxzNml0cXZ1amFNWFg1SENxSkgwWmRHM3pkUm9YMjJONVZrTTE5ZCtJRmFWUzZDNS9XbmJzelFWRmNkSmJ5UjUxRjJzNUUxU3Z0Nm1odVFZNitJNnVNbS8wM1dSQmtuajVQYjJXM3V6N2VpMGQvRUN2eGVWL3FOZmk1WStTUGZKMG1tOEphUmMvNWd1SWZoeWtubnlyd1g3MGsyOUlLSDI2SUVFOW9DdDlsaXpLZzV1YVhiZUR6NlYzeUJrcWQ4UmZKQmZ6NDdub29UWlZzOWxZWTFXK1RDN2xDeDMxWXI3KzZKcyttaHo0d1ZlMGhpcEJubnRIZWI2VzdTK01MNjJWbnFTTDV5Y3BaYXJjdHFtVjBRVnk2NmJWcEthalEwK2RoQ3BDeDZOSjE0bnRVa05SRnJrQ3lGNXRueHJTRjQ1dzFKdzJnOWtkVW91anZLcTExU0MxWTZwYmdpcnZUcWxGNnFHbnJveHNlT2RVWDdVYWYwaXdTNnBidGFJTUVydW01dGVlZG5HMzFDRHRLOTBHeUNtcXJsNjdwOVl6cHFQbndKUFVCbVgrSkVsdmVvL1UrbUZxK0h3K211clRMSDNQVkI4L0oyMU4wL2RLOWRQdW1GYjByTVhmTzdWY3hybTYyd3owWnc3bFN0T1RXN0o5VW5MKytueEswc25oTkdweis2YUc1dFdiRzJLL0ZCOStQWEdsRXZaUERiVUMwUWw5UUtwZm1xVFNOQzFWdndOVFBGL2kyOTdZVGNWQktYM05WVnM1T05WTExjSm52WG9zY2tocVVWaGJkMDBndDdBVi8xQnB6bmtGSFNhN3BpTDBIQzVxaU1OVEc2b25kRlY3a3ArbnFrN3RjNjlYYXh5UldzN2pYY2VWajVRZGlRLzJSMG16U1A4MzYxSGpIcTFxMWY1czRwaFVlT1dLb281TjhVWEZxN3ErN0lLMDJuR3BRZlZBU0lkNUpubDhLNTlwMU14bWplSk9vT2FaS0RjYm5rVVRkUnErVDB4dHdOT1g4T01oaTY1NDVRbUxQNWR0V3I1dlZVNktPam8vVVpDdTVBYit5U2srTDNYWGFWaDhMZEVmTHAyU1d1SmJOWDZNR2ViVmJYVnFhamc2TjlURVUwNmswMktubHhRa1paN09zVElzOGpTSkMrRWJpalA0OEVzczU5UWoyWmtwSHJIa2d4cTNaZ2RueVhta0hoZzVkTUdkUFZ1Zk9keEQxbGh6NnRwOVRtcUZOR3BEMm9sUFhydlZ2T2ZHZDA0YU5keTU4K0lwM1BSUnl2bXlsWEJHcnFmV0Y2U1c2N2JqT2JwdDFHTDN2eGVtQnFJSmdKNzRYOFF0cEdMa0RLVmJJUDRZOE9KVVVZS1Njc204UFBxandrdFRmZEw3N0hCQXZTekY5d0w2dkpNZWRibGswVEY4RWw0Uno4SWRvbnBsYWxsN2x0YitYY1VuV2F1d3E2WDIvaFNOT0d2MEN0ZEkrWk1lVFN4VXhMWFNXT0ZhOGNhNkxwN1MxbnV1ajZlME5mME5NcTVGdGVVRnVXVFNzRVAzbXpkeXMwVFhEc2VkNDhIUDlXK1NjVVpIMHc3ZUxPT0hEdk1Ia3h4NWk1eTVZU1NQcEJScE9rMGFoU3EzeWdvVHZqb0JKK2JrTnVpMkZGL2FPWEwrM1BQMlZMZk96cTEzaC9STURrbWIzUmtsOG5HNkswcVVhOEhkMFlaaUgrM2V3NWNUaWZRczA3S253eUh1M3RSaVhZSFdGWlFyZlYrcWx5TmxtT1Z0M0ovcWo4SjBIYVJlOWtDcUw0cVJMdnBnTEVJcThwQmNVNkk0cWZuRGNyUmIrV2pmSG9ucXE3TEp4ZnZSMUxKNU1kRlkvcGdjb0ZodEtJNW1aNDlIZTZpdXlPck9LUENlU0MySnRYdWp5ZSt1eUE0OG1lcm1XSDFEK3BTcWZldHU5T25Vb2xZTEJGWmRjajNEaGFselJqNmJzTjJBUm0wcStOblVvbGdFWHlVTXozcE9obVk5SGxKaHZqVGw4Nm5oVm15cjFWOUlEY3V3WVVhSFFmcmRpeng4cVMzR0R1ZExxUTEwQWVIaGJML2V2VXhET0ErNlZCUFBrdytDQXY4VmJpQlZVdHRLcjZaV3RQWkpYY2hsemlNRDBHdDhyaXhNMUJPeDErbHFKTnQxSGFjbUIvTU42VS94MXdqVWJyd3A4V3BHRkgrQjRLM1VRQ3drUmJ5ZDZ0VlhLYldWZDFMcnljZEQxdVNZZWhGRUhnV29ENGdtSjk1TjlYUFltZGlLZHpPWWM2MzNWSXgrRU1XajRmdXBZdmhBYnRYSUI2a0MzU0xPU09oRGxUVjYvcmxxNUtOVUlZd1orVGpWSzhOZ0dQRkphZ045emVoWW1kS25xY1h4RDZ2REJ2TS9hM1dhdGljbm81L0hSdURZRk8rTFZQKzh0d3krVEEyb2JLM3UrVlZxU1R5cU5YQjhuZXFMUHl0Wk5iSldyaWVPMi9UTG5xaytYYXRVdDAyM21xUzBYVHFlZzY0Vm5HUDc5UHpWYXM3a0RndHlVdVNPYlpGY0xOMzM3dFFXeVpOM2l0dzVQVFN2ekNiMTJGM2FZcmxRanQwMXZheERYanFqTFhlMzlOSk9TVFJwM1QyZDR5ZERXM3ZCSHVrbDg2dHYwRDI0YWUyNW9BNTgwUFphVUNSVlYxTDJUZytIS2ZHNTRUN3B3Vm5ibmFKU1Rab3FsMGZHcVNuM2JSV2lQK0VNNXdIN3BaZUduMUo2bHVQeGUwQjBVOUtnMitUOTAwdm1wMHc3M29UdEh5RDFOSzBheitvTjJyMEpmaXh6WUhvZ2pLVU5TbmM2S00xelRkK3VyUWxQTEwvcFdwNmNmQWVuZXlTaDVsZExOZGM4SkQwa1Fia2txWjdqV1kxRDB6MWhBZHdORDB2M1JrRWV4Zzl2SlhON0hKSHUxVVc2SmRlcHpSMHA5WlNPTHpOVG1qRFRIZjVSYWI3N3IxYlYxZVBvZEpFWGVlWllOby9oOG1sRXNydzZ6NlROWTlOTFpicEZMVjZ4WjNXODNBUWN4NnRKSVRUeUhaOGVtcjhSYXZVVDBnUHpZMC9za0hHMGRGS0gyUEd4azlQREN3c3RyVDZsUTNScDQvRlRPMFJ2UEZJNkxiMTRZU0VibGNaTzd4QmYybWhzOVJrZDRzYzIrdkg0bVIzaVY0Lzh1SFJXZWttSFBSOWRQWFoyaDRUUjBvL0dWNS9USVdGODQ0MUh4ODlOTDExWTFPaklSajhxblpkT1UwT1BuUzkvVmwrUXp0Q2ZrZkVMMDJuK0hQVWlDWTZXTHBhLzQyT1hwTE9jWEZwOXFTeFEwMXdtQzlRWWwvTVpHUER1WHlGTHZNTlh5aEx2NGxXeXhEdDFkVG92VzZEZHVFWVdwZUxYeXFKVTlicDBnVE5JNWE2WFhsK3ZtTUhJeG5UaThDN2NrTzVyUlhIRWpla2VXd2VuakZyMXBuUldoVzVXRmRxNGJONlM3bkVkbWhFNEFjK2p6VnRsVnplK3JYVkd1ZE5iUzFHM3B3ZGMxNVdndnY4eTcwajNjMURObytWVXZGUEZoRmQzaXJrclhaUmlwZ3pERzdrN25aY0FOZk05ZElyem9qWHJsbVhqOHFrSVhaM3VsVEV5MnJUYXNmdGt2SkhJK0dYMC92UktsWkgyUU0xZmVGNVUweTkyMlZ6bUEzTGlTaTQ1Y1IrVUUxZUY2YngrcUJYazdUeWNIcENSU20rRW94NUpEOGFqWkZiM2FIcFJQRTROZm8rbEN4SlpOU3JXNCtrbDhReDhqOTJvR0ExejdvbjIwcVJLVDBwanEyamZsWTArbGU2cFdGYmRwVnRIdXQwM24xWUhTZStpK1V4YTNXclFhS3JlRlh4VzJxeHFCZkc3NHVmU0E2MWM4cWYwZkxxL0ZTVjc4b0k2MEU1OXdtN29SbjFST3BGK3BzWjVYa29YVzhQM3krbkIyTGJWamRVcjZhSFd2WllmM2xlOTJoNnI3NlJlUy9NOU05OTFWcWlpZEpDY2h2OTZlbmxyTG1CUE5tSkpwVGZTUytmUHRheFp5NlJCOHMzMHNtOUlLYjJWN2cyVCtKRlM2ZTEwajc2d3k5VG5IVzZHcUdLYzQ5MTArRlJMcGowMDNPcXAwbnV0a3FRdDN1ZEdiVDFwNEhuSUIrbjE5YnJXTEU5VTU1WHdZWG85blJ4N1l6ZDZwUE5SZXRrM0pYMGNsZHNwdGZSSmVuRzhKbE16ZXNiMUtlK2NUTWdDcDhtdjVJMTkxbW9vK1N6SDRxZWthdGIxZVhySmdnVFBvcVB6UmF2WlkwbDh4bnpaTVlYdkNiOUtmNmZqT2s0OW5NUjluZDZnUXc2YXorbjB0V20rYVRNc1hidHRNMkZRUGpmZEx0T3RnOXpudDZlUXZDd2xhVHVva1A2RWRjZU1ldkc1VHAxaW9sYmFLWlAzbXhQeXRzYk9tVlRkbnQwbFU0aEszVFdUcHhpK0o3QjJ5d3lFMndzOFZZWGRNMHRpVWR4dHEzeXpaRS92a2VtUEpmRFc5bXlMNGFiYUs3TzhMWS9wV1hYK3BIakNHaC9idTIxYlVwTjlNdkwwVFIxc3U2cmV3ZHMzTTlRZUtkWGFMN080UFZhL2NyUC8vTnp5NGNVQjh3dm1CL2NIem8va0o0UUh6VisvNGhsMjQyQnBlTHBJMExqaUJZZklVZUdub1JJOE5GT01ndDVoWWFCbXVuT0h0d0pHY0VSWUJnZXFSNnBENmN2N2Q5V2pwRVR1eFlHenhtb2NUVWRIc2xMb21FeXZXallOM3pMcjdyR1pQaFZ1NklqakpJTitWWTk2MVBHeE1OK21uaUR0UEVHWng4ZjB5SFNpbERHaDN2M2pJM2VTSERrZEllMTRzaHk1V0JaNUVLbHV2VTZSM1ZKcDFWUGpaZkhEbWROa3o2WjE4dW54a21sSzYvbG55SkVMdDZWdTRua3lmS1ljRGgwZjNyNmZwU3F2SXZuMU45YzZXMFhwdDhMbDA5WnpwSS9PZXkyYys4NjVhdXY2cFczZXIvUGlhMHZNTnVkTGcwWHZnRmN2aUs4a2o2MHV6UFJGeVhLM2NKSGFCLzE2dVMrZGpKOTFYcHdaakJjbDVWOGlQVXJIeVIweE4rZWw4UklrVmwzbkw4c014Q041Snk1WERST0xwWTV5UldaSUZqMnJadEdoMWNsWFpzTFBMTnJmZnJ3cXM0R09EMXVuUGYzcXpIYzdybGR1VElReC9qV1paVzFITXBidDJzejZuVmRYbnhoY0p5MFFUK1orZXIxc2M5NEs0Yk1PSFgyREhCcCtDcWR1VG02VXZpVmhLdTZtVm9qR3BadmxzSVVoZnVaeFMyWTRqSW1lKzFCMWJwV1RUYUs1ZVc5ckJYa012MTFhTzl5RVh1VU9QaHVpRDlHay9HaVdjV2RtcWF6ZzgyZTVyWmtjclh5WHFyMHpiYXVlZHJlMDRMeDNZRlRTUFZMSS9DU3UzcjBkVjZKTGNjTzZMN095VTNueEI2SDN5NEZ2eTJJSHNlMCtJRWV1WXpwdi9NSE1uM3hUY3R1ejA0ZStPVjliZFI0T3gwQjV5K0FSYVovV21QNW9ackFWNENsWjNXazhKa2NudWhnODNscUZnKzRUY2pySEx3Q2xKK1dvUzVROGZyZE5HZGlmYXEwcFEvclRjcXEwWlpOTHhUUGNJdXFEQWJveE5UelhjeXBON2lvMWh6OVhlSmFIR2tsV0VUeGZsZTArbCttZHR2akxTZVVLWFhUTDV2TlJ1Q3JoRnpMRDhiQXF2R3krR0l2bU40dDE5RXVab1lsbUVQRDNyR3k2UXVxTnY1eFpIQy9EczZZdG1hTytraG1NeDh0Ym02KzJiMDkvSW0rK0ZrVlg0dFY0UFJZZHE4WWJtZTl3SThtOHErMHh1cHJVMEtEenBneTlIWEs4bGVscmY4RC90bHdvVkU1cHNYY3lpMXFmb29aUHhkNVZoMGw5c2tycnZ4ZGJTOGJpOXpOOU03WWJLL2NER1YxVWp0Ymp3UTlWdjVGWVd1dWp6SUJhYmoyNi96aTJKWTc5Uk1adUZRNmYzSDhxcDZXdXM5eFhtYlNxU3lQQ1o1bkY2cm1GRHV0WHNQelBwVnROemN5dnp4ZHlHb2Z4MGRkdWVBZStsRjBNaytxRysxVm1CVVhZZFdOU1BsM21iNS9ObGwxN2xoOXkrVi9MQmxSaStBb0x6MmJXWmhZdGpOdzJ1N1M5cEREQjN5NjdwRDNGZGVRcHNiOTlka1hzZ3pGL2pqWktjd2w1T2FwVzJpRTdGSzJsWG5UZ3duYk1EbmVJTGUyVVhUUS8ydkIyemc3b0dEa1FOYU5oN1pMdGJlV2oyRjJ6eFZaZ055azd2R3BGVDl4M3ozYnJqOEo0ai9iSXRqL2NMTzBwKzgxZlZZaXVkOVRsK09zcGUyWHp2c0dmbFcxajdaM3ROWjBhelhvcjVhcmJEUHg5c2xtMTByN1pITTlnYUdtLzdHTGRHSjYxZFpOZitsSzNOUHRubDlSdDMrZmpYcVVKaUh6L1JSSU95RzRRclNEditzekxkbUQyajJWeVJxM0sxNVhvc2hHOXRxS2UzV1cvSXplT2RFQWF2SWVUVThHOEhBZExYU2ZOeWlGWjdqeWUrbVpBMld0VURzMFdXeEdIWlFkaXFWdHordUhabm5qVUViSysvbVNDK24zbFNEa2FNbXJMbE9Zb3ljOHZyOG1Hajg1MjZ5QVA4Y2RJWmc2cGp5R1B6YVlubk1yY2NkRTZNbzg3UGx1UW5lYjFUOURWazhDSnVpNXF3SytlSk8zT1ovM0pzaFdkNEo2U3pldDQ5OVJzZjFSVTJmQThZKzQwMlVVVnM0MktPbDIyb2FQTzBFMFFXK1hNN0dDc2RCVjNsdFRSbEtpenMzcjZYV202NTJUMUZMNUJnWFBWamxoMVdqNVBUcURLWEVOV2x3WnJPRnpIODZXSzhZUUxKS1pLQnozYzZJWFM2aEtqcW5sUmxoODV4Q0l1emthM0FKVkxwSm1zV1ZmZFZGMHFqUzVCbWRaY2xpMkd6NVZkNy9Kc04xMFU3T3FjaEs3STl1cVpUM09DdzFkbSs5VDNRcWVObW1TNHFsVTB4MTJkTFVSSjE4Z090alpUTnZnVFkwcTlOdHdlOWVINmRWbjlia1RWNE12SDlkbThDbFkydlNIY05wME9kZjRFVmI0eEx2Y2xOMlV6RnMrZmJwYkQ3TGpxWGRKYnBLazVSQ1BQclZJeER2Q24wS1hic2tVL21vM2RuaDFzQmZqclRWVDZIVzF4NmpXZU83T0xZM0ZxVE9HUjZhNjIrR202a0RqeVZPVHViSTk2aTFHdGZrKzJMNWF0V2cvdXpRN0VJbVRzdUMvYkg0dml5ZUg5MmU0cGE1YnZkRW8wb0Q0UTdTSHZ4b05aOVNWYlZmNUQwZ24wL3ZKODlXRzFreXIxRVJscXcxU1pkbExiUHhxMUVRMTRqMlg3OVNBWVBoTjVQQ3BTZmEwNWVDSmJuSXlLZkRJcWNqSlc1RlB0RzlMWDRhZGwzSjBmVzNvbWl1WWlvcmNkbnBXK0V1WU9Yd2VpSm5tdXRmL1VjNStYY3pHK1Q2VVg1TnlJUjcwWXJjTGovMHZaNkVsZldmYnhaYW11Zmt0U0RoMGYwbGNXeFBJQmZUVzJzaHl1MTdKRDhyY3NRMXM0N0wwdTQ0RmZsNis4QjU3TFhmT05iSSs4VjZGYjcwMDVIVGxoc3Y1V3RqY3FsV1BlenFvNXFId1lUZE5KZm1VdUc5N3gwR1didTQ1Y3RONlY2c1JpMzhzT3gvT0VIOU8rcjNaR3gvSUh5THpTQjNKTkMyUFZaelZ5L2ZRL2xCUzFZK3BrNHpramIvRWpPUzU2bDhNNUJ5ZDhuQjJLRW55WDdtZ2w5aE51ZXJsNjhTUEJUK1g2clQ2NG84bGpuZCtlclh5bXU3Q0srbHlhUmIxQTlZV00wanlwM1BwTHVUcFZTbHQvbFEyZkt1clBYY09tK0ZxYXZEMWhiWGFaRVh0bHJ4SkwyallYSmRFZUcxNHNhYnZjVXAwME1SZFk4ZWVPMjB0S2JNTjBvNjVXM3lHM0lrcnhZNU0wTlp2SjljY1N1US91bEpQblBWUDYycnR6cmxzSCtSSzRTNjZQRmtkMDg5THB1R3R1Z0NKS0c0KzNvbmJMOWVvMTFHVnk5NmhBdVQ3dWtlT0c5dDBwdmdzeDlKZTg5OHhKcDZRZVlUbWpGUlczVjY2bzlwVzczZDY1b1ZhQW53UFEyVEZ0N1pQakk5S1VyNWZ1bS91dTdyVHlxTjJvYk5XazYwdUR2OUVuYzAzcTE2WDlwSkdpUExIMy9QYlA2WGRacTY1L1FHNGdub3YzKzhCY24zN1ZWY2NlbEpNYktxZnBtV2E4bklOekJYOUdQMnM1SkRjNDd6UHNWU09INXBaUnVxMmZ1ZkZydTVhbkgwSWRsa3ViN3R6STRmS25kSVQ4R1R0Uy9xdytLcmUwdzJvOHloeWRXN1F3NVpqY24vTlNlWlBmbDdmWTVGZS8vZVhQeTV2OWFzdnk3MVp6UGViSEhadjcvanJtM1dKay9MaDF6enhhT242ZE0yLzJ5eTFQV09mTVA5djBseWV1ZXpYR3gwN3FtSmwycGxOcm5KejdpM1hOVEpHbmZJdmNvNlZUMXowM05jaHA2NTZiV3VUMGIxR1Q4YkV6T2pmSmFLbFRrNXpadWVoT21XbDdaMzJMM0tPbHM5YzlOelhKT2V1ZW01cmszRzlSay9HeDh6bzJDVzIwVTVPYzM3SG9qcG1wU1M3NEZybEhTeGV1ZTI2S3ZHamRjMU9UWFB3dGFqSStka25ISnFGaU9qWEpwUjJMN3BpWm11U3liNUY3dEhUNXV1ZW1mYmxpM1hOVDVKWGZvaWJqWTFkMVBuSEd4em8xeWRXZE8yQ256TlFrMTN5TDNLT2xhOWM5TnpYSmRldWVtL2I4K205UmsvR3hHMmdHTU1NZmx2QXJXRFE5OSt6WkczTTkvT00wRGYyYys2WmN0MDh6TngyNldWK3dQRXRsbHV2ckxibThUOWZuc2o4eWZtc3VMMDlMYVBHMlhIZmRuaDBQSEVtNFhVS3JkZWlPWEsrc1lkWnNsOE4zNW5wbHRUQjhWMjRnWERlTXVsdWlWc2VqN3NrVnBSUjU1SGh2cmloRlNPQytYRys0dm9UdmwvRHFLUHdBN1JTdnFiNjE4MkN1VzFaVm9ZZHlmZUc2S3VKaGlWamRpbmdrM04vUjBxUGgvbzZXSG92dDcyanA4ZGoranBhZW1OOXNmUEYva2hvaEh2bFVib2tPaDc5TG9GOHdlRHEzS0lwekd2S081TWo0TTduRlVhUjYvcXppbjQzRjh3TW53MVB4enkwc1pMVDBmTWRDUmtzdmRDeGt0UFRpdkVLa01WOWFXSWpFdjd5d0VJbC9KVGZVVm9ocTFGZHpTK2FYb2hKZWl5WG9ZbFRDNnpMVGs2ZHBicE9LTmliOU4zSzlVVjV1dVRkallXN3l0M0k5cXF1cnR6UGV6ZzN5cDg2MnZHYXA4NzJUNjJ1dHdtOTh2SnNiVUY5UHJOT05oaS8zcnUvbEN1b0RLam9wM3M4dHR0V0VMbnl2WFUzUVA4aXAxenFiNFgyRC8yRk9QYkhnZDg0K3l2WExzVlozdHdGTnB6K1dNOUhXSVNuc0V6M2RiRGcyUHhlWk11VHByUnpOVDc4cGFiVDBXY2NrYWZuUGM4czdKS25XL0lJNjlZeDZhdk1sblkzeTgxUjZBdnhWVG4wbktyRHE3dGRxaWl6dlY2eFZxM0JWdDgzTE13Mlp4NnFIN25TN2t3ODd2WDZneFluYlM2VDZYb3cwRjkzR1ZIYklkMHVoYXY2N1kzNngvcmhBbnZaR1plNlU3MnVQMkRrL0hGc3R1aWZkSlo5VHY1b1Q3SnBQeTRQWmZENDhwTHZuQjhyOGV6QU5SMzdQalEvbUh2bE1wVm12eisyWjd5M3pWMGJDTHl6c2xlOEp3L3hkekwxYnlmTGtaWjk4MmpBZGY5OThZdlA5YU5HM0cvdm5VNXV2R2ptQUFvSFJPSkN6Lyt3M3Y5dVV4dHBOZjdIbEZnZmxNeHhkT3BoL2J6QVd2MnJrRUY3QnNRK2xXcXQzdFE3TFo2UUNoK2N6Wlg3NzZnaXVNdzBTZEVOTm8wbk44Q2F0SS9QRlZ0UlJuSSsyZjNRK1JibVB5ZWRrclVyMVdGNmkrRXIxdUh4M0szdjFlRzRWdjNvQ0ovTjNPVXNuU3NUVVNmbDhXZitlNGNuNUhDM3dSd3VuNkVocXpWT2xaUDZtOG1tOEU3SVUzdFNkbnU4cmg4dE90V0xNbmNHdFIrUGFWSG1XZjMvdnpIeXg2cFluREkvdTk3MnpvclFtcDUwZEJSME9ucE5QVWEzT3pXY0N4eDBwblVkZHc3Vk02aWo4RHNINStaNVdNYXRHTHNqM1VsQjlLWXRQclF2emFWcTFkRkUrSit1dUdyazQzeHRiZTlYSUpXM3JseTdOOTdldHYycmtNajVzcldwWEw4OTN0MWFvWGhHbFNrMnJWMFpoMlpIcVZma01iNzk2ZFZpQjBqVVNVeCs1ZHY1aEwxMlhUMWVOQ2YvNmZFWitpUElHK2x0ekhPL0dmTDVxcS9jUmJxSW9mdGgvTS8zMXFKUmIrS0J6by9QWCtHN2xSbXMyd3VCdCtVS1pMdkRTTTIvbjVhb3N6dDZSejZxbE8vTTU2ZVdyUnU3aTVKb3BkL3gzOHc3b1pmNXRoSHZ5UFpPR0hYM3FlVzkrWlRuKys1WGhqMDd5ajBVR1hwT2ZvdDZYejlKaHA0VDc4NW1wZ09JZnlFYy9IRGd5L2lCRnpybE84RkErNlcvOWNMNW95OVNFbjlnOFFrZEN2c2d6WlhoMXczMDAzeCsrMXhZNDhsVHVNV3FJNWpiYnpKbDE5L0Y4dDFwUlRvc244bG1iaHVGZzdzbDh6dmJsRzdWUDhaSThHM282bjYzVnVQV2V5ZWZVUXZWWjdwcHlrQ3IyOURhVzV6elgxZ2xHbjQvU2FSeW44YWp5UWo1VmN5WmZWQjF3L0tWOFJzcDVtVXFXOGw3aDA2REdROEtyZEpaTWVOVHE1bXY1TEo4NFU5N3JhcUh1dmtFTDhrT1NiMG9UUjc4ZDZiM0Y3YU4vTU5KN096d3FwWGZ5Zy9HV251TnY1cjJiSHk2WFhmMVRCL3lxOGF3Yy92ZnlTK1pIcTQ3d2ZqNnJPc2dIZk5LcXVBL3pTMlBGNnBYa2tjdEh0RVY5RWplTWhpTnhIK2NMMGZJblhGSHE1MUxpcDl6ZE9LQksvU3lmNW9QNGVUN05QK2IxUlQ3bE9qTmZocDErOUt0OGtkdlpibFNwc0svemVYbjRRazIzdHEzaHg3WXRGUGxqTDd2QlYvWHRDa1YrdTFRRnRpKzBuYmFsSFFyenp0UFNqb1dzT2tsMktneTAvYVNvYTFkMkxnekhmeWswL0pYUlhRcXhIeFVOditPOWF5R3JWdHF0a0MrcnQ1cmMzUXVENnN0allXdFp0ZW9laFRRdjcwbC9hS3Q3RlRLeThiM3ByOU5zVlBZcFpMbllpY2EraFJRTnVQc1YwdlRmNnY3eVorcUFRdDV2cU1vZVNERmJlOEZCbEozeU42b0hGNWEzblY5MGVlSDVnblR6UXdyTE9xVnh2enVVMWcvb1F1RWRWdWd1bDlWaW8xazdYRVhYM1NONFgvekFwWUg4U0JYbnpoMVZ5UEdDN3phT0xzaDFUWjNoNWRveGhYd1lPTFpRak9LOTQyVE5tdFU0WHRac1VMa25GQXB5TGVEdG5TaXh2SFNTWktTQ1QxWUxnWGRLb1MrWWNmZ1pwM29QelR1MU1NQnRhY1dpVHFORDZqUzlXTXpwaFY1YWE4YVkwK0V6ZUM5b2hLRm1QN05BcDV3TXNXZnhrajlWcyt0bnkwNU8wU0V6enlrVStETHYyNU9OMnJsVUx6a1V0Zk1LZE9KVlhmbGVpVjJkcTUxZnlGVHJUcVYyQWYybGdiZDJJVGVlVEl2NFdGeFV5RTlac3hLOHVKQ3ZXS1lzWGlLbE5haG5YaW83RnppemwrbUZ5dVhTY0lIVHJOV3UwSXV6cTBhdWxIWUo2S3k0U2k4MWExZnJWV3JYY0pWYXYyc2JYRnVnS3pmTkNxNHJwT2kvMXhmUzlOK3BHd29aK2ZIZEcxVzcweEc0cVRCVUxrOVhWUitLcGprM0Y3cDFETDhPZVVzaFJkM2pWdW5PRkhsYkllYzYvSG5oNU8yODIwRjU5ZzcxMTdsVC9XM2VWVWk1UnVYdVFqNHMrSjVDbGhPcTdyMkZJYjJ1ZktWSXp3L3ZLOHk3Z28zZVh5aE1oOWVxQjJnNTdPVVBjb2RYazZTSHVNZllEV25oaHdzMFd2cnlsblloTjEyVkUrRFJRb1kzMDNpc1VQRDVVSFBleHlsVm5SNVBGTHIxcDFYY0NaNHNoTDk5SEd2QnB3cTVHWk9hdGo3eGRDRTdZL0xDTTRWbDgzNVJtWCt2V0o2WFAwdm4zNFMzNWprNndEWDEyZVh6aFd5bHhwUGJGd3FGU2szUFZGOHNET3JmOVZGdjkvRFg3MS9pUVVFMVBKOEM4dXJ6eTRXQlNzMTFmTHFmQzZOZUtmVHk1K1NPL01RQnJmWXE5MUtqVWdtcW82OXhXeGpVZHdONzlIWHV4alVycUpiZTRLVkpYbnFUczlJbGlySyt4ZjJFSnQ1V28xS3BVdExicmJEUDRYZGFYZGNPcXU5S1IrZFFrOStqcjc0bllmazhTRWFuOTduaHF2eVpsQzFmTkpZM256L2cydFQ4S1k5cTh5RnZtVytFcXFNZmhZdjI2TWR5Z2pVbktQWVRIakw0aDZiTW9GcXBsajZOQmYxcTZiTkNWdjBjeCtlRk5QK0E0eGVGblA3MXhpOEw4anNMNGU5d2YxVW90bjcwK2V0Q1Z2M280MW9lV3MzcGJZdjU4SmVldHl1bStadUMyeGV6Nm5lZWR5Z1dXOFA0anNWOE9IanZSQm5rSjNSMkxpNXVHeWtOVTMzVFo1Zmk4Z1h4ay9ycnZMdCtReHEvZmJwYmNWbkhOS3JON3NWdXFzdVdkQ2UwdVJWc3RFZVJmMmM4RE8xWkxFamVMWXhwYTY5aWp5eHZia25IM3B0MmdZT2JjSS9hcDdoK3grTDFqMVB0Vzh4VzVjNXp2MkttRVRoVC92N0ZudGFVaXU0d2lqTFRxaDNZaWg2bHVlNUJSYjYreVNlOFhLRDh0SVIvY0pGL1JmU25mTFpzWlc5bEgxTHNEWU8yVGVGRGkzMWhlSm9qdGpxczJCM0xmM2c4WkI5UlZMOTY3UWZOaWUvRlN6Mnl1SFJoZ3BSL1ZISFp3aFMxcGFPTGl6dVdka3puZVB0WVhSVC9Nc204SC9BK3JqZ2NTNHArdi90NFhTMFZIZi81N2hQYVZvaCt2VHY1ejVtRGkrbXVkTlVOdkVSaW8yUmlKSlVvSFZMTXpJdEpKMFlQTFdZWFJtWVNZNGNWVS9INHc5dUR1UitsdS9yTCt2am9sNWdTM1dFRWRhNWtUeGpnWHBqS0I3cGpGVFpNZCtWV2VYTFRtOGlzNGovSkROM09iZVduMHFzbWZMOXJmTURuRDdPc1h4bnlodGZ2TnYvbDkvaUhnbjd5d3grT2xINjBhaVA2djVHZmpHNjAwVVkvbE45a1dNVS9VYjZLWnQzL0Y0RTJlb1g3ZWhFQSIpKSxWPW5ldyBVaW50OEFycmF5KGEudW56aXAocCkpO2Z1bmN0aW9uIEgobix0KXtpZihudWxsPT09dHx8MTA9PT10KXtjb25zdCB0PWZ1bmN0aW9uKG4sdCxlKXtjb25zdCBmPXQrTmFOO2xldCBBPXQ7Zm9yKDtuW0FdJiYhKEE+PWYpOykrK0E7bGV0IHI9IiI7Zm9yKDt0PEE7KXIrPVN0cmluZy5mcm9tQ2hhckNvZGUoblt0KytdKTtyZXR1cm4gcn0obmV3IFVpbnQ4QXJyYXkobi5vdXRwdXQpLDApO2lmKHQuaW5jbHVkZXMoIkNvdWxkIG5vdCB1cGRhdGUgdGltZXN0YW1wcyBmb3Igc2tpcHBlZCBzYW1wbGVzIikpcmV0dXJuOyhmdW5jdGlvbihuKXtyZXR1cm4hZC5zb21lKCh0PT5uLmluY2x1ZGVzKHQpKSl9KSh0KSYmZSgid2FzbSAiK3QpLG4ub3V0cHV0PVtdfWVsc2UgMCE9PXQmJm4ub3V0cHV0LnB1c2godCl9Y29uc3QgVD1bXTtmdW5jdGlvbiBqKG4sdCxmLHUpe3RyeXtjb25zdCBlPWZ1bmN0aW9uKG4sdCxlLGYsQSl7bGV0IHI9MDtmb3IobGV0IHU9MDt1PGU7dSsrKXtjb25zdCBlPUFbdCs4KnU+PjJdLHY9QVt0Kyg4KnUrNCk+PjJdO2ZvcihsZXQgdD0wO3Q8djt0Kyspbi50dHkub3BzLnB1dF9jaGFyKG4udHR5LGZbZSt0XSk7aWYobi5wb3NpdGlvbis9dix2PDApcmV0dXJuLTE7cis9dn1yZXR1cm4gcn0oVFtuXSx0LGYsQSxyKTtyZXR1cm4gclt1Pj4yXT1lLDB9Y2F0Y2godCl7ZShgd2FzbSBfZmRfd3JpdGUgcHJvYmxlbSAke259ICR7dH1gKX19bGV0IGg7cmV0dXJuIFRbMV09e3Bvc2l0aW9uOjAsdHR5OntpbnB1dDpbXSxvdXRwdXQ6W10sb3BzOntwdXRfY2hhcjpIfX19LFRbMl09e3Bvc2l0aW9uOjAsdHR5OntpbnB1dDpbXSxvdXRwdXQ6W10sb3BzOntwdXRfY2hhcjpIfX19LFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKFYseSkudGhlbigobj0+e2NvbnN0IHQ9bi5pbnN0YW5jZS5leHBvcnRzO2lmKCFmdW5jdGlvbihuKXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2Ygbi5pbml0X2RlY29kZXImJiJmdW5jdGlvbiI9PXR5cGVvZiBuLmdldF9pbnB1dF9idWZmZXImJiJmdW5jdGlvbiI9PXR5cGVvZiBuLmdldF9pbnB1dF9idWZmZXJfY2FwYWNpdHkmJiJmdW5jdGlvbiI9PXR5cGVvZiBuLnB1c2hfZGF0YSYmImZ1bmN0aW9uIj09dHlwZW9mIG4uY2xlYXJfZGF0YX0odCkpdGhyb3cgbmV3IEVycm9yKCJOb3QgdmFsaWQgd2FzbSBleHBvcnRzIik7dmFyIGUsZixBO2Y9ciwoQT12KVsoKGU9eik+PjIpLTFdPTM0ODIxMjIzLEFbKGU+PjIpLTJdPTIzMTA3MjEwMjIsZlswXT0xNjY4NTA5MDI5LGZ1bmN0aW9uKG4sdCxlKXtjb25zdCBmPWVbKG4+PjIpLTFdLEE9ZVsobj4+MiktMl07aWYoMzQ4MjEyMjMhPT1mfHwyMzEwNzIxMDIyIT09QSl0aHJvdyBuZXcgRXJyb3IoYHdhc20gU3RhY2sgb3ZlcmZsb3chIFN0YWNrIGNvb2tpZSBoYXMgYmVlbiBvdmVyd3JpdHRlbiwgXG4gICAgICAgICAgICBleHBlY3RlZCBoZXggZHdvcmRzIDB4ODlCQUNERkUgYW5kIDB4MjEzNTQ2NywgXG4gICAgICAgICAgICBidXQgcmVjZWl2ZWQgMHgke0EudG9TdHJpbmcoMTYpfSAke2YudG9TdHJpbmcoMTYpfWApO2lmKDE2Njg1MDkwMjkhPT10WzBdKXRocm93IG5ldyBFcnJvcigid2FzbSBSdW50aW1lIGVycm9yOiBUaGUgYXBwbGljYXRpb24gaGFzIGNvcnJ1cHRlZCBpdHMgaGVhcCBtZW1vcnkgYXJlYSAoYWRkcmVzcyB6ZXJvKSEiKX0oeixyLHYpLHQuaW5pdF9kZWNvZGVyKGkpO2xldCB1PU8odCk7cmV0dXJue3B1c2hTdHJlYW1EYXRhOm49PntsZXQgZT1uLmJ5dGVMZW5ndGg7aWYoImZ0eXAiPT09bi5zdWJhcnJheSg0LDgpLnJlZHVjZSgoKG4sdCk9Pm4rU3RyaW5nLmZyb21DaGFyQ29kZSh0KSksIiIpJiYoaD1uLnNsaWNlKCksbT0hMSksbSYmKG09ITEsdC5jbGVhcl9kYXRhKCksdT1PKHQpLHUud3JpdGUoaCksZSs9aC5ieXRlTGVuZ3RoKSwhbSl7dS53cml0ZShuKTt0cnl7Y29uc3Qgbj10LnB1c2hfZGF0YShlLHBlcmZvcm1hbmNlLm5vdygpKTt1LnNldFNpemUobil9Y2F0Y2gobil7bT0hMH19fX19KSk7ZnVuY3Rpb24gTyhuKXtjb25zdCB0PW4uZ2V0X2lucHV0X2J1ZmZlcigpO3JldHVybiBuZXcgYyh1LnN1YmFycmF5KHQsdCtpKSl9fWNsYXNzIHF7Y29uc3RydWN0b3Iobil7dGhpcy5jYWxsYmFja3M9bixiKHRoaXMuY2FsbGJhY2tzLm9uQXVkaW9TdHJlYW0sdGhpcy5jYWxsYmFja3Mub25BdWRpb0ZyYW1lLHRoaXMuY2FsbGJhY2tzLm9uRXJyb3JNc2cpLnRoZW4oKG49Pnt0aGlzLndhc209bix0aGlzLmNhbGxiYWNrcy5vbldhc21Jbml0KCl9KSkuY2F0Y2goKG49PnRoaXMuY2FsbGJhY2tzLm9uRXJyb3JNc2cobi5tZXNzYWdlKSkpfXNldEJpbmFyeURhdGEobix0KXt2YXIgZTtudWxsPT09KGU9dGhpcy53YXNtKXx8dm9pZCAwPT09ZXx8ZS5wdXNoU3RyZWFtRGF0YShuZXcgVWludDhBcnJheShuKSl9fXZhciBQOyFmdW5jdGlvbihuKXtuLlNldEJpbmFyeURhdGE9IlNldEJpbmFyeURhdGEiLG4uSW5pdD0iSW5pdCIsbi5PbkF1ZGlvRnJhbWU9Ik9uQXVkaW9GcmFtZSIsbi5PbkF1ZGlvU3RyZWFtPSJPbkF1ZGlvU3RyZWFtIixuLk9uV2FzbUluaXQ9Ik9uV2FzbUluaXQiLG4uT25FcnJvck1zZz0iT25FcnJvck1zZyJ9KFB8fChQPXt9KSk7Y29uc3QgeT1zZWxmO2xldCBtLHA9ITE7Y29uc3QgVj1bXTtmdW5jdGlvbiBIKCl7cD0hMCx5LnBvc3RNZXNzYWdlKHt0eXBlOlAuT25XYXNtSW5pdH0pO2Zvcihjb25zdCBuIG9mIFYpbnVsbD09bXx8bS5zZXRCaW5hcnlEYXRhKC4uLm4pO1YubGVuZ3RoPTB9ZnVuY3Rpb24gVChuLHQsZSxmKXt5LnBvc3RNZXNzYWdlKHt0eXBlOlAuT25BdWRpb1N0cmVhbSxpbmRleDpuLHNhbXBsZUZvcm1hdDp0LG51bUNoYW5uZWxzOmUsc2FtcGxlUmF0ZTpmfSl9ZnVuY3Rpb24gaihuKXtjb25zdCB0PVtdLGU9W107Zm9yKGNvbnN0IGYgb2Ygbi5idWZmZXJzKXQucHVzaChmLnNsaWNlKCkpLGUucHVzaCh0W3QubGVuZ3RoLTFdLmJ1ZmZlcik7eS5wb3N0TWVzc2FnZSh7dHlwZTpQLk9uQXVkaW9GcmFtZSxwdHM6bi5wdHMsbnVtQ2hhbm5lbHM6bi5udW1DaGFubmVscyxudW1TYW1wbGVzOm4ubnVtU2FtcGxlcyxidWZmZXJzOnR9LGUpfWZ1bmN0aW9uIGgobil7eS5wb3N0TWVzc2FnZSh7dHlwZTpQLk9uRXJyb3JNc2csZXJyb3JNc2c6bn0pfXkuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKG49Pntzd2l0Y2gobi5kYXRhLnR5cGUpe2Nhc2UgUC5Jbml0OmlmKG0pYnJlYWs7bT1uZXcgcSh7b25XYXNtSW5pdDpILG9uQXVkaW9TdHJlYW06VCxvbkF1ZGlvRnJhbWU6aixvbkVycm9yTXNnOmh9KTticmVhaztjYXNlIFAuU2V0QmluYXJ5RGF0YTpwP251bGw9PW18fG0uc2V0QmluYXJ5RGF0YShuLmRhdGEuYnVmZmVyLG4uZGF0YS5zdHJlYW0pOlYucHVzaChbbi5kYXRhLmJ1ZmZlcixuLmRhdGEuc3RyZWFtXSl9fSkpfSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGVyLndvcmtlci5qcy5tYXAKCg==")
                  , t = e.indexOf("\n", 10) + 1
                  , V = e.substring(t) + ""
                  , l = new Blob([V],{
                    type: "application/javascript"
                });
                return URL.createObjectURL(l)
            }(),
            new Worker(Pl,e)
        };
        function $l(e) {
            const t = new _l;
            let V, l = "";
            return t.addEventListener("message", (t => {
                switch (t.data.type) {
                case ql.OnAudioStream:
                    l = t.data.stream;
                    break;
                case ql.OnAudioFrame:
                    e(t.data);
                    break;
                case ql.OnErrorMsg:
                    e(new Error(t.data.errorMsg))
                }
            }
            )),
            t.postMessage({
                type: ql.Init
            }),
            {
                push: function(e) {
                    var d;
                    const a = (0,
                    Ul.extractAtoms)(new Uint8Array(e))
                      , U = a.find((e => "moov" === e.name));
                    if (U) {
                        const e = (0,
                        Ul.extractAtoms)(U.data).filter((e => "trak" === e.name)).map(Ul.parseAudioMeta).filter((e => !!e));
                        e[0] && (V = e[0])
                    }
                    const n = [];
                    "ftyp" === a[0].name && n.push(...a);
                    for (let t = 0; t < a.length && V; t++) {
                        const e = a[t];
                        if ("moof" !== e.name)
                            continue;
                        const [l] = null !== (d = (0,
                        Ul.findAtom)(e.data, ["traf", "tfhd"])) && void 0 !== d ? d : [];
                        if (!l)
                            continue;
                        if ((0,
                        Ul.toInt)(l.data.subarray(4, 8)) !== V.id)
                            continue;
                        const U = a[t + 1];
                        U && (n.push(e),
                        n.push(U))
                    }
                    if (0 === n.length)
                        return;
                    const R = a[a.length - 1];
                    "egwc" === R.name && n.push(R),
                    t.postMessage({
                        type: ql.SetBinaryData,
                        buffer: (0,
                        Ul.atomsToBuffer)(n),
                        stream: l
                    })
                },
                close: function() {
                    t.terminate()
                }
            }
        }
        !function(e) {
            e.SetBinaryData = "SetBinaryData",
            e.Init = "Init",
            e.OnAudioFrame = "OnAudioFrame",
            e.OnAudioStream = "OnAudioStream",
            e.OnWasmInit = "OnWasmInit",
            e.OnErrorMsg = "OnErrorMsg"
        }(ql || (ql = {}));
        const ed = (e, t) => {
            const V = Math.round(t.length / e.totalPacketCount)
              , l = e.beforePacketCount * V * 4
              , d = e.middlePacketCount * V;
            return new Float32Array(t.buffer,l,d)
        }
          , td = (e, t) => {
            const V = 150 * e.totalPacketCount
              , l = Math.round(V / 2)
              , d = new Float32Array(t.length + V);
            d.set(t, l);
            const a = d.length / e.totalPacketCount
              , U = 4 * Math.floor(e.beforePacketCount * a)
              , n = Math.ceil(e.middlePacketCount * a);
            return new Float32Array(d.buffer,U,n)
        }
        ;
        function Vd(e, t, V) {
            const l = {
                middlePacketCount: e.windowSize,
                beforePacketCount: e.windowOffset,
                afterPacketCount: e.windowOffset,
                totalPacketCount: e.windowSize + 2 * e.windowOffset
            }
              , d = []
              , a = e.audioContext;
            function U(e) {
                const a = d.shift();
                if (!a)
                    return void V(new Error("No MP4 file"));
                const U = new Array(a.numChannels).fill(0).map(( (t, V) => e.getChannelData(V)));
                if (!a.pts)
                    return void V(new Error("PTS is not defined"));
                const R = function(e, V) {
                    const d = e.map((e => t(l, e)))
                      , a = d[0].length;
                    return {
                        buffers: d,
                        pts: V.pts,
                        numChannels: V.numChannels,
                        numSamples: a
                    }
                }(U, a);
                V(R),
                d.length && n()
            }
            function n() {
                a.decodeAudioData(d[0].buffer).then(U).catch(V)
            }
            return {
                push: function(e) {
                    d.push(e),
                    1 === d.length && n()
                },
                close: function() {
                    d.splice(0)
                }
            }
        }
        const ld = new Map(["ftyp", "moov", "mvhd", "trak", "tkhd", "mdia", "mdhd", "hdlr", "minf", "smhd", "dinf", "dref", "stbl", "stsd", "mp4a", "esds", "stts", "stsc", "stsz", "stco", "mdat"].map((e => [e, [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]])));
        class dd {
            static generate(e) {
                e.offset = dd.ftyp(e).byteLength + dd.moov(e).byteLength + 8;
                const t = dd.ftyp(e)
                  , V = dd.moov(e)
                  , l = dd.mdat(e)
                  , d = new Uint8Array(t.byteLength + V.byteLength + l.byteLength);
                return d.set(t, 0),
                d.set(V, t.byteLength),
                d.set(l, t.byteLength + V.byteLength),
                d.buffer
            }
            static ftyp(e) {
                const t = new Uint8Array([105, 115, 111, 109, 0, 0, 0, 1, 105, 115, 111, 109, 97, 118, 99, 49]);
                return dd.box(ld.get("ftyp"), t)
            }
            static mdat(e) {
                const t = e.samples;
                let V = 0
                  , l = 0;
                for (const a of e.samples)
                    l += a.byteLength;
                const d = new Uint8Array(l);
                for (const a of t) {
                    const e = a;
                    d.set(e, V),
                    V += e.byteLength
                }
                return dd.box(ld.get("mdat"), new Uint8Array(d))
            }
            static moov(e) {
                const t = dd.mvhd(e)
                  , V = dd.trak(e);
                return dd.box(ld.get("moov"), t, V)
            }
            static mvhd(e) {
                const t = e.timescale
                  , V = 1024 * e.samples.length / e.audioSampleRate
                  , l = (0 | V).toString(16)
                  , d = parseInt(l.substr(-8), 16)
                  , a = d === V ? 0 : parseInt(l.substr(0, l.length - 8), 16);
                return dd.box(ld.get("mvhd"), new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]))
            }
            static trak(e) {
                return dd.box(ld.get("trak"), dd.tkhd(e), dd.mdia(e))
            }
            static tkhd(e) {
                const t = 1024 * e.samples.length / e.audioSampleRate;
                return dd.box(ld.get("tkhd"), new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))
            }
            static mdia(e) {
                return dd.box(ld.get("mdia"), dd.mdhd(e), dd.hdlr(e), dd.minf(e))
            }
            static mdhd(e) {
                const t = e.timescale
                  , V = 1024 * e.samples.length / e.audioSampleRate
                  , l = (0 | V).toString(16)
                  , d = parseInt(l.substr(-8), 16)
                  , a = d === V ? 0 : parseInt(l.substr(0, l.length - 8), 16);
                return dd.box(ld.get("mdhd"), new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, 85, 196, 0, 0]))
            }
            static hdlr(e) {
                const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                return dd.box(ld.get("hdlr"), t)
            }
            static minf(e) {
                const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])
                  , V = dd.box(ld.get("smhd"), t);
                return dd.box(ld.get("minf"), V, dd.dinf(e), dd.stbl(e))
            }
            static dinf(e) {
                const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1])
                  , V = dd.box(ld.get("dref"), t);
                return dd.box(ld.get("dinf"), V)
            }
            static stbl(e) {
                return dd.box(ld.get("stbl"), dd.stsd(e), dd.stts(e), dd.stsc(e), dd.stsz(e), dd.stco(e))
            }
            static stsc(e) {
                const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, e.samples.length >>> 24 & 255, e.samples.length >>> 16 & 255, e.samples.length >>> 8 & 255, 255 & e.samples.length, 0, 0, 0, 1]);
                return dd.box(ld.get("stsc"), t)
            }
            static stts(e) {
                const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, e.samples.length >>> 24 & 255, e.samples.length >>> 16 & 255, e.samples.length >>> 8 & 255, 255 & e.samples.length, 0, 0, 4, 0]);
                return dd.box(ld.get("stts"), t)
            }
            static stco(e) {
                const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, e.offset >>> 24 & 255, e.offset >>> 16 & 255, e.offset >>> 8 & 255, 255 & e.offset]);
                return dd.box(ld.get("stco"), t)
            }
            static stsz(e) {
                const t = [0, 0, 0, 0, 0, 0, 0, 0, e.samples.length >>> 24 & 255, e.samples.length >>> 16 & 255, e.samples.length >>> 8 & 255, 255 & e.samples.length];
                for (const V of e.samples)
                    t.push(V.byteLength >> 24 & 255, V.byteLength >> 16 & 255, V.byteLength >> 8 & 255, 255 & V.byteLength);
                return dd.box(ld.get("stsz"), new Uint8Array(t))
            }
            static stsd(e) {
                const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                return dd.box(ld.get("stsd"), t, dd.mp4a(e))
            }
            static mp4a(e) {
                const t = e.channelCount
                  , V = e.audioSampleRate
                  , l = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t, 0, 16, 0, 0, 0, 0, V >>> 8 & 255, 255 & V, 0, 0]);
                return dd.box(ld.get("mp4a"), l, dd.esds(e))
            }
            static esds(e) {
                const t = e.streamDescriptor
                  , V = t.length
                  , l = new Uint8Array([0, 0, 0, 0, 3, 23 + V, 0, 1, 0, 4, 15 + V, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([V]).concat(t).concat([6, 1, 2]));
                return dd.box(ld.get("esds"), l)
            }
            static box(e, ...t) {
                if (!e)
                    throw new Error("Type cannot be undefined");
                const V = Array.prototype.slice.call(arguments, 1)
                  , l = V.length;
                let d = 8;
                for (let n = 0; n < l; n++)
                    d += V[n].byteLength;
                const a = new Uint8Array(d);
                a[0] = d >>> 24 & 255,
                a[1] = d >>> 16 & 255,
                a[2] = d >>> 8 & 255,
                a[3] = 255 & d,
                a.set(e, 4);
                let U = 8;
                for (let n = 0; n < l; n++)
                    a.set(V[n], U),
                    U += V[n].byteLength;
                return a
            }
        }
        function ad(e, t) {
            const V = function(e) {
                let t = [];
                const {windowSize: V, windowOffset: d} = e
                  , a = 2 * d
                  , U = V + a;
                let n;
                function R(e, t, V) {
                    var l, d;
                    const [a] = null !== (l = (0,
                    Ul.findAtom)(t.data, ["traf", "tfhd"])) && void 0 !== l ? l : [];
                    if (!a)
                        return;
                    const [U] = null !== (d = (0,
                    Ul.findAtom)(t.data, ["traf", "tfdt"])) && void 0 !== d ? d : [];
                    if (!U)
                        return;
                    if ((0,
                    Ul.toInt)(a.data.subarray(4, 8)) !== e.id)
                        return;
                    const n = (0,
                    Ul.toInt)(U.data.subarray(0, 1))
                      , R = (0,
                    Ul.toInt)(U.data.subarray(4, 0 === n ? 8 : 16));
                    return [V.data, R]
                }
                return {
                    push: function(e) {
                        if (function(e) {
                            var V;
                            let l, d;
                            const a = [];
                            let U;
                            const Z = (0,
                            Ul.extractAtoms)(e);
                            for (const t of Z) {
                                if ("moov" === t.name) {
                                    const e = null !== (V = (0,
                                    Ul.findAtom)(t.data, ["trak"])) && void 0 !== V ? V : [];
                                    for (const t of e) {
                                        const e = (0,
                                        Ul.parseAudioMeta)(t);
                                        e && (n = e)
                                    }
                                }
                                if ("moof" === t.name && (l = t),
                                "mdat" === t.name && (d = t),
                                n && l && d) {
                                    const e = R(n, l, d);
                                    e && a.push(e),
                                    l = void 0,
                                    d = void 0
                                }
                                "egwc" === t.name && (U = (0,
                                Ul.getEgwc)(t))
                            }
                            if (U)
                                for (const [n,R] of a)
                                    t.push([n, U, R])
                        }(new Uint8Array(e)),
                        n && t.length >= U) {
                            (e => {
                                if (e instanceof Error)
                                    return void console.error(e);
                                const t = function(e) {
                                    const t = {
                                        channelCount: e.numChannels,
                                        timescale: e.timescale,
                                        audioSampleRate: e.sampleRate,
                                        samples: e.samples,
                                        streamDescriptor: [42, 528, 136, 0],
                                        offset: 0
                                    };
                                    return {
                                        buffer: dd.generate(t),
                                        pts: Math.round(1e3 * e.timestamp / e.timescale),
                                        egwc: e.egwc,
                                        sampleRate: t.audioSampleRate,
                                        numChannels: t.channelCount
                                    }
                                }(e);
                                l.push(t)
                            }
                            )({
                                samples: t.slice(0, U).map((e => e[0])),
                                timescale: n.timeScale,
                                timestamp: t[d][2],
                                egwc: t[d][1],
                                sampleRate: n.sampleRate,
                                numChannels: n.numberOfChannels
                            });
                            const e = t.length - U;
                            t = [...t.slice(-a - e)]
                        }
                    },
                    close: function() {
                        t.splice(0),
                        n = void 0
                    }
                }
            }(e)
              , l = function(e, t) {
                return null !== navigator.userAgent.match(/iPhone|iPod/i) ? Vd(e, td, t) : Vd(e, ed, t)
            }(e, t);
            return {
                push: function(e) {
                    V.push(e)
                },
                close: function() {
                    V.close(),
                    l.close()
                }
            }
        }
        function Ud(e) {
            let t, V;
            function l(t) {
                const V = function(e) {
                    const t = [];
                    for (let V = 0; V < e.numberOfChannels; V++) {
                        const l = {
                            format: "f32-planar",
                            planeIndex: V
                        }
                          , d = e.allocationSize(l)
                          , a = new ArrayBuffer(d);
                        e.copyTo(a, l),
                        t.push(new Float32Array(a))
                    }
                    return {
                        pts: e.timestamp / 1e3,
                        numChannels: e.numberOfChannels,
                        numSamples: e.numberOfFrames,
                        buffers: t
                    }
                }(t);
                e(V)
            }
            function d(t) {
                if ("EncodingError" === t.name)
                    return console.error(t),
                    void U();
                e(t)
            }
            function a(e) {
                var V;
                const l = null !== (V = (0,
                Ul.findAtom)(e.data, ["trak"])) && void 0 !== V ? V : [];
                for (const d of l) {
                    const e = (0,
                    Ul.parseAudioMeta)(d);
                    e && (t = e)
                }
            }
            function U() {
                t && (V && "closed" !== V.state && V.close(),
                V = new AudioDecoder({
                    output: l,
                    error: d
                }),
                V.configure(t))
            }
            function n(l, d) {
                if (!t)
                    return;
                const a = function(e, t, V) {
                    var l, d;
                    const [a] = null !== (l = (0,
                    Ul.findAtom)(t.data, ["traf", "tfhd"])) && void 0 !== l ? l : [];
                    if (!a)
                        return;
                    const [U] = null !== (d = (0,
                    Ul.findAtom)(t.data, ["traf", "tfdt"])) && void 0 !== d ? d : [];
                    if (!U)
                        return;
                    if ((0,
                    Ul.toInt)(a.data.subarray(4, 8)) !== e.id)
                        return;
                    const n = (0,
                    Ul.toInt)(U.data.subarray(0, 1))
                      , R = (0,
                    Ul.toInt)(U.data.subarray(4, 0 === n ? 8 : 16));
                    return new EncodedAudioChunk({
                        type: "key",
                        timestamp: R / e.timeScale * 1e6,
                        data: V.data
                    })
                }(t, l, d);
                if (a && V)
                    try {
                        V.decode(a)
                    } catch (U) {
                        if (U instanceof Error)
                            return void e(new Error(U.message));
                        e(new Error(`${U}`))
                    }
            }
            return {
                push: function(e) {
                    const t = (0,
                    Ul.extractAtoms)(new Uint8Array(e));
                    let V = 0;
                    for (; V < t.length; ) {
                        const e = t[V];
                        "moov" !== e.name ? "moof" !== e.name ? V += 1 : (n(e, t[V + 1]),
                        V += 2) : (a(e),
                        U(),
                        V += 1)
                    }
                },
                close: function() {
                    V && "closed" !== V.state && V.close(),
                    V = void 0,
                    t = void 0
                }
            }
        }
        function nd(e, t, V) {
            const {webCodec: l, webAssembly: d, webAudio: a} = t;
            return !1 !== l.audio && l.audio[e] ? Ud : !1 !== d && "opus" === e ? $l : a && "aac" === e ? e => ad({
                audioContext: V,
                windowSize: 10,
                windowOffset: 2
            }, e) : Cl
        }
        class Rd {
            urlToStream(e, t) {
                var V;
                return null !== (V = function(e, t=0) {
                    var V;
                    const l = e.match(Kl);
                    if (!l)
                        return null === (V = e.match(gl)) || void 0 === V ? void 0 : V[1];
                    const d = l[1].match(fl);
                    if (!d)
                        return;
                    let a = t;
                    return (a < Number(d[1]) || a > Number(d[2])) && (a = Number(d[1])),
                    l[1].replace(fl, a.toString()).split("?")[0]
                }(e, t)) && void 0 !== V ? V : ""
            }
            multiUrlToSingleUrl(e, t) {
                return e.replace(fl, t.toString())
            }
            constructor(e, t, V, l, d) {
                this.config = e,
                this.observables = t,
                this.scope = V,
                this.state = l,
                this.failPlayer = d,
                ct(this.config.canvas, 400, 200);
                const a = t.streamId.pipe(el((t => {
                    const V = (d = t,
                    (l = e.settings.video.urls)[et(l) ? 0 : d]);
                    var l, d;
                    return e.onStats({
                        streamHost: new URL(V).host
                    }),
                    V || null
                }
                )), r(), ot(( () => new mt(1))))
                  , U = new s;
                V.add(T(( () => U.close()))),
                t.url.pipe(el((e => e)), Le(1), Ie(a, l), ge(( ([,,e]) => "IDLE" === e.state))).subscribe(( ([,e]) => {
                    this.prepareForPlay(t, e, U)
                }
                )).closeBy(V),
                V.add(T(( () => {
                    this.config.onStop(),
                    this.state.next({
                        state: "STOPPING"
                    }),
                    this.state.next({
                        state: "IDLE"
                    }),
                    this.state.next({
                        state: "DESTROYED"
                    })
                }
                ))),
                this.failPlayer.subscribe((e => {
                    this.config.onFailure(e),
                    U.close()
                }
                )).closeBy(V)
            }
            prepareForPlay(e, t, V) {
                const {url: l, volume: d, muted: a, streamId: U} = e;
                this.state.next({
                    state: "LOADING"
                });
                const n = o([l, U], (e => e)).pipe(el((e => {
                    const [,V] = e;
                    return this.urlToStream(t, V)
                }
                )), r(), ot(( () => new mt(1))));
                o([l, d, a, U], (e => e)).pipe(el((e => {
                    const [V,l,d,a] = e;
                    return V ? {
                        videoUrl: this.multiUrlToSingleUrl(t, a),
                        audioUrl: this.multiUrlToSingleUrl(V, a),
                        canvas: this.config.canvas,
                        audioContext: this.config.audioContext,
                        volume: l,
                        muted: d,
                        initBufferLength: this.config.settings.buffer.init,
                        audioDecoderFactory: nd(this.config.settings.audioCodec, this.config.browserFeatures, this.config.audioContext)
                    } : null
                }
                )), r(( () => !0)), al((e => function(e, t) {
                    const V = new i
                      , l = new i
                      , d = new i
                      , a = new i
                      , U = new i
                      , n = e => {
                        d.next(e)
                    }
                      , R = e => {
                        l.next(e)
                    }
                      , Z = e => {
                        a.next(e)
                    }
                    ;
                    return Rl([vl((e => {
                        V.next(e)
                    }
                    ), e, t.videoUrl), Pe(El(t.audioUrl, console.error).catch(( () => {}
                    )))], (e => e)).pipe(al(( ([N,c]) => {
                        const F = new Zl;
                        e.add(T(( () => {
                            F.destroy()
                        }
                        )));
                        const h = new i;
                        F.addListener((e => e && h.next(e)));
                        const o = new s
                          , m = new i;
                        let M;
                        o.add(T(( () => {
                            m.next()
                        }
                        ))),
                        e.add(T(( () => {
                            o.close()
                        }
                        ))),
                        e.add(T(( () => {
                            null == c || c.dispose(),
                            V.complete(),
                            l.complete(),
                            d.complete(),
                            a.complete(),
                            U.complete()
                        }
                        )));
                        e: try {
                            const {audioContext: V, volume: l, muted: d, initBufferLength: a} = t;
                            if (!V || !c)
                                break e;
                            const U = (S = c.binaries,
                            new W((e => {
                                function t(t) {
                                    e.onNext(t)
                                }
                                return S.subscribe(t),
                                T(( () => S.unsubscribe(t)))
                            }
                            ))).pipe(_e((e => e.buffer)), ot(( () => new i)))
                              , n = U.pipe(Le(1), el((e => {
                                const t = (0,
                                Ul.findAtom)(new Uint8Array(e), ["moov", "trak", "mdia", "minf", "stbl", "stsd"]);
                                if (t)
                                    return (0,
                                    Ul.getSampleRate)(t[0])
                            }
                            )), ot(( () => new mt(1)))).pipe(_e((e => (0,
                            nl.createAudioPlayer)(V, a, e, 1, l, d, 1))), qe((e => e.pts.subscribe((e => {
                                F.setPts(e)
                            }
                            )))), ot(( () => new mt(1))))
                              , R = t.audioDecoderFactory((e => {
                                if (e instanceof Error)
                                    return console.warn(e),
                                    void o.close();
                                null == M || M.pushFrame(e)
                            }
                            ));
                            o.add(T(( () => {
                                null == M || M.destroy(),
                                R.close()
                            }
                            ))),
                            U.subscribe((e => {
                                R.push(e)
                            }
                            )).closeBy(e),
                            n.subscribe((e => {
                                M = e,
                                o.add(T(( () => {
                                    e.destroy()
                                }
                                )))
                            }
                            ), (e => {
                                console.warn(e),
                                o.close()
                            }
                            )).closeBy(o)
                        } catch (u) {
                            console.warn(u),
                            o.close()
                        }
                        var S;
                        const E = function() {
                            const e = new i;
                            let t = 0;
                            return {
                                frames: e,
                                push: V => {
                                    t = V.metadata.pts;
                                    const l = new Image
                                      , d = URL.createObjectURL(V.blob);
                                    l.onload = () => {
                                        e.next(Object.assign(Object.assign({}, V), {
                                            image: l
                                        })),
                                        URL.revokeObjectURL(l.src)
                                    }
                                    ,
                                    l.src = d,
                                    l.onerror = t => {
                                        e.error(Ql(t))
                                    }
                                }
                                ,
                                getLastReceivedPTS: () => t,
                                destroy: () => {
                                    e.complete()
                                }
                            }
                        }()
                          , p = new kl(n,E.getLastReceivedPTS);
                        e.add(T(( () => {
                            p.destroy(),
                            E.destroy()
                        }
                        ))),
                        N.blob.subscribe((e => E.push(e))).closeBy(e);
                        const b = E.frames;
                        m.pipe(al(( () => b)), Le(1)).subscribe((e => {
                            F.setPts(e.metadata.pts - t.initBufferLength)
                        }
                        )).closeBy(e),
                        b.subscribe((e => p.push(e))).closeBy(e);
                        const k = h.pipe(el((e => p.getFrame(e))), ot(( () => new mt(1))))
                          , Y = Dl(R, t.canvas);
                        if (Y instanceof Yl)
                            throw Y;
                        e.add(T(( () => Y.destroy()))),
                        k.subscribe((e => Y.render(e))).closeBy(e);
                        const Q = new Il(Z);
                        k.subscribe((e => Q.update(e))).closeBy(e);
                        const J = new i
                          , G = new Ll((e => J.next(e)));
                        k.subscribe(( () => G.update())).closeBy(e),
                        k.subscribe((e => {
                            U.next(Math.trunc(e.metadata.wallclock / 1e3))
                        }
                        )).closeBy(e);
                        const z = new i;
                        k.pipe(_e((e => e.metadata.name)), r(( (e, t) => !e || !t || e === t))).subscribe(( () => {
                            z.next()
                        }
                        )).closeBy(e);
                        const x = e => e.pipe(Ie(k), _e((e => e[0])), ot(( () => new i)));
                        return we({
                            play: e => Rl([N.play(e), c ? Pe(c.play({
                                name: `${e.name}_audioonly`,
                                url: e.url
                            })) : we(void 0), k.pipe(Le(1))], (e => e[0])),
                            switchStream: e => Rl([N.switchStream(e), c ? Pe(null == c ? void 0 : c.switchStream({
                                name: e.name.slice(e.name.indexOf("/") + 1),
                                url: e.url
                            })) : we(void 0), z], (e => e[0])),
                            setVolume: e => {
                                null == M || M.mute.set(0 === e),
                                null == M || M.volume.set(e)
                            }
                            ,
                            setPlaybackRate: e => {
                                null == M || M.playbackRate.set(e)
                            }
                            ,
                            canUpgrade: () => J,
                            stats: {
                                bandwidth: () => V.pipe(x),
                                fps: () => l.pipe(x),
                                buffer: () => d.pipe(x),
                                latency: () => a.pipe(x),
                                wallclock: () => U.pipe(x)
                            }
                        })
                    }
                    )))
                }(V, e)))).subscribe((e => {
                    n.pipe(Ie(this.state, ( (e, t) => [e, t])), el(( ([e,t]) => e && "PLAYING" === t.state ? e : null)), Ie(U, l), el(( ([e,t,V]) => void 0 !== V ? [e, t, V] : null)), al(( ([t,V,l]) => e.switchStream({
                        name: t,
                        url: l
                    }).pipe(_e((e => [e, V])))))).subscribe(( ([e,t]) => {
                        this.config.onStats({
                            streamName: e.split("/")[1],
                            streamId: t
                        })
                    }
                    )).closeBy(V),
                    n.pipe(Le(1), Ie(l), el(( ([e,t]) => void 0 !== t ? [e, t] : null)), al(( ([t,V]) => e.play({
                        name: t,
                        url: V
                    }).pipe(_e(( () => t))))), Ie(U)).subscribe(( ([e,t]) => {
                        this.state.next({
                            state: "PLAYING"
                        }),
                        this.config.onStats({
                            streamName: e.split("/")[1],
                            streamId: t
                        })
                    }
                    )).closeBy(V),
                    o([d, a], (e => e)).subscribe((t => {
                        const [V,l] = t;
                        e.setVolume(l ? 0 : V)
                    }
                    )).closeBy(V),
                    V.add(T(( () => {
                        this.state.next({
                            state: "STOPPING"
                        }),
                        this.state.next({
                            state: "IDLE"
                        })
                    }
                    ))),
                    this.config.onStats({
                        qualityMode: E.MANUAL,
                        currentQuality: m.LOW,
                        availableQualities: [m.LOW]
                    }),
                    e.stats.bandwidth().subscribe((e => this.config.onStats({
                        bandwidth: e,
                        playbackBitrate: e
                    }))).closeBy(V),
                    e.stats.latency().subscribe((e => this.config.onStats({
                        latency: e
                    }))).closeBy(V),
                    e.stats.buffer().subscribe((e => this.config.onStats({
                        bufferLength: e
                    }))).closeBy(V),
                    e.stats.fps().subscribe((e => this.config.onStats({
                        fps: e
                    }))).closeBy(V),
                    e.stats.wallclock().subscribe((e => this.config.onStats({
                        wallclock: e
                    }))).closeBy(V),
                    e.canUpgrade().subscribe((e => {
                        this.config.onPlayerCanUpgrade({
                            emitter: k.Flipbook,
                            reason: y.AcceptableAverageMsBetweenFrames,
                            metrics: e
                        })
                    }
                    )).closeBy(V),
                    this.observables.playbackRate.subscribe((t => e.setPlaybackRate(t))).closeBy(V)
                }
                ), (e => this.config.onFailure(Je(e, H.MediaError)))).closeBy(V)
            }
            destroy() {
                this.scope.close(),
                Tt(this.config.canvas)
            }
        }
        function Zd(e, t) {
            const V = new s
              , l = new F({
                state: "IDLE"
            })
              , d = new i;
            return [qV(V, e.videoTag), $V(V, l.pipe(_e((e => "PLAYING" === e.state))), e.settings.latency, (e => d.next(e))), ll(V, e.settings.buffer), dl(V, l, k.Flipbook)].reduce(( (e, t) => t(e)), ( (e, t) => new Rd(e,t,V,l,d)))(e, t)
        }
        function Nd(e, t) {
            if (t.includes(e))
                return e;
            if (0 === t.length)
                return null;
            const V = (e, t) => Math.abs(M[e] - M[t]);
            return t.reduce(( (t, l) => V(l, e) < V(t, e) ? l : t))
        }
        function cd(e) {
            return new Promise((t => {
                const V = e.subscribe((e => {
                    t(e),
                    V.close()
                }
                ))
            }
            ))
        }
        var Td = function(e, t, V, l) {
            return new (V || (V = Promise))((function(d, a) {
                function U(e) {
                    try {
                        R(l.next(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function n(e) {
                    try {
                        R(l.throw(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function R(e) {
                    var t;
                    e.done ? d(e.value) : (t = e.value,
                    t instanceof V ? t : new V((function(e) {
                        e(t)
                    }
                    ))).then(U, n)
                }
                R((l = l.apply(e, t || [])).next())
            }
            ))
        };
        class Wd {
            constructor(e, t) {
                var V;
                this.config = e,
                this.parentObservables = t,
                this.availableQualities = new F([]),
                this.destroyScope = new s,
                this.disposableStack = [],
                this.subjects = (V = this.getObservablesProps(),
                {
                    url: new F(V.url),
                    playbackRate: new F(1)
                }),
                this.triggerStart(t),
                this.subscribeToStreamId(t),
                this.subscribeToMediaUrlsResolve(t);
                const l = o([t.quality, this.availableQualities.pipe(ge((e => e.length > 0)), r(( (e, t) => e.every(( (e, V) => t[V] === e))))), t.qualityMode, t.maxAutoQuality], (e => e)).pipe(_e(( ([e,t,V,l]) => [e, V === E.AUTO && void 0 !== l ? lt(t, e) : t])), el(( ([e,t]) => Nd(e, t))), ot(( () => new mt(1))));
                this.observables = {
                    maxAutoQuality: t.maxAutoQuality.pipe(r()),
                    qualityMode: t.qualityMode.pipe(r()),
                    volume: t.volume,
                    muted: t.muted,
                    quality: l,
                    url: this.subjects.url.pipe(r()),
                    streamId: t.streamId,
                    playbackRate: this.subjects.playbackRate,
                    isBackgroundMode: t.isBackgroundMode
                };
                const d = () => this.destroy();
                window.addEventListener("beforeunload", (function e() {
                    d(),
                    window.removeEventListener("beforeunload", e)
                }
                ))
            }
            destroy() {
                var e, t;
                for (this.config.scheduler.deschedule(this.maxTimeToFirstFrameScheduler); this.disposableStack.length > 0; )
                    null === (e = this.disposableStack.pop()) || void 0 === e || e();
                this.destroyScope.close();
                for (const V of Object.values(this.subjects))
                    V.complete();
                null === (t = this.mediaPlayer) || void 0 === t || t.destroy(),
                this.mediaPlayer = void 0
            }
            getObservablesProps() {
                return {
                    url: void 0,
                    playbackRate: 1
                }
            }
            getMediaPlayerConfig(e) {
                const {scheduler: t, browserFeatures: V, canvas: l, onStop: d, onPlayerCanUpgrade: a} = this.config;
                return {
                    manifest: e,
                    scheduler: t,
                    browserFeatures: V,
                    canvas: l,
                    onSuccess: this.onSuccess.bind(this),
                    onStop: d,
                    onStats: this.config.onStats.bind(this),
                    onPlaybackEvent: this.config.onPlaybackEvent.bind(this),
                    onFailure: this.onFailure.bind(this),
                    onEvent: this.config.onEvent.bind(this),
                    onPlayerCanUpgrade: a,
                    settings: this.config.settings,
                    audioContext: this.config.audioContext,
                    videoTag: this.config.videoTag
                }
            }
            onSuccess() {
                this.config.onSuccess(),
                this.config.scheduler.deschedule(this.maxTimeToFirstFrameScheduler)
            }
            onFailure(e) {
                this.config.scheduler.deschedule(this.maxTimeToFirstFrameScheduler),
                this.config.onFailure(e),
                this.destroyScope.close()
            }
            reportManifestStats(e, t) {
                const V = e.streams.map((e => e.quality));
                this.availableQualities.next(V);
                const [l,d] = t
                  , a = {
                    cdnDecisionTime: d,
                    manifestLoadingTime: l,
                    availableQualities: V
                }
                  , U = new URL(e.streams[0].url).host;
                this.config.onPlaybackEvent({
                    eventType: J.MANIFEST_STATS,
                    eventReason: J.MANIFEST_STATS,
                    data: {
                        manifestFetchStats: a,
                        streamHost: U
                    }
                })
            }
            subscribeToMediaUrlsResolve(e) {
                o([e.quality, e.qualityMode], ( ([e,t]) => ({
                    quality: e,
                    mode: t
                }))).pipe(Ke(2, 1), ge(( ([e,t]) => this.shouldResolveUrls(e, t)))).subscribe(( () => this.config.restartPlayer())).closeBy(this.destroyScope)
            }
            subscribeToStreamId(e) {
                const {streamId: t} = e;
                t.subscribe(( () => {
                    this.availableQualities.next([])
                }
                )).closeBy(this.destroyScope),
                t.pipe(Ke(2, 1)).subscribe(( ([e,t]) => {
                    this.config.onPlaybackEvent({
                        eventType: J.STREAM_ID_CHANGED,
                        eventReason: G.StreamIdChangeRequested,
                        data: {
                            streamIdChanged: {
                                prev: e,
                                next: t
                            }
                        }
                    })
                }
                )).closeBy(this.destroyScope)
            }
            triggerStart(e) {
                const {quality: t, qualityMode: V, streamId: l} = e
                  , {settings: d} = this.config;
                we(void 0).pipe(Ie(t, V, l, ( (e, t, V, l) => ({
                    quality: t,
                    qualityMode: V,
                    streamId: l
                }))), al((e => {
                    const t = {
                        streamId: e.streamId,
                        quality: e.quality,
                        qualityMode: e.qualityMode
                    }
                      , V = d.player === k.Flipbook ? d.audio.urls : d.urls;
                    return Pe(this.attemptPlayback(V, t))
                }
                ))).subscribe((e => this.subjects.url.next(e)), (e => {
                    if (e instanceof DOMException && "AbortError" === e.name)
                        return;
                    const t = e instanceof Qe ? e : Je(e, j.FailedLoadingManifest);
                    this.onFailure(t)
                }
                )).closeBy(this.destroyScope)
            }
            attemptPlayback(e, t) {
                return Td(this, void 0, void 0, (function*() {
                    var V;
                    const {settings: {session: l, stream: d}} = this.config;
                    this.scheduleMaxTimeToFirstFrame(),
                    this.config.onPlaybackAttempt({
                        videoSessionId: l.videoSessionId,
                        pressedStart: !1,
                        tableBaseName: d.baseName
                    }),
                    this.availableQualities.next([]);
                    const a = et(e) ? e[0] : e[t.streamId];
                    if (!a)
                        throw new Error("video url is not defined");
                    const U = new URL(a);
                    U.searchParams.set("streamid", `${t.streamId}`);
                    const [n,R] = yield Promise.race([this.resolveMediaStreamUrl(U.toString(), t,l.tableId), new Promise(( (e, t) => this.disposableStack.push(( () => t(new DOMException("Manifest fetch aborted","AbortError"))))))]);
                    return null === (V = this.mediaPlayer) || void 0 === V || V.destroy(),
                    this.mediaPlayer = void 0,
                    this.mediaPlayer = yield Promise.race([this.initMediaPlayer(n), new Promise(( (e, t) => this.disposableStack.push(( () => t(new DOMException("Media player initialization aborted","AbortError"))))))]),
                    R
                }
                ))
            }
            initMediaPlayer(e) {
                return Td(this, void 0, void 0, (function*() {
                    const [t,V] = yield Promise.all([cd(this.parentObservables.qualityMode), cd(this.parentObservables.maxAutoQuality)]);
                    let l = e;
                    t === E.AUTO && void 0 !== V && (l = {
                        mediaManifests: e.mediaManifests.map((e => Object.assign(Object.assign({}, e), {
                            streams: e.streams.filter((e => t !== E.AUTO || void 0 === V || M[e.quality] <= M[V]))
                        })))
                    });
                    const d = this.getMediaPlayerConfig(l);
                    return this.getMediaPlayer()(d, this.observables)
                }
                ))
            }
            scheduleMaxTimeToFirstFrame() {
                this.config.scheduler.deschedule(this.maxTimeToFirstFrameScheduler),
                this.maxTimeToFirstFrameScheduler = this.config.scheduler.schedule(( () => {
                    this.onFailure(new Qe(H.NetworkError,"FIRST_FRAME_TIMEOUT"))
                }
                ), this.config.settings.playback.maxTimeToFirstFrame)
            }
        }
        class id extends Wd {
            shouldResolveUrls() {
                return !1
            }
            resolveMediaStreamUrl(e, t,table_id) {
                return this.config.manifestManager.fetch(e,table_id).then(( ([e,V]) => {
                    const l = e.mediaManifests.length > 1 ? t.streamId : 0;
                    return [e, e.mediaManifests[l], V]
                }
                )).then(( ([e,V,l]) => {
                    this.reportManifestStats(V, l),
                    this.emitAvailableQualities(V);
                    const d = Math.max(V.streams.findIndex((e => e.quality === t.quality)), 0);
                    return [e, V.streams[d].url]
                }
                ))
            }
            getMediaPlayer() {
                return this.config.mediaPlayerFactory
            }
            emitAvailableQualities(e) {
                const t = e.streams.map((e => e.quality));
                this.config.onStats({
                    availableQualities: t
                })
            }
        }
        function Fd(e, t) {
            const V = Object.assign(Object.assign({}, e), {
                manifestManager: new vV(LV,KV()),
                mediaPlayerFactory: Zd
            });
            return new id(V,t)
        }
        const rd = new Map([[E.MANUAL, G.ManualChange], [E.INTERNAL, G.InternalOverride]])
          , sd = new Map([[J.UPGRADE, G.SufficientBandwidth], [J.DOWNGRADE, G.InsufficientBandwidth]])
          , hd = (e, t=new F([])) => V => (l, d) => {
            const a = function() {
                let e = !1;
                return (t, V) => {
                    if (V.length <= 1)
                        return V[0] !== E.AUTO ? G.ManualChange : sd.get(t);
                    const [,l] = V;
                    return l !== E.AUTO ? (e = !1,
                    rd.get(l)) : l !== E.AUTO || e ? l === E.AUTO && e ? sd.get(t) : G.UnknownReason : (e = !0,
                    G.SwitchToAuto)
                }
            }()
              , U = new mt(1)
              , n = new mt(1)
              , R = Object.assign(Object.assign({}, l), {
                onStats: e => {
                    e.currentQuality && U.next(e.currentQuality),
                    e.qualityMode && n.next(e.qualityMode),
                    l.onStats(e)
                }
            });
            return n.pipe(r(), Ke(2, 1), Ie(U)).subscribe(( ([[e,t],V]) => {
                const d = e === E.INTERNAL || t === E.INTERNAL ? G.InternalOverride : G.ManualChange;
                l.onPlaybackEvent({
                    eventType: J.QUALITY_MODE_CHANGED,
                    eventReason: d,
                    data: {
                        qualityModeChanged: {
                            prev: e,
                            next: t,
                            quality: V
                        }
                    }
                })
            }
            )).closeBy(e),
            U.pipe(r(), Ke(2, 1), Ie(n.pipe(r(), Ke(2, 1, !0)), t), _e(( ([[e,t],V,l]) => {
                const d = function(e, t) {
                    return M[t] > M[e]
                }(e, t) ? J.UPGRADE : J.DOWNGRADE
                  , U = a(d, V)
                  , n = {
                    eventType: d,
                    eventReason: null != U ? U : G.UnknownReason,
                    data: {
                        qualityChanged: {
                            prev: e,
                            next: t
                        }
                    }
                };
                if (V[V.length - 1] === E.AUTO) {
                    const V = l.find((V => V.from === e && V.to === t));
                    if (V)
                        return Object.assign(Object.assign({}, n), {
                            eventReason: V.reason
                        })
                }
                return n
            }
            ))).subscribe((e => {
                l.onPlaybackEvent(e)
            }
            )).closeBy(e),
            V(R, d)
        }
        ;
        function od(e) {
            return new W((t => {
                t.onNext();
                const V = setInterval(( () => t.onNext()), e);
                return T(( () => clearInterval(V)))
            }
            ))
        }
        const md = {
            setItem: (e, t) => {
                try {
                    localStorage.setItem(e, t)
                } catch (V) {}
            }
            ,
            getItem: e => {
                try {
                    return localStorage.getItem(e)
                } catch (t) {
                    return null
                }
            }
            ,
            removeItem: e => {
                try {
                    localStorage.removeItem(e)
                } catch (t) {}
            }
        };
        var Md;
        !function(e) {
            e.Bandwidth = "evo.video.bandwidth",
            e.Session = "evo.video.sessionId"
        }(Md || (Md = {}));
        const Sd = (e, t=6e4, V=md) => l => (d, a) => {
            const U = new i
              , n = Object.assign(Object.assign({}, d), {
                onStats: e => {
                    U.next(e),
                    d.onStats(e)
                }
            });
            a.streamId.pipe(el((e => function(e, t) {
                var V;
                return (null !== (V = e.mediaManifests.find((e => e.id === t))) && void 0 !== V ? V : e.mediaManifests[0]).streams.sort(( (e, t) => e.bitrate - t.bitrate)).map((e => [e.bitrate, e.quality]))
            }(d.manifest, e))), Le(1), Ie(a.qualityMode), el(( ([e,t]) => t !== E.MANUAL ? e : null)), el((e => function(e, t, V) {
                if (e.getItem(Md.Session) !== t)
                    return null;
                const l = e.getItem(Md.Bandwidth);
                if (!l)
                    return null;
                const d = parseFloat(l);
                if (!d)
                    return null;
                const a = V.filter(( ([e]) => d > e)).pop();
                return a ? a[1] : null
            }(V, d.settings.session.gameSessionId, e)))).subscribe((e => a.quality.next(e))).closeBy(e);
            const R = U.pipe(el((e => e.qualityMode)))
              , Z = U.pipe(el((e => e.bandwidth)));
            return gV(od(t).pipe(_e(( () => {}
            ))), a.quality.pipe(_e(( () => {}
            )))).pipe(Ie(R, Z), ge(( ([,e]) => e === E.AUTO))).subscribe(( ([,,e]) => {
                V.setItem(Md.Session, d.settings.session.gameSessionId),
                V.setItem(Md.Bandwidth, e.toString())
            }
            )).closeBy(e),
            l(n, a)
        }
          , Ed = (e, t, V) => {
            V.pipe(el((e => e.qualityMode)), Ke(2, 1), Ie(t), el(( ([[,e],t]) => e === E.AUTO ? t : null))).subscribe((e => t.next(e))).closeBy(e)
        }
        ;
        function pd(e, t, V, l, d, a) {
            return h(( (U, n) => {
                let R = 0;
                l.subscribe((e => {
                    e || (R = 0)
                }
                ), n.onError, n.onComplete).closeBy(U),
                e.pipe(Ie(l), el(( ([e,t]) => t ? e : null))).pipe(qe(( () => {
                    R = Math.round(R * d * 100) / 100
                }
                )), ge((e => (t(e) && (R += 1),
                R >= a))), _e((e => V(e, R)))).subscribe(n.onNext, n.onError, n.onComplete).closeBy(U)
            }
            ))
        }
        function bd(e, t, V, l=.95, d=4) {
            return pd(e, (e => e < t), ( () => ({
                timestamp: performance.now(),
                reason: "BUFFER RULE",
                direction: "down"
            })), V, l, d)
        }
        function kd(e, t, V, l=.95, d=10) {
            return pd(e.pipe(Ie(t)), ( ([e,t]) => e < t), ( () => ({
                timestamp: performance.now(),
                reason: "BITRATE RULE",
                direction: "down"
            })), V, l, d)
        }
        function Yd(e, t, V, l=.95, d=5) {
            return pd(e.pipe(Ie(t)), ( ([e,t]) => e > t), ( () => ({
                timestamp: performance.now(),
                reason: "THROUGHPUT RULE",
                direction: "up"
            })), V, l, d)
        }
        function Qd(e, t, V) {
            const l = t.pipe(el((e => e.bufferLength)), r())
              , d = t.pipe(el((e => e.bandwidth)), r())
              , a = t.pipe(el((e => e.playbackBitrate)), r())
              , U = o([t.pipe(el((e => e.currentQuality))), V], (e => e)).pipe(_e(( ([e,t]) => {
                const V = t.findIndex(( ([,t]) => t === e));
                if (V + 1 >= t.length)
                    return Number.MAX_VALUE;
                const [l] = t[V + 1];
                return 1.15 * l
            }
            )));
            return gV(bd(l, 400, e), kd(d, a, e), Yd(d, U, e))
        }
        const Jd = (e, t, V=Qd, l=[Ed], d=new F([])) => a => (U, n) => {
            const R = new i
              , Z = Object.assign(Object.assign({}, U), {
                onStats: e => {
                    R.next(e),
                    U.onStats(e)
                }
            })
              , N = new i;
            N.subscribe((e => n.quality.next(e))).closeBy(e);
            const c = R.pipe(el((e => e.currentQuality)), ot(( () => new mt(1))))
              , T = o([gV(N, n.quality), c], ( ([e,t]) => e !== t)).pipe(ot(( () => new mt(1))))
              , W = o([t, n.qualityMode.pipe(_e((e => e === E.AUTO))), T], ( ([e,t,V]) => e && t && !V)).pipe(ot(( () => new mt(1))))
              , F = n.streamId.pipe(el((e => function(e, t) {
                var V;
                return (null !== (V = e.mediaManifests.find((e => e.id === t))) && void 0 !== V ? V : e.mediaManifests[0]).streams.sort(( (e, t) => e.bitrate - t.bitrate)).map((e => [e.bitrate, e.quality]))
            }(U.manifest, e))), ot(( () => new mt(1))));
            V(W, R, F).pipe(Ie(F, c), el(( ([e,t,V]) => {
                const l = t.findIndex(( ([,e]) => e === V)) + ("up" === e.direction ? 1 : -1);
                if (l < 0 || l >= t.length)
                    return null;
                const [,d] = t[l];
                return Object.assign(Object.assign({}, e), {
                    from: V,
                    to: d
                })
            }
            ))).pipe(Ie(d.pipe((e => e.pipe(_V(( (e, t) => {
                const V = performance.now();
                return e.concat(t).filter((e => V - e.timestamp < 3e4)).slice(-50)
            }
            ), []))))), el(( ([e,t]) => {
                if ("down" === e.direction)
                    return e;
                const V = t.filter((e => "down" === e.direction))
                  , l = (d = V)[d.length - 1];
                var d;
                return l ? e.timestamp - l.timestamp > function(e, t=4, V=6) {
                    return 1e3 * Math.pow(2, Math.min(e + t, V))
                }(V.length) ? e : null : e
            }
            )), qe((e => d.next([e])))).subscribe((e => N.next(e.to))).closeBy(e);
            for (const t of l)
                t(e, N, R, F);
            return a(Z, n)
        }
        ;
        function Gd(e, t) {
            return t.pipe(Ie(e), ge(( ([,e]) => e)), _e(( () => ({
                reason: "RESTART RULE",
                direction: "down",
                timestamp: performance.now()
            }))))
        }
        const zd = e => t => (V, l) => {
            const d = new mt(1)
              , a = l.qualityMode.pipe(Ke(2, 1), ot());
            return a.pipe(ge(( ([,e]) => e === E.INTERNAL)), Ie(l.quality, ( (e, t) => t)), qe((e => d.next(e))), el((e => M[e] > M.MEDIUM ? m.MEDIUM : e))).subscribe((e => l.quality.next(e))).closeBy(e),
            a.pipe(ge(( ([e,t]) => e === E.INTERNAL && t === E.MANUAL)), Ie(d, ( (e, t) => t))).subscribe((e => l.quality.next(e))).closeBy(e),
            t(V, l)
        }
        ;
        function xd(e) {
            return new W((t => {
                for (const V of e)
                    t.onNext(V);
                return t.onComplete(),
                T()
            }
            ))
        }
        var ud = V(632);
        class Xd {
            constructor(e, t, V, l=new F({
                state: "IDLE"
            }), d=new i) {
                this.lifeCycleScope = e,
                this.config = t,
                this.fmp4State = l,
                this.transition = d,
                this.handleTransportWarnings = e => {
                    this.config.onPlaybackEvent({
                        eventType: J.WARNING,
                        eventReason: e.message
                    })
                }
                ,
                tt(this.config.videoTag);
                const a = o([V.streamId, V.quality], (e => e)).pipe(el(( ([e,t]) => {
                    var V, l;
                    const {mediaManifests: d} = this.config.manifest
                      , a = (null !== (V = d.find((t => t.id === e))) && void 0 !== V ? V : d[0]).streams;
                    return null !== (l = a.find((e => e.quality === t))) && void 0 !== l ? l : a[a.length - 1]
                }
                )), ot(( () => new mt(1))));
                this.handleStateTransitions(V),
                this.triggerPlay(a, V),
                this.handleStreamChange(a),
                this.handlePlaybackRateChange(V.playbackRate),
                this.handleMuted(V),
                this.handleVolumeChange(V.volume)
            }
            destroy() {
                this.transition.next({
                    action: "DESTROY"
                }),
                this.lifeCycleScope.close(),
                Vt(this.config.videoTag)
            }
            handleStateTransitions(e) {
                this.transition.pipe(al((t => {
                    let V = we(void 0);
                    switch (t.action) {
                    case "INIT":
                        V = this.processInit(t.config);
                        break;
                    case "PLAY":
                        V = this.processPlay(e);
                        break;
                    case "DESTROY":
                        V = this.processDestroy(t.error)
                    }
                    return V.pipe((l = e => (this.transition.next({
                        action: "DESTROY",
                        error: this.toEvoError(e)
                    }),
                    we(void 0)),
                    e => new W((t => {
                        let V, d, a = !1;
                        return V = e.subscribe((e => t.onNext(e)), (e => {
                            a = !0,
                            d = l(e).subscribe((e => t.onNext(e)), (e => t.onError(e)), ( () => t.onComplete()))
                        }
                        ), ( () => {
                            a || t.onComplete()
                        }
                        )),
                        T(( () => {
                            null == V || V.close(),
                            null == d || d.close()
                        }
                        ))
                    }
                    ))));
                    var l
                }
                ))).subscribe().closeBy(this.lifeCycleScope)
            }
            processInit(e) {
                return this.fmp4State.pipe(Le(1), _e((t => {
                    if ("IDLE" !== t.state)
                        return;
                    this.fmp4State.next({
                        state: "LOADING"
                    });
                    const V = new s;
                    T(( () => V.close())).closeBy(this.lifeCycleScope);
                    const l = new ud.FMP4Player(e);
                    this.fmp4State.next({
                        state: "READY",
                        fmp4: l,
                        scope: V
                    })
                }
                )))
            }
            processPlay(e) {
                return this.fmp4State.pipe(Le(1), Ce((t => {
                    if ("READY" !== t.state)
                        return we(void 0);
                    const {scope: V, fmp4: l} = t;
                    return Pe(l.play().then(( () => {
                        this.wireStats(V, l, e),
                        l.state.subscribe((e => {
                            "DESTROYED" === e.state && this.transition.next({
                                action: "DESTROY",
                                error: this.toEvoError(e.error)
                            })
                        }
                        )),
                        l.state.subscribe((e => {
                            "PLAYING" === e.state && this.config.onPlaybackEvent({
                                eventType: J.PLAYING,
                                eventReason: J.PLAYING
                            })
                        }
                        )),
                        l.stats.isBuffering.subscribe((e => {
                            this.config.onPlaybackEvent({
                                eventType: e ? J.WAITING : J.PLAYING,
                                eventReason: e ? J.WAITING : J.PLAYING
                            })
                        }
                        ))
                    }
                    )).then(( () => this.fmp4State.next(Object.assign(Object.assign({}, t), {
                        state: "PLAYING"
                    })))))
                }
                )))
            }
            processDestroy(e) {
                return this.fmp4State.pipe(Le(1), _e((t => {
                    "READY" !== t.state && "PLAYING" !== t.state || (this.fmp4State.next({
                        state: "STOPPING",
                        error: e
                    }),
                    t.fmp4.dispose(),
                    t.scope.close(),
                    this.fmp4State.next({
                        state: "IDLE"
                    }))
                }
                )))
            }
            triggerPlay(e, t) {
                we(void 0).pipe(Ie(e, t.muted, t.volume), _e(( ([e,t,V,l]) => ({
                    action: "INIT",
                    config: {
                        video: this.config.videoTag,
                        transport: (e, t) => bl(e, t, {
                            implementation: El,
                            plugins: [ol(this.handleTransportWarnings)]
                        }),
                        stream: t,
                        codec: this.codecMimeType(this.config.settings.videoCodec, this.config.settings.audioCodec),
                        initBufferLength: this.config.settings.buffer.init,
                        volume: l,
                        muted: V
                    }
                })))).pipe(Ie(this.fmp4State), _e(( ([e,t]) => {
                    const V = [];
                    return "READY" !== t.state && "PLAYING" !== t.state || V.push({
                        action: "DESTROY"
                    }),
                    V.push(e),
                    V.push({
                        action: "PLAY"
                    }),
                    V
                }
                )), al((e => xd(e)))).subscribe((e => this.transition.next(e))).closeBy(this.lifeCycleScope)
            }
            handleStreamChange(e) {
                e.pipe(yd(this.fmp4State)).subscribe(( ([e,t]) => t.switchStream(e))).closeBy(this.lifeCycleScope)
            }
            handlePlaybackRateChange(e) {
                e.pipe(yd(this.fmp4State)).subscribe(( ([e,t]) => t.setPlaybackRate(e))).closeBy(this.lifeCycleScope)
            }
            handleMuted(e) {
                o([e.muted, e.volume], ( ([e,t]) => e || 0 === t)).pipe(yd(this.fmp4State)).subscribe(( ([e,t]) => t.mute(e))).closeBy(this.lifeCycleScope)
            }
            handleVolumeChange(e) {
                e.pipe(yd(this.fmp4State)).subscribe(( ([e,t]) => t.setVolume(e))).closeBy(this.lifeCycleScope)
            }
            codecMimeType(e, t) {
                return `video/mp4; codecs="${v[e]}, ${I[t]}"`
            }
            toEvoError(e) {
                if (!e)
                    return;
                let t = H.MediaError;
                return "VideoDecoderError" === e.name && (t = H.DecodeError),
                "NotAllowedError" === e.name && (t = H.PermissionError),
                "NotSupportedError" === e.name && (t = D.NotSupported),
                "EncodingError" === e.name && (Object.defineProperty(e, "code", {
                    value: 3
                }),
                t = H.DecodeError),
                e instanceof Nl && ("STREAM_SHUTDOWN" === e.type && (t = H.StreamShutdown),
                "NETWORK_ERROR" === e.type && (t = H.NetworkError),
                "STREAM_SECURITY_ERROR" === e.type && (t = B.StreamSecurityError)),
                new Qe(t,e.message)
            }
            wireStats(e, t, V) {
                t.stats.latency.subscribe((e => this.config.onStats({
                    latency: e
                }))),
                t.stats.wallclock.subscribe((e => this.config.onStats({
                    wallclock: e
                }))),
                t.stats.bufferLength.subscribe((e => this.config.onStats({
                    bufferLength: e
                }))),
                t.stats.bitrate.subscribe((e => this.config.onStats({
                    playbackBitrate: e
                }))),
                t.stats.droppedFrames.subscribe((e => this.config.onStats({
                    droppedFrames: e
                }))),
                t.stats.fps.subscribe((e => this.config.onStats({
                    fps: e
                }))),
                t.stats.bandwidth.subscribe((e => this.config.onStats({
                    bandwidth: e
                })));
                const l = this.config.manifest.mediaManifests.flatMap((e => e.streams));
                var d;
                (d = t.stats.streamName,
                new W((e => {
                    function t(t) {
                        e.onNext(t)
                    }
                    return d.subscribe(t),
                    T(( () => d.unsubscribe(t)))
                }
                ))).pipe(el((e => l.find((t => t.name === e)))), Ie(V.streamId)).subscribe(( ([e,t]) => this.config.onStats({
                    currentQuality: e.quality,
                    streamName: e.name,
                    streamHost: new URL(e.url).host,
                    streamId: t
                }))).closeBy(e),
                V.qualityMode.subscribe((e => this.config.onStats({
                    qualityMode: e
                }))).closeBy(e)
            }
        }
        function yd(e) {
            return t => t.pipe(Ce((t => e.pipe(el((e => "READY" === e.state || "PLAYING" === e.state ? e.fmp4 : void 0)), Le(1), _e((e => [t, e]))))))
        }
        function Bd(e, t) {
            const V = new s
              , l = new F({
                state: "IDLE"
            })
              , d = new i
              , a = l.pipe(_e((e => "PLAYING" === e.state)))
              , U = l.pipe(ge((e => {
                var t;
                return "STOPPING" === e.state && (null === (t = e.error) || void 0 === t ? void 0 : t.type) === H.MaxLatencyReached
            }
            )), _e(( () => {}
            )))
              , n = new F([])
              , R = [$V(V, a, e.settings.latency, (e => d.next({
                action: "DESTROY",
                error: e
            }))), hd(V, n), dl(V, l, k.Fmp4), ll(V, e.settings.buffer), Sd(V, 1e4), Jd(V, a, ( (t, V, l) => {
                const d = []
                  , a = V.pipe(el((e => e.bandwidth)), r())
                  , n = V.pipe(el((e => e.bufferLength)), r());
                if (e.settings.adaptive.bitrateRule.enable) {
                    const l = V.pipe(el((e => e.playbackBitrate)), r());
                    d.push(kd(a, l, t, e.settings.adaptive.bitrateRule.fadeCoefficient, e.settings.adaptive.bitrateRule.switchCoefficient))
                }
                const R = o([V.pipe(el((e => e.currentQuality))), l], (e => e)).pipe(_e(( ([e,t]) => {
                    const V = t.findIndex(( ([,t]) => t === e));
                    if (V + 1 >= t.length)
                        return Number.MAX_VALUE;
                    const [l] = t[V + 1];
                    return 1.15 * l
                }
                )));
                return gV(...d, bd(n, 400, t), Gd(t, U), Yd(a, R, t))
            }
            ), [Ed], n), zd(V)].reduce(( (e, t) => t(e)), ( (e, t) => new Xd(V,e,t,l,d)))
              , Z = ( () => {
                const e = new mt(1);
                return t.quality.subscribe((t => e.next(t))).closeBy(V),
                e
            }
            )();
            return R(e, Object.assign(Object.assign({}, t), {
                quality: Z
            }))
        }
        function Hd(e, t) {
            const V = Object.assign(Object.assign({}, e), {
                manifestManager: new vV(LV,KV()),
                mediaPlayerFactory: Bd
            });
            return new id(V,t)
        }
        function jd(e, t=e => e) {
            return (V, l) => e(V, l, t)
        }
        function Dd(e, t, V) {
            if (-1 === e.indexOf("#EXTM3U"))
                throw new Error(`Supplied data is not an HLS manifest: ${e}`);
            return -1 !== e.indexOf("#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID") ? function(e, t) {
                const V = [];
                let l, d = 0;
                const a = t(e)
                  , U = e.split("\n");
                for (; d < U.length; ) {
                    const e = U[d];
                    if (-1 === e.indexOf("EXT-X-MEDIA:TYPE=VIDEO")) {
                        d += 1;
                        continue
                    }
                    const t = Number(Id(e, "NAME"));
                    l && (null == l ? void 0 : l.id) === t || (l = {
                        id: t,
                        url: a,
                        streams: []
                    },
                    V.push(l));
                    const n = "YES" === Id(e, "DEFAULT")
                      , R = n ? Od(U.slice(d, d + 3)) : Ad(e);
                    l.streams.push(R),
                    d += n ? 3 : 1
                }
                return {
                    mediaManifests: V
                }
            }(e, V) : function(e, t, V) {
                const l = e.split("\n");
                let d = {
                    id: 0,
                    url: V(e),
                    streams: []
                }
                  , a = 0;
                for (; a < l.length; ) {
                    if (-1 === l[a].indexOf("EXT-X-STREAM-INF")) {
                        a += 1;
                        continue
                    }
                    const e = wd(l.slice(a, a + 2));
                    d.streams.push(e),
                    a += 2
                }
                return 0 === d.streams.length && d.streams.push({
                    url: t,
                    name: "",
                    quality: m.MEDIUM,
                    bitrate: 0
                }),
                {
                    mediaManifests: [d]
                }
            }(e, t, V)
        }
        function Od(e) {
            const t = Id(e[0], "GROUP-ID")
              , V = e[2]
              , l = vd(V, t);
            return {
                quality: t,
                bitrate: Ld(Number(Id(e[1], "BANDWIDTH"))),
                url: V,
                name: l
            }
        }
        function Ad(e) {
            var t;
            const V = Id(e, "GROUP-ID")
              , l = null !== (t = Id(e, "URI")) && void 0 !== t ? t : ""
              , d = vd(l, V)
              , a = Ld(function(e) {
                const t = e.split("/");
                if (0 === t.length)
                    return 0;
                const V = t[t.length - 1]
                  , l = V.indexOf("_b") + 2
                  , d = V.indexOf("_", l);
                return Number(V.slice(l, d))
            }(l));
            return {
                quality: V,
                bitrate: a,
                url: l,
                name: d
            }
        }
        function wd(e) {
            var t;
            const V = null !== (t = Id(e[0], "NAME")) && void 0 !== t ? t : m.MEDIUM
              , l = e[1]
              , d = vd(l, V);
            return {
                quality: V,
                bitrate: Ld(Number(Id(e[0], "BANDWIDTH"))),
                url: l,
                name: d
            }
        }
        function vd(e, t) {
            const V = e.split("/");
            return V[V.length - 2].replace("amlst:", "").replace("_auto", `_${p[t]}`)
        }
        function Id(e, t) {
            const V = e.indexOf(t);
            if (-1 === V)
                return;
            const l = V + t.length + 1
              , d = e.indexOf(",", l)
              , a = -1 !== d ? d : e.length
              , U = e.slice(l, a);
            return '"' === U[0] ? U.slice(1, U.length - 1) : U
        }
        function Ld(e) {
            return e / 1e3
        }
        function Kd(e) {
            return `data:application/vnd.apple.mpegurl;base64,${btoa(e)}`
        }
        class gd {
            constructor() {
                this.patterns = {}
            }
            addPattern(e, t) {
                return "string" == typeof e ? this.patterns[e.toLowerCase()] = t : e.forEach((e => this.patterns[e.toLowerCase()] = t)),
                this
            }
            checkPatterns(e) {
                const t = e.join(",").toLowerCase();
                var V;
                (V = this.patterns,
                Object.keys(V).map((e => [e, V[e]]))).forEach(( ([e,V]) => {
                    t.includes(e) && V()
                }
                ))
            }
        }
        const fd = {
            deltaTime: 0,
            halfRoundTripTime: 0
        };
        class Cd {
            constructor(e, t) {
                this.mediaTag = e,
                this.dispatchWallclock = t,
                this.lastValidWallclock = -1,
                this.enableMetadataTrack = () => {
                    let e = this.cacheTextTrack;
                    const t = this.mediaTag.textTracks;
                    let V;
                    if (t && t.length) {
                        for (const e of t)
                            "metadata" === e.kind && (V = e),
                            e.mode = "disabled";
                        e && (e.removeEventListener("cuechange", this.onTextTrackCueChange),
                        e = void 0),
                        V && "function" == typeof V.addEventListener && "function" == typeof V.removeEventListener && (e = V,
                        e.mode = "showing",
                        e.addEventListener("cuechange", this.onTextTrackCueChange))
                    }
                    return e
                }
                ,
                this.onTextTrackCueChange = e => {
                    const t = e.currentTarget.activeCues;
                    if (!t || !t.length)
                        return;
                    if (this.mediaTag.currentTime < 1)
                        return;
                    const V = t[t.length - 1]
                      , l = V.value ? V.value.data : void 0
                      , d = l ? l.substr(0, l.length - 3) : V.text
                      , a = this.mediaTag.currentTime - V.startTime
                      , U = parseInt(d, 10) + Math.round(1e3 * a);
                    U <= this.lastValidWallclock || (this.lastValidWallclock = U,
                    this.dispatchWallclock(U))
                }
            }
            enableWallclock(e) {
                if (!(this.mediaTag instanceof HTMLVideoElement))
                    return e;
                e = this.disableWallclock(e);
                const t = this.mediaTag.textTracks;
                return t ? (t.length && (this.cacheTextTrack = e,
                e = this.enableMetadataTrack()),
                "function" == typeof t.addEventListener && (this.cacheTextTrack = e,
                t.addEventListener("addtrack", this.enableMetadataTrack)),
                e) : e
            }
            disableWallclock(e) {
                if (this.mediaTag.textTracks && "function" == typeof this.mediaTag.textTracks.removeEventListener && this.mediaTag.textTracks.removeEventListener("addtrack", this.enableMetadataTrack),
                !e)
                    return e;
                e.removeEventListener("cuechange", this.onTextTrackCueChange);
                const t = e.cues;
                if (t)
                    try {
                        for (let V = t.length; V > 0; V--)
                            null == e || e.removeCue(t[0])
                    } catch (V) {}
            }
        }
        const Pd = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "waiting"];
        var qd;
        !function(e) {
            e[e.InitSuspendEventPatterns = 0] = "InitSuspendEventPatterns",
            e[e.IdleMediaPlayer = 1] = "IdleMediaPlayer",
            e[e.LoadMediaPlayer = 2] = "LoadMediaPlayer",
            e[e.StopMediaPlayer = 3] = "StopMediaPlayer",
            e[e.ReloadMediaPlayer = 4] = "ReloadMediaPlayer",
            e[e.DestroyMediaPlayer = 5] = "DestroyMediaPlayer",
            e[e.StartMediaPlayback = 6] = "StartMediaPlayback",
            e[e.ProgressEvent = 7] = "ProgressEvent",
            e[e.SetMediaUrl = 8] = "SetMediaUrl",
            e[e.PushBufferLength = 9] = "PushBufferLength",
            e[e.AttachEmptiedListener = 10] = "AttachEmptiedListener",
            e[e.CheckVideoCurrentTime = 11] = "CheckVideoCurrentTime",
            e[e.FixIosMicroStutter = 12] = "FixIosMicroStutter",
            e[e.ResumeOnPause = 13] = "ResumeOnPause",
            e[e.ChromeVideoStalled = 14] = "ChromeVideoStalled",
            e[e.CheckVideoTimeDifference = 15] = "CheckVideoTimeDifference",
            e[e.FailPlayerWhenStalled = 16] = "FailPlayerWhenStalled",
            e[e.HandleNotSupportedError = 17] = "HandleNotSupportedError",
            e[e.CanPlayThroughEvent = 18] = "CanPlayThroughEvent",
            e[e.OnPlayerPlayingEvent = 19] = "OnPlayerPlayingEvent",
            e[e.ErrorEvent = 20] = "ErrorEvent",
            e[e.PauseEvent = 21] = "PauseEvent"
        }(qd || (qd = {}));
        class _d {
            constructor(e, t, V, l, d) {
                this.lifeCycleScope = e,
                this.config = t,
                this.state = l,
                this.failPlayerPipe = d,
                this.patternEvents = [],
                this.patternStackSize = 10,
                this.patternAnalyzeOn = !0,
                this.patternAnalyzer = new gd,
                this.lastVideoTime = 0,
                this.hadPlayingEvent = !1,
                this.hadWaitingEvent = !1,
                this.isStopped = !0,
                this.actionsPipe = new i,
                this.reloadMediaPlayer = ({mediaTag: e}) => {
                    e.removeEventListener("pause", this.eventListener),
                    e.addEventListener("pause", this.resumeOnPause),
                    e.pause()
                }
                ,
                this.subscribeAction = (e, t, V) => {
                    this.actionsPipe.pipe(ge((e => e === t)), Ie(e.url)).subscribe((e => V({
                        url: e[1],
                        mediaTag: this.config.videoTag,
                        videoToken: ""
                    }))).closeBy(this.lifeCycleScope)
                }
                ,
                this.progressEvent = () => {
                    this.actionsPipe.next(qd.StartMediaPlayback)
                }
                ,
                this.pushBufferLength = ({mediaTag: e}) => {
                    const t = function(e) {
                        const {buffered: t} = e;
                        if (!t || !t.length)
                            return;
                        if (e.currentTime < 1)
                            return;
                        const V = t.end(t.length - 1) - e.currentTime;
                        return V > 0 ? V : 0
                    }(e);
                    void 0 !== t && this.config.onStats({
                        bufferLength: 1e3 * t
                    })
                }
                ,
                this.resumeOnPause = () => {
                    this.actionsPipe.next(qd.ResumeOnPause)
                }
                ,
                this.resumeOnPauseAction = ({mediaTag: e}) => {
                    e.removeEventListener("pause", this.resumeOnPause),
                    e.addEventListener("pause", this.eventListener),
                    this.actionsPipe.next(qd.StartMediaPlayback)
                }
                ,
                this.eventListener = ({type: e}) => {
                    switch (this.config.onEvent({
                        eventType: e
                    }),
                    this.analyzeEvent(e),
                    e) {
                    case "playing":
                        this.hadPlayingEvent = !0,
                        this.hadWaitingEvent = !1;
                        break;
                    case "durationchange":
                    case "timeupdate":
                        this.hadPlayingEvent && (this.onPlayerPlaying(),
                        this.hadPlayingEvent = !1),
                        this.isStopped && (this.isStopped = !1,
                        this.config.onSuccess()),
                        this.hadWaitingEvent && this.actionsPipe.next(qd.FixIosMicroStutter);
                        break;
                    case "canplaythrough":
                        "PLAYING" !== this.state.value.state && this.actionsPipe.next(qd.CanPlayThroughEvent);
                        break;
                    case "error":
                        this.actionsPipe.next(qd.ErrorEvent);
                        break;
                    case "waiting":
                        this.hadWaitingEvent = !0
                    }
                }
                ,
                this.fixIosMicroStutter = ({mediaTag: e}) => {
                    e.dispatchEvent(new Event("playing"))
                }
                ,
                this.handleNotSupportedError = () => {
                    this.config.onFailure(new Qe(D.NotSupported,"Not supported"))
                }
                ,
                this.idleMediaPlayer = ({url: e, mediaTag: t}) => {
                    this.detachEmptiedListener(t),
                    this.state.next({
                        state: "IDLE"
                    }),
                    e ? this.setMediaUrl(e) : t.pause()
                }
                ,
                this.startMediaPlayback = ({mediaTag: e}) => {
                    e.play().catch((e => {
                        const t = new Qe("NotAllowedError" === e.name ? H.PermissionError : H.MediaError,e.message);
                        this.failPlayer(t)
                    }
                    ))
                }
                ,
                this.onMediaEmptied = () => {
                    this.actionsPipe.next(qd.IdleMediaPlayer)
                }
                ,
                this.attachEmptiedListener = ({mediaTag: e}) => {
                    e.addEventListener("emptied", this.onMediaEmptied),
                    this.emptiedTimeout = this.config.scheduler.schedule(this.onMediaEmptied, 500)
                }
                ,
                this.stopMediaPlayer = () => {
                    this.stopTimeUpdateValidation(),
                    this.state.next({
                        state: "STOPPING"
                    }),
                    this.setMediaUrl(void 0)
                }
                ,
                this.checkVideoCurrentTime = ({mediaTag: e}) => {
                    const t = Math.floor(e.currentTime || 0);
                    t > 0 && t === this.lastVideoTime ? this.failPlayer(new Qe(H.NetworkError,"hls Time check failed")) : this.lastVideoTime = t
                }
                ,
                this.errorEvent = ({mediaTag: e, url: t}) => {
                    const {error: V, src: l} = e;
                    V && V.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED ? this.actionsPipe.next(qd.HandleNotSupportedError) : "" !== l && this.failPlayer(new Qe(H.NetworkError,`hls Error loading remote source: ${t}`))
                }
                ,
                tt(this.config.videoTag),
                this.initEventPatterns(),
                this.analyzeEvent = this.analyzeEvent.bind(this),
                this.subscribeToActions(V),
                this.subscribeObservables(V),
                d.subscribe((e => this.failPlayer(e))).closeBy(this.lifeCycleScope)
            }
            destroy() {
                this.actionsPipe.next(qd.DestroyMediaPlayer),
                this.lifeCycleScope.close(),
                Vt(this.config.videoTag)
            }
            destroyMediaPlayer({mediaTag: e}) {
                Pd.forEach((t => {
                    e.removeEventListener(t, this.eventListener)
                }
                )),
                e.removeEventListener("pause", this.resumeOnPause),
                e.removeEventListener("emptied", this.onMediaEmptied),
                this.actionsPipe.next(qd.StopMediaPlayer),
                e.pause(),
                e.removeAttribute("src"),
                e.load(),
                this.config.scheduler.deschedule([this.emptiedTimeout, this.scheduledValidation, this.timeUpdateInterval])
            }
            initEventPatterns() {}
            analyzeEvent(e) {
                this.pushPatternEvent(e),
                this.patternAnalyzeOn && this.patternAnalyzer.checkPatterns(this.patternEvents)
            }
            onPlayerPlaying() {
                ["LOADING", "IDLE"].includes(this.state.value.state) && (this.state.next({
                    state: "PLAYING"
                }),
                this.actionsPipe.next(qd.OnPlayerPlayingEvent))
            }
            playerPlaying({mediaTag: e}) {
                this.stopTimeoutValidation(),
                this.startTimeUpdateValidation(e)
            }
            failPlayer(e) {
                this.actionsPipe.next(qd.StopMediaPlayer),
                this.config.onFailure(e)
            }
            reload() {
                this.actionsPipe.next(qd.StopMediaPlayer)
            }
            subscribeToActions(e) {
                this.subscribeAction(e, qd.IdleMediaPlayer, this.idleMediaPlayer),
                this.subscribeAction(e, qd.LoadMediaPlayer, this.loadMediaPlayer.bind(this)),
                this.subscribeAction(e, qd.StopMediaPlayer, this.stopMediaPlayer),
                this.subscribeAction(e, qd.ReloadMediaPlayer, this.reloadMediaPlayer),
                this.subscribeAction(e, qd.DestroyMediaPlayer, this.destroyMediaPlayer.bind(this)),
                this.subscribeAction(e, qd.StartMediaPlayback, this.startMediaPlayback),
                this.subscribeAction(e, qd.ProgressEvent, this.progressEvent),
                this.subscribeAction(e, qd.PushBufferLength, this.pushBufferLength),
                this.subscribeAction(e, qd.AttachEmptiedListener, this.attachEmptiedListener),
                this.subscribeAction(e, qd.CheckVideoCurrentTime, this.checkVideoCurrentTime),
                this.subscribeAction(e, qd.FixIosMicroStutter, this.fixIosMicroStutter),
                this.subscribeAction(e, qd.ResumeOnPause, this.resumeOnPauseAction),
                this.subscribeAction(e, qd.HandleNotSupportedError, this.handleNotSupportedError),
                this.subscribeAction(e, qd.CanPlayThroughEvent, this.canPlayThroughEvent.bind(this)),
                this.subscribeAction(e, qd.OnPlayerPlayingEvent, this.playerPlaying.bind(this)),
                this.subscribeAction(e, qd.ErrorEvent, this.errorEvent)
            }
            loadMediaPlayer({url: e, mediaTag: t}) {
                const V = this.state.value.state
                  , l = this.config.videoTag.src === e && "IDLE" === V
                  , d = !this.config.videoTag.src && "STOPPING" === V;
                return !(!l && !d || (this.config.videoTag.load(),
                l && (this.detachEmptiedListener(this.config.videoTag),
                this.state.next({
                    state: "LOADING"
                }),
                this.scheduledValidation || this.startTimeoutValidation(),
                0)))
            }
            canPlayThroughEvent(e) {
                this.actionsPipe.next(qd.StartMediaPlayback)
            }
            subscribeObservables(e) {
                this.subscribeToMediaTag(),
                this.subscribeToUrl(e),
                this.subscribeToPlay(e),
                this.subscribeToVolume(e),
                this.subscribeToMuted(e)
            }
            subscribeToPlay(e) {
                const {url: t} = e;
                t.subscribe((e => {
                    e && (this.config.videoTag.pause(),
                    this.config.videoTag.src = e,
                    this.config.videoTag.load(),
                    this.actionsPipe.next(qd.LoadMediaPlayer))
                }
                )).closeBy(this.lifeCycleScope)
            }
            subscribeToMediaTag() {
                this.actionsPipe.next(qd.LoadMediaPlayer),
                Pd.forEach((e => {
                    this.config.videoTag.addEventListener(e, this.eventListener)
                }
                ))
            }
            subscribeToUrl(e) {
                const {url: t} = e
                  , V = t.pipe(r());
                V.pipe(Ie(this.state), ge(( ([e,{state: t}]) => "PLAYING" === t || "LOADING" === t))).subscribe(( () => {
                    this.actionsPipe.next(qd.StopMediaPlayer)
                }
                )).closeBy(this.lifeCycleScope),
                V.pipe(Ie(this.state), el(( ([e,{state: t}]) => "IDLE" === t ? e : null))).subscribe((e => {
                    this.setMediaUrl(e)
                }
                )).closeBy(this.lifeCycleScope)
            }
            subscribeToVolume(e) {
                e.volume.subscribe((e => {
                    this.config.videoTag.volume = e
                }
                )).closeBy(this.lifeCycleScope)
            }
            subscribeToMuted(e) {
                o([e.volume, e.muted], (e => e)).pipe(_e(( ([e,t]) => t || 0 === e))).subscribe((e => this.config.videoTag.muted = e)).closeBy(this.lifeCycleScope)
            }
            pushPatternEvent(e) {
                this.patternEvents.length >= this.patternStackSize && this.patternEvents.shift(),
                this.patternEvents.push(e)
            }
            setMediaUrl(e) {
                void 0 === e && void 0 === this.emptiedTimeout && this.actionsPipe.next(qd.AttachEmptiedListener),
                this.isStopped = !0,
                this.config.onStop()
            }
            detachEmptiedListener(e) {
                e.removeEventListener("emptied", this.onMediaEmptied),
                this.config.scheduler.deschedule(this.emptiedTimeout),
                this.emptiedTimeout = void 0
            }
            startTimeoutValidation() {
                this.scheduledValidation = this.config.scheduler.schedule(( () => {
                    this.failPlayer(new Qe(H.ValidationTimeout,"hls player failed on validation timeout"))
                }
                ), this.config.settings.validationTimeout)
            }
            stopTimeoutValidation() {
                this.config.scheduler.deschedule(this.scheduledValidation),
                this.scheduledValidation = void 0
            }
            startTimeUpdateValidation(e) {
                this.timeUpdateInterval || (this.lastVideoTime = Math.floor(e.currentTime || 0),
                this.timeUpdateInterval = this.config.scheduler.schedule(( () => this.actionsPipe.next(qd.CheckVideoCurrentTime)), 4e3, {
                    repeat: !0
                }))
            }
            stopTimeUpdateValidation() {
                this.config.scheduler.deschedule(this.timeUpdateInterval),
                this.timeUpdateInterval = void 0,
                this.lastVideoTime = 0
            }
        }
        function $d(e) {
            const t = e.lastIndexOf("/");
            return e.substring(0, t + 1)
        }
        function ea(e) {
            const t = e.match(/amlst:(.+)\//);
            if (t && t[1])
                return t[1]
        }
        class ta extends _d {
            constructor(e, t, V, l, d) {
                super(e, t, V, l, d),
                this.lifeCycleScope = e,
                this.config = t,
                this.state = l,
                this.failPlayerPipe = d,
                this.pxIteration = 0,
                this.firstSavedVideoTimestamp = -1,
                this.referenceVideoTimestamp = -1,
                this.referenceSystemTimestamp = -1,
                this.timeDiffCheckOn = !1,
                this.suspendPatternAnalyzer = new gd,
                this.canPlayPatternAnalyzer = new gd,
                this.stallingStartTimestamp = 0,
                this.serverClientDeltaTime = void 0,
                this.firstLatency = void 0,
                this.lastWallclock = 0,
                this.videoTrackList = new mt(1),
                this.startMeasuringLatency = () => {
                    this.latencySchedulerId || (this.latencySchedulerId = this.config.scheduler.schedule(this.measureLatency, 300, {
                        repeat: !0
                    }))
                }
                ,
                this.stopMeasuringLatency = () => {
                    this.config.scheduler.deschedule(this.latencySchedulerId),
                    this.latencySchedulerId = void 0,
                    this.lastWallclock = 0
                }
                ,
                this.measureLatency = () => {
                    if (!this.serverClientDeltaTime || !this.firstLatency || !this.lastWallclock)
                        return;
                    const e = performance.now() - this.lastWallclock - this.serverClientDeltaTime;
                    this.config.onStats({
                        latency: Math.round(this.firstLatency + e)
                    })
                }
                ,
                this.pauseEvent = () => {
                    "PLAYING" === this.state.value.state && this.actionsPipe.next(qd.StartMediaPlayback)
                }
                ,
                this.failPlayerWhenStalled = () => {
                    this.stallingStartTimestamp && this.stallingStartTimestamp < performance.now() - 1e4 && (this.config.scheduler.deschedule(this.stallingTimeout),
                    this.failPlayer(new Qe(H.MediaStalledCritical,"Stalling detected")))
                }
                ,
                this.checkVideoTimeDifference = ({mediaTag: e}) => {
                    if ("PLAYING" !== this.state.value.state)
                        return;
                    if (e.currentTime < 1)
                        return;
                    const t = window.performance.now()
                      , V = e.currentTime;
                    if (-1 === this.firstSavedVideoTimestamp ? this.firstSavedVideoTimestamp = V : -1 === this.referenceVideoTimestamp && V - this.firstSavedVideoTimestamp > 1 && (this.referenceVideoTimestamp = V,
                    this.referenceSystemTimestamp = t),
                    -1 === this.referenceVideoTimestamp)
                        return;
                    const l = (t - this.referenceSystemTimestamp) / 1e3
                      , d = V - this.referenceVideoTimestamp;
                    Math.abs(l - d) > this.config.settings.maxVideoTimeDiff + .5 && this.reloadVideo()
                }
                ,
                this.handleChromeVideoStalled = () => {
                    this.actionsPipe.next(qd.ChromeVideoStalled)
                }
                ,
                this.handleChromeVideoStalledAction = ({mediaTag: e}) => {
                    e.removeEventListener("stalled", this.handleChromeVideoStalled),
                    this.chromeStalledTimeout = this.config.scheduler.schedule(( () => {
                        this.actionsPipe.next(qd.StartMediaPlayback),
                        this.onPlayerPlaying()
                    }
                    ), 1e3)
                }
                ,
                this.initSuspendEventPatterns = ({mediaTag: e}) => {
                    this.suspendPatternAnalyzer.addPattern(["abort,emptied,loadstart,progress,suspend", "abort,emptied,ratechange,loadstart,progress,suspend", "abort,emptied,timeupdate,loadstart,suspend", "abort,emptied,loadstart,suspend"], ( () => {
                        e.removeEventListener("suspend", this.analyseSuspendPatterns),
                        this.reload()
                    }
                    ))
                }
                ,
                this.analyseSuspendPatterns = () => {
                    this.suspendPatternAnalyzer.checkPatterns(this.patternEvents)
                }
                ,
                this.subscribeToVideoActions(V),
                this.initCanPlayPatterns(),
                this.actionsPipe.next(qd.InitSuspendEventPatterns),
                we(this.config.videoTag).pipe(r(), _e((e => e.videoTracks)), al((e => gV(fV(e, "addtrack"), fV(e, "removetrack")).pipe(_e(( () => e)))))).subscribe((e => this.videoTrackList.next(e))).closeBy(this.lifeCycleScope),
                V.playbackRate.subscribe((e => this.config.videoTag.playbackRate = e)).closeBy(this.lifeCycleScope)
            }
            destroyMediaPlayer(e) {
                e.mediaTag.removeEventListener("stalled", this.handleChromeVideoStalled),
                e.mediaTag.removeEventListener("suspend", this.analyseSuspendPatterns),
                this.disableWallclock(),
                this.config.scheduler.deschedule([this.delayedReloadTimeout, this.chromeStalledTimeout, this.stallingTimeout, this.latencySchedulerId]),
                super.destroyMediaPlayer(e)
            }
            reloadVideo() {
                this.timeDiffCheckOn = !1,
                this.reload()
            }
            subscribeToVideoActions(e) {
                this.subscribeAction(e, qd.InitSuspendEventPatterns, this.initSuspendEventPatterns),
                this.subscribeAction(e, qd.ChromeVideoStalled, this.handleChromeVideoStalledAction),
                this.subscribeAction(e, qd.CheckVideoTimeDifference, this.checkVideoTimeDifference),
                this.subscribeAction(e, qd.FailPlayerWhenStalled, this.failPlayerWhenStalled),
                this.subscribeAction(e, qd.PauseEvent, this.pauseEvent),
                this.subscribeAction(e, qd.StartMediaPlayback, this.startMeasuringLatency),
                this.subscribeAction(e, qd.StopMediaPlayer, this.stopMeasuringLatency),
                this.subscribeAction(e, qd.StopMediaPlayer, this.disableWallclock.bind(this)),
                this.wireStats(this.lifeCycleScope, e)
            }
            dispatchWallclock(e) {
                this.lastWallclock = e,
                this.config.onStats({
                    wallclock: e
                })
            }
            initEventPatterns() {
                this.patternAnalyzer.addPattern("timeupdate,timeupdate", ( () => {
                    this.patternAnalyzeOn = !1,
                    this.onPlayerPlaying()
                }
                )).addPattern(["durationchange,play,playing,stalled", "canplaythrough,play,playing,timeupdate,stalled", "durationchange,loadedmetadata,stalled"], ( () => this.actionsPipe.next(qd.StartMediaPlayback))).addPattern(["canplaythrough,play,playing,stalled", "canplay,canplaythrough,play,playing,timeupdate,stalled"], ( () => {
                    this.onPlayerPlaying()
                }
                )).addPattern(["progress,progress,timeupdate,progress,stalled", "playing,durationchange,timeupdate,pause,stalled", "playing,durationchange,pause,stalled", "play,playing,timeupdate,durationchange,timeupdate,stalled"], ( () => this.onPlayerPlaying())).addPattern(["progress,progress"], ( () => {
                    this.actionsPipe.next(qd.ProgressEvent)
                }
                )).addPattern(["pause,ended,stalled,play,playing", "timeupdate,pause,ended,stalled", "stalled,timeupdate,pause,ended"], ( () => {
                    this.actionsPipe.next(qd.StartMediaPlayback),
                    this.onPlayerPlaying()
                }
                ))
            }
            playerPlaying(e) {
                super.playerPlaying(e),
                this.wallclockManager = new Cd(e.mediaTag,this.dispatchWallclock.bind(this)),
                this.wallclockTextTrack = this.wallclockManager.enableWallclock(this.wallclockTextTrack),
                this.stalledChromeRestartTimeout && this.config.scheduler.deschedule(this.stalledChromeRestartTimeout),
                this.patternAnalyzeOn = !0,
                e.mediaTag.addEventListener("suspend", this.analyseSuspendPatterns)
            }
            analyzeEvent(e) {
                switch (e) {
                case "timeupdate":
                    this.timeDiffCheckOn && this.actionsPipe.next(qd.CheckVideoTimeDifference),
                    this.actionsPipe.next(qd.PushBufferLength),
                    this.stallingStartTimestamp = performance.now();
                    break;
                case "pause":
                    this.actionsPipe.next(qd.PauseEvent);
                    break;
                case "canplay":
                    this.canPlayPatternAnalyzer.checkPatterns(this.patternEvents)
                }
                super.analyzeEvent(e)
            }
            loadMediaPlayer(e) {
                return super.loadMediaPlayer(e)
            }
            canPlayThroughEvent(e) {
                super.canPlayThroughEvent(e),
                this.stallingStartTimestamp = performance.now(),
                this.config.scheduler.deschedule(this.stallingTimeout),
                this.stallingTimeout = this.config.scheduler.schedule(( () => this.actionsPipe.next(qd.FailPlayerWhenStalled)), 1e3, {
                    repeat: !0
                })
            }
            subscribeObservables(e) {
                super.subscribeObservables(e),
                this.subscribeToStreamId(e)
            }
            disableWallclock() {
                var e;
                this.wallclockTextTrack = null === (e = this.wallclockManager) || void 0 === e ? void 0 : e.disableWallclock(this.wallclockTextTrack)
            }
            subscribeToStreamId(e) {
                e.streamId.pipe(r(), Ke(2, 1), Ce(( ([e,t]) => this.videoTrackList.pipe(ge((e => e.length > 0)), Le(1), _e((V => [V, e, t])))))).subscribe(( ([e,t,V]) => {
                    const l = e.getTrackById(V.toString());
                    l && (l.selected = !0);
                    const d = e.getTrackById(t.toString());
                    d && (d.selected = !1)
                }
                )).closeBy(this.lifeCycleScope)
            }
            initCanPlayPatterns() {
                this.canPlayPatternAnalyzer.addPattern("emptied,timeupdate,emptied,timeupdate,loadstart,suspend,durationchange,loadedmetadata,loadeddata", ( () => {
                    this.reloadVideo()
                }
                ))
            }
            wireStats(e, t) {
                const V = function(e, t=od(1e3)) {
                    return t.pipe(el(( () => {
                        const t = e.getEntriesByType("resource");
                        let V;
                        for (let e = t.length - 1; e >= 0; e--) {
                            const d = t[e]
                              , a = d.name.split("?")[0];
                            if ((l = d) && void 0 !== l.initiatorType && "video" === d.initiatorType && (a.endsWith(".ts") || a.endsWith(".mp4"))) {
                                V = d.name;
                                break
                            }
                        }
                        var l;
                        return e.clearResourceTimings(),
                        V
                    }
                    )), ot(( () => new mt(1))))
                }((l = window.performance) && "getEntriesByType"in l && "addEventListener"in l && "clearResourceTimings"in l ? window.performance : {
                    getEntriesByType: () => [],
                    addEventListener: () => {}
                    ,
                    clearResourceTimings: () => {}
                });
                var l;
                const d = ( () => {
                    const l = new mt(1);
                    return t.quality.pipe(Le(1)).subscribe((e => l.next(e))).closeBy(e),
                    V.pipe(Ie(t.streamId), el(( ([e,t]) => function(e, t, V) {
                        const l = e.match(/_t64(.+)_/);
                        if (l && l[1]) {
                            const [e] = atob(l[1]).split(".");
                            return e
                        }
                        const d = t.mediaManifests[V].streams.find((t => $d(t.url) === $d(e)));
                        if (d)
                            return d.quality
                    }(e, this.config.manifest, t))), r()).subscribe((e => l.next(e))).closeBy(e),
                    l
                }
                )();
                o([d, t.streamId], (e => e)).pipe(el(( ([e,t]) => {
                    var V, l;
                    const d = null === (l = null === (V = this.config.manifest.mediaManifests.find(( (e, V, l) => e.id === t || 1 === l.length))) || void 0 === V ? void 0 : V.streams.find((t => t.quality === e))) || void 0 === l ? void 0 : l.name;
                    return d ? [d, t] : void 0
                }
                )), _e(( ([e,t]) => {
                    let V = decodeURIComponent(e)
                      , l = "";
                    const d = V.lastIndexOf("_");
                    d > -1 && (l = V.slice(d, V.length),
                    V = V.slice(0, d));
                    const a = V.lastIndexOf("(");
                    return a > -1 && (V = V.slice(0, a),
                    V += t),
                    V + l
                }
                ))).subscribe((e => this.config.onStats({
                    streamName: `${e}`
                }))).closeBy(e),
                V.pipe(el(ea), Ie(t.streamId, ( (e, t) => t))).subscribe((e => {
                    this.config.onStats({
                        streamId: e
                    })
                }
                )).closeBy(e),
                d.subscribe((e => this.config.onStats({
                    currentQuality: e
                }))).closeBy(e),
                t.qualityMode.subscribe((e => this.config.onStats({
                    qualityMode: e
                }))).closeBy(e),
                t.url.pipe(r(), Ie(t.qualityMode)).subscribe(( ([,e]) => this.config.onStats({
                    qualityMode: e
                }))).closeBy(e),
                V.pipe(_e((e => {
                    const t = new URL(e);
                    return `${t.protocol}//${t.host}`
                }
                )), r(), Ce((e => Pe(function(e, t=window.fetch) {
                    const V = performance.now();
                    return t(function(e) {
                        return `https://${new URL(e).host}/clock`
                    }(e)).then((e => {
                        if (!e.ok)
                            return fd;
                        const t = performance.now()
                          , l = Math.round((t - V) / 2);
                        return {
                            deltaTime: t - Number(e.headers.get("x-clockms")),
                            halfRoundTripTime: l
                        }
                    }
                    )).catch((e => fd))
                }(e))))).subscribe(( ({deltaTime: e, halfRoundTripTime: t}) => {
                    this.firstLatency = t,
                    this.serverClientDeltaTime = e
                }
                )).closeBy(e)
            }
        }
        class Va extends Wd {
            destroy() {
                this.mediaPlayer && this.mediaPlayer.destroy(),
                this.mediaPlayer = void 0,
                super.destroy()
            }
            getMediaPlayer() {
                return (e, t) => function(e, t) {
                    const V = new s
                      , l = new F({
                        state: "IDLE"
                    })
                      , d = new i;
                    return [$V(V, l.pipe(_e((e => "PLAYING" === e.state))), e.settings.latency, (e => d.next(e))), hd(V), dl(V, l, k.Hls), ll(V, e.settings.buffer)].reduce(( (e, t) => t(e)), ( (e, t) => new ta(V,e,t,l,d)))(e, t)
                }(e, t)
            }
            shouldResolveUrls(e, t) {
                return e.quality !== t.quality && t.mode !== E.AUTO || e.mode !== t.mode
            }
            resolveMediaStreamUrl(e, t,table_id) {
                return this.config.manifestManager.fetch(e,table_id).then(( ([e,V]) => {
                    const l = e.mediaManifests.length > 1 ? t.streamId : 0;
                    return [e, e.mediaManifests[l], V]
                }
                )).then(( ([e,V,l]) => {
                    this.reportManifestStats(V, l);
                    const d = V.streams.flatMap((e => e.quality))
                      , a = Nd(t.quality, d);
                    if (null === a) {
                        const e = new Qe(j.NoQualitiesAvailable,"No qualities available");
                        throw this.config.onEvent({
                            eventType: e.type,
                            eventReason: e.message
                        }),
                        this.config.onStats({
                            availableQualities: []
                        }),
                        e
                    }
                    return this.config.onStats({
                        streamHost: new URL(V.streams[0].url).host,
                        masterHost: new URL(V.url).host
                    }),
                    [e, this.getHlsStreamByQuality(a, t.qualityMode, e.mediaManifests.length > 1, V)]
                }
                ))
            }
            getHlsStreamByQuality(e, t, V, l) {
                var d;
                if (t === E.AUTO)
                    return l.url;
                const a = l.streams[l.streams.length - 1].url
                  , U = V ? function(e, t) {
                    const V = e.slice(e.indexOf(",") + 1)
                      , l = atob(V).split("\n");
                    let d = `${l.shift()}\n${l.shift()}`
                      , a = 0;
                    for (; a < l.length; ) {
                        const e = l[a];
                        if (!(e.indexOf("EXT-X-MEDIA:TYPE=VIDEO") > -1 && e.indexOf(`GROUP-ID="${t}"`) > -1)) {
                            a += 1;
                            continue
                        }
                        const V = e.indexOf("DEFAULT=YES") > -1
                          , U = V ? l.slice(a, a + 3).join("\n") : e;
                        d = d.concat("\n", U),
                        a += V ? 3 : 1
                    }
                    return Kd(d)
                }(l.url, e) : null === (d = l.streams.find((t => t.quality === e))) || void 0 === d ? void 0 : d.url;
                return null != U ? U : a
            }
        }
        function la(e, t) {
            const V = Object.assign(Object.assign({}, e), {
                manifestManager: new vV(jd(Dd, Kd),(V => {
                    return l = this,
                    d = void 0,
                    U = function*() {
                        const l = yield KV()(V)
                          , d = yield cd(t.maxAutoQuality)
                          , a = yield cd(t.qualityMode)
                          , U = l.length - 1
                          , n = Object.values(m).filter((e => l[U].text.includes(`"${e}"`))).reverse()
                          , R = [...l];
                        return R[U] && d && a === E.AUTO && (R[U].text = function(e, t) {
                            const V = [];
                            if (void 0 !== t) {
                                const e = M[t];
                                for (const t in M)
                                    M.hasOwnProperty(t) && M[t] > e && V.push(t)
                            }
                            const l = e.split("\n");
                            let d = [];
                            if (-1 !== e.indexOf("#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID"))
                                d = l.filter((e => !V.some((t => e.includes(`GROUP-ID="${t}"`))))),
                                V.forEach((e => {
                                    for (let t = d.length - 1; t >= 0; t--)
                                        d[t].includes(`VIDEO="${e}"`) && d.splice(t, 2)
                                }
                                ));
                            else {
                                const e = IV(l.map(( (e, t) => V.some((t => e.includes(`NAME="${t}"`))) ? [t, t + 1] : [])), (e => e));
                                d = l.filter(( (t, V) => !e.includes(V)))
                            }
                            return d.join("\n")
                        }(l[U].text, d)),
                        e.onStats({
                            availableQualities: n
                        }),
                        R
                    }
                    ,
                    new ((a = void 0) || (a = Promise))((function(e, t) {
                        function V(e) {
                            try {
                                R(U.next(e))
                            } catch (V) {
                                t(V)
                            }
                        }
                        function n(e) {
                            try {
                                R(U.throw(e))
                            } catch (V) {
                                t(V)
                            }
                        }
                        function R(t) {
                            var l;
                            t.done ? e(t.value) : (l = t.value,
                            l instanceof a ? l : new a((function(e) {
                                e(l)
                            }
                            ))).then(V, n)
                        }
                        R((U = U.apply(l, d || [])).next())
                    }
                    ));
                    var l, d, a, U
                }
                ))
            });
            return new Va(V,t)
        }
        function da(e) {
            const t = e.createTexture();
            return t ? (e.bindTexture(e.TEXTURE_2D, t),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
            t) : new Error("Failed to create WebGl texture")
        }
        function aa(e, t) {
            const V = t.map(( ([t,V]) => function(e, t, V) {
                const l = e.createShader(V);
                if (!l)
                    return new Error("Failed to compile shader");
                if (e.shaderSource(l, t),
                e.compileShader(l),
                !e.getShaderParameter(l, e.COMPILE_STATUS)) {
                    const t = e.getShaderInfoLog(l);
                    return e.deleteShader(l),
                    new Error("WebGl could not compile shader" + t)
                }
                return l
            }(e, t, V)))
              , l = V.find((e => e instanceof Error));
            return l instanceof Error ? l : function(e, t) {
                const V = e.createProgram();
                if (!V)
                    return new Error("Failed to create WebGl program");
                for (const l of t)
                    e.attachShader(V, l);
                e.linkProgram(V),
                e.useProgram(V);
                for (const l of t)
                    e.detachShader(V, l),
                    e.deleteShader(l);
                return t.length = 0,
                e.getProgramParameter(V, e.LINK_STATUS) ? V : new Error("WebGl program fail to link " + e.getShaderInfoLog(V))
            }(e, V)
        }
        const Ua = "\n    attribute vec4 a_position;\n    attribute vec2 a_texCoord;\n    varying vec2 v_texCoord;\n    void main() {\n        gl_Position = a_position;\n        v_texCoord = a_texCoord;\n    }\n"
          , na = "\n    precision lowp float;\n    uniform sampler2D samplerY;\n    uniform sampler2D samplerU;\n    uniform sampler2D samplerV;\n    varying vec2 v_texCoord;\n    void main() {\n        float r,g,b,y,u,v,fYmul;\n        y = texture2D(samplerY, v_texCoord).r;\n        u = texture2D(samplerU, v_texCoord).r;\n        v = texture2D(samplerV, v_texCoord).r;\n        fYmul = y * 1.1643835616;\n        r = fYmul + 1.7927410714 * v - 0.96914450781;\n        g = fYmul - 0.2132486143 * u - 0.5329093286 * v + 0.300305;\n        b = fYmul + 2.1124017857 * u - 1.12897486719;\n        gl_FragColor = vec4(r, g, b, 1.0);\n    }\n";
        const Ra = "\n    precision lowp float;\n    uniform sampler2D samplerBGRA;\n    varying vec2 v_texCoord;\n    \n    void main() {\n        vec4 texColor = texture2D(samplerBGRA, v_texCoord);\n        gl_FragColor = vec4(texColor.b, texColor.g, texColor.r, texColor.a);\n    }\n";
        const Za = "\n    precision lowp float;\n    uniform sampler2D samplerBGRA;\n    varying vec2 v_texCoord;\n    \n    void main() {\n        vec4 texColor = texture2D(samplerBGRA, v_texCoord);\n        gl_FragColor = vec4(texColor.b, texColor.g, texColor.r, 1.0);\n    }\n";
        const Na = "\n    precision lowp float;\n    uniform sampler2D samplerY;\n    uniform sampler2D samplerUV;\n    varying vec2 v_texCoord;\n    void main() {\n        float r,g,b;\n        vec3 yuv;\n\n        vec3 yuv2r = vec3(1.164, 0.0, 1.596);\n        vec3 yuv2g = vec3(1.164, -0.391, -0.813);\n        vec3 yuv2b = vec3(1.164, 2.018, 0.0);\n\n        yuv.x = texture2D(samplerY, v_texCoord).r - 0.0625;\n        yuv.y = texture2D(samplerUV, v_texCoord).r - 0.5;\n        yuv.z = texture2D(samplerUV, v_texCoord).a - 0.5;\n\n        r = dot(yuv, yuv2r);\n        g = dot(yuv, yuv2g);\n        b = dot(yuv, yuv2b);\n\n        gl_FragColor = vec4(r, g, b, 1.0);\n    }\n";
        const ca = "\n    precision lowp float;\n    uniform sampler2D samplerRGBA;\n    varying vec2 v_texCoord;\n    \n    void main() {\n        vec4 texColor = texture2D(samplerRGBA, v_texCoord);\n        gl_FragColor = vec4(texColor.r, texColor.g, texColor.b, texColor.a);\n    }\n";
        const Ta = "\n    precision lowp float;\n    uniform sampler2D samplerRGBA;\n    varying vec2 v_texCoord;\n    \n    void main() {\n        vec4 texColor = texture2D(samplerRGBA, v_texCoord);\n        gl_FragColor = vec4(texColor.r, texColor.g, texColor.b, 1.0);\n    }\n";
        const Wa = "\n    attribute vec4 a_position;\n    attribute vec2 a_texCoord;\n    varying vec2 v_texCoord;\n    void main() {\n        gl_Position = a_position;\n        v_texCoord = a_texCoord;\n    }\n"
          , ia = "\n    precision mediump float;\n    uniform sampler2D u_image;\n    varying vec2 v_texCoord;\n    void main() {\n        gl_FragColor = texture2D(u_image, v_texCoord);\n    }\n";
        function Fa(e) {
            const t = e.getContext("webgl", {
                preserveDrawingBuffer: !0
            }) || e.getContext("experimental-webgl", {
                preserveDrawingBuffer: !0
            });
            if (!(t && t instanceof WebGLRenderingContext))
                return new Error("WebGL not supported");
            let V;
            return {
                draw: l => {
                    if (!V) {
                        const e = function(e, t) {
                            let V;
                            switch (t) {
                            case "RGBA":
                                V = function(e) {
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
                                    const t = aa(e, [[Ua, e.VERTEX_SHADER], [ca, e.FRAGMENT_SHADER]]);
                                    if (t instanceof Error)
                                        return t;
                                    const V = function(e, t) {
                                        const V = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, V),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW);
                                        const l = e.getAttribLocation(t, "a_position");
                                        if (-1 === l)
                                            return new Error("Webgl vertex attribute failed");
                                        e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(l);
                                        const d = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
                                          , a = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.bufferData(e.ARRAY_BUFFER, d, e.STATIC_DRAW);
                                        const U = e.getAttribLocation(t, "a_texCoord");
                                        if (-1 === U)
                                            return new Error("Webgl texture attribute failed");
                                        e.vertexAttribPointer(U, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(U),
                                        e.activeTexture(e.TEXTURE0);
                                        const n = da(e);
                                        return n ? (e.uniform1i(e.getUniformLocation(t, "samplerRGBA"), 0),
                                        e.activeTexture(e.TEXTURE1),
                                        [n]) : new Error("Failed to create WebGL texture")
                                    }(e, t);
                                    if (V instanceof Error)
                                        return V;
                                    const [l] = V;
                                    return e.clearColor(0, 0, 0, 0),
                                    e.clear(e.COLOR_BUFFER_BIT),
                                    e.useProgram(t),
                                    {
                                        render: t => {
                                            e.bindTexture(e.TEXTURE_2D, l),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.codedWidth, t.codedHeight, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(t.data)),
                                            e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
                                        }
                                    }
                                }(e);
                                break;
                            case "RGBX":
                                V = function(e) {
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
                                    const t = aa(e, [[Ua, e.VERTEX_SHADER], [Ta, e.FRAGMENT_SHADER]]);
                                    if (t instanceof Error)
                                        return t;
                                    const V = function(e, t) {
                                        const V = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, V),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW);
                                        const l = e.getAttribLocation(t, "a_position");
                                        if (-1 === l)
                                            return new Error("Webgl vertex attribute failed");
                                        e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(l);
                                        const d = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
                                          , a = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.bufferData(e.ARRAY_BUFFER, d, e.STATIC_DRAW);
                                        const U = e.getAttribLocation(t, "a_texCoord");
                                        if (-1 === U)
                                            return new Error("Webgl texture attribute failed");
                                        e.vertexAttribPointer(U, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(U),
                                        e.activeTexture(e.TEXTURE0);
                                        const n = da(e);
                                        return n ? (e.uniform1i(e.getUniformLocation(t, "samplerRGBA"), 0),
                                        e.activeTexture(e.TEXTURE1),
                                        [n]) : new Error("Failed to create WebGL texture")
                                    }(e, t);
                                    if (V instanceof Error)
                                        return V;
                                    const [l] = V;
                                    return e.clearColor(0, 0, 0, 0),
                                    e.clear(e.COLOR_BUFFER_BIT),
                                    e.useProgram(t),
                                    {
                                        render: t => {
                                            e.bindTexture(e.TEXTURE_2D, l),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.codedWidth, t.codedHeight, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(t.data)),
                                            e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
                                        }
                                    }
                                }(e);
                                break;
                            case "BGRA":
                                V = function(e) {
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
                                    const t = aa(e, [[Ua, e.VERTEX_SHADER], [Ra, e.FRAGMENT_SHADER]]);
                                    if (t instanceof Error)
                                        return t;
                                    const V = function(e, t) {
                                        const V = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, V),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW);
                                        const l = e.getAttribLocation(t, "a_position");
                                        if (-1 === l)
                                            return new Error("Webgl vertex attribute failed");
                                        e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(l);
                                        const d = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
                                          , a = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.bufferData(e.ARRAY_BUFFER, d, e.STATIC_DRAW);
                                        const U = e.getAttribLocation(t, "a_texCoord");
                                        if (-1 === U)
                                            return new Error("Webgl texture attribute failed");
                                        e.vertexAttribPointer(U, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(U),
                                        e.activeTexture(e.TEXTURE0);
                                        const n = da(e);
                                        return n ? (e.uniform1i(e.getUniformLocation(t, "samplerBGRA"), 0),
                                        e.activeTexture(e.TEXTURE1),
                                        [n]) : new Error("Failed to create WebGL texture")
                                    }(e, t);
                                    if (V instanceof Error)
                                        return V;
                                    const [l] = V;
                                    return e.clearColor(0, 0, 0, 0),
                                    e.clear(e.COLOR_BUFFER_BIT),
                                    e.useProgram(t),
                                    {
                                        render: t => {
                                            e.bindTexture(e.TEXTURE_2D, l),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.codedWidth, t.codedHeight, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(t.data)),
                                            e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
                                        }
                                    }
                                }(e);
                                break;
                            case "BGRX":
                                V = function(e) {
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
                                    const t = aa(e, [[Ua, e.VERTEX_SHADER], [Za, e.FRAGMENT_SHADER]]);
                                    if (t instanceof Error)
                                        return t;
                                    const V = function(e, t) {
                                        const V = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, V),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW);
                                        const l = e.getAttribLocation(t, "a_position");
                                        if (-1 === l)
                                            return new Error("Webgl vertex attribute failed");
                                        e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(l);
                                        const d = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
                                          , a = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.bufferData(e.ARRAY_BUFFER, d, e.STATIC_DRAW);
                                        const U = e.getAttribLocation(t, "a_texCoord");
                                        if (-1 === U)
                                            return new Error("Webgl texture attribute failed");
                                        e.vertexAttribPointer(U, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(U),
                                        e.activeTexture(e.TEXTURE0);
                                        const n = da(e);
                                        return n ? (e.uniform1i(e.getUniformLocation(t, "samplerBGRA"), 0),
                                        e.activeTexture(e.TEXTURE1),
                                        [n]) : new Error("Failed to create WebGL texture")
                                    }(e, t);
                                    if (V instanceof Error)
                                        return V;
                                    const [l] = V;
                                    return e.clearColor(0, 0, 0, 0),
                                    e.clear(e.COLOR_BUFFER_BIT),
                                    e.useProgram(t),
                                    {
                                        render: t => {
                                            e.bindTexture(e.TEXTURE_2D, l),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.codedWidth, t.codedHeight, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(t.data)),
                                            e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
                                        }
                                    }
                                }(e);
                                break;
                            case "NV12":
                                V = function(e) {
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
                                    const t = aa(e, [[Ua, e.VERTEX_SHADER], [Na, e.FRAGMENT_SHADER]]);
                                    if (t instanceof Error)
                                        return t;
                                    const V = function(e, t) {
                                        const V = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, V),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW);
                                        const l = e.getAttribLocation(t, "a_position");
                                        if (-1 === l)
                                            return new Error("Webgl vertex attribute failed");
                                        e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(l);
                                        const d = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
                                          , a = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.bufferData(e.ARRAY_BUFFER, d, e.STATIC_DRAW);
                                        const U = e.getAttribLocation(t, "a_texCoord");
                                        if (-1 === U)
                                            return new Error("Webgl texture attribute failed");
                                        e.vertexAttribPointer(U, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(U);
                                        const n = da(e);
                                        if (!n)
                                            return new Error("Failed to create WebGL texture for Y plane");
                                        e.uniform1i(e.getUniformLocation(t, "samplerY"), 0),
                                        e.activeTexture(e.TEXTURE1);
                                        const R = da(e);
                                        return R ? (e.uniform1i(e.getUniformLocation(t, "samplerUV"), 1),
                                        e.activeTexture(e.TEXTURE2),
                                        [n, R]) : new Error("Failed to create WebGL texture for UV plane")
                                    }(e, t);
                                    if (V instanceof Error)
                                        return V;
                                    const [l,d] = V;
                                    return e.clearColor(0, 0, 0, 0),
                                    e.clear(e.COLOR_BUFFER_BIT),
                                    e.useProgram(t),
                                    {
                                        render: t => {
                                            const V = t.codedWidth * t.codedHeight
                                              , a = V / 2
                                              , U = new Uint8Array(t.data.slice(0, V))
                                              , n = new Uint8Array(t.data.slice(V, V + a));
                                            e.activeTexture(e.TEXTURE0),
                                            e.bindTexture(e.TEXTURE_2D, l),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth, t.codedHeight, 0, e.LUMINANCE, e.UNSIGNED_BYTE, U),
                                            e.activeTexture(e.TEXTURE1),
                                            e.bindTexture(e.TEXTURE_2D, d),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE_ALPHA, t.codedWidth / 2, t.codedHeight / 2, 0, e.LUMINANCE_ALPHA, e.UNSIGNED_BYTE, n),
                                            e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
                                        }
                                    }
                                }(e);
                                break;
                            case "I420":
                            case "I420A":
                                V = function(e) {
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
                                    const t = aa(e, [[Ua, e.VERTEX_SHADER], [na, e.FRAGMENT_SHADER]]);
                                    if (t instanceof Error)
                                        return t;
                                    const V = function(e, t) {
                                        const V = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, V),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW);
                                        const l = e.getAttribLocation(t, "a_position");
                                        if (-1 === l)
                                            return new Error("Webgl vertex attribute failed");
                                        e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(l);
                                        const d = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
                                          , a = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.bufferData(e.ARRAY_BUFFER, d, e.STATIC_DRAW);
                                        const U = e.getAttribLocation(t, "a_texCoord");
                                        if (-1 === U)
                                            return new Error("Webgl texture attribute failed");
                                        e.vertexAttribPointer(U, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(U),
                                        e.activeTexture(e.TEXTURE0);
                                        const n = da(e);
                                        if (!n)
                                            return new Error("Failed to create WebGL texture for Y plane");
                                        e.uniform1i(e.getUniformLocation(t, "samplerY"), 0),
                                        e.activeTexture(e.TEXTURE1);
                                        const R = da(e);
                                        if (!R)
                                            return new Error("Failed to create WebGL texture for U plane");
                                        e.uniform1i(e.getUniformLocation(t, "samplerU"), 1),
                                        e.activeTexture(e.TEXTURE2);
                                        const Z = da(e);
                                        return Z ? (e.uniform1i(e.getUniformLocation(t, "samplerV"), 2),
                                        [n, R, Z]) : new Error("Failed to create WebGL texture for V plane")
                                    }(e, t);
                                    if (V instanceof Error)
                                        return V;
                                    const [l,d,a] = V;
                                    return e.clearColor(0, 0, 0, 0),
                                    e.clear(e.COLOR_BUFFER_BIT),
                                    e.useProgram(t),
                                    {
                                        render: t => {
                                            const V = t.codedWidth * t.codedHeight
                                              , U = V / 4
                                              , n = new Uint8Array(t.data.slice(0, V))
                                              , R = new Uint8Array(t.data.slice(V, V + U))
                                              , Z = new Uint8Array(t.data.slice(V + U, V + 2 * U));
                                            e.bindTexture(e.TEXTURE_2D, l),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth, t.codedHeight, 0, e.LUMINANCE, e.UNSIGNED_BYTE, n),
                                            e.bindTexture(e.TEXTURE_2D, d),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth >> 1, t.codedHeight >> 1, 0, e.LUMINANCE, e.UNSIGNED_BYTE, R),
                                            e.bindTexture(e.TEXTURE_2D, a),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth >> 1, t.codedHeight >> 1, 0, e.LUMINANCE, e.UNSIGNED_BYTE, Z),
                                            e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
                                        }
                                    }
                                }(e);
                                break;
                            case "I422":
                                V = function(e) {
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
                                    const t = aa(e, [[Ua, e.VERTEX_SHADER], [na, e.FRAGMENT_SHADER]]);
                                    if (t instanceof Error)
                                        return t;
                                    const V = function(e, t) {
                                        const V = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, V),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW);
                                        const l = e.getAttribLocation(t, "a_position");
                                        if (-1 === l)
                                            return new Error("Webgl vertex attribute failed");
                                        e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(l);
                                        const d = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
                                          , a = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.bufferData(e.ARRAY_BUFFER, d, e.STATIC_DRAW);
                                        const U = e.getAttribLocation(t, "a_texCoord");
                                        if (-1 === U)
                                            return new Error("Webgl texture attribute failed");
                                        e.vertexAttribPointer(U, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(U),
                                        e.activeTexture(e.TEXTURE0);
                                        const n = da(e);
                                        if (!n)
                                            return new Error("Failed to create WebGL texture for Y plane");
                                        e.uniform1i(e.getUniformLocation(t, "samplerY"), 0),
                                        e.activeTexture(e.TEXTURE1);
                                        const R = da(e);
                                        if (!R)
                                            return new Error("Failed to create WebGL texture for U plane");
                                        e.uniform1i(e.getUniformLocation(t, "samplerU"), 1),
                                        e.activeTexture(e.TEXTURE2);
                                        const Z = da(e);
                                        return Z ? (e.uniform1i(e.getUniformLocation(t, "samplerV"), 2),
                                        [n, R, Z]) : new Error("Failed to create WebGL texture for V plane")
                                    }(e, t);
                                    if (V instanceof Error)
                                        return V;
                                    const [l,d,a] = V;
                                    return e.clearColor(0, 0, 0, 0),
                                    e.clear(e.COLOR_BUFFER_BIT),
                                    e.useProgram(t),
                                    {
                                        render: t => {
                                            const V = t.codedWidth * t.codedHeight
                                              , U = V / 2
                                              , n = new Uint8Array(t.data.slice(0, V))
                                              , R = new Uint8Array(t.data.slice(V, V + U))
                                              , Z = new Uint8Array(t.data.slice(V + U, V + 2 * U));
                                            e.bindTexture(e.TEXTURE_2D, l),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth, t.codedHeight, 0, e.LUMINANCE, e.UNSIGNED_BYTE, n),
                                            e.bindTexture(e.TEXTURE_2D, d),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth >> 1, t.codedHeight, 0, e.LUMINANCE, e.UNSIGNED_BYTE, R),
                                            e.bindTexture(e.TEXTURE_2D, a),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth >> 1, t.codedHeight, 0, e.LUMINANCE, e.UNSIGNED_BYTE, Z),
                                            e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
                                        }
                                    }
                                }(e);
                                break;
                            case "I444":
                                V = function(e) {
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
                                    const t = aa(e, [[Ua, e.VERTEX_SHADER], [na, e.FRAGMENT_SHADER]]);
                                    if (t instanceof Error)
                                        return t;
                                    const V = function(e, t) {
                                        const V = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, V),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), e.STATIC_DRAW);
                                        const l = e.getAttribLocation(t, "a_position");
                                        if (-1 === l)
                                            return new Error("Webgl vertex attribute failed");
                                        e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(l);
                                        const d = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
                                          , a = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.bufferData(e.ARRAY_BUFFER, d, e.STATIC_DRAW);
                                        const U = e.getAttribLocation(t, "a_texCoord");
                                        if (-1 === U)
                                            return new Error("Webgl texture attribute failed");
                                        e.vertexAttribPointer(U, 2, e.FLOAT, !1, 0, 0),
                                        e.enableVertexAttribArray(U),
                                        e.activeTexture(e.TEXTURE0);
                                        const n = da(e);
                                        if (!n)
                                            return new Error("Failed to create WebGL texture for Y plane");
                                        e.uniform1i(e.getUniformLocation(t, "samplerY"), 0),
                                        e.activeTexture(e.TEXTURE1);
                                        const R = da(e);
                                        if (!R)
                                            return new Error("Failed to create WebGL texture for U plane");
                                        e.uniform1i(e.getUniformLocation(t, "samplerU"), 1),
                                        e.activeTexture(e.TEXTURE2);
                                        const Z = da(e);
                                        return Z ? (e.uniform1i(e.getUniformLocation(t, "samplerV"), 2),
                                        [n, R, Z]) : new Error("Failed to create WebGL texture for V plane")
                                    }(e, t);
                                    if (V instanceof Error)
                                        return V;
                                    const [l,d,a] = V;
                                    return e.clearColor(0, 0, 0, 0),
                                    e.clear(e.COLOR_BUFFER_BIT),
                                    e.useProgram(t),
                                    {
                                        render: t => {
                                            const V = t.codedWidth * t.codedHeight
                                              , U = new Uint8Array(t.data.slice(0, V))
                                              , n = new Uint8Array(t.data.slice(V, 2 * V))
                                              , R = new Uint8Array(t.data.slice(2 * V, 3 * V));
                                            e.bindTexture(e.TEXTURE_2D, l),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth, t.codedHeight, 0, e.LUMINANCE, e.UNSIGNED_BYTE, U),
                                            e.bindTexture(e.TEXTURE_2D, d),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth, t.codedHeight, 0, e.LUMINANCE, e.UNSIGNED_BYTE, n),
                                            e.bindTexture(e.TEXTURE_2D, a),
                                            e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, t.codedWidth, t.codedHeight, 0, e.LUMINANCE, e.UNSIGNED_BYTE, R),
                                            e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
                                        }
                                    }
                                }(e);
                                break;
                            default:
                                V = function(e) {
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
                                    const t = aa(e, [[Wa, e.VERTEX_SHADER], [ia, e.FRAGMENT_SHADER]]);
                                    if (t instanceof Error)
                                        return t;
                                    const V = function(e, t) {
                                        const V = da(e);
                                        if (!V)
                                            return new Error("Failed to create WebGl texture");
                                        const l = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, l),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([-1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1]), e.STATIC_DRAW);
                                        let d = e.getAttribLocation(t, "a_position");
                                        if (-1 === d)
                                            return new Error("Webgl vertex attribute failed");
                                        e.enableVertexAttribArray(d),
                                        e.bindBuffer(e.ARRAY_BUFFER, l),
                                        e.vertexAttribPointer(d, 2, e.FLOAT, !1, 0, 0);
                                        const a = e.createBuffer();
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e.STATIC_DRAW);
                                        let U = e.getAttribLocation(t, "a_texCoord");
                                        return -1 === U ? new Error("Webgl texture attribute failed") : (e.enableVertexAttribArray(U),
                                        e.bindBuffer(e.ARRAY_BUFFER, a),
                                        e.vertexAttribPointer(U, 2, e.FLOAT, !1, 0, 0),
                                        V)
                                    }(e, t);
                                    return V instanceof Error ? V : (e.clearColor(0, 0, 0, 0),
                                    e.clear(e.COLOR_BUFFER_BIT),
                                    e.useProgram(t),
                                    {
                                        render: t => {
                                            const V = new VideoFrame(t.data,{
                                                codedHeight: t.codedHeight,
                                                codedWidth: t.codedWidth,
                                                format: t.format,
                                                timestamp: t.timestamp || 0,
                                                layout: t.layout
                                            });
                                            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, V),
                                            e.drawArrays(e.TRIANGLES, 0, 6)
                                        }
                                    })
                                }(e)
                            }
                            return V
                        }(t, l.format);
                        if (e instanceof Error)
                            return e;
                        V = e
                    }
                    (e.width !== l.codedWidth || e.height !== l.codedHeight) && (e.height = l.codedHeight,
                    e.width = l.codedWidth,
                    t.viewport(0, 0, l.codedWidth, l.codedHeight));
                    try {
                        V.render(l)
                    } catch (d) {
                        return function(e) {
                            return e instanceof Error ? e : "string" == typeof e ? new Error(e) : new Error(JSON.stringify(e))
                        }(d)
                    }
                    return !0
                }
                ,
                destroy: () => {
                    t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT | t.STENCIL_BUFFER_BIT)
                }
            }
        }
        class ra extends Error {
            constructor(e, t) {
                super(t),
                this.type = e,
                this.name = "VideoDecoderError",
                Object.setPrototypeOf(this, ra.prototype)
            }
        }
        function sa(e) {
            let t, V;
            const l = [];
            function d(t) {
                try {
                    const V = {
                        x: 0,
                        y: 0,
                        width: t.codedWidth,
                        height: t.codedHeight
                    }
                      , d = t.allocationSize({
                        rect: V
                    })
                      , a = new ArrayBuffer(d);
                    t.copyTo(a, {
                        rect: V
                    }).then((d => {
                        var U;
                        const n = null !== (U = l.shift()) && void 0 !== U ? U : 0;
                        e({
                            pts: t.timestamp,
                            wallclock: n,
                            codedWidth: t.codedWidth,
                            codedHeight: t.codedHeight,
                            format: t.format,
                            visibleRect: V,
                            data: a,
                            layout: d
                        }),
                        t.close()
                    }
                    )).catch((V => {
                        t.close(),
                        e(V)
                    }
                    ))
                } catch (V) {
                    t.close(),
                    e(new ra("OUT_OF_MEMORY","Out of memory"))
                }
            }
            function a(e) {
                var V;
                const l = null !== (V = (0,
                Ul.findAtom)(e.data, ["trak"])) && void 0 !== V ? V : [];
                for (const d of l) {
                    const e = (0,
                    Ul.parseVideoMeta)(d);
                    e && (t = e)
                }
            }
            function U(d, a, U) {
                if (!V)
                    return;
                if (V.decodeQueueSize > 48)
                    return void e(new ra("PERFORMANCE_ERROR","Too many frames scheduled for decoding"));
                if (!t)
                    return;
                const n = function(e, t, V) {
                    var l, d, a;
                    const [U] = null !== (l = (0,
                    Ul.findAtom)(t.data, ["traf", "tfhd"])) && void 0 !== l ? l : [];
                    if (!U)
                        return;
                    if ((0,
                    Ul.toInt)(U.data.subarray(4, 8)) !== e.id)
                        return;
                    const [n] = null !== (d = (0,
                    Ul.findAtom)(t.data, ["traf", "tfdt"])) && void 0 !== d ? d : [];
                    if (!n)
                        return;
                    const [R] = null !== (a = (0,
                    Ul.findAtom)(t.data, ["traf", "trun"])) && void 0 !== a ? a : [];
                    if (!R)
                        return;
                    const Z = (0,
                    Ul.toInt)(n.data.subarray(0, 1))
                      , N = (0,
                    Ul.toInt)(n.data.subarray(4, 0 === Z ? 8 : 16))
                      , c = function(e) {
                        const t = 16777215 & (0,
                        Ul.toInt)(e.data.subarray(0, 4));
                        let V = 8;
                        return 1 & t && (V += 4),
                        !!(4 & t && 2 == (3 & (0,
                        Ul.toInt)(e.data.subarray(V, V + 1))))
                    }(R) ? "key" : "delta";
                    return new EncodedVideoChunk({
                        type: c,
                        timestamp: 1e3 * N / e.timeScale,
                        data: V.data
                    })
                }(t, d, a);
                if (!n)
                    return;
                const {wallclock: R} = (0,
                Ul.getEgwc)(U);
                l.push(R);
                try {
                    V.decode(n)
                } catch (d) {
                    if (d instanceof Error)
                        return void e(new ra("DECODE_ERROR",d.message));
                    e(new ra("DECODE_ERROR",`${d}`))
                }
            }
            return {
                push: function(l) {
                    const n = (0,
                    Ul.extractAtoms)(new Uint8Array(l));
                    let R = 0;
                    for (; R < n.length; ) {
                        const l = n[R];
                        "moov" !== l.name ? "moof" !== l.name ? R += 1 : (U(l, n[R + 1], n[n.length - 1]),
                        R += 2) : (a(l),
                        t && (V && "closed" !== V.state && V.close(),
                        V = new VideoDecoder({
                            output: d,
                            error: e
                        }),
                        V.configure({
                            codec: t.codec,
                            codedWidth: t.codedWidth,
                            codedHeight: t.codedHeight,
                            description: t.description
                        })),
                        R += 1)
                    }
                },
                close: function() {
                    V && "closed" !== V.state && (l.splice(0),
                    V.close()),
                    V = void 0,
                    t = void 0
                }
            }
        }
        function ha() {
            const e = []
              , t = [];
            function V() {
                return e.length < 2 ? 0 : e[e.length - 1].pts - e[0].pts
            }
            return {
                push: function(l) {
                    e.push(l);
                    const d = V();
                    for (const e of t)
                        e(d)
                },
                shift: function(l) {
                    const d = function(t) {
                        if (0 === e.length)
                            return [];
                        const V = []
                          , l = [];
                        for (let d = 0; d < e.length; d++)
                            t && e[d].pts > t || (V.push(e[d]),
                            l.push(d));
                        for (let d = l.length - 1; d >= 0; d--)
                            e.splice(d, 1);
                        return V.sort(( (e, t) => e.pts - t.pts))
                    }(l)
                      , a = V();
                    for (const e of t)
                        e(a);
                    return d
                },
                destroy: function() {
                    e.splice(0),
                    t.splice(0)
                },
                bufferLength: {
                    subscribe: function(e) {
                        t.push(e)
                    },
                    unsubscribe: function(e) {
                        const V = t.indexOf(e);
                        V > -1 && t.splice(V, 1)
                    }
                }
            }
        }
        function oa() {
            let e, t, V = !1;
            return {
                promise: new Promise(( (l, d) => {
                    e = e => {
                        V || (V = !0,
                        l(e))
                    }
                    ,
                    t = e => {
                        V || (V = !0,
                        d(e))
                    }
                }
                )),
                resolve: e,
                reject: t
            }
        }
        var ma = function(e) {
            return this instanceof ma ? (this.v = e,
            this) : new ma(e)
        };
        function Ma() {
            const e = [];
            return {
                notify: function(t) {
                    for (const V of e.slice())
                        V(t)
                },
                subscribe: function(t) {
                    e.push(t)
                },
                unsubscribe: function(t) {
                    const V = e.indexOf(t);
                    V > -1 && e.splice(V, 1)
                },
                dispose: function() {
                    e.splice(0)
                }
            }
        }
        function Sa(e, t={
            replay: !1
        }) {
            let V = e;
            const l = [];
            return {
                set: function(e) {
                    V = e;
                    for (const t of l.slice())
                        t(V)
                },
                get: function() {
                    return V
                },
                subscribe: function(e) {
                    l.push(e),
                    t.replay && e(V)
                },
                unsubscribe: function(e) {
                    const t = l.indexOf(e);
                    t > -1 && l.splice(t, 1)
                },
                dispose: function() {
                    l.splice(0)
                }
            }
        }
        function Ea(e=500) {
            const t = Sa(!1);
            let V = performance.now();
            return {
                tick: function(l) {
                    V = l ? performance.now() : V;
                    const d = performance.now() - V > e;
                    d !== t.get() && t.set(d)
                },
                subscribe: t.subscribe,
                unsubscribe: t.unsubscribe,
                dispose: t.dispose
            }
        }
        function pa() {
            const e = Ma();
            let t = 0;
            return Object.assign(Object.assign({}, e), {
                push: function(V) {
                    t += V,
                    e.notify(t)
                }
            })
        }
        function ba() {
            const e = Ma()
              , t = [];
            return Object.assign(Object.assign({}, e), {
                tick: function() {
                    const V = performance.now();
                    t.push(V);
                    const l = t[0];
                    if (l && V - l > 1e3) {
                        const V = t.filter((e => e - l < 1e3)).length;
                        t.splice(0, V),
                        e.notify(V)
                    }
                }
            })
        }
        function ka() {
            const e = Ma();
            let t, V, l;
            function d() {
                if (!V)
                    return;
                if (!l)
                    return;
                const t = Math.round(performance.now());
                e.notify(l.serverTime + (t - l.clientTime) - V)
            }
            return t = window.setInterval(d, 1e3),
            {
                setWallclock: function(e) {
                    V = e,
                    d()
                },
                setTimeSync: function(e) {
                    l = e,
                    d()
                },
                subscribe: e.subscribe,
                unsubscribe: e.unsubscribe,
                dispose: function() {
                    window.clearInterval(t),
                    e.dispose()
                }
            }
        }
        function Ya(e, t) {
            const V = "subscribe"in e ? e.subscribe : e.addListener.bind(e)
              , l = "unsubscribe"in e ? e.unsubscribe : e.removeListener.bind(e);
            return new Promise((e => {
                V((function V(d) {
                    const a = t(d);
                    "none" !== a.kind && (e(a.value),
                    l(V))
                }
                ))
            }
            ))
        }
        function Qa(e) {
            return {
                kind: "some",
                value: e
            }
        }
        var Ja = function(e, t, V, l) {
            return new (V || (V = Promise))((function(d, a) {
                function U(e) {
                    try {
                        R(l.next(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function n(e) {
                    try {
                        R(l.throw(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function R(e) {
                    var t;
                    e.done ? d(e.value) : (t = e.value,
                    t instanceof V ? t : new V((function(e) {
                        e(t)
                    }
                    ))).then(U, n)
                }
                R((l = l.apply(e, t || [])).next())
            }
            ))
        };
        function Ga(e) {
            const t = function() {
                const e = [];
                return {
                    defer: function(t) {
                        e.push(t)
                    },
                    dispose: function() {
                        for (var t; e.length > 0; )
                            try {
                                null === (t = e.pop()) || void 0 === t || t()
                            } catch (V) {
                                console.error(V)
                            }
                    }
                }
            }()
              , V = Sa({
                state: "IDLE",
                context: {
                    stream: e.stream,
                    configuration: {
                        transport: e.transport,
                        audioDecoder: e.audioDecoder,
                        audioPlayer: t => {
                            var V, l, d;
                            return (0,
                            nl.createAudioPlayer)(e.audioContext, null !== (V = e.initBufferLength) && void 0 !== V ? V : 1e3, t.sampleRate, t.numberOfChannels, null !== (l = e.volume) && void 0 !== l ? l : 1, null === (d = e.muted) || void 0 === d || d, 1)
                        }
                        ,
                        videoDecoder: sa,
                        videoRenderer: () => Fa(e.canvas)
                    }
                }
            })
              , l = {
                streamName: Sa(e.stream.name, {
                    replay: !0
                }),
                latency: ka(),
                wallclock: Ma(),
                bufferLength: Ma(),
                bitrate: Ma(),
                fps: ba(),
                droppedFrames: pa(),
                bandwidth: Ma(),
                isBuffering: Ea()
            };
            function d(d) {
                return Ja(this, void 0, void 0, (function*() {
                    const U = yield function(e) {
                        return Ja(this, void 0, void 0, (function*() {
                            const V = yield e.configuration.transport(e.stream.url, a);
                            return t.defer(V.dispose),
                            V.stats.bandwidth.subscribe(l.bandwidth.notify),
                            V.stats.bitrate.subscribe(l.bitrate.notify),
                            V
                        }
                        ))
                    }(d);
                    U.stats.serverTime.subscribe(l.latency.setTimeSync);
                    const {audioBuffer: n, audioDecoder: R} = function(e, V) {
                        const l = ha();
                        t.defer(l.destroy);
                        const d = e((e => {
                            e instanceof Error ? a(e) : l.push(e)
                        }
                        ));
                        return t.defer(d.close),
                        V.binaries.subscribe((e => {
                            try {
                                d.push(e.buffer)
                            } catch (t) {
                                a(t)
                            }
                        }
                        )),
                        {
                            audioBuffer: l,
                            audioDecoder: d
                        }
                    }(d.configuration.audioDecoder, U)
                      , {videoBuffer: Z, videoDecoder: N} = function(e, V) {
                        const d = ha();
                        t.defer(d.destroy),
                        d.bufferLength.subscribe(l.bufferLength.notify);
                        const U = e((e => {
                            e instanceof Error ? a(e) : d.push(e)
                        }
                        ));
                        return t.defer(U.close),
                        V.binaries.subscribe((e => {
                            try {
                                U.push(e.buffer)
                            } catch (t) {
                                a(t)
                            }
                        }
                        )),
                        {
                            videoBuffer: d,
                            videoDecoder: U
                        }
                    }(d.configuration.videoDecoder, U)
                      , c = function() {
                        const e = new Zl;
                        return t.defer(( () => e.destroy())),
                        e
                    }();
                    U.binaries.subscribe(( () => c.update()));
                    const T = yield function(V, l, d, a, U) {
                        return Ja(this, void 0, void 0, (function*() {
                            const n = Ya(l.binaries, (e => {
                                const t = (0,
                                Ul.findAtom)(new Uint8Array(e.buffer), ["moov", "trak"]);
                                if (!t)
                                    return {
                                        kind: "none"
                                    };
                                for (const V of t) {
                                    const e = (0,
                                    Ul.parseAudioMeta)(V);
                                    if (e)
                                        return Qa(e)
                                }
                                return {
                                    kind: "none"
                                }
                            }
                            ))
                              , [,R] = yield Promise.all([l.play({
                                name: V,
                                url: e.stream.url
                            }), n])
                              , Z = U(R);
                            return t.defer(Z.destroy),
                            Z.pts.subscribe((e => e && d.setPts(e))),
                            d.addListener(( () => {
                                const e = a.shift();
                                for (const t of e)
                                    Z.pushFrame(t)
                            }
                            )),
                            Z
                        }
                        ))
                    }(d.stream.name, U, c, n, d.configuration.audioPlayer)
                      , W = d.configuration.videoRenderer();
                    if (W instanceof Error)
                        throw W;
                    t.defer(W.destroy);
                    const i = function(e, t) {
                        let V = e;
                        const l = function() {
                            return function(e, t, V) {
                                if (!Symbol.asyncIterator)
                                    throw new TypeError("Symbol.asyncIterator is not defined.");
                                var l, d = V.apply(e, t || []), a = [];
                                return l = Object.create(("function" == typeof AsyncIterator ? AsyncIterator : Object).prototype),
                                U("next"),
                                U("throw"),
                                U("return", (function(e) {
                                    return function(t) {
                                        return Promise.resolve(t).then(e, Z)
                                    }
                                }
                                )),
                                l[Symbol.asyncIterator] = function() {
                                    return this
                                }
                                ,
                                l;
                                function U(e, t) {
                                    d[e] && (l[e] = function(t) {
                                        return new Promise((function(V, l) {
                                            a.push([e, t, V, l]) > 1 || n(e, t)
                                        }
                                        ))
                                    }
                                    ,
                                    t && (l[e] = t(l[e])))
                                }
                                function n(e, t) {
                                    try {
                                        !function(e) {
                                            e.value instanceof ma ? Promise.resolve(e.value.v).then(R, Z) : N(a[0][2], e)
                                        }(d[e](t))
                                    } catch (V) {
                                        N(a[0][3], V)
                                    }
                                }
                                function R(e) {
                                    n("next", e)
                                }
                                function Z(e) {
                                    n("throw", e)
                                }
                                function N(e, t) {
                                    e(t),
                                    a.shift(),
                                    a.length && n(a[0][0], a[0][1])
                                }
                            }(this, arguments, (function*() {
                                for (; ; ) {
                                    const [l,d] = yield yield ma(void 0);
                                    if (V.name !== l.name)
                                        try {
                                            yield ma(t.switchStream(l)),
                                            d.resolve(),
                                            V = l
                                        } catch (e) {
                                            d.reject(e)
                                        }
                                }
                            }
                            ))
                        }();
                        return l.next().catch(console.error),
                        {
                            change: function(e) {
                                return t = this,
                                V = void 0,
                                a = function*() {
                                    const t = oa();
                                    return l.next([e, t]).catch(console.error),
                                    t.promise
                                }
                                ,
                                new ((d = void 0) || (d = Promise))((function(e, l) {
                                    function U(e) {
                                        try {
                                            R(a.next(e))
                                        } catch (t) {
                                            l(t)
                                        }
                                    }
                                    function n(e) {
                                        try {
                                            R(a.throw(e))
                                        } catch (t) {
                                            l(t)
                                        }
                                    }
                                    function R(t) {
                                        var V;
                                        t.done ? e(t.value) : (V = t.value,
                                        V instanceof d ? V : new d((function(e) {
                                            e(V)
                                        }
                                        ))).then(U, n)
                                    }
                                    R((a = a.apply(t, V || [])).next())
                                }
                                ));
                                var t, V, d, a
                            },
                            dispose: function() {
                                l.return().catch(console.error)
                            }
                        }
                    }(d.stream, U);
                    t.defer(i.dispose);
                    const F = Ma()
                      , r = Ya(F, (e => e.length > 0 ? Qa(void 0) : {
                        kind: "none"
                    }));
                    F.subscribe(( ([e,...t]) => {
                        if (e) {
                            const t = W.draw(e);
                            if (t instanceof Error)
                                return void a(t);
                            l.wallclock.notify(e.pts),
                            l.fps.tick(),
                            l.latency.setWallclock(e.pts)
                        }
                        l.droppedFrames.push(t.length),
                        l.isBuffering.tick(void 0 !== e)
                    }
                    )),
                    c.addListener((e => {
                        if (!e)
                            return;
                        const t = Z.shift(e);
                        F.notify(t)
                    }
                    )),
                    yield r,
                    V.set({
                        state: "PLAYING",
                        context: {
                            transport: U,
                            syncer: c,
                            audioBuffer: n,
                            audioDecoder: R,
                            audioPlayer: T,
                            videoBuffer: Z,
                            videoDecoder: N,
                            videoRenderer: W,
                            switcher: i
                        }
                    })
                }
                ))
            }
            function a(e) {
                if ("DESTROYED" !== V.get().state) {
                    V.set({
                        state: "DESTROYED",
                        error: e
                    });
                    for (const e of [...Object.values(l), t, V])
                        e.dispose()
                }
            }
            return {
                state: V,
                play: function() {
                    return Ja(this, void 0, void 0, (function*() {
                        const e = V.get();
                        if ("IDLE" !== e.state)
                            return;
                        const l = e.context
                          , U = oa();
                        return t.defer(( () => {
                            const e = V.get()
                              , t = "DESTROYED" === e.state && e.error ? e.error : new Error("Play is cancelled");
                            U.reject(t)
                        }
                        )),
                        d(l).then(U.resolve).catch((e => {
                            U.reject(e),
                            a(e)
                        }
                        )),
                        U.promise
                    }
                    ))
                },
                dispose: a,
                switchStream: function(e) {
                    const t = V.get();
                    if ("PLAYING" !== t.state)
                        return;
                    const {switcher: d, videoBuffer: a, syncer: U} = t.context;
                    d.change(e).then(( () => Ja(this, void 0, void 0, (function*() {
                        const t = yield Promise.all([(V = a.bufferLength,
                        new Promise((e => {
                            V.subscribe((function t(l) {
                                e(l),
                                V.unsubscribe(t)
                            }
                            ))
                        }
                        ))), Ya(U, (e => e ? Qa(e) : {
                            kind: "none"
                        }))]).then(( ([e,t]) => e + t)).catch(console.error);
                        var V;
                        if (t) {
                            for (; (yield Ya(U, (e => e ? Qa(e) : {
                                kind: "none"
                            }))) < t; )
                                ;
                            l.streamName.set(e.name)
                        }
                    }
                    ))))
                },
                setVolume: function(e) {
                    const t = V.get();
                    "PLAYING" === t.state && t.context.audioPlayer.volume.set(e)
                },
                mute: function(e) {
                    const t = V.get();
                    "PLAYING" === t.state && t.context.audioPlayer.mute.set(e)
                },
                setPlaybackRate: function(e) {
                    const t = V.get();
                    "PLAYING" === t.state && t.context.audioPlayer.playbackRate.set(e)
                },
                stats: l
            }
        }
        class za {
            constructor(e, t, V, l=new F({
                state: "IDLE"
            }), d=new i) {
                this.lifeCycleScope = e,
                this.config = t,
                this.state = l,
                this.transition = d,
                this.handleTransportWarnings = e => {
                    this.config.onPlaybackEvent({
                        eventType: J.WARNING,
                        eventReason: e.message
                    })
                }
                ,
                ct(this.config.canvas);
                const a = o([V.streamId, V.quality], (e => e)).pipe(el(( ([e,t]) => {
                    var V, l;
                    const {mediaManifests: d} = this.config.manifest
                      , a = (null !== (V = d.find((t => t.id === e))) && void 0 !== V ? V : d[0]).streams;
                    return null !== (l = a.find((e => e.quality === t))) && void 0 !== l ? l : a[a.length - 1]
                }
                )), ot(( () => new mt(1))));
                this.handleStateTransitions(V),
                this.triggerPlay(a, V),
                this.handleStreamChange(a),
                this.handlePlaybackRateChange(V.playbackRate),
                this.handleMuted(V),
                this.handleVolumeChange(V.volume)
            }
            destroy() {
                this.transition.next({
                    action: "DESTROY"
                }),
                this.lifeCycleScope.close(),
                Tt(this.config.canvas)
            }
            handleStateTransitions(e) {
                this.transition.pipe(Ce((t => {
                    let V = we(void 0);
                    switch (t.action) {
                    case "INIT":
                        V = this.processInit(t.config);
                        break;
                    case "PLAY":
                        V = this.processPlay(e);
                        break;
                    case "DESTROY":
                        V = this.processDestroy(t.error)
                    }
                    return V.pipe((l = e => (this.transition.next({
                        action: "DESTROY",
                        error: this.toEvoError(e)
                    }),
                    we(void 0)),
                    e => new W((t => {
                        let V, d, a = !1;
                        return V = e.subscribe((e => t.onNext(e)), (e => {
                            a = !0,
                            d = l(e).subscribe((e => t.onNext(e)), (e => t.onError(e)), ( () => t.onComplete()))
                        }
                        ), ( () => {
                            a || t.onComplete()
                        }
                        )),
                        T(( () => {
                            null == V || V.close(),
                            null == d || d.close()
                        }
                        ))
                    }
                    ))));
                    var l
                }
                ))).subscribe().closeBy(this.lifeCycleScope)
            }
            processInit(e) {
                return this.state.pipe(Le(1), _e((t => {
                    if ("IDLE" !== t.state)
                        return;
                    this.state.next({
                        state: "LOADING"
                    });
                    const V = new s;
                    T(( () => V.close())).closeBy(this.lifeCycleScope);
                    const l = Ga(e);
                    this.state.next({
                        state: "READY",
                        player: l,
                        scope: V
                    })
                }
                )))
            }
            processPlay(e) {
                return this.state.pipe(Le(1), Ce((t => {
                    if ("READY" !== t.state)
                        return we(void 0);
                    const {scope: V, player: l} = t;
                    return Pe(l.play().then(( () => {
                        this.wireStats(V, l, e),
                        l.state.subscribe((e => {
                            "DESTROYED" === e.state && this.transition.next({
                                action: "DESTROY",
                                error: this.toEvoError(e.error)
                            })
                        }
                        )),
                        l.state.subscribe((e => {
                            "PLAYING" === e.state && this.config.onPlaybackEvent({
                                eventType: J.PLAYING,
                                eventReason: J.PLAYING
                            })
                        }
                        )),
                        l.stats.isBuffering.subscribe((e => {
                            this.config.onPlaybackEvent({
                                eventType: e ? J.WAITING : J.PLAYING,
                                eventReason: e ? J.WAITING : J.PLAYING
                            })
                        }
                        ))
                    }
                    )).then(( () => this.state.next(Object.assign(Object.assign({}, t), {
                        state: "PLAYING"
                    })))))
                }
                )))
            }
            processDestroy(e) {
                return this.state.pipe(Le(1), _e((t => {
                    "READY" !== t.state && "PLAYING" !== t.state || (this.state.next({
                        state: "STOPPING",
                        error: e
                    }),
                    t.player.dispose(),
                    t.scope.close(),
                    this.state.next({
                        state: "IDLE"
                    }))
                }
                )))
            }
            triggerPlay(e, t) {
                e.pipe(Ie(t.muted, t.volume), Le(1), _e(( ([e,t,V]) => ({
                    action: "INIT",
                    config: {
                        canvas: this.config.canvas,
                        audioContext: this.config.audioContext,
                        transport: (e, t) => bl(e, t, {
                            implementation: El,
                            plugins: [ol(this.handleTransportWarnings)]
                        }),
                        audioDecoder: nd(this.config.settings.audioCodec, this.config.browserFeatures, this.config.audioContext),
                        stream: e,
                        initBufferLength: this.config.settings.buffer.init,
                        volume: V,
                        muted: t
                    }
                })))).pipe(Ie(this.state), _e(( ([e,t]) => {
                    const V = [];
                    return "READY" !== t.state && "PLAYING" !== t.state || V.push({
                        action: "DESTROY"
                    }),
                    V.push(e),
                    V.push({
                        action: "PLAY"
                    }),
                    V
                }
                )), al((e => xd(e)))).subscribe((e => this.transition.next(e))).closeBy(this.lifeCycleScope)
            }
            handleStreamChange(e) {
                e.pipe(xa(this.state)).subscribe(( ([e,t]) => t.switchStream(e))).closeBy(this.lifeCycleScope)
            }
            handlePlaybackRateChange(e) {
                e.pipe(xa(this.state)).subscribe(( ([e,t]) => t.setPlaybackRate(e))).closeBy(this.lifeCycleScope)
            }
            handleMuted(e) {
                o([e.muted, e.volume], ( ([e,t]) => e || 0 === t)).pipe(xa(this.state)).subscribe(( ([e,t]) => t.mute(e))).closeBy(this.lifeCycleScope)
            }
            handleVolumeChange(e) {
                e.pipe(xa(this.state)).subscribe(( ([e,t]) => t.setVolume(e))).closeBy(this.lifeCycleScope)
            }
            toEvoError(e) {
                if (!e)
                    return;
                let t = H.MediaError;
                return e instanceof ra && (t = "PERFORMANCE_ERROR" === e.type ? H.PerformanceError : H.DecodeError),
                "NotAllowedError" === e.name && (t = H.PermissionError),
                "NotSupportedError" === e.name && (t = D.NotSupported),
                "EncodingError" === e.name && (Object.defineProperty(e, "code", {
                    value: 3
                }),
                t = H.DecodeError),
                e instanceof Nl && ("STREAM_SHUTDOWN" === e.type && (t = H.StreamShutdown),
                "NETWORK_ERROR" === e.type && (t = H.NetworkError),
                "STREAM_SECURITY_ERROR" === e.type && (t = B.StreamSecurityError)),
                new Qe(t,e.message)
            }
            wireStats(e, t, V) {
                t.stats.latency.subscribe((e => this.config.onStats({
                    latency: e
                }))),
                t.stats.wallclock.subscribe((e => this.config.onStats({
                    wallclock: e
                }))),
                t.stats.bufferLength.subscribe((e => this.config.onStats({
                    bufferLength: e
                }))),
                t.stats.bitrate.subscribe((e => this.config.onStats({
                    playbackBitrate: e
                }))),
                t.stats.droppedFrames.subscribe((e => this.config.onStats({
                    droppedFrames: e
                }))),
                t.stats.fps.subscribe((e => this.config.onStats({
                    fps: e
                }))),
                t.stats.bandwidth.subscribe((e => this.config.onStats({
                    bandwidth: e
                })));
                const l = this.config.manifest.mediaManifests.flatMap((e => e.streams));
                var d;
                (d = t.stats.streamName,
                new W((e => {
                    function t(t) {
                        e.onNext(t)
                    }
                    return d.subscribe(t),
                    T(( () => d.unsubscribe(t)))
                }
                ))).pipe(el((e => l.find((t => t.name === e)))), Ie(V.streamId)).subscribe(( ([e,t]) => this.config.onStats({
                    currentQuality: e.quality,
                    streamName: e.name,
                    streamHost: new URL(e.url).host,
                    streamId: t
                }))).closeBy(e),
                V.qualityMode.subscribe((e => this.config.onStats({
                    qualityMode: e
                }))).closeBy(e)
            }
        }
        function xa(e) {
            return t => t.pipe(Ce((t => e.pipe(el((e => "READY" === e.state || "PLAYING" === e.state ? e.player : void 0)), Le(1), _e((e => [t, e]))))))
        }
        function ua(e, t) {
            const V = new s
              , l = new F({
                state: "IDLE"
            })
              , d = new i
              , a = l.pipe(_e((e => "PLAYING" === e.state)))
              , U = l.pipe(ge((e => {
                var t;
                return "STOPPING" === e.state && (null === (t = e.error) || void 0 === t ? void 0 : t.type) === H.MaxLatencyReached
            }
            )), _e(( () => {}
            )))
              , n = new F([])
              , R = [$V(V, a, e.settings.latency, (e => d.next({
                action: "DESTROY",
                error: e
            }))), hd(V, n), dl(V, l, k.Fmp4), ll(V, e.settings.buffer), Sd(V, 1e4), Jd(V, a, ( (t, V, l) => {
                const d = []
                  , a = V.pipe(el((e => e.bandwidth)), r())
                  , n = V.pipe(el((e => e.bufferLength)), r());
                if (e.settings.adaptive.bitrateRule.enable) {
                    const l = V.pipe(el((e => e.playbackBitrate)), r());
                    d.push(kd(a, l, t, e.settings.adaptive.bitrateRule.fadeCoefficient, e.settings.adaptive.bitrateRule.switchCoefficient))
                }
                const R = o([V.pipe(el((e => e.currentQuality))), l], (e => e)).pipe(_e(( ([e,t]) => {
                    const V = t.findIndex(( ([,t]) => t === e));
                    if (V + 1 >= t.length)
                        return Number.MAX_VALUE;
                    const [l] = t[V + 1];
                    return 1.15 * l
                }
                )));
                return gV(...d, bd(n, 400, t), Gd(t, U), Yd(a, R, t))
            }
            ), [Ed], n), zd(V), qV(V, e.videoTag)].reduce(( (e, t) => t(e)), ( (e, t) => new za(V,e,t,l,d)))
              , Z = ( () => {
                const e = new mt(1);
                return t.quality.subscribe((t => e.next(t))).closeBy(V),
                e
            }
            )();
            return R(e, Object.assign(Object.assign({}, t), {
                quality: Z
            }))
        }
        function Xa(e, t) {
            const V = Object.assign(Object.assign({}, e), {
                manifestManager: new vV(LV,KV()),
                mediaPlayerFactory: ua
            });
            return new id(V,t)
        }
        function ya(e) {
            return t = this,
            V = void 0,
            d = function*() {
                return "running" === e.state
            }
            ,
            new ((l = void 0) || (l = Promise))((function(e, a) {
                function U(e) {
                    try {
                        R(d.next(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function n(e) {
                    try {
                        R(d.throw(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function R(t) {
                    var V;
                    t.done ? e(t.value) : (V = t.value,
                    V instanceof l ? V : new l((function(e) {
                        e(V)
                    }
                    ))).then(U, n)
                }
                R((d = d.apply(t, V || [])).next())
            }
            ));
            var t, V, l, d
        }
        function Ba(e) {
            return t = this,
            V = void 0,
            d = function*() {
                const t = e.muted;
                let V;
                e.muted = !1,
                e.src = "data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAC721kYXQhEAUgpBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcCEQBSCkG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAsJtb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAALwABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAB7HRyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAIAAAAAAAAALwAAAAAAAAAAAAAAAQEAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAAC8AAAAAAAEAAAAAAWRtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAAKxEAAAIAFXEAAAAAAAtaGRscgAAAAAAAAAAc291bgAAAAAAAAAAAAAAAFNvdW5kSGFuZGxlcgAAAAEPbWluZgAAABBzbWhkAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAADTc3RibAAAAGdzdHNkAAAAAAAAAAEAAABXbXA0YQAAAAAAAAABAAAAAAAAAAAAAgAQAAAAAKxEAAAAAAAzZXNkcwAAAAADgICAIgACAASAgIAUQBUAAAAAAfQAAAHz+QWAgIACEhAGgICAAQIAAAAYc3R0cwAAAAAAAAABAAAAAgAABAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAIAAAABAAAAHHN0c3oAAAAAAAAAAAAAAAIAAAFzAAABdAAAABRzdGNvAAAAAAAAAAEAAAAsAAAAYnVkdGEAAABabWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcmFwcGwAAAAAAAAAAAAAAAAtaWxzdAAAACWpdG9vAAAAHWRhdGEAAAABAAAAAExhdmY1Ni40MC4xMDE=";
                try {
                    yield e.play(),
                    V = !0
                } catch (l) {
                    V = !1
                }
                return e.pause(),
                e.removeAttribute("src"),
                e.load(),
                e.muted = t,
                V
            }
            ,
            new ((l = void 0) || (l = Promise))((function(e, a) {
                function U(e) {
                    try {
                        R(d.next(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function n(e) {
                    try {
                        R(d.throw(e))
                    } catch (t) {
                        a(t)
                    }
                }
                function R(t) {
                    var V;
                    t.done ? e(t.value) : (V = t.value,
                    V instanceof l ? V : new l((function(e) {
                        e(V)
                    }
                    ))).then(U, n)
                }
                R((d = d.apply(t, V || [])).next())
            }
            ));
            var t, V, l, d
        }
        const Ha = (e, t) => wV(e, t, [{
            name: k.WebCodec,
            factory: Xa,
            initialSoundCheck: (e, t) => ya(t)
        }, {
            name: k.Fmp4,
            factory: Hd,
            initialSoundCheck: (e, t) => Ba(e)
        }, {
            name: k.Hls,
            factory: la,
            initialSoundCheck: (e, t) => Ba(e)
        }, {
            name: k.Flipbook,
            factory: Fd,
            initialSoundCheck: (e, t) => ya(t)
        }])
    }
    )(),
    l
}
)()));
//# sourceMappingURL=https://sourcemaps.egcdn.com/frontend/cvi/evo-video-components/13.20241220.112403-eebbbae7.video_wf4hfb_v13.js.map
