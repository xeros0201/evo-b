"use strict";(()=>{const x=2,W="evo-cache-v",M=`${W}${x}`,c="assets-cache-prefix-",z="remote-cache-prefix-",N={json:"application/json",png:"image/png",jpg:"image/jpg",jpeg:"image/jpeg",webp:"image/webp",avif:"image/avif",svg:"image/svg+xml",fnt:"application/xml"},t=(new RegExp(`("|')\\S+\\.(${["png","jpg","jpeg","webp","avif","svg"].join("|")})("|')`,"gm"),4),X="assetsCache",o="remote:";function R(x){return x.endsWith(".atlas")}class I{constructor(){this.assetServerUrl=null,this.db=void 0}async init(x,W){return this.assetServerUrl=this.assetServerUrl||W,this.db?this.db:new Promise(((W,M)=>{const c=x.open(X,t);c.onerror=x=>M(x.target.error),c.onsuccess=async x=>{this.db=x.target.result,W(this.db)},c.onupgradeneeded=x=>{const W=x.target.result;W&&this.getIndexeddbConfig().stores.forEach((x=>{try{W.createObjectStore(x.name,{keyPath:x.keyPath}).createIndex(x.keyPath,x.keyPath,{unique:!0})}catch(x){}}))}}))}async saveLocalFiles(x){await this.saveFiles(x,this.getIndexeddbConfig().localFilesTable)}async saveRemoteFiles(x){await this.saveFiles(x,this.getIndexeddbConfig().remoteFilesTable)}async saveLocalConfig(x){await this.saveConfig(x,this.getIndexeddbConfig().localConfigsTable)}async saveRemoteConfig(x){await this.saveConfig(x,this.getIndexeddbConfig().remoteConfigsTable)}async clearLocalFilesAndConfigs(){await Promise.all([this.clearLocalConfigs(),this.clearLocalFiles()])}async clearRemoteFilesAndConfigs(){await Promise.all([this.clearRemoteConfigs(),this.clearRemoteFiles()])}async clearLocalConfigs(){return await this.clearStore(this.getIndexeddbConfig().localConfigsTable)}async clearLocalFiles(){return await this.clearStore(this.getIndexeddbConfig().localFilesTable)}async clearRemoteConfigs(){return await this.clearStore(this.getIndexeddbConfig().remoteConfigsTable)}async clearRemoteFiles(){return await this.clearStore(this.getIndexeddbConfig().remoteFilesTable)}async getAllConfigsRecords(){return{...await this.getLocalConfigsRecords(),...await this.getRemoteConfigsRecords()}}async getLocalConfigsRecords(){return this.getConfigsRecords(this.getIndexeddbConfig().localConfigsTable)}async getRemoteConfigsRecords(){return this.getConfigsRecords(this.getIndexeddbConfig().remoteConfigsTable)}async getAllFilesRecords(){return{...await this.getLocalFilesRecords(),...await this.getRemoteFilesRecords()}}async getLocalFilesRecords(){return this.getFilesRecords(this.getIndexeddbConfig().localFilesTable)}async getRemoteFilesRecords(){return this.getFilesRecords(this.getIndexeddbConfig().remoteFilesTable)}async getRemoteOrLocalFile(x){return await this.getRemoteFile(x)||await this.getLocalFile(x)}async getLocalFile(x){return await this.getFile(this.getIndexeddbConfig().localFilesTable,x)}async getRemoteFile(x){return await this.getFile(this.getIndexeddbConfig().remoteFilesTable,x)}async getAllLocalConfigNames(){return await this.getAllKeys(this.getStore(this.getIndexeddbConfig().localConfigsTable,"readonly"))}async getAllRemoteConfigNames(){return await this.getAllKeys(this.getStore(this.getIndexeddbConfig().remoteConfigsTable,"readonly"))}async getAllLocalFileNames(){return await this.getAllKeys(this.getStore(this.getIndexeddbConfig().localFilesTable,"readonly"))}async getAllRemoteFileNames(){return await this.getAllKeys(this.getStore(this.getIndexeddbConfig().remoteFilesTable,"readonly"))}async deleteLocalFileByName(x){return await this.deleteKey(x,this.getStore(this.getIndexeddbConfig().localFilesTable,"readwrite"))}async deleteRemoteFileByName(x){return await this.deleteKey(x,this.getStore(this.getIndexeddbConfig().remoteFilesTable,"readwrite"))}async deleteLocalConfigByName(x){return await this.deleteKey(x,this.getStore(this.getIndexeddbConfig().localConfigsTable,"readwrite"))}async deleteRemoteConfigByName(x){return await this.deleteKey(x,this.getStore(this.getIndexeddbConfig().remoteConfigsTable,"readwrite"))}async uploadToRemote(x){await this.uploadConfigToRemote(x),await this.uploadFilesToRemote(x)}isReady(){return!!this.db}async syncWithRemote(x){if(!this.assetServerUrl)return;const W=await fetch(`${this.assetServerUrl}/${x}/config.json`);if(!W.ok)return;const{configs:M}=await W.json();for(const x of Object.values(M))await this.saveRemoteConfig(x);const N=await fetch(`${this.assetServerUrl}/${x}`);if(!N.ok)throw new Error(`Failed to fetch files from remote: ${N.statusText}`);const{files:t}=await N.json(),X=[];for(const W of t){const M=W.replace(z,c);let N=`${o}${this.assetServerUrl}/${x}/${W}`;if(R(M)){const M=await fetch(`${this.assetServerUrl}/${x}/${W}`);if(!M.ok)throw new Error(`Failed to fetch file from remote: ${M.statusText}`);N=await M.text()}X.push({name:M,content:N})}await this.saveRemoteFiles(X)}async saveFiles(x,W){return new Promise(((M,c)=>{const z=this.getStore(W,"readwrite");x.forEach((({name:x,content:W})=>{z.put({fileName:x,content:W})})),z.transaction.oncomplete=()=>M(),z.transaction.onerror=x=>c(x.target.error)}))}async saveConfig(x,W){return new Promise(((M,c)=>{const z=this.getStore(W,"readwrite");z.put({assetName:x.assetName,content:x}),z.transaction.oncomplete=()=>M(),z.transaction.onerror=x=>c(x.target.error)}))}getIndexeddbConfig(){const x="assetsFiles",W="assetsFilesRemote",M="assetsConfigs",c="assetsConfigsRemote";return{localFilesTable:x,remoteFilesTable:W,localConfigsTable:M,remoteConfigsTable:c,stores:[{name:x,keyPath:"fileName"},{name:W,keyPath:"fileName"},{name:M,keyPath:"assetName"},{name:c,keyPath:"assetName"}]}}async uploadConfigToRemote(x){const W=await this.getLocalConfigsRecords(),M=new FormData;M.append("file",new Blob([JSON.stringify({configs:W})],{type:"application/json"}),"config.json");const c=await fetch(`${this.assetServerUrl}/${x}`,{method:"POST",body:M});if(!c.ok)throw new Error(`Failed to upload config to remote: ${c.statusText}`);for(const x of Object.values(W))await this.saveRemoteConfig(x)}async uploadFilesToRemote(x){const W=[],M=await this.getLocalFilesRecords();for(const[N,t]of Object.entries(M)){const M=new FormData,X=t instanceof Blob,I=!X&&"object"==typeof t;if("string"==typeof t&&t.startsWith(o))continue;const f=X?t:I?new Blob([JSON.stringify(t)],{type:"application/json"}):new Blob([t],{type:"text/plain"}),D=N.replace(c,z);M.append("file",f,D);const p=await fetch(`${this.assetServerUrl}/${x}`,{method:"POST",body:M});if(!p.ok)throw new Error(`Failed to upload file to remote: ${p.statusText}`);R(N)||W.push({name:N,content:`${o}${this.assetServerUrl}/${x}/${D}`})}await this.saveRemoteFiles(W)}async getAllKeys(x){return new Promise(((W,M)=>{const c=x.getAllKeys();c.onsuccess=x=>{var M;return W(null!==(M=x.target.result)&&void 0!==M?M:[])},c.onerror=x=>M(x.target.error)}))}async deleteKey(x,W){return new Promise(((M,c)=>{const z=W.delete(x);z.onsuccess=()=>M(),z.onerror=x=>c(x.target.error)}))}getStore(x,W){if(!this.db)throw new Error("DB wasn't inited!");return this.db.transaction(x,W).objectStore(x)}async clearStore(x){return new Promise(((W,M)=>{const c=this.getStore(x,"readwrite");c.clear(),c.transaction.oncomplete=W,c.transaction.onerror=x=>M(x.target.error)}))}async getConfigsRecords(x){return new Promise(((W,M)=>{const c={},z=this.getStore(x,"readonly");z.openCursor().onsuccess=x=>{const M=x.target.result;if(M){const{assetName:x,content:W}=M.value;c[x]=W,M.continue()}else W(c)},z.openCursor().onerror=x=>M(x.target.error)}))}async getFilesRecords(x){return new Promise(((W,M)=>{const c={},z=this.getStore(x,"readonly");z.openCursor().onsuccess=x=>{const M=x.target.result;if(M){const{fileName:x,content:W}=M.value;c[x]=W,M.continue()}else W(c)},z.openCursor().onerror=x=>M(x.target.error)}))}async getFile(x,W){return new Promise(((M,c)=>{const z=this.getStore(x,"readonly").get(W);z.onsuccess=x=>{M(x.target.result)},z.onerror=x=>c(x.target.error)}))}}I.instance=new I;const f=10,D=10,p=100,r="iFrAmE",K="wRetryCount",O=0,_=10,y="wRetryDelay",F=250,h="wRetryBackoffFactor",j=1,T=self,G=new class{constructor(x=p){var W;this.useConnectionDownlink=!!(null===(W=null===navigator||void 0===navigator?void 0:navigator.connection)||void 0===W?void 0:W.downlink),this.responseSizeBytesSum=0,this.responseTimeMsSum=0,this.filled=0,this.pointer=0,this.queueSize=x;try{this.useConnectionDownlink||"undefined"==typeof PerformanceObserver||(this.responseSizeBytesQueue=new Uint32Array(x),this.responseTimeMsQueue=new Uint32Array(x),this.responseEndMsQueue=new Uint32Array(x),new PerformanceObserver((x=>{x.getEntries().forEach((x=>{const{responseEnd:W,responseStart:M,transferSize:c}=x,z=null!=c?c:0,N=Math.trunc(M),t=Math.trunc(W);t-N>D&&z>f&&this.updateState(z,N,t)}))})).observe({type:"resource",buffered:!0}))}catch(x){console.error(x)}}perf(){return this.useConnectionDownlink?navigator.connection.downlink:this.filled>0?this.bytesPerMsToMbps(this.responseSizeBytesSum,this.responseTimeMsSum):0}bytesPerMsToMbps(x,W){return x/W/125}updateState(x,W,M){var c,z,N;const t=0===this.pointer?this.queueSize-1:this.pointer-1,X=(null===(c=this.responseEndMsQueue)||void 0===c?void 0:c[t])||0;this.responseEndMsQueue&&(this.responseEndMsQueue[this.pointer]=Math.max(M,X));const o=(null===(z=this.responseSizeBytesQueue)||void 0===z?void 0:z[this.pointer])||0;this.responseSizeBytesQueue&&(this.responseSizeBytesQueue[this.pointer]=x),this.responseSizeBytesSum+=x-o;const R=null===(N=this.responseTimeMsQueue)||void 0===N?void 0:N[this.pointer];let I=M-W;W<X&&(I=Math.max(M-X,0)),this.responseTimeMsQueue&&(this.responseTimeMsQueue[this.pointer]=I),this.responseTimeMsSum+=I-(R||0),this.pointer+=1,this.filled=Math.max(this.filled,this.pointer),this.pointer===this.queueSize&&(this.pointer=0)}};let C;const s=function(x,W,M=!0){let c,z=0;return(...N)=>{clearTimeout(c),!z||Date.now()-z>W?(z=Date.now(),x(...N)):M&&(c=setTimeout((()=>{x(...N)}),W))}}((async x=>{const W=G.perf();if(W!==C){C=W;const M=await T.clients.get(x);null==M||M.postMessage({type:"requests-speed",message:G.perf()})}}),1e3);async function Y(x){const W=await caches.open(M),c=await W.match(x);if(c)return c.clone();const z=await fetch(x);return function(x,W){var M,c;return!!W.ok&&!!(null===(M=W.headers.get("cache-control"))||void 0===M?void 0:M.toLowerCase().includes("immutable"))&&"GET"===x.method&&206!==W.status&&!(null===(c=W.headers.get("vary"))||void 0===c?void 0:c.includes("*"))}(x,z)&&await W.put(x,z.clone()),z}function E(x){return new Promise((W=>{setTimeout(W,x)}))}T.addEventListener("install",(M=>{M.waitUntil(T.skipWaiting());for(let c=1;c<x;c++)M.waitUntil(caches.delete(`${W}${c}`))})),T.addEventListener("fetch",(x=>{x.request.url.includes(c)?x.respondWith(async function(x){var W,M;try{const c=null===(M=null===(W=x.request.url)||void 0===W?void 0:W.split("/"))||void 0===M?void 0:M.pop();if(!c)return new Response(null,{status:404,statusText:`Filename is empty`});await I.instance.init(T.indexedDB,null);const z=await I.instance.getRemoteOrLocalFile(c);if(!z)return new Response(null,{status:404,statusText:`${c} is not found in indexeddb`});if("string"==typeof z.content&&z.content.startsWith(o))return fetch(z.content.replace(o,""));const t=c.split(".").pop(),X=z.content instanceof Blob?z.content:"object"==typeof z.content?JSON.stringify(z.content):z.content;return new Response(X,{headers:{"Content-Type":N[t]}})}catch(W){return console.error(W),new Response(null,{status:400,statusText:`Some error during handling ${x.request.url} in service.worker`})}}(x)):x.respondWith(async function(x){const{request:W,url:M}=function(x){const W=new URL(x.url),M=W.searchParams;if("iframe"!==x.destination||!M.has(r))return{request:x,url:W};M.delete(r);const c={};for(const W in x){const M=x[W];M&&"function"!=typeof M&&(c[W]=M)}c.mode="navigate"===x.mode?"same-origin":x.mode;const z=new Request(W.toString(),c);return{request:z,url:new URL(z.url)}}(x.request),c=M.searchParams,z=Number(c.get(K))||O;let N=Math.min(Math.max(z,0),_),t=Number(c.get(y))||F;const X=Number(c.get(h))||j;let o=await Y(W);for(;N>0&&!o.ok&&"opaque"!==o.type&&"opaqueredirect"!==o.type;)await E(t),t*=X,o=await Y(W),N--;return o}(x).catch((async W=>{if(x.clientId){const M=await T.clients.get(x.clientId);null==M||M.postMessage({type:"processing-failed",message:W.message,stack:W.stack})}throw W}))),x.clientId&&s(x.clientId)}))})();
//# sourceMappingURL=https://sourcemaps.egcdn.com/frontend/evo/r2/service.worker.0266d75d.js.map